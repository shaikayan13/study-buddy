"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pdfjs-dist";
exports.ids = ["vendor-chunks/pdfjs-dist"];
exports.modules = {

/***/ "./node_modules/pdfjs-dist/build/pdf.mjs":
/*!***********************************************!*\
  !*** ./node_modules/pdfjs-dist/build/pdf.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortException: () => (/* binding */ AbortException),\n/* harmony export */   AnnotationEditorLayer: () => (/* binding */ AnnotationEditorLayer),\n/* harmony export */   AnnotationEditorParamsType: () => (/* binding */ AnnotationEditorParamsType),\n/* harmony export */   AnnotationEditorType: () => (/* binding */ AnnotationEditorType),\n/* harmony export */   AnnotationEditorUIManager: () => (/* binding */ AnnotationEditorUIManager),\n/* harmony export */   AnnotationLayer: () => (/* binding */ AnnotationLayer),\n/* harmony export */   AnnotationMode: () => (/* binding */ AnnotationMode),\n/* harmony export */   AnnotationType: () => (/* binding */ AnnotationType),\n/* harmony export */   ColorPicker: () => (/* binding */ ColorPicker),\n/* harmony export */   DOMSVGFactory: () => (/* binding */ DOMSVGFactory),\n/* harmony export */   DrawLayer: () => (/* binding */ DrawLayer),\n/* harmony export */   FeatureTest: () => (/* binding */ util_FeatureTest),\n/* harmony export */   GlobalWorkerOptions: () => (/* binding */ GlobalWorkerOptions),\n/* harmony export */   ImageKind: () => (/* binding */ util_ImageKind),\n/* harmony export */   InvalidPDFException: () => (/* binding */ InvalidPDFException),\n/* harmony export */   MathClamp: () => (/* binding */ MathClamp),\n/* harmony export */   OPS: () => (/* binding */ OPS),\n/* harmony export */   OutputScale: () => (/* binding */ OutputScale),\n/* harmony export */   PDFDataRangeTransport: () => (/* binding */ PDFDataRangeTransport),\n/* harmony export */   PDFDateString: () => (/* binding */ PDFDateString),\n/* harmony export */   PDFWorker: () => (/* binding */ PDFWorker),\n/* harmony export */   PasswordResponses: () => (/* binding */ PasswordResponses),\n/* harmony export */   PermissionFlag: () => (/* binding */ PermissionFlag),\n/* harmony export */   PixelsPerInch: () => (/* binding */ PixelsPerInch),\n/* harmony export */   RenderingCancelledException: () => (/* binding */ RenderingCancelledException),\n/* harmony export */   ResponseException: () => (/* binding */ ResponseException),\n/* harmony export */   SignatureExtractor: () => (/* binding */ SignatureExtractor),\n/* harmony export */   SupportedImageMimeTypes: () => (/* binding */ SupportedImageMimeTypes),\n/* harmony export */   TextLayer: () => (/* binding */ TextLayer),\n/* harmony export */   TouchManager: () => (/* binding */ TouchManager),\n/* harmony export */   Util: () => (/* binding */ Util),\n/* harmony export */   VerbosityLevel: () => (/* binding */ VerbosityLevel),\n/* harmony export */   XfaLayer: () => (/* binding */ XfaLayer),\n/* harmony export */   build: () => (/* binding */ build),\n/* harmony export */   createValidAbsoluteUrl: () => (/* binding */ createValidAbsoluteUrl),\n/* harmony export */   fetchData: () => (/* binding */ fetchData),\n/* harmony export */   getDocument: () => (/* binding */ getDocument),\n/* harmony export */   getFilenameFromUrl: () => (/* binding */ getFilenameFromUrl),\n/* harmony export */   getPdfFilenameFromUrl: () => (/* binding */ getPdfFilenameFromUrl),\n/* harmony export */   getRGB: () => (/* binding */ getRGB),\n/* harmony export */   getUuid: () => (/* binding */ getUuid),\n/* harmony export */   getXfaPageViewport: () => (/* binding */ getXfaPageViewport),\n/* harmony export */   isDataScheme: () => (/* binding */ isDataScheme),\n/* harmony export */   isPdfFile: () => (/* binding */ isPdfFile),\n/* harmony export */   isValidExplicitDest: () => (/* binding */ isValidExplicitDest),\n/* harmony export */   noContextMenu: () => (/* binding */ noContextMenu),\n/* harmony export */   normalizeUnicode: () => (/* binding */ normalizeUnicode),\n/* harmony export */   setLayerDimensions: () => (/* binding */ setLayerDimensions),\n/* harmony export */   shadow: () => (/* binding */ shadow),\n/* harmony export */   stopEvent: () => (/* binding */ stopEvent),\n/* harmony export */   updateUrlHash: () => (/* binding */ updateUrlHash),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/**\n * @licstart The following is the entire license notice for the\n * JavaScript code in this page\n *\n * Copyright 2024 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * JavaScript code in this page\n */\n\n/**\n * pdfjsVersion = 5.4.149\n * pdfjsBuild = 9e2e9e209\n */\n/******/ // The require scope\n/******/ var __nested_webpack_require_899__ = {};\n/******/ \n/************************************************************************/\n/******/ /* webpack/runtime/define property getters */\n/******/ (() => {\n/******/ \t// define getter functions for harmony exports\n/******/ \t__nested_webpack_require_899__.d = (exports, definition) => {\n/******/ \t\tfor(var key in definition) {\n/******/ \t\t\tif(__nested_webpack_require_899__.o(definition, key) && !__nested_webpack_require_899__.o(exports, key)) {\n/******/ \t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t}\n/******/ \t\t}\n/******/ \t};\n/******/ })();\n/******/ \n/******/ /* webpack/runtime/hasOwnProperty shorthand */\n/******/ (() => {\n/******/ \t__nested_webpack_require_899__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ })();\n/******/ \n/************************************************************************/\nvar __webpack_exports__ = {};\n\n;// ./src/shared/util.js\nconst isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\nconst FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];\nconst LINE_FACTOR = 1.35;\nconst LINE_DESCENT_FACTOR = 0.35;\nconst BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;\nconst RenderingIntentFlag = {\n  ANY: 0x01,\n  DISPLAY: 0x02,\n  PRINT: 0x04,\n  SAVE: 0x08,\n  ANNOTATIONS_FORMS: 0x10,\n  ANNOTATIONS_STORAGE: 0x20,\n  ANNOTATIONS_DISABLE: 0x40,\n  IS_EDITING: 0x80,\n  OPLIST: 0x100\n};\nconst AnnotationMode = {\n  DISABLE: 0,\n  ENABLE: 1,\n  ENABLE_FORMS: 2,\n  ENABLE_STORAGE: 3\n};\nconst AnnotationEditorPrefix = \"pdfjs_internal_editor_\";\nconst AnnotationEditorType = {\n  DISABLE: -1,\n  NONE: 0,\n  FREETEXT: 3,\n  HIGHLIGHT: 9,\n  STAMP: 13,\n  INK: 15,\n  POPUP: 16,\n  SIGNATURE: 101,\n  COMMENT: 102\n};\nconst AnnotationEditorParamsType = {\n  RESIZE: 1,\n  CREATE: 2,\n  FREETEXT_SIZE: 11,\n  FREETEXT_COLOR: 12,\n  FREETEXT_OPACITY: 13,\n  INK_COLOR: 21,\n  INK_THICKNESS: 22,\n  INK_OPACITY: 23,\n  HIGHLIGHT_COLOR: 31,\n  HIGHLIGHT_THICKNESS: 32,\n  HIGHLIGHT_FREE: 33,\n  HIGHLIGHT_SHOW_ALL: 34,\n  DRAW_STEP: 41\n};\nconst PermissionFlag = {\n  PRINT: 0x04,\n  MODIFY_CONTENTS: 0x08,\n  COPY: 0x10,\n  MODIFY_ANNOTATIONS: 0x20,\n  FILL_INTERACTIVE_FORMS: 0x100,\n  COPY_FOR_ACCESSIBILITY: 0x200,\n  ASSEMBLE: 0x400,\n  PRINT_HIGH_QUALITY: 0x800\n};\nconst TextRenderingMode = {\n  FILL: 0,\n  STROKE: 1,\n  FILL_STROKE: 2,\n  INVISIBLE: 3,\n  FILL_ADD_TO_PATH: 4,\n  STROKE_ADD_TO_PATH: 5,\n  FILL_STROKE_ADD_TO_PATH: 6,\n  ADD_TO_PATH: 7,\n  FILL_STROKE_MASK: 3,\n  ADD_TO_PATH_FLAG: 4\n};\nconst util_ImageKind = {\n  GRAYSCALE_1BPP: 1,\n  RGB_24BPP: 2,\n  RGBA_32BPP: 3\n};\nconst AnnotationType = {\n  TEXT: 1,\n  LINK: 2,\n  FREETEXT: 3,\n  LINE: 4,\n  SQUARE: 5,\n  CIRCLE: 6,\n  POLYGON: 7,\n  POLYLINE: 8,\n  HIGHLIGHT: 9,\n  UNDERLINE: 10,\n  SQUIGGLY: 11,\n  STRIKEOUT: 12,\n  STAMP: 13,\n  CARET: 14,\n  INK: 15,\n  POPUP: 16,\n  FILEATTACHMENT: 17,\n  SOUND: 18,\n  MOVIE: 19,\n  WIDGET: 20,\n  SCREEN: 21,\n  PRINTERMARK: 22,\n  TRAPNET: 23,\n  WATERMARK: 24,\n  THREED: 25,\n  REDACT: 26\n};\nconst AnnotationReplyType = {\n  GROUP: \"Group\",\n  REPLY: \"R\"\n};\nconst AnnotationFlag = {\n  INVISIBLE: 0x01,\n  HIDDEN: 0x02,\n  PRINT: 0x04,\n  NOZOOM: 0x08,\n  NOROTATE: 0x10,\n  NOVIEW: 0x20,\n  READONLY: 0x40,\n  LOCKED: 0x80,\n  TOGGLENOVIEW: 0x100,\n  LOCKEDCONTENTS: 0x200\n};\nconst AnnotationFieldFlag = {\n  READONLY: 0x0000001,\n  REQUIRED: 0x0000002,\n  NOEXPORT: 0x0000004,\n  MULTILINE: 0x0001000,\n  PASSWORD: 0x0002000,\n  NOTOGGLETOOFF: 0x0004000,\n  RADIO: 0x0008000,\n  PUSHBUTTON: 0x0010000,\n  COMBO: 0x0020000,\n  EDIT: 0x0040000,\n  SORT: 0x0080000,\n  FILESELECT: 0x0100000,\n  MULTISELECT: 0x0200000,\n  DONOTSPELLCHECK: 0x0400000,\n  DONOTSCROLL: 0x0800000,\n  COMB: 0x1000000,\n  RICHTEXT: 0x2000000,\n  RADIOSINUNISON: 0x2000000,\n  COMMITONSELCHANGE: 0x4000000\n};\nconst AnnotationBorderStyleType = {\n  SOLID: 1,\n  DASHED: 2,\n  BEVELED: 3,\n  INSET: 4,\n  UNDERLINE: 5\n};\nconst AnnotationActionEventType = {\n  E: \"Mouse Enter\",\n  X: \"Mouse Exit\",\n  D: \"Mouse Down\",\n  U: \"Mouse Up\",\n  Fo: \"Focus\",\n  Bl: \"Blur\",\n  PO: \"PageOpen\",\n  PC: \"PageClose\",\n  PV: \"PageVisible\",\n  PI: \"PageInvisible\",\n  K: \"Keystroke\",\n  F: \"Format\",\n  V: \"Validate\",\n  C: \"Calculate\"\n};\nconst DocumentActionEventType = {\n  WC: \"WillClose\",\n  WS: \"WillSave\",\n  DS: \"DidSave\",\n  WP: \"WillPrint\",\n  DP: \"DidPrint\"\n};\nconst PageActionEventType = {\n  O: \"PageOpen\",\n  C: \"PageClose\"\n};\nconst VerbosityLevel = {\n  ERRORS: 0,\n  WARNINGS: 1,\n  INFOS: 5\n};\nconst OPS = {\n  dependency: 1,\n  setLineWidth: 2,\n  setLineCap: 3,\n  setLineJoin: 4,\n  setMiterLimit: 5,\n  setDash: 6,\n  setRenderingIntent: 7,\n  setFlatness: 8,\n  setGState: 9,\n  save: 10,\n  restore: 11,\n  transform: 12,\n  moveTo: 13,\n  lineTo: 14,\n  curveTo: 15,\n  curveTo2: 16,\n  curveTo3: 17,\n  closePath: 18,\n  rectangle: 19,\n  stroke: 20,\n  closeStroke: 21,\n  fill: 22,\n  eoFill: 23,\n  fillStroke: 24,\n  eoFillStroke: 25,\n  closeFillStroke: 26,\n  closeEOFillStroke: 27,\n  endPath: 28,\n  clip: 29,\n  eoClip: 30,\n  beginText: 31,\n  endText: 32,\n  setCharSpacing: 33,\n  setWordSpacing: 34,\n  setHScale: 35,\n  setLeading: 36,\n  setFont: 37,\n  setTextRenderingMode: 38,\n  setTextRise: 39,\n  moveText: 40,\n  setLeadingMoveText: 41,\n  setTextMatrix: 42,\n  nextLine: 43,\n  showText: 44,\n  showSpacedText: 45,\n  nextLineShowText: 46,\n  nextLineSetSpacingShowText: 47,\n  setCharWidth: 48,\n  setCharWidthAndBounds: 49,\n  setStrokeColorSpace: 50,\n  setFillColorSpace: 51,\n  setStrokeColor: 52,\n  setStrokeColorN: 53,\n  setFillColor: 54,\n  setFillColorN: 55,\n  setStrokeGray: 56,\n  setFillGray: 57,\n  setStrokeRGBColor: 58,\n  setFillRGBColor: 59,\n  setStrokeCMYKColor: 60,\n  setFillCMYKColor: 61,\n  shadingFill: 62,\n  beginInlineImage: 63,\n  beginImageData: 64,\n  endInlineImage: 65,\n  paintXObject: 66,\n  markPoint: 67,\n  markPointProps: 68,\n  beginMarkedContent: 69,\n  beginMarkedContentProps: 70,\n  endMarkedContent: 71,\n  beginCompat: 72,\n  endCompat: 73,\n  paintFormXObjectBegin: 74,\n  paintFormXObjectEnd: 75,\n  beginGroup: 76,\n  endGroup: 77,\n  beginAnnotation: 80,\n  endAnnotation: 81,\n  paintImageMaskXObject: 83,\n  paintImageMaskXObjectGroup: 84,\n  paintImageXObject: 85,\n  paintInlineImageXObject: 86,\n  paintInlineImageXObjectGroup: 87,\n  paintImageXObjectRepeat: 88,\n  paintImageMaskXObjectRepeat: 89,\n  paintSolidColorImageMask: 90,\n  constructPath: 91,\n  setStrokeTransparent: 92,\n  setFillTransparent: 93,\n  rawFillPath: 94\n};\nconst DrawOPS = {\n  moveTo: 0,\n  lineTo: 1,\n  curveTo: 2,\n  closePath: 3\n};\nconst PasswordResponses = {\n  NEED_PASSWORD: 1,\n  INCORRECT_PASSWORD: 2\n};\nlet verbosity = VerbosityLevel.WARNINGS;\nfunction setVerbosityLevel(level) {\n  if (Number.isInteger(level)) {\n    verbosity = level;\n  }\n}\nfunction getVerbosityLevel() {\n  return verbosity;\n}\nfunction info(msg) {\n  if (verbosity >= VerbosityLevel.INFOS) {\n    console.log(`Info: ${msg}`);\n  }\n}\nfunction warn(msg) {\n  if (verbosity >= VerbosityLevel.WARNINGS) {\n    console.log(`Warning: ${msg}`);\n  }\n}\nfunction unreachable(msg) {\n  throw new Error(msg);\n}\nfunction assert(cond, msg) {\n  if (!cond) {\n    unreachable(msg);\n  }\n}\nfunction _isValidProtocol(url) {\n  switch (url?.protocol) {\n    case \"http:\":\n    case \"https:\":\n    case \"ftp:\":\n    case \"mailto:\":\n    case \"tel:\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction createValidAbsoluteUrl(url, baseUrl = null, options = null) {\n  if (!url) {\n    return null;\n  }\n  if (options && typeof url === \"string\") {\n    if (options.addDefaultProtocol && url.startsWith(\"www.\")) {\n      const dots = url.match(/\\./g);\n      if (dots?.length >= 2) {\n        url = `http://${url}`;\n      }\n    }\n    if (options.tryConvertEncoding) {\n      try {\n        url = stringToUTF8String(url);\n      } catch {}\n    }\n  }\n  const absoluteUrl = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);\n  return _isValidProtocol(absoluteUrl) ? absoluteUrl : null;\n}\nfunction updateUrlHash(url, hash, allowRel = false) {\n  const res = URL.parse(url);\n  if (res) {\n    res.hash = hash;\n    return res.href;\n  }\n  if (allowRel && createValidAbsoluteUrl(url, \"http://example.com\")) {\n    return url.split(\"#\", 1)[0] + `${hash ? `#${hash}` : \"\"}`;\n  }\n  return \"\";\n}\nfunction shadow(obj, prop, value, nonSerializable = false) {\n  Object.defineProperty(obj, prop, {\n    value,\n    enumerable: !nonSerializable,\n    configurable: true,\n    writable: false\n  });\n  return value;\n}\nconst BaseException = function BaseExceptionClosure() {\n  function BaseException(message, name) {\n    this.message = message;\n    this.name = name;\n  }\n  BaseException.prototype = new Error();\n  BaseException.constructor = BaseException;\n  return BaseException;\n}();\nclass PasswordException extends BaseException {\n  constructor(msg, code) {\n    super(msg, \"PasswordException\");\n    this.code = code;\n  }\n}\nclass UnknownErrorException extends BaseException {\n  constructor(msg, details) {\n    super(msg, \"UnknownErrorException\");\n    this.details = details;\n  }\n}\nclass InvalidPDFException extends BaseException {\n  constructor(msg) {\n    super(msg, \"InvalidPDFException\");\n  }\n}\nclass ResponseException extends BaseException {\n  constructor(msg, status, missing) {\n    super(msg, \"ResponseException\");\n    this.status = status;\n    this.missing = missing;\n  }\n}\nclass FormatError extends BaseException {\n  constructor(msg) {\n    super(msg, \"FormatError\");\n  }\n}\nclass AbortException extends BaseException {\n  constructor(msg) {\n    super(msg, \"AbortException\");\n  }\n}\nfunction bytesToString(bytes) {\n  if (typeof bytes !== \"object\" || bytes?.length === undefined) {\n    unreachable(\"Invalid argument for bytesToString\");\n  }\n  const length = bytes.length;\n  const MAX_ARGUMENT_COUNT = 8192;\n  if (length < MAX_ARGUMENT_COUNT) {\n    return String.fromCharCode.apply(null, bytes);\n  }\n  const strBuf = [];\n  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {\n    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n    const chunk = bytes.subarray(i, chunkEnd);\n    strBuf.push(String.fromCharCode.apply(null, chunk));\n  }\n  return strBuf.join(\"\");\n}\nfunction stringToBytes(str) {\n  if (typeof str !== \"string\") {\n    unreachable(\"Invalid argument for stringToBytes\");\n  }\n  const length = str.length;\n  const bytes = new Uint8Array(length);\n  for (let i = 0; i < length; ++i) {\n    bytes[i] = str.charCodeAt(i) & 0xff;\n  }\n  return bytes;\n}\nfunction string32(value) {\n  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n}\nfunction objectSize(obj) {\n  return Object.keys(obj).length;\n}\nfunction isLittleEndian() {\n  const buffer8 = new Uint8Array(4);\n  buffer8[0] = 1;\n  const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n  return view32[0] === 1;\n}\nfunction isEvalSupported() {\n  try {\n    new Function(\"\");\n    return true;\n  } catch {\n    return false;\n  }\n}\nclass util_FeatureTest {\n  static get isLittleEndian() {\n    return shadow(this, \"isLittleEndian\", isLittleEndian());\n  }\n  static get isEvalSupported() {\n    return shadow(this, \"isEvalSupported\", isEvalSupported());\n  }\n  static get isOffscreenCanvasSupported() {\n    return shadow(this, \"isOffscreenCanvasSupported\", typeof OffscreenCanvas !== \"undefined\");\n  }\n  static get isImageDecoderSupported() {\n    return shadow(this, \"isImageDecoderSupported\", typeof ImageDecoder !== \"undefined\");\n  }\n  static get platform() {\n    const {\n      platform,\n      userAgent\n    } = navigator;\n    return shadow(this, \"platform\", {\n      isAndroid: userAgent.includes(\"Android\"),\n      isLinux: platform.includes(\"Linux\"),\n      isMac: platform.includes(\"Mac\"),\n      isWindows: platform.includes(\"Win\"),\n      isFirefox: userAgent.includes(\"Firefox\")\n    });\n  }\n  static get isCSSRoundSupported() {\n    return shadow(this, \"isCSSRoundSupported\", globalThis.CSS?.supports?.(\"width: round(1.5px, 1px)\"));\n  }\n}\nconst hexNumbers = Array.from(Array(256).keys(), n => n.toString(16).padStart(2, \"0\"));\nclass Util {\n  static makeHexColor(r, g, b) {\n    return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\n  }\n  static domMatrixToTransform(dm) {\n    return [dm.a, dm.b, dm.c, dm.d, dm.e, dm.f];\n  }\n  static scaleMinMax(transform, minMax) {\n    let temp;\n    if (transform[0]) {\n      if (transform[0] < 0) {\n        temp = minMax[0];\n        minMax[0] = minMax[2];\n        minMax[2] = temp;\n      }\n      minMax[0] *= transform[0];\n      minMax[2] *= transform[0];\n      if (transform[3] < 0) {\n        temp = minMax[1];\n        minMax[1] = minMax[3];\n        minMax[3] = temp;\n      }\n      minMax[1] *= transform[3];\n      minMax[3] *= transform[3];\n    } else {\n      temp = minMax[0];\n      minMax[0] = minMax[1];\n      minMax[1] = temp;\n      temp = minMax[2];\n      minMax[2] = minMax[3];\n      minMax[3] = temp;\n      if (transform[1] < 0) {\n        temp = minMax[1];\n        minMax[1] = minMax[3];\n        minMax[3] = temp;\n      }\n      minMax[1] *= transform[1];\n      minMax[3] *= transform[1];\n      if (transform[2] < 0) {\n        temp = minMax[0];\n        minMax[0] = minMax[2];\n        minMax[2] = temp;\n      }\n      minMax[0] *= transform[2];\n      minMax[2] *= transform[2];\n    }\n    minMax[0] += transform[4];\n    minMax[1] += transform[5];\n    minMax[2] += transform[4];\n    minMax[3] += transform[5];\n  }\n  static transform(m1, m2) {\n    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];\n  }\n  static multiplyByDOMMatrix(m, md) {\n    return [m[0] * md.a + m[2] * md.b, m[1] * md.a + m[3] * md.b, m[0] * md.c + m[2] * md.d, m[1] * md.c + m[3] * md.d, m[0] * md.e + m[2] * md.f + m[4], m[1] * md.e + m[3] * md.f + m[5]];\n  }\n  static applyTransform(p, m, pos = 0) {\n    const p0 = p[pos];\n    const p1 = p[pos + 1];\n    p[pos] = p0 * m[0] + p1 * m[2] + m[4];\n    p[pos + 1] = p0 * m[1] + p1 * m[3] + m[5];\n  }\n  static applyTransformToBezier(p, transform, pos = 0) {\n    const m0 = transform[0];\n    const m1 = transform[1];\n    const m2 = transform[2];\n    const m3 = transform[3];\n    const m4 = transform[4];\n    const m5 = transform[5];\n    for (let i = 0; i < 6; i += 2) {\n      const pI = p[pos + i];\n      const pI1 = p[pos + i + 1];\n      p[pos + i] = pI * m0 + pI1 * m2 + m4;\n      p[pos + i + 1] = pI * m1 + pI1 * m3 + m5;\n    }\n  }\n  static applyInverseTransform(p, m) {\n    const p0 = p[0];\n    const p1 = p[1];\n    const d = m[0] * m[3] - m[1] * m[2];\n    p[0] = (p0 * m[3] - p1 * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n    p[1] = (-p0 * m[1] + p1 * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n  }\n  static axialAlignedBoundingBox(rect, transform, output) {\n    const m0 = transform[0];\n    const m1 = transform[1];\n    const m2 = transform[2];\n    const m3 = transform[3];\n    const m4 = transform[4];\n    const m5 = transform[5];\n    const r0 = rect[0];\n    const r1 = rect[1];\n    const r2 = rect[2];\n    const r3 = rect[3];\n    let a0 = m0 * r0 + m4;\n    let a2 = a0;\n    let a1 = m0 * r2 + m4;\n    let a3 = a1;\n    let b0 = m3 * r1 + m5;\n    let b2 = b0;\n    let b1 = m3 * r3 + m5;\n    let b3 = b1;\n    if (m1 !== 0 || m2 !== 0) {\n      const m1r0 = m1 * r0;\n      const m1r2 = m1 * r2;\n      const m2r1 = m2 * r1;\n      const m2r3 = m2 * r3;\n      a0 += m2r1;\n      a3 += m2r1;\n      a1 += m2r3;\n      a2 += m2r3;\n      b0 += m1r0;\n      b3 += m1r0;\n      b1 += m1r2;\n      b2 += m1r2;\n    }\n    output[0] = Math.min(output[0], a0, a1, a2, a3);\n    output[1] = Math.min(output[1], b0, b1, b2, b3);\n    output[2] = Math.max(output[2], a0, a1, a2, a3);\n    output[3] = Math.max(output[3], b0, b1, b2, b3);\n  }\n  static inverseTransform(m) {\n    const d = m[0] * m[3] - m[1] * m[2];\n    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];\n  }\n  static singularValueDecompose2dScale(matrix, output) {\n    const m0 = matrix[0];\n    const m1 = matrix[1];\n    const m2 = matrix[2];\n    const m3 = matrix[3];\n    const a = m0 ** 2 + m1 ** 2;\n    const b = m0 * m2 + m1 * m3;\n    const c = m2 ** 2 + m3 ** 2;\n    const first = (a + c) / 2;\n    const second = Math.sqrt(first ** 2 - (a * c - b ** 2));\n    output[0] = Math.sqrt(first + second || 1);\n    output[1] = Math.sqrt(first - second || 1);\n  }\n  static normalizeRect(rect) {\n    const r = rect.slice(0);\n    if (rect[0] > rect[2]) {\n      r[0] = rect[2];\n      r[2] = rect[0];\n    }\n    if (rect[1] > rect[3]) {\n      r[1] = rect[3];\n      r[3] = rect[1];\n    }\n    return r;\n  }\n  static intersect(rect1, rect2) {\n    const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));\n    const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));\n    if (xLow > xHigh) {\n      return null;\n    }\n    const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));\n    const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));\n    if (yLow > yHigh) {\n      return null;\n    }\n    return [xLow, yLow, xHigh, yHigh];\n  }\n  static pointBoundingBox(x, y, minMax) {\n    minMax[0] = Math.min(minMax[0], x);\n    minMax[1] = Math.min(minMax[1], y);\n    minMax[2] = Math.max(minMax[2], x);\n    minMax[3] = Math.max(minMax[3], y);\n  }\n  static rectBoundingBox(x0, y0, x1, y1, minMax) {\n    minMax[0] = Math.min(minMax[0], x0, x1);\n    minMax[1] = Math.min(minMax[1], y0, y1);\n    minMax[2] = Math.max(minMax[2], x0, x1);\n    minMax[3] = Math.max(minMax[3], y0, y1);\n  }\n  static #getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, t, minMax) {\n    if (t <= 0 || t >= 1) {\n      return;\n    }\n    const mt = 1 - t;\n    const tt = t * t;\n    const ttt = tt * t;\n    const x = mt * (mt * (mt * x0 + 3 * t * x1) + 3 * tt * x2) + ttt * x3;\n    const y = mt * (mt * (mt * y0 + 3 * t * y1) + 3 * tt * y2) + ttt * y3;\n    minMax[0] = Math.min(minMax[0], x);\n    minMax[1] = Math.min(minMax[1], y);\n    minMax[2] = Math.max(minMax[2], x);\n    minMax[3] = Math.max(minMax[3], y);\n  }\n  static #getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, a, b, c, minMax) {\n    if (Math.abs(a) < 1e-12) {\n      if (Math.abs(b) >= 1e-12) {\n        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, -c / b, minMax);\n      }\n      return;\n    }\n    const delta = b ** 2 - 4 * c * a;\n    if (delta < 0) {\n      return;\n    }\n    const sqrtDelta = Math.sqrt(delta);\n    const a2 = 2 * a;\n    this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b + sqrtDelta) / a2, minMax);\n    this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b - sqrtDelta) / a2, minMax);\n  }\n  static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax) {\n    minMax[0] = Math.min(minMax[0], x0, x3);\n    minMax[1] = Math.min(minMax[1], y0, y3);\n    minMax[2] = Math.max(minMax[2], x0, x3);\n    minMax[3] = Math.max(minMax[3], y0, y3);\n    this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-x0 + 3 * (x1 - x2) + x3), 6 * (x0 - 2 * x1 + x2), 3 * (x1 - x0), minMax);\n    this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-y0 + 3 * (y1 - y2) + y3), 6 * (y0 - 2 * y1 + y2), 3 * (y1 - y0), minMax);\n  }\n}\nconst PDFStringTranslateTable = (/* unused pure expression or super */ null && (0));\nfunction stringToPDFString(str, keepEscapeSequence = false) {\n  if (str[0] >= \"\\xEF\") {\n    let encoding;\n    if (str[0] === \"\\xFE\" && str[1] === \"\\xFF\") {\n      encoding = \"utf-16be\";\n      if (str.length % 2 === 1) {\n        str = str.slice(0, -1);\n      }\n    } else if (str[0] === \"\\xFF\" && str[1] === \"\\xFE\") {\n      encoding = \"utf-16le\";\n      if (str.length % 2 === 1) {\n        str = str.slice(0, -1);\n      }\n    } else if (str[0] === \"\\xEF\" && str[1] === \"\\xBB\" && str[2] === \"\\xBF\") {\n      encoding = \"utf-8\";\n    }\n    if (encoding) {\n      try {\n        const decoder = new TextDecoder(encoding, {\n          fatal: true\n        });\n        const buffer = stringToBytes(str);\n        const decoded = decoder.decode(buffer);\n        if (keepEscapeSequence || !decoded.includes(\"\\x1b\")) {\n          return decoded;\n        }\n        return decoded.replaceAll(/\\x1b[^\\x1b]*(?:\\x1b|$)/g, \"\");\n      } catch (ex) {\n        warn(`stringToPDFString: \"${ex}\".`);\n      }\n    }\n  }\n  const strBuf = [];\n  for (let i = 0, ii = str.length; i < ii; i++) {\n    const charCode = str.charCodeAt(i);\n    if (!keepEscapeSequence && charCode === 0x1b) {\n      while (++i < ii && str.charCodeAt(i) !== 0x1b) {}\n      continue;\n    }\n    const code = PDFStringTranslateTable[charCode];\n    strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n  }\n  return strBuf.join(\"\");\n}\nfunction stringToUTF8String(str) {\n  return decodeURIComponent(escape(str));\n}\nfunction utf8StringToString(str) {\n  return unescape(encodeURIComponent(str));\n}\nfunction isArrayEqual(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (let i = 0, ii = arr1.length; i < ii; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getModificationDate(date = new Date()) {\n  if (!(date instanceof Date)) {\n    date = new Date(date);\n  }\n  const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, \"0\"), date.getUTCDate().toString().padStart(2, \"0\"), date.getUTCHours().toString().padStart(2, \"0\"), date.getUTCMinutes().toString().padStart(2, \"0\"), date.getUTCSeconds().toString().padStart(2, \"0\")];\n  return buffer.join(\"\");\n}\nlet NormalizeRegex = null;\nlet NormalizationMap = null;\nfunction normalizeUnicode(str) {\n  if (!NormalizeRegex) {\n    NormalizeRegex = /([\\u00a0\\u00b5\\u037e\\u0eb3\\u2000-\\u200a\\u202f\\u2126\\ufb00-\\ufb04\\ufb06\\ufb20-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufba1\\ufba4-\\ufba9\\ufbae-\\ufbb1\\ufbd3-\\ufbdc\\ufbde-\\ufbe7\\ufbea-\\ufbf8\\ufbfc-\\ufbfd\\ufc00-\\ufc5d\\ufc64-\\ufcf1\\ufcf5-\\ufd3d\\ufd88\\ufdf4\\ufdfa-\\ufdfb\\ufe71\\ufe77\\ufe79\\ufe7b\\ufe7d]+)|(\\ufb05+)/gu;\n    NormalizationMap = new Map([[\"ﬅ\", \"ſt\"]]);\n  }\n  return str.replaceAll(NormalizeRegex, (_, p1, p2) => p1 ? p1.normalize(\"NFKC\") : NormalizationMap.get(p2));\n}\nfunction getUuid() {\n  if (typeof crypto.randomUUID === \"function\") {\n    return crypto.randomUUID();\n  }\n  const buf = new Uint8Array(32);\n  crypto.getRandomValues(buf);\n  return bytesToString(buf);\n}\nconst AnnotationPrefix = \"pdfjs_internal_id_\";\nfunction _isValidExplicitDest(validRef, validName, dest) {\n  if (!Array.isArray(dest) || dest.length < 2) {\n    return false;\n  }\n  const [page, zoom, ...args] = dest;\n  if (!validRef(page) && !Number.isInteger(page)) {\n    return false;\n  }\n  if (!validName(zoom)) {\n    return false;\n  }\n  const argsLen = args.length;\n  let allowNull = true;\n  switch (zoom.name) {\n    case \"XYZ\":\n      if (argsLen < 2 || argsLen > 3) {\n        return false;\n      }\n      break;\n    case \"Fit\":\n    case \"FitB\":\n      return argsLen === 0;\n    case \"FitH\":\n    case \"FitBH\":\n    case \"FitV\":\n    case \"FitBV\":\n      if (argsLen > 1) {\n        return false;\n      }\n      break;\n    case \"FitR\":\n      if (argsLen !== 4) {\n        return false;\n      }\n      allowNull = false;\n      break;\n    default:\n      return false;\n  }\n  for (const arg of args) {\n    if (typeof arg === \"number\" || allowNull && arg === null) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\nfunction MathClamp(v, min, max) {\n  return Math.min(Math.max(v, min), max);\n}\nfunction toHexUtil(arr) {\n  if (Uint8Array.prototype.toHex) {\n    return arr.toHex();\n  }\n  return Array.from(arr, num => hexNumbers[num]).join(\"\");\n}\nfunction toBase64Util(arr) {\n  if (Uint8Array.prototype.toBase64) {\n    return arr.toBase64();\n  }\n  return btoa(bytesToString(arr));\n}\nfunction fromBase64Util(str) {\n  if (Uint8Array.fromBase64) {\n    return Uint8Array.fromBase64(str);\n  }\n  return stringToBytes(atob(str));\n}\nif (typeof Promise.try !== \"function\") {\n  Promise.try = function (fn, ...args) {\n    return new Promise(resolve => {\n      resolve(fn(...args));\n    });\n  };\n}\nif (typeof Math.sumPrecise !== \"function\") {\n  Math.sumPrecise = function (numbers) {\n    return numbers.reduce((a, b) => a + b, 0);\n  };\n}\n\n;// ./src/display/display_utils.js\n\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\nclass PixelsPerInch {\n  static CSS = 96.0;\n  static PDF = 72.0;\n  static PDF_TO_CSS_UNITS = this.CSS / this.PDF;\n}\nasync function fetchData(url, type = \"text\") {\n  if (isValidFetchUrl(url, document.baseURI)) {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(response.statusText);\n    }\n    switch (type) {\n      case \"arraybuffer\":\n        return response.arrayBuffer();\n      case \"blob\":\n        return response.blob();\n      case \"json\":\n        return response.json();\n    }\n    return response.text();\n  }\n  return new Promise((resolve, reject) => {\n    const request = new XMLHttpRequest();\n    request.open(\"GET\", url, true);\n    request.responseType = type;\n    request.onreadystatechange = () => {\n      if (request.readyState !== XMLHttpRequest.DONE) {\n        return;\n      }\n      if (request.status === 200 || request.status === 0) {\n        switch (type) {\n          case \"arraybuffer\":\n          case \"blob\":\n          case \"json\":\n            resolve(request.response);\n            return;\n        }\n        resolve(request.responseText);\n        return;\n      }\n      reject(new Error(request.statusText));\n    };\n    request.send(null);\n  });\n}\nclass PageViewport {\n  constructor({\n    viewBox,\n    userUnit,\n    scale,\n    rotation,\n    offsetX = 0,\n    offsetY = 0,\n    dontFlip = false\n  }) {\n    this.viewBox = viewBox;\n    this.userUnit = userUnit;\n    this.scale = scale;\n    this.rotation = rotation;\n    this.offsetX = offsetX;\n    this.offsetY = offsetY;\n    scale *= userUnit;\n    const centerX = (viewBox[2] + viewBox[0]) / 2;\n    const centerY = (viewBox[3] + viewBox[1]) / 2;\n    let rotateA, rotateB, rotateC, rotateD;\n    rotation %= 360;\n    if (rotation < 0) {\n      rotation += 360;\n    }\n    switch (rotation) {\n      case 180:\n        rotateA = -1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = 1;\n        break;\n      case 90:\n        rotateA = 0;\n        rotateB = 1;\n        rotateC = 1;\n        rotateD = 0;\n        break;\n      case 270:\n        rotateA = 0;\n        rotateB = -1;\n        rotateC = -1;\n        rotateD = 0;\n        break;\n      case 0:\n        rotateA = 1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = -1;\n        break;\n      default:\n        throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n    }\n    if (dontFlip) {\n      rotateC = -rotateC;\n      rotateD = -rotateD;\n    }\n    let offsetCanvasX, offsetCanvasY;\n    let width, height;\n    if (rotateA === 0) {\n      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n      width = (viewBox[3] - viewBox[1]) * scale;\n      height = (viewBox[2] - viewBox[0]) * scale;\n    } else {\n      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n      width = (viewBox[2] - viewBox[0]) * scale;\n      height = (viewBox[3] - viewBox[1]) * scale;\n    }\n    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];\n    this.width = width;\n    this.height = height;\n  }\n  get rawDims() {\n    const dims = this.viewBox;\n    return shadow(this, \"rawDims\", {\n      pageWidth: dims[2] - dims[0],\n      pageHeight: dims[3] - dims[1],\n      pageX: dims[0],\n      pageY: dims[1]\n    });\n  }\n  clone({\n    scale = this.scale,\n    rotation = this.rotation,\n    offsetX = this.offsetX,\n    offsetY = this.offsetY,\n    dontFlip = false\n  } = {}) {\n    return new PageViewport({\n      viewBox: this.viewBox.slice(),\n      userUnit: this.userUnit,\n      scale,\n      rotation,\n      offsetX,\n      offsetY,\n      dontFlip\n    });\n  }\n  convertToViewportPoint(x, y) {\n    const p = [x, y];\n    Util.applyTransform(p, this.transform);\n    return p;\n  }\n  convertToViewportRectangle(rect) {\n    const topLeft = [rect[0], rect[1]];\n    Util.applyTransform(topLeft, this.transform);\n    const bottomRight = [rect[2], rect[3]];\n    Util.applyTransform(bottomRight, this.transform);\n    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];\n  }\n  convertToPdfPoint(x, y) {\n    const p = [x, y];\n    Util.applyInverseTransform(p, this.transform);\n    return p;\n  }\n}\nclass RenderingCancelledException extends BaseException {\n  constructor(msg, extraDelay = 0) {\n    super(msg, \"RenderingCancelledException\");\n    this.extraDelay = extraDelay;\n  }\n}\nfunction isDataScheme(url) {\n  const ii = url.length;\n  let i = 0;\n  while (i < ii && url[i].trim() === \"\") {\n    i++;\n  }\n  return url.substring(i, i + 5).toLowerCase() === \"data:\";\n}\nfunction isPdfFile(filename) {\n  return typeof filename === \"string\" && /\\.pdf$/i.test(filename);\n}\nfunction getFilenameFromUrl(url) {\n  [url] = url.split(/[#?]/, 1);\n  return url.substring(url.lastIndexOf(\"/\") + 1);\n}\nfunction getPdfFilenameFromUrl(url, defaultFilename = \"document.pdf\") {\n  if (typeof url !== \"string\") {\n    return defaultFilename;\n  }\n  if (isDataScheme(url)) {\n    warn('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.');\n    return defaultFilename;\n  }\n  const getURL = urlString => {\n    try {\n      return new URL(urlString);\n    } catch {\n      try {\n        return new URL(decodeURIComponent(urlString));\n      } catch {\n        try {\n          return new URL(urlString, \"https://foo.bar\");\n        } catch {\n          try {\n            return new URL(decodeURIComponent(urlString), \"https://foo.bar\");\n          } catch {\n            return null;\n          }\n        }\n      }\n    }\n  };\n  const newURL = getURL(url);\n  if (!newURL) {\n    return defaultFilename;\n  }\n  const decode = name => {\n    try {\n      let decoded = decodeURIComponent(name);\n      if (decoded.includes(\"/\")) {\n        decoded = decoded.split(\"/\").at(-1);\n        if (decoded.test(/^\\.pdf$/i)) {\n          return decoded;\n        }\n        return name;\n      }\n      return decoded;\n    } catch {\n      return name;\n    }\n  };\n  const pdfRegex = /\\.pdf$/i;\n  const filename = newURL.pathname.split(\"/\").at(-1);\n  if (pdfRegex.test(filename)) {\n    return decode(filename);\n  }\n  if (newURL.searchParams.size > 0) {\n    const values = Array.from(newURL.searchParams.values()).reverse();\n    for (const value of values) {\n      if (pdfRegex.test(value)) {\n        return decode(value);\n      }\n    }\n    const keys = Array.from(newURL.searchParams.keys()).reverse();\n    for (const key of keys) {\n      if (pdfRegex.test(key)) {\n        return decode(key);\n      }\n    }\n  }\n  if (newURL.hash) {\n    const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n    const hashFilename = reFilename.exec(newURL.hash);\n    if (hashFilename) {\n      return decode(hashFilename[0]);\n    }\n  }\n  return defaultFilename;\n}\nclass StatTimer {\n  started = Object.create(null);\n  times = [];\n  time(name) {\n    if (name in this.started) {\n      warn(`Timer is already running for ${name}`);\n    }\n    this.started[name] = Date.now();\n  }\n  timeEnd(name) {\n    if (!(name in this.started)) {\n      warn(`Timer has not been started for ${name}`);\n    }\n    this.times.push({\n      name,\n      start: this.started[name],\n      end: Date.now()\n    });\n    delete this.started[name];\n  }\n  toString() {\n    const outBuf = [];\n    let longest = 0;\n    for (const {\n      name\n    } of this.times) {\n      longest = Math.max(name.length, longest);\n    }\n    for (const {\n      name,\n      start,\n      end\n    } of this.times) {\n      outBuf.push(`${name.padEnd(longest)} ${end - start}ms\\n`);\n    }\n    return outBuf.join(\"\");\n  }\n}\nfunction isValidFetchUrl(url, baseUrl) {\n  const res = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);\n  return res?.protocol === \"http:\" || res?.protocol === \"https:\";\n}\nfunction noContextMenu(e) {\n  e.preventDefault();\n}\nfunction stopEvent(e) {\n  e.preventDefault();\n  e.stopPropagation();\n}\nfunction deprecated(details) {\n  console.log(\"Deprecated API usage: \" + details);\n}\nclass PDFDateString {\n  static #regex;\n  static toDateObject(input) {\n    if (input instanceof Date) {\n      return input;\n    }\n    if (!input || typeof input !== \"string\") {\n      return null;\n    }\n    this.#regex ||= new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n    const matches = this.#regex.exec(input);\n    if (!matches) {\n      return null;\n    }\n    const year = parseInt(matches[1], 10);\n    let month = parseInt(matches[2], 10);\n    month = month >= 1 && month <= 12 ? month - 1 : 0;\n    let day = parseInt(matches[3], 10);\n    day = day >= 1 && day <= 31 ? day : 1;\n    let hour = parseInt(matches[4], 10);\n    hour = hour >= 0 && hour <= 23 ? hour : 0;\n    let minute = parseInt(matches[5], 10);\n    minute = minute >= 0 && minute <= 59 ? minute : 0;\n    let second = parseInt(matches[6], 10);\n    second = second >= 0 && second <= 59 ? second : 0;\n    const universalTimeRelation = matches[7] || \"Z\";\n    let offsetHour = parseInt(matches[8], 10);\n    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n    let offsetMinute = parseInt(matches[9], 10) || 0;\n    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n    if (universalTimeRelation === \"-\") {\n      hour += offsetHour;\n      minute += offsetMinute;\n    } else if (universalTimeRelation === \"+\") {\n      hour -= offsetHour;\n      minute -= offsetMinute;\n    }\n    return new Date(Date.UTC(year, month, day, hour, minute, second));\n  }\n}\nfunction getXfaPageViewport(xfaPage, {\n  scale = 1,\n  rotation = 0\n}) {\n  const {\n    width,\n    height\n  } = xfaPage.attributes.style;\n  const viewBox = [0, 0, parseInt(width), parseInt(height)];\n  return new PageViewport({\n    viewBox,\n    userUnit: 1,\n    scale,\n    rotation\n  });\n}\nfunction getRGB(color) {\n  if (color.startsWith(\"#\")) {\n    const colorRGB = parseInt(color.slice(1), 16);\n    return [(colorRGB & 0xff0000) >> 16, (colorRGB & 0x00ff00) >> 8, colorRGB & 0x0000ff];\n  }\n  if (color.startsWith(\"rgb(\")) {\n    return color.slice(4, -1).split(\",\").map(x => parseInt(x));\n  }\n  if (color.startsWith(\"rgba(\")) {\n    return color.slice(5, -1).split(\",\").map(x => parseInt(x)).slice(0, 3);\n  }\n  warn(`Not a valid color format: \"${color}\"`);\n  return [0, 0, 0];\n}\nfunction getColorValues(colors) {\n  const span = document.createElement(\"span\");\n  span.style.visibility = \"hidden\";\n  span.style.colorScheme = \"only light\";\n  document.body.append(span);\n  for (const name of colors.keys()) {\n    span.style.color = name;\n    const computedColor = window.getComputedStyle(span).color;\n    colors.set(name, getRGB(computedColor));\n  }\n  span.remove();\n}\nfunction getCurrentTransform(ctx) {\n  const {\n    a,\n    b,\n    c,\n    d,\n    e,\n    f\n  } = ctx.getTransform();\n  return [a, b, c, d, e, f];\n}\nfunction getCurrentTransformInverse(ctx) {\n  const {\n    a,\n    b,\n    c,\n    d,\n    e,\n    f\n  } = ctx.getTransform().invertSelf();\n  return [a, b, c, d, e, f];\n}\nfunction setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {\n  if (viewport instanceof PageViewport) {\n    const {\n      pageWidth,\n      pageHeight\n    } = viewport.rawDims;\n    const {\n      style\n    } = div;\n    const useRound = util_FeatureTest.isCSSRoundSupported;\n    const w = `var(--total-scale-factor) * ${pageWidth}px`,\n      h = `var(--total-scale-factor) * ${pageHeight}px`;\n    const widthStr = useRound ? `round(down, ${w}, var(--scale-round-x))` : `calc(${w})`,\n      heightStr = useRound ? `round(down, ${h}, var(--scale-round-y))` : `calc(${h})`;\n    if (!mustFlip || viewport.rotation % 180 === 0) {\n      style.width = widthStr;\n      style.height = heightStr;\n    } else {\n      style.width = heightStr;\n      style.height = widthStr;\n    }\n  }\n  if (mustRotate) {\n    div.setAttribute(\"data-main-rotation\", viewport.rotation);\n  }\n}\nclass OutputScale {\n  constructor() {\n    const {\n      pixelRatio\n    } = OutputScale;\n    this.sx = pixelRatio;\n    this.sy = pixelRatio;\n  }\n  get scaled() {\n    return this.sx !== 1 || this.sy !== 1;\n  }\n  get symmetric() {\n    return this.sx === this.sy;\n  }\n  limitCanvas(width, height, maxPixels, maxDim, capAreaFactor = -1) {\n    let maxAreaScale = Infinity,\n      maxWidthScale = Infinity,\n      maxHeightScale = Infinity;\n    maxPixels = OutputScale.capPixels(maxPixels, capAreaFactor);\n    if (maxPixels > 0) {\n      maxAreaScale = Math.sqrt(maxPixels / (width * height));\n    }\n    if (maxDim !== -1) {\n      maxWidthScale = maxDim / width;\n      maxHeightScale = maxDim / height;\n    }\n    const maxScale = Math.min(maxAreaScale, maxWidthScale, maxHeightScale);\n    if (this.sx > maxScale || this.sy > maxScale) {\n      this.sx = maxScale;\n      this.sy = maxScale;\n      return true;\n    }\n    return false;\n  }\n  static get pixelRatio() {\n    return globalThis.devicePixelRatio || 1;\n  }\n  static capPixels(maxPixels, capAreaFactor) {\n    if (capAreaFactor >= 0) {\n      const winPixels = Math.ceil(window.screen.availWidth * window.screen.availHeight * this.pixelRatio ** 2 * (1 + capAreaFactor / 100));\n      return maxPixels > 0 ? Math.min(maxPixels, winPixels) : winPixels;\n    }\n    return maxPixels;\n  }\n}\nconst SupportedImageMimeTypes = [\"image/apng\", \"image/avif\", \"image/bmp\", \"image/gif\", \"image/jpeg\", \"image/png\", \"image/svg+xml\", \"image/webp\", \"image/x-icon\"];\n\n;// ./src/display/editor/toolbar.js\n\nclass EditorToolbar {\n  #toolbar = null;\n  #colorPicker = null;\n  #editor;\n  #buttons = null;\n  #altText = null;\n  #comment = null;\n  #signatureDescriptionButton = null;\n  static #l10nRemove = null;\n  constructor(editor) {\n    this.#editor = editor;\n    EditorToolbar.#l10nRemove ||= Object.freeze({\n      freetext: \"pdfjs-editor-remove-freetext-button\",\n      highlight: \"pdfjs-editor-remove-highlight-button\",\n      ink: \"pdfjs-editor-remove-ink-button\",\n      stamp: \"pdfjs-editor-remove-stamp-button\",\n      signature: \"pdfjs-editor-remove-signature-button\"\n    });\n  }\n  render() {\n    const editToolbar = this.#toolbar = document.createElement(\"div\");\n    editToolbar.classList.add(\"editToolbar\", \"hidden\");\n    editToolbar.setAttribute(\"role\", \"toolbar\");\n    const signal = this.#editor._uiManager._signal;\n    if (signal instanceof AbortSignal && !signal.aborted) {\n      editToolbar.addEventListener(\"contextmenu\", noContextMenu, {\n        signal\n      });\n      editToolbar.addEventListener(\"pointerdown\", EditorToolbar.#pointerDown, {\n        signal\n      });\n    }\n    const buttons = this.#buttons = document.createElement(\"div\");\n    buttons.className = \"buttons\";\n    editToolbar.append(buttons);\n    const position = this.#editor.toolbarPosition;\n    if (position) {\n      const {\n        style\n      } = editToolbar;\n      const x = this.#editor._uiManager.direction === \"ltr\" ? 1 - position[0] : position[0];\n      style.insetInlineEnd = `${100 * x}%`;\n      style.top = `calc(${100 * position[1]}% + var(--editor-toolbar-vert-offset))`;\n    }\n    return editToolbar;\n  }\n  get div() {\n    return this.#toolbar;\n  }\n  static #pointerDown(e) {\n    e.stopPropagation();\n  }\n  #focusIn(e) {\n    this.#editor._focusEventsAllowed = false;\n    stopEvent(e);\n  }\n  #focusOut(e) {\n    this.#editor._focusEventsAllowed = true;\n    stopEvent(e);\n  }\n  #addListenersToElement(element) {\n    const signal = this.#editor._uiManager._signal;\n    if (!(signal instanceof AbortSignal) || signal.aborted) {\n      return false;\n    }\n    element.addEventListener(\"focusin\", this.#focusIn.bind(this), {\n      capture: true,\n      signal\n    });\n    element.addEventListener(\"focusout\", this.#focusOut.bind(this), {\n      capture: true,\n      signal\n    });\n    element.addEventListener(\"contextmenu\", noContextMenu, {\n      signal\n    });\n    return true;\n  }\n  hide() {\n    this.#toolbar.classList.add(\"hidden\");\n    this.#colorPicker?.hideDropdown();\n  }\n  show() {\n    this.#toolbar.classList.remove(\"hidden\");\n    this.#altText?.shown();\n    this.#comment?.shown();\n  }\n  addDeleteButton() {\n    const {\n      editorType,\n      _uiManager\n    } = this.#editor;\n    const button = document.createElement(\"button\");\n    button.classList.add(\"basic\", \"deleteButton\");\n    button.tabIndex = 0;\n    button.setAttribute(\"data-l10n-id\", EditorToolbar.#l10nRemove[editorType]);\n    if (this.#addListenersToElement(button)) {\n      button.addEventListener(\"click\", e => {\n        _uiManager.delete();\n      }, {\n        signal: _uiManager._signal\n      });\n    }\n    this.#buttons.append(button);\n  }\n  get #divider() {\n    const divider = document.createElement(\"div\");\n    divider.className = \"divider\";\n    return divider;\n  }\n  async addAltText(altText) {\n    const button = await altText.render();\n    this.#addListenersToElement(button);\n    this.#buttons.append(button, this.#divider);\n    this.#altText = altText;\n  }\n  addComment(comment) {\n    if (this.#comment) {\n      return;\n    }\n    const button = comment.render();\n    if (!button) {\n      return;\n    }\n    this.#addListenersToElement(button);\n    this.#buttons.append(button, this.#divider);\n    this.#comment = comment;\n    comment.toolbar = this;\n  }\n  addColorPicker(colorPicker) {\n    if (this.#colorPicker) {\n      return;\n    }\n    this.#colorPicker = colorPicker;\n    const button = colorPicker.renderButton();\n    this.#addListenersToElement(button);\n    this.#buttons.append(button, this.#divider);\n  }\n  async addEditSignatureButton(signatureManager) {\n    const button = this.#signatureDescriptionButton = await signatureManager.renderEditButton(this.#editor);\n    this.#addListenersToElement(button);\n    this.#buttons.append(button, this.#divider);\n  }\n  async addButton(name, tool) {\n    switch (name) {\n      case \"colorPicker\":\n        this.addColorPicker(tool);\n        break;\n      case \"altText\":\n        await this.addAltText(tool);\n        break;\n      case \"editSignature\":\n        await this.addEditSignatureButton(tool);\n        break;\n      case \"delete\":\n        this.addDeleteButton();\n        break;\n      case \"comment\":\n        this.addComment(tool);\n        break;\n    }\n  }\n  updateEditSignatureButton(description) {\n    if (this.#signatureDescriptionButton) {\n      this.#signatureDescriptionButton.title = description;\n    }\n  }\n  remove() {\n    this.#toolbar.remove();\n    this.#colorPicker?.destroy();\n    this.#colorPicker = null;\n  }\n}\nclass FloatingToolbar {\n  #buttons = null;\n  #toolbar = null;\n  #uiManager;\n  constructor(uiManager) {\n    this.#uiManager = uiManager;\n  }\n  #render() {\n    const editToolbar = this.#toolbar = document.createElement(\"div\");\n    editToolbar.className = \"editToolbar\";\n    editToolbar.setAttribute(\"role\", \"toolbar\");\n    const signal = this.#uiManager._signal;\n    if (signal instanceof AbortSignal && !signal.aborted) {\n      editToolbar.addEventListener(\"contextmenu\", noContextMenu, {\n        signal\n      });\n    }\n    const buttons = this.#buttons = document.createElement(\"div\");\n    buttons.className = \"buttons\";\n    editToolbar.append(buttons);\n    if (this.#uiManager.hasCommentManager()) {\n      this.#makeButton(\"commentButton\", `pdfjs-comment-floating-button`, \"pdfjs-comment-floating-button-label\", () => {\n        this.#uiManager.commentSelection(\"floating_button\");\n      });\n    }\n    this.#makeButton(\"highlightButton\", `pdfjs-highlight-floating-button1`, \"pdfjs-highlight-floating-button-label\", () => {\n      this.#uiManager.highlightSelection(\"floating_button\");\n    });\n    return editToolbar;\n  }\n  #getLastPoint(boxes, isLTR) {\n    let lastY = 0;\n    let lastX = 0;\n    for (const box of boxes) {\n      const y = box.y + box.height;\n      if (y < lastY) {\n        continue;\n      }\n      const x = box.x + (isLTR ? box.width : 0);\n      if (y > lastY) {\n        lastX = x;\n        lastY = y;\n        continue;\n      }\n      if (isLTR) {\n        if (x > lastX) {\n          lastX = x;\n        }\n      } else if (x < lastX) {\n        lastX = x;\n      }\n    }\n    return [isLTR ? 1 - lastX : lastX, lastY];\n  }\n  show(parent, boxes, isLTR) {\n    const [x, y] = this.#getLastPoint(boxes, isLTR);\n    const {\n      style\n    } = this.#toolbar ||= this.#render();\n    parent.append(this.#toolbar);\n    style.insetInlineEnd = `${100 * x}%`;\n    style.top = `calc(${100 * y}% + var(--editor-toolbar-vert-offset))`;\n  }\n  hide() {\n    this.#toolbar.remove();\n  }\n  #makeButton(buttonClass, l10nId, labelL10nId, clickHandler) {\n    const button = document.createElement(\"button\");\n    button.classList.add(\"basic\", buttonClass);\n    button.tabIndex = 0;\n    button.setAttribute(\"data-l10n-id\", l10nId);\n    const span = document.createElement(\"span\");\n    button.append(span);\n    span.className = \"visuallyHidden\";\n    span.setAttribute(\"data-l10n-id\", labelL10nId);\n    const signal = this.#uiManager._signal;\n    if (signal instanceof AbortSignal && !signal.aborted) {\n      button.addEventListener(\"contextmenu\", noContextMenu, {\n        signal\n      });\n      button.addEventListener(\"click\", clickHandler, {\n        signal\n      });\n    }\n    this.#buttons.append(button);\n  }\n}\n\n;// ./src/display/editor/tools.js\n\n\n\nfunction bindEvents(obj, element, names) {\n  for (const name of names) {\n    element.addEventListener(name, obj[name].bind(obj));\n  }\n}\nclass IdManager {\n  #id = 0;\n  get id() {\n    return `${AnnotationEditorPrefix}${this.#id++}`;\n  }\n}\nclass ImageManager {\n  #baseId = getUuid();\n  #id = 0;\n  #cache = null;\n  static get _isSVGFittingCanvas() {\n    const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n    const canvas = new OffscreenCanvas(1, 3);\n    const ctx = canvas.getContext(\"2d\", {\n      willReadFrequently: true\n    });\n    const image = new Image();\n    image.src = svg;\n    const promise = image.decode().then(() => {\n      ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);\n      return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;\n    });\n    return shadow(this, \"_isSVGFittingCanvas\", promise);\n  }\n  async #get(key, rawData) {\n    this.#cache ||= new Map();\n    let data = this.#cache.get(key);\n    if (data === null) {\n      return null;\n    }\n    if (data?.bitmap) {\n      data.refCounter += 1;\n      return data;\n    }\n    try {\n      data ||= {\n        bitmap: null,\n        id: `image_${this.#baseId}_${this.#id++}`,\n        refCounter: 0,\n        isSvg: false\n      };\n      let image;\n      if (typeof rawData === \"string\") {\n        data.url = rawData;\n        image = await fetchData(rawData, \"blob\");\n      } else if (rawData instanceof File) {\n        image = data.file = rawData;\n      } else if (rawData instanceof Blob) {\n        image = rawData;\n      }\n      if (image.type === \"image/svg+xml\") {\n        const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;\n        const fileReader = new FileReader();\n        const imageElement = new Image();\n        const imagePromise = new Promise((resolve, reject) => {\n          imageElement.onload = () => {\n            data.bitmap = imageElement;\n            data.isSvg = true;\n            resolve();\n          };\n          fileReader.onload = async () => {\n            const url = data.svgUrl = fileReader.result;\n            imageElement.src = (await mustRemoveAspectRatioPromise) ? `${url}#svgView(preserveAspectRatio(none))` : url;\n          };\n          imageElement.onerror = fileReader.onerror = reject;\n        });\n        fileReader.readAsDataURL(image);\n        await imagePromise;\n      } else {\n        data.bitmap = await createImageBitmap(image);\n      }\n      data.refCounter = 1;\n    } catch (e) {\n      warn(e);\n      data = null;\n    }\n    this.#cache.set(key, data);\n    if (data) {\n      this.#cache.set(data.id, data);\n    }\n    return data;\n  }\n  async getFromFile(file) {\n    const {\n      lastModified,\n      name,\n      size,\n      type\n    } = file;\n    return this.#get(`${lastModified}_${name}_${size}_${type}`, file);\n  }\n  async getFromUrl(url) {\n    return this.#get(url, url);\n  }\n  async getFromBlob(id, blobPromise) {\n    const blob = await blobPromise;\n    return this.#get(id, blob);\n  }\n  async getFromId(id) {\n    this.#cache ||= new Map();\n    const data = this.#cache.get(id);\n    if (!data) {\n      return null;\n    }\n    if (data.bitmap) {\n      data.refCounter += 1;\n      return data;\n    }\n    if (data.file) {\n      return this.getFromFile(data.file);\n    }\n    if (data.blobPromise) {\n      const {\n        blobPromise\n      } = data;\n      delete data.blobPromise;\n      return this.getFromBlob(data.id, blobPromise);\n    }\n    return this.getFromUrl(data.url);\n  }\n  getFromCanvas(id, canvas) {\n    this.#cache ||= new Map();\n    let data = this.#cache.get(id);\n    if (data?.bitmap) {\n      data.refCounter += 1;\n      return data;\n    }\n    const offscreen = new OffscreenCanvas(canvas.width, canvas.height);\n    const ctx = offscreen.getContext(\"2d\");\n    ctx.drawImage(canvas, 0, 0);\n    data = {\n      bitmap: offscreen.transferToImageBitmap(),\n      id: `image_${this.#baseId}_${this.#id++}`,\n      refCounter: 1,\n      isSvg: false\n    };\n    this.#cache.set(id, data);\n    this.#cache.set(data.id, data);\n    return data;\n  }\n  getSvgUrl(id) {\n    const data = this.#cache.get(id);\n    if (!data?.isSvg) {\n      return null;\n    }\n    return data.svgUrl;\n  }\n  deleteId(id) {\n    this.#cache ||= new Map();\n    const data = this.#cache.get(id);\n    if (!data) {\n      return;\n    }\n    data.refCounter -= 1;\n    if (data.refCounter !== 0) {\n      return;\n    }\n    const {\n      bitmap\n    } = data;\n    if (!data.url && !data.file) {\n      const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\n      const ctx = canvas.getContext(\"bitmaprenderer\");\n      ctx.transferFromImageBitmap(bitmap);\n      data.blobPromise = canvas.convertToBlob();\n    }\n    bitmap.close?.();\n    data.bitmap = null;\n  }\n  isValidId(id) {\n    return id.startsWith(`image_${this.#baseId}_`);\n  }\n}\nclass CommandManager {\n  #commands = [];\n  #locked = false;\n  #maxSize;\n  #position = -1;\n  constructor(maxSize = 128) {\n    this.#maxSize = maxSize;\n  }\n  add({\n    cmd,\n    undo,\n    post,\n    mustExec,\n    type = NaN,\n    overwriteIfSameType = false,\n    keepUndo = false\n  }) {\n    if (mustExec) {\n      cmd();\n    }\n    if (this.#locked) {\n      return;\n    }\n    const save = {\n      cmd,\n      undo,\n      post,\n      type\n    };\n    if (this.#position === -1) {\n      if (this.#commands.length > 0) {\n        this.#commands.length = 0;\n      }\n      this.#position = 0;\n      this.#commands.push(save);\n      return;\n    }\n    if (overwriteIfSameType && this.#commands[this.#position].type === type) {\n      if (keepUndo) {\n        save.undo = this.#commands[this.#position].undo;\n      }\n      this.#commands[this.#position] = save;\n      return;\n    }\n    const next = this.#position + 1;\n    if (next === this.#maxSize) {\n      this.#commands.splice(0, 1);\n    } else {\n      this.#position = next;\n      if (next < this.#commands.length) {\n        this.#commands.splice(next);\n      }\n    }\n    this.#commands.push(save);\n  }\n  undo() {\n    if (this.#position === -1) {\n      return;\n    }\n    this.#locked = true;\n    const {\n      undo,\n      post\n    } = this.#commands[this.#position];\n    undo();\n    post?.();\n    this.#locked = false;\n    this.#position -= 1;\n  }\n  redo() {\n    if (this.#position < this.#commands.length - 1) {\n      this.#position += 1;\n      this.#locked = true;\n      const {\n        cmd,\n        post\n      } = this.#commands[this.#position];\n      cmd();\n      post?.();\n      this.#locked = false;\n    }\n  }\n  hasSomethingToUndo() {\n    return this.#position !== -1;\n  }\n  hasSomethingToRedo() {\n    return this.#position < this.#commands.length - 1;\n  }\n  cleanType(type) {\n    if (this.#position === -1) {\n      return;\n    }\n    for (let i = this.#position; i >= 0; i--) {\n      if (this.#commands[i].type !== type) {\n        this.#commands.splice(i + 1, this.#position - i);\n        this.#position = i;\n        return;\n      }\n    }\n    this.#commands.length = 0;\n    this.#position = -1;\n  }\n  destroy() {\n    this.#commands = null;\n  }\n}\nclass KeyboardManager {\n  constructor(callbacks) {\n    this.buffer = [];\n    this.callbacks = new Map();\n    this.allKeys = new Set();\n    const {\n      isMac\n    } = util_FeatureTest.platform;\n    for (const [keys, callback, options = {}] of callbacks) {\n      for (const key of keys) {\n        const isMacKey = key.startsWith(\"mac+\");\n        if (isMac && isMacKey) {\n          this.callbacks.set(key.slice(4), {\n            callback,\n            options\n          });\n          this.allKeys.add(key.split(\"+\").at(-1));\n        } else if (!isMac && !isMacKey) {\n          this.callbacks.set(key, {\n            callback,\n            options\n          });\n          this.allKeys.add(key.split(\"+\").at(-1));\n        }\n      }\n    }\n  }\n  #serialize(event) {\n    if (event.altKey) {\n      this.buffer.push(\"alt\");\n    }\n    if (event.ctrlKey) {\n      this.buffer.push(\"ctrl\");\n    }\n    if (event.metaKey) {\n      this.buffer.push(\"meta\");\n    }\n    if (event.shiftKey) {\n      this.buffer.push(\"shift\");\n    }\n    this.buffer.push(event.key);\n    const str = this.buffer.join(\"+\");\n    this.buffer.length = 0;\n    return str;\n  }\n  exec(self, event) {\n    if (!this.allKeys.has(event.key)) {\n      return;\n    }\n    const info = this.callbacks.get(this.#serialize(event));\n    if (!info) {\n      return;\n    }\n    const {\n      callback,\n      options: {\n        bubbles = false,\n        args = [],\n        checker = null\n      }\n    } = info;\n    if (checker && !checker(self, event)) {\n      return;\n    }\n    callback.bind(self, ...args, event)();\n    if (!bubbles) {\n      stopEvent(event);\n    }\n  }\n}\nclass ColorManager {\n  static _colorsMapping = new Map([[\"CanvasText\", [0, 0, 0]], [\"Canvas\", [255, 255, 255]]]);\n  get _colors() {\n    const colors = new Map([[\"CanvasText\", null], [\"Canvas\", null]]);\n    getColorValues(colors);\n    return shadow(this, \"_colors\", colors);\n  }\n  convert(color) {\n    const rgb = getRGB(color);\n    if (!window.matchMedia(\"(forced-colors: active)\").matches) {\n      return rgb;\n    }\n    for (const [name, RGB] of this._colors) {\n      if (RGB.every((x, i) => x === rgb[i])) {\n        return ColorManager._colorsMapping.get(name);\n      }\n    }\n    return rgb;\n  }\n  getHexCode(name) {\n    const rgb = this._colors.get(name);\n    if (!rgb) {\n      return name;\n    }\n    return Util.makeHexColor(...rgb);\n  }\n}\nclass AnnotationEditorUIManager {\n  #abortController = new AbortController();\n  #activeEditor = null;\n  #allEditableAnnotations = null;\n  #allEditors = new Map();\n  #allLayers = new Map();\n  #altTextManager = null;\n  #annotationStorage = null;\n  #changedExistingAnnotations = null;\n  #commandManager = new CommandManager();\n  #commentManager = null;\n  #copyPasteAC = null;\n  #currentDrawingSession = null;\n  #currentPageIndex = 0;\n  #deletedAnnotationsElementIds = new Set();\n  #draggingEditors = null;\n  #editorTypes = null;\n  #editorsToRescale = new Set();\n  _editorUndoBar = null;\n  #enableHighlightFloatingButton = false;\n  #enableUpdatedAddImage = false;\n  #enableNewAltTextWhenAddingImage = false;\n  #filterFactory = null;\n  #focusMainContainerTimeoutId = null;\n  #focusManagerAC = null;\n  #highlightColors = null;\n  #highlightWhenShiftUp = false;\n  #floatingToolbar = null;\n  #idManager = new IdManager();\n  #isEnabled = false;\n  #isPointerDown = false;\n  #isWaiting = false;\n  #keyboardManagerAC = null;\n  #lastActiveElement = null;\n  #mainHighlightColorPicker = null;\n  #missingCanvases = null;\n  #mlManager = null;\n  #mode = AnnotationEditorType.NONE;\n  #selectedEditors = new Set();\n  #selectedTextNode = null;\n  #signatureManager = null;\n  #pageColors = null;\n  #showAllStates = null;\n  #pdfDocument = null;\n  #previousStates = {\n    isEditing: false,\n    isEmpty: true,\n    hasSomethingToUndo: false,\n    hasSomethingToRedo: false,\n    hasSelectedEditor: false,\n    hasSelectedText: false\n  };\n  #translation = [0, 0];\n  #translationTimeoutId = null;\n  #container = null;\n  #viewer = null;\n  #viewerAlert = null;\n  #updateModeCapability = null;\n  static TRANSLATE_SMALL = 1;\n  static TRANSLATE_BIG = 10;\n  static get _keyboardManager() {\n    const proto = AnnotationEditorUIManager.prototype;\n    const arrowChecker = self => self.#container.contains(document.activeElement) && document.activeElement.tagName !== \"BUTTON\" && self.hasSomethingToControl();\n    const textInputChecker = (_self, {\n      target: el\n    }) => {\n      if (el instanceof HTMLInputElement) {\n        const {\n          type\n        } = el;\n        return type !== \"text\" && type !== \"number\";\n      }\n      return true;\n    };\n    const small = this.TRANSLATE_SMALL;\n    const big = this.TRANSLATE_BIG;\n    return shadow(this, \"_keyboardManager\", new KeyboardManager([[[\"ctrl+a\", \"mac+meta+a\"], proto.selectAll, {\n      checker: textInputChecker\n    }], [[\"ctrl+z\", \"mac+meta+z\"], proto.undo, {\n      checker: textInputChecker\n    }], [[\"ctrl+y\", \"ctrl+shift+z\", \"mac+meta+shift+z\", \"ctrl+shift+Z\", \"mac+meta+shift+Z\"], proto.redo, {\n      checker: textInputChecker\n    }], [[\"Backspace\", \"alt+Backspace\", \"ctrl+Backspace\", \"shift+Backspace\", \"mac+Backspace\", \"mac+alt+Backspace\", \"mac+ctrl+Backspace\", \"Delete\", \"ctrl+Delete\", \"shift+Delete\", \"mac+Delete\"], proto.delete, {\n      checker: textInputChecker\n    }], [[\"Enter\", \"mac+Enter\"], proto.addNewEditorFromKeyboard, {\n      checker: (self, {\n        target: el\n      }) => !(el instanceof HTMLButtonElement) && self.#container.contains(el) && !self.isEnterHandled\n    }], [[\" \", \"mac+ \"], proto.addNewEditorFromKeyboard, {\n      checker: (self, {\n        target: el\n      }) => !(el instanceof HTMLButtonElement) && self.#container.contains(document.activeElement)\n    }], [[\"Escape\", \"mac+Escape\"], proto.unselectAll], [[\"ArrowLeft\", \"mac+ArrowLeft\"], proto.translateSelectedEditors, {\n      args: [-small, 0],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowLeft\", \"mac+shift+ArrowLeft\"], proto.translateSelectedEditors, {\n      args: [-big, 0],\n      checker: arrowChecker\n    }], [[\"ArrowRight\", \"mac+ArrowRight\"], proto.translateSelectedEditors, {\n      args: [small, 0],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowRight\", \"mac+shift+ArrowRight\"], proto.translateSelectedEditors, {\n      args: [big, 0],\n      checker: arrowChecker\n    }], [[\"ArrowUp\", \"mac+ArrowUp\"], proto.translateSelectedEditors, {\n      args: [0, -small],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowUp\", \"mac+shift+ArrowUp\"], proto.translateSelectedEditors, {\n      args: [0, -big],\n      checker: arrowChecker\n    }], [[\"ArrowDown\", \"mac+ArrowDown\"], proto.translateSelectedEditors, {\n      args: [0, small],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowDown\", \"mac+shift+ArrowDown\"], proto.translateSelectedEditors, {\n      args: [0, big],\n      checker: arrowChecker\n    }]]));\n  }\n  constructor(container, viewer, viewerAlert, altTextManager, commentManager, signatureManager, eventBus, pdfDocument, pageColors, highlightColors, enableHighlightFloatingButton, enableUpdatedAddImage, enableNewAltTextWhenAddingImage, mlManager, editorUndoBar, supportsPinchToZoom) {\n    const signal = this._signal = this.#abortController.signal;\n    this.#container = container;\n    this.#viewer = viewer;\n    this.#viewerAlert = viewerAlert;\n    this.#altTextManager = altTextManager;\n    this.#commentManager = commentManager;\n    this.#signatureManager = signatureManager;\n    this.#pdfDocument = pdfDocument;\n    this._eventBus = eventBus;\n    eventBus._on(\"editingaction\", this.onEditingAction.bind(this), {\n      signal\n    });\n    eventBus._on(\"pagechanging\", this.onPageChanging.bind(this), {\n      signal\n    });\n    eventBus._on(\"scalechanging\", this.onScaleChanging.bind(this), {\n      signal\n    });\n    eventBus._on(\"rotationchanging\", this.onRotationChanging.bind(this), {\n      signal\n    });\n    eventBus._on(\"setpreference\", this.onSetPreference.bind(this), {\n      signal\n    });\n    eventBus._on(\"switchannotationeditorparams\", evt => this.updateParams(evt.type, evt.value), {\n      signal\n    });\n    window.addEventListener(\"pointerdown\", () => {\n      this.#isPointerDown = true;\n    }, {\n      capture: true,\n      signal\n    });\n    window.addEventListener(\"pointerup\", () => {\n      this.#isPointerDown = false;\n    }, {\n      capture: true,\n      signal\n    });\n    this.#addSelectionListener();\n    this.#addDragAndDropListeners();\n    this.#addKeyboardManager();\n    this.#annotationStorage = pdfDocument.annotationStorage;\n    this.#filterFactory = pdfDocument.filterFactory;\n    this.#pageColors = pageColors;\n    this.#highlightColors = highlightColors || null;\n    this.#enableHighlightFloatingButton = enableHighlightFloatingButton;\n    this.#enableUpdatedAddImage = enableUpdatedAddImage;\n    this.#enableNewAltTextWhenAddingImage = enableNewAltTextWhenAddingImage;\n    this.#mlManager = mlManager || null;\n    this.viewParameters = {\n      realScale: PixelsPerInch.PDF_TO_CSS_UNITS,\n      rotation: 0\n    };\n    this.isShiftKeyDown = false;\n    this._editorUndoBar = editorUndoBar || null;\n    this._supportsPinchToZoom = supportsPinchToZoom !== false;\n  }\n  destroy() {\n    this.#updateModeCapability?.resolve();\n    this.#updateModeCapability = null;\n    this.#abortController?.abort();\n    this.#abortController = null;\n    this._signal = null;\n    for (const layer of this.#allLayers.values()) {\n      layer.destroy();\n    }\n    this.#allLayers.clear();\n    this.#allEditors.clear();\n    this.#editorsToRescale.clear();\n    this.#missingCanvases?.clear();\n    this.#activeEditor = null;\n    this.#selectedEditors.clear();\n    this.#commandManager.destroy();\n    this.#altTextManager?.destroy();\n    this.#commentManager?.destroy();\n    this.#signatureManager?.destroy();\n    this.#floatingToolbar?.hide();\n    this.#floatingToolbar = null;\n    this.#mainHighlightColorPicker?.destroy();\n    this.#mainHighlightColorPicker = null;\n    this.#allEditableAnnotations = null;\n    if (this.#focusMainContainerTimeoutId) {\n      clearTimeout(this.#focusMainContainerTimeoutId);\n      this.#focusMainContainerTimeoutId = null;\n    }\n    if (this.#translationTimeoutId) {\n      clearTimeout(this.#translationTimeoutId);\n      this.#translationTimeoutId = null;\n    }\n    this._editorUndoBar?.destroy();\n    this.#pdfDocument = null;\n  }\n  combinedSignal(ac) {\n    return AbortSignal.any([this._signal, ac.signal]);\n  }\n  get mlManager() {\n    return this.#mlManager;\n  }\n  get useNewAltTextFlow() {\n    return this.#enableUpdatedAddImage;\n  }\n  get useNewAltTextWhenAddingImage() {\n    return this.#enableNewAltTextWhenAddingImage;\n  }\n  get hcmFilter() {\n    return shadow(this, \"hcmFilter\", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : \"none\");\n  }\n  get direction() {\n    return shadow(this, \"direction\", getComputedStyle(this.#container).direction);\n  }\n  get _highlightColors() {\n    return shadow(this, \"_highlightColors\", this.#highlightColors ? new Map(this.#highlightColors.split(\",\").map(pair => {\n      pair = pair.split(\"=\").map(x => x.trim());\n      pair[1] = pair[1].toUpperCase();\n      return pair;\n    })) : null);\n  }\n  get highlightColors() {\n    const {\n      _highlightColors\n    } = this;\n    if (!_highlightColors) {\n      return shadow(this, \"highlightColors\", null);\n    }\n    const map = new Map();\n    const hasHCM = !!this.#pageColors;\n    for (const [name, color] of _highlightColors) {\n      const isNameForHCM = name.endsWith(\"_HCM\");\n      if (hasHCM && isNameForHCM) {\n        map.set(name.replace(\"_HCM\", \"\"), color);\n        continue;\n      }\n      if (!hasHCM && !isNameForHCM) {\n        map.set(name, color);\n      }\n    }\n    return shadow(this, \"highlightColors\", map);\n  }\n  get highlightColorNames() {\n    return shadow(this, \"highlightColorNames\", this.highlightColors ? new Map(Array.from(this.highlightColors, e => e.reverse())) : null);\n  }\n  getNonHCMColor(color) {\n    if (!this._highlightColors) {\n      return color;\n    }\n    const colorName = this.highlightColorNames.get(color);\n    return this._highlightColors.get(colorName) || color;\n  }\n  getNonHCMColorName(color) {\n    return this.highlightColorNames.get(color) || color;\n  }\n  setCurrentDrawingSession(layer) {\n    if (layer) {\n      this.unselectAll();\n      this.disableUserSelect(true);\n    } else {\n      this.disableUserSelect(false);\n    }\n    this.#currentDrawingSession = layer;\n  }\n  setMainHighlightColorPicker(colorPicker) {\n    this.#mainHighlightColorPicker = colorPicker;\n  }\n  editAltText(editor, firstTime = false) {\n    this.#altTextManager?.editAltText(this, editor, firstTime);\n  }\n  hasCommentManager() {\n    return !!this.#commentManager;\n  }\n  editComment(editor, position) {\n    this.#commentManager?.open(this, editor, position);\n  }\n  getSignature(editor) {\n    this.#signatureManager?.getSignature({\n      uiManager: this,\n      editor\n    });\n  }\n  get signatureManager() {\n    return this.#signatureManager;\n  }\n  switchToMode(mode, callback) {\n    this._eventBus.on(\"annotationeditormodechanged\", callback, {\n      once: true,\n      signal: this._signal\n    });\n    this._eventBus.dispatch(\"showannotationeditorui\", {\n      source: this,\n      mode\n    });\n  }\n  setPreference(name, value) {\n    this._eventBus.dispatch(\"setpreference\", {\n      source: this,\n      name,\n      value\n    });\n  }\n  onSetPreference({\n    name,\n    value\n  }) {\n    switch (name) {\n      case \"enableNewAltTextWhenAddingImage\":\n        this.#enableNewAltTextWhenAddingImage = value;\n        break;\n    }\n  }\n  onPageChanging({\n    pageNumber\n  }) {\n    this.#currentPageIndex = pageNumber - 1;\n  }\n  focusMainContainer() {\n    this.#container.focus();\n  }\n  findParent(x, y) {\n    for (const layer of this.#allLayers.values()) {\n      const {\n        x: layerX,\n        y: layerY,\n        width,\n        height\n      } = layer.div.getBoundingClientRect();\n      if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) {\n        return layer;\n      }\n    }\n    return null;\n  }\n  disableUserSelect(value = false) {\n    this.#viewer.classList.toggle(\"noUserSelect\", value);\n  }\n  addShouldRescale(editor) {\n    this.#editorsToRescale.add(editor);\n  }\n  removeShouldRescale(editor) {\n    this.#editorsToRescale.delete(editor);\n  }\n  onScaleChanging({\n    scale\n  }) {\n    this.commitOrRemove();\n    this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;\n    for (const editor of this.#editorsToRescale) {\n      editor.onScaleChanging();\n    }\n    this.#currentDrawingSession?.onScaleChanging();\n  }\n  onRotationChanging({\n    pagesRotation\n  }) {\n    this.commitOrRemove();\n    this.viewParameters.rotation = pagesRotation;\n  }\n  #getAnchorElementForSelection({\n    anchorNode\n  }) {\n    return anchorNode.nodeType === Node.TEXT_NODE ? anchorNode.parentElement : anchorNode;\n  }\n  #getLayerForTextLayer(textLayer) {\n    const {\n      currentLayer\n    } = this;\n    if (currentLayer.hasTextLayer(textLayer)) {\n      return currentLayer;\n    }\n    for (const layer of this.#allLayers.values()) {\n      if (layer.hasTextLayer(textLayer)) {\n        return layer;\n      }\n    }\n    return null;\n  }\n  highlightSelection(methodOfCreation = \"\", comment = false) {\n    const selection = document.getSelection();\n    if (!selection || selection.isCollapsed) {\n      return;\n    }\n    const {\n      anchorNode,\n      anchorOffset,\n      focusNode,\n      focusOffset\n    } = selection;\n    const text = selection.toString();\n    const anchorElement = this.#getAnchorElementForSelection(selection);\n    const textLayer = anchorElement.closest(\".textLayer\");\n    const boxes = this.getSelectionBoxes(textLayer);\n    if (!boxes) {\n      return;\n    }\n    selection.empty();\n    const layer = this.#getLayerForTextLayer(textLayer);\n    const isNoneMode = this.#mode === AnnotationEditorType.NONE;\n    const callback = () => {\n      const editor = layer?.createAndAddNewEditor({\n        x: 0,\n        y: 0\n      }, false, {\n        methodOfCreation,\n        boxes,\n        anchorNode,\n        anchorOffset,\n        focusNode,\n        focusOffset,\n        text\n      });\n      if (isNoneMode) {\n        this.showAllEditors(\"highlight\", true, true);\n      }\n      if (comment) {\n        editor?.editComment();\n      }\n    };\n    if (isNoneMode) {\n      this.switchToMode(AnnotationEditorType.HIGHLIGHT, callback);\n      return;\n    }\n    callback();\n  }\n  commentSelection(methodOfCreation = \"\") {\n    this.highlightSelection(methodOfCreation, true);\n  }\n  #displayFloatingToolbar() {\n    const selection = document.getSelection();\n    if (!selection || selection.isCollapsed) {\n      return;\n    }\n    const anchorElement = this.#getAnchorElementForSelection(selection);\n    const textLayer = anchorElement.closest(\".textLayer\");\n    const boxes = this.getSelectionBoxes(textLayer);\n    if (!boxes) {\n      return;\n    }\n    this.#floatingToolbar ||= new FloatingToolbar(this);\n    this.#floatingToolbar.show(textLayer, boxes, this.direction === \"ltr\");\n  }\n  addToAnnotationStorage(editor) {\n    if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) {\n      this.#annotationStorage.setValue(editor.id, editor);\n    }\n  }\n  a11yAlert(messageId, args = null) {\n    const viewerAlert = this.#viewerAlert;\n    if (!viewerAlert) {\n      return;\n    }\n    viewerAlert.setAttribute(\"data-l10n-id\", messageId);\n    if (args) {\n      viewerAlert.setAttribute(\"data-l10n-args\", JSON.stringify(args));\n    } else {\n      viewerAlert.removeAttribute(\"data-l10n-args\");\n    }\n  }\n  #selectionChange() {\n    const selection = document.getSelection();\n    if (!selection || selection.isCollapsed) {\n      if (this.#selectedTextNode) {\n        this.#floatingToolbar?.hide();\n        this.#selectedTextNode = null;\n        this.#dispatchUpdateStates({\n          hasSelectedText: false\n        });\n      }\n      return;\n    }\n    const {\n      anchorNode\n    } = selection;\n    if (anchorNode === this.#selectedTextNode) {\n      return;\n    }\n    const anchorElement = this.#getAnchorElementForSelection(selection);\n    const textLayer = anchorElement.closest(\".textLayer\");\n    if (!textLayer) {\n      if (this.#selectedTextNode) {\n        this.#floatingToolbar?.hide();\n        this.#selectedTextNode = null;\n        this.#dispatchUpdateStates({\n          hasSelectedText: false\n        });\n      }\n      return;\n    }\n    this.#floatingToolbar?.hide();\n    this.#selectedTextNode = anchorNode;\n    this.#dispatchUpdateStates({\n      hasSelectedText: true\n    });\n    if (this.#mode !== AnnotationEditorType.HIGHLIGHT && this.#mode !== AnnotationEditorType.NONE) {\n      return;\n    }\n    if (this.#mode === AnnotationEditorType.HIGHLIGHT) {\n      this.showAllEditors(\"highlight\", true, true);\n    }\n    this.#highlightWhenShiftUp = this.isShiftKeyDown;\n    if (!this.isShiftKeyDown) {\n      const activeLayer = this.#mode === AnnotationEditorType.HIGHLIGHT ? this.#getLayerForTextLayer(textLayer) : null;\n      activeLayer?.toggleDrawing();\n      if (this.#isPointerDown) {\n        const ac = new AbortController();\n        const signal = this.combinedSignal(ac);\n        const pointerup = e => {\n          if (e.type === \"pointerup\" && e.button !== 0) {\n            return;\n          }\n          ac.abort();\n          activeLayer?.toggleDrawing(true);\n          if (e.type === \"pointerup\") {\n            this.#onSelectEnd(\"main_toolbar\");\n          }\n        };\n        window.addEventListener(\"pointerup\", pointerup, {\n          signal\n        });\n        window.addEventListener(\"blur\", pointerup, {\n          signal\n        });\n      } else {\n        activeLayer?.toggleDrawing(true);\n        this.#onSelectEnd(\"main_toolbar\");\n      }\n    }\n  }\n  #onSelectEnd(methodOfCreation = \"\") {\n    if (this.#mode === AnnotationEditorType.HIGHLIGHT) {\n      this.highlightSelection(methodOfCreation);\n    } else if (this.#enableHighlightFloatingButton) {\n      this.#displayFloatingToolbar();\n    }\n  }\n  #addSelectionListener() {\n    document.addEventListener(\"selectionchange\", this.#selectionChange.bind(this), {\n      signal: this._signal\n    });\n  }\n  #addFocusManager() {\n    if (this.#focusManagerAC) {\n      return;\n    }\n    this.#focusManagerAC = new AbortController();\n    const signal = this.combinedSignal(this.#focusManagerAC);\n    window.addEventListener(\"focus\", this.focus.bind(this), {\n      signal\n    });\n    window.addEventListener(\"blur\", this.blur.bind(this), {\n      signal\n    });\n  }\n  #removeFocusManager() {\n    this.#focusManagerAC?.abort();\n    this.#focusManagerAC = null;\n  }\n  blur() {\n    this.isShiftKeyDown = false;\n    if (this.#highlightWhenShiftUp) {\n      this.#highlightWhenShiftUp = false;\n      this.#onSelectEnd(\"main_toolbar\");\n    }\n    if (!this.hasSelection) {\n      return;\n    }\n    const {\n      activeElement\n    } = document;\n    for (const editor of this.#selectedEditors) {\n      if (editor.div.contains(activeElement)) {\n        this.#lastActiveElement = [editor, activeElement];\n        editor._focusEventsAllowed = false;\n        break;\n      }\n    }\n  }\n  focus() {\n    if (!this.#lastActiveElement) {\n      return;\n    }\n    const [lastEditor, lastActiveElement] = this.#lastActiveElement;\n    this.#lastActiveElement = null;\n    lastActiveElement.addEventListener(\"focusin\", () => {\n      lastEditor._focusEventsAllowed = true;\n    }, {\n      once: true,\n      signal: this._signal\n    });\n    lastActiveElement.focus();\n  }\n  #addKeyboardManager() {\n    if (this.#keyboardManagerAC) {\n      return;\n    }\n    this.#keyboardManagerAC = new AbortController();\n    const signal = this.combinedSignal(this.#keyboardManagerAC);\n    window.addEventListener(\"keydown\", this.keydown.bind(this), {\n      signal\n    });\n    window.addEventListener(\"keyup\", this.keyup.bind(this), {\n      signal\n    });\n  }\n  #removeKeyboardManager() {\n    this.#keyboardManagerAC?.abort();\n    this.#keyboardManagerAC = null;\n  }\n  #addCopyPasteListeners() {\n    if (this.#copyPasteAC) {\n      return;\n    }\n    this.#copyPasteAC = new AbortController();\n    const signal = this.combinedSignal(this.#copyPasteAC);\n    document.addEventListener(\"copy\", this.copy.bind(this), {\n      signal\n    });\n    document.addEventListener(\"cut\", this.cut.bind(this), {\n      signal\n    });\n    document.addEventListener(\"paste\", this.paste.bind(this), {\n      signal\n    });\n  }\n  #removeCopyPasteListeners() {\n    this.#copyPasteAC?.abort();\n    this.#copyPasteAC = null;\n  }\n  #addDragAndDropListeners() {\n    const signal = this._signal;\n    document.addEventListener(\"dragover\", this.dragOver.bind(this), {\n      signal\n    });\n    document.addEventListener(\"drop\", this.drop.bind(this), {\n      signal\n    });\n  }\n  addEditListeners() {\n    this.#addKeyboardManager();\n    this.#addCopyPasteListeners();\n  }\n  removeEditListeners() {\n    this.#removeKeyboardManager();\n    this.#removeCopyPasteListeners();\n  }\n  dragOver(event) {\n    for (const {\n      type\n    } of event.dataTransfer.items) {\n      for (const editorType of this.#editorTypes) {\n        if (editorType.isHandlingMimeForPasting(type)) {\n          event.dataTransfer.dropEffect = \"copy\";\n          event.preventDefault();\n          return;\n        }\n      }\n    }\n  }\n  drop(event) {\n    for (const item of event.dataTransfer.items) {\n      for (const editorType of this.#editorTypes) {\n        if (editorType.isHandlingMimeForPasting(item.type)) {\n          editorType.paste(item, this.currentLayer);\n          event.preventDefault();\n          return;\n        }\n      }\n    }\n  }\n  copy(event) {\n    event.preventDefault();\n    this.#activeEditor?.commitOrRemove();\n    if (!this.hasSelection) {\n      return;\n    }\n    const editors = [];\n    for (const editor of this.#selectedEditors) {\n      const serialized = editor.serialize(true);\n      if (serialized) {\n        editors.push(serialized);\n      }\n    }\n    if (editors.length === 0) {\n      return;\n    }\n    event.clipboardData.setData(\"application/pdfjs\", JSON.stringify(editors));\n  }\n  cut(event) {\n    this.copy(event);\n    this.delete();\n  }\n  async paste(event) {\n    event.preventDefault();\n    const {\n      clipboardData\n    } = event;\n    for (const item of clipboardData.items) {\n      for (const editorType of this.#editorTypes) {\n        if (editorType.isHandlingMimeForPasting(item.type)) {\n          editorType.paste(item, this.currentLayer);\n          return;\n        }\n      }\n    }\n    let data = clipboardData.getData(\"application/pdfjs\");\n    if (!data) {\n      return;\n    }\n    try {\n      data = JSON.parse(data);\n    } catch (ex) {\n      warn(`paste: \"${ex.message}\".`);\n      return;\n    }\n    if (!Array.isArray(data)) {\n      return;\n    }\n    this.unselectAll();\n    const layer = this.currentLayer;\n    try {\n      const newEditors = [];\n      for (const editor of data) {\n        const deserializedEditor = await layer.deserialize(editor);\n        if (!deserializedEditor) {\n          return;\n        }\n        newEditors.push(deserializedEditor);\n      }\n      const cmd = () => {\n        for (const editor of newEditors) {\n          this.#addEditorToLayer(editor);\n        }\n        this.#selectEditors(newEditors);\n      };\n      const undo = () => {\n        for (const editor of newEditors) {\n          editor.remove();\n        }\n      };\n      this.addCommands({\n        cmd,\n        undo,\n        mustExec: true\n      });\n    } catch (ex) {\n      warn(`paste: \"${ex.message}\".`);\n    }\n  }\n  keydown(event) {\n    if (!this.isShiftKeyDown && event.key === \"Shift\") {\n      this.isShiftKeyDown = true;\n    }\n    if (this.#mode !== AnnotationEditorType.NONE && !this.isEditorHandlingKeyboard) {\n      AnnotationEditorUIManager._keyboardManager.exec(this, event);\n    }\n  }\n  keyup(event) {\n    if (this.isShiftKeyDown && event.key === \"Shift\") {\n      this.isShiftKeyDown = false;\n      if (this.#highlightWhenShiftUp) {\n        this.#highlightWhenShiftUp = false;\n        this.#onSelectEnd(\"main_toolbar\");\n      }\n    }\n  }\n  onEditingAction({\n    name\n  }) {\n    switch (name) {\n      case \"undo\":\n      case \"redo\":\n      case \"delete\":\n      case \"selectAll\":\n        this[name]();\n        break;\n      case \"highlightSelection\":\n        this.highlightSelection(\"context_menu\");\n        break;\n      case \"commentSelection\":\n        this.commentSelection(\"context_menu\");\n        break;\n    }\n  }\n  #dispatchUpdateStates(details) {\n    const hasChanged = Object.entries(details).some(([key, value]) => this.#previousStates[key] !== value);\n    if (hasChanged) {\n      this._eventBus.dispatch(\"annotationeditorstateschanged\", {\n        source: this,\n        details: Object.assign(this.#previousStates, details)\n      });\n      if (this.#mode === AnnotationEditorType.HIGHLIGHT && details.hasSelectedEditor === false) {\n        this.#dispatchUpdateUI([[AnnotationEditorParamsType.HIGHLIGHT_FREE, true]]);\n      }\n    }\n  }\n  #dispatchUpdateUI(details) {\n    this._eventBus.dispatch(\"annotationeditorparamschanged\", {\n      source: this,\n      details\n    });\n  }\n  setEditingState(isEditing) {\n    if (isEditing) {\n      this.#addFocusManager();\n      this.#addCopyPasteListeners();\n      this.#dispatchUpdateStates({\n        isEditing: this.#mode !== AnnotationEditorType.NONE,\n        isEmpty: this.#isEmpty(),\n        hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n        hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n        hasSelectedEditor: false\n      });\n    } else {\n      this.#removeFocusManager();\n      this.#removeCopyPasteListeners();\n      this.#dispatchUpdateStates({\n        isEditing: false\n      });\n      this.disableUserSelect(false);\n    }\n  }\n  registerEditorTypes(types) {\n    if (this.#editorTypes) {\n      return;\n    }\n    this.#editorTypes = types;\n    for (const editorType of this.#editorTypes) {\n      this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n    }\n  }\n  getId() {\n    return this.#idManager.id;\n  }\n  get currentLayer() {\n    return this.#allLayers.get(this.#currentPageIndex);\n  }\n  getLayer(pageIndex) {\n    return this.#allLayers.get(pageIndex);\n  }\n  get currentPageIndex() {\n    return this.#currentPageIndex;\n  }\n  addLayer(layer) {\n    this.#allLayers.set(layer.pageIndex, layer);\n    if (this.#isEnabled) {\n      layer.enable();\n    } else {\n      layer.disable();\n    }\n  }\n  removeLayer(layer) {\n    this.#allLayers.delete(layer.pageIndex);\n  }\n  async updateMode(mode, editId = null, isFromKeyboard = false, mustEnterInEditMode = false, editComment = false) {\n    if (this.#mode === mode) {\n      return;\n    }\n    if (this.#updateModeCapability) {\n      await this.#updateModeCapability.promise;\n      if (!this.#updateModeCapability) {\n        return;\n      }\n    }\n    this.#updateModeCapability = Promise.withResolvers();\n    this.#currentDrawingSession?.commitOrRemove();\n    if (this.#mode === AnnotationEditorType.POPUP) {\n      this.#commentManager?.hideSidebar();\n    }\n    this.#mode = mode;\n    if (mode === AnnotationEditorType.NONE) {\n      this.setEditingState(false);\n      this.#disableAll();\n      this._editorUndoBar?.hide();\n      this.#updateModeCapability.resolve();\n      return;\n    }\n    if (mode === AnnotationEditorType.SIGNATURE) {\n      await this.#signatureManager?.loadSignatures();\n    }\n    if (mode === AnnotationEditorType.POPUP) {\n      this.#allEditableAnnotations ||= await this.#pdfDocument.getAnnotationsByType(new Set(this.#editorTypes.map(editorClass => editorClass._editorType)));\n      this.#commentManager?.showSidebar(this.#allEditableAnnotations);\n    }\n    this.setEditingState(true);\n    await this.#enableAll();\n    this.unselectAll();\n    for (const layer of this.#allLayers.values()) {\n      layer.updateMode(mode);\n    }\n    if (!editId) {\n      if (isFromKeyboard) {\n        this.addNewEditorFromKeyboard();\n      }\n      this.#updateModeCapability.resolve();\n      return;\n    }\n    for (const editor of this.#allEditors.values()) {\n      if (editor.annotationElementId === editId || editor.id === editId) {\n        this.setSelected(editor);\n        if (editComment) {\n          editor.editComment();\n        } else if (mustEnterInEditMode) {\n          editor.enterInEditMode();\n        }\n      } else {\n        editor.unselect();\n      }\n    }\n    this.#updateModeCapability.resolve();\n  }\n  addNewEditorFromKeyboard() {\n    if (this.currentLayer.canCreateNewEmptyEditor()) {\n      this.currentLayer.addNewEditor();\n    }\n  }\n  updateToolbar(options) {\n    if (options.mode === this.#mode) {\n      return;\n    }\n    this._eventBus.dispatch(\"switchannotationeditormode\", {\n      source: this,\n      ...options\n    });\n  }\n  updateParams(type, value) {\n    if (!this.#editorTypes) {\n      return;\n    }\n    switch (type) {\n      case AnnotationEditorParamsType.CREATE:\n        this.currentLayer.addNewEditor(value);\n        return;\n      case AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL:\n        this._eventBus.dispatch(\"reporttelemetry\", {\n          source: this,\n          details: {\n            type: \"editing\",\n            data: {\n              type: \"highlight\",\n              action: \"toggle_visibility\"\n            }\n          }\n        });\n        (this.#showAllStates ||= new Map()).set(type, value);\n        this.showAllEditors(\"highlight\", value);\n        break;\n    }\n    if (this.hasSelection) {\n      for (const editor of this.#selectedEditors) {\n        editor.updateParams(type, value);\n      }\n    } else {\n      for (const editorType of this.#editorTypes) {\n        editorType.updateDefaultParams(type, value);\n      }\n    }\n  }\n  showAllEditors(type, visible, updateButton = false) {\n    for (const editor of this.#allEditors.values()) {\n      if (editor.editorType === type) {\n        editor.show(visible);\n      }\n    }\n    const state = this.#showAllStates?.get(AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL) ?? true;\n    if (state !== visible) {\n      this.#dispatchUpdateUI([[AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL, visible]]);\n    }\n  }\n  enableWaiting(mustWait = false) {\n    if (this.#isWaiting === mustWait) {\n      return;\n    }\n    this.#isWaiting = mustWait;\n    for (const layer of this.#allLayers.values()) {\n      if (mustWait) {\n        layer.disableClick();\n      } else {\n        layer.enableClick();\n      }\n      layer.div.classList.toggle(\"waiting\", mustWait);\n    }\n  }\n  async #enableAll() {\n    if (!this.#isEnabled) {\n      this.#isEnabled = true;\n      const promises = [];\n      for (const layer of this.#allLayers.values()) {\n        promises.push(layer.enable());\n      }\n      await Promise.all(promises);\n      for (const editor of this.#allEditors.values()) {\n        editor.enable();\n      }\n    }\n  }\n  #disableAll() {\n    this.unselectAll();\n    if (this.#isEnabled) {\n      this.#isEnabled = false;\n      for (const layer of this.#allLayers.values()) {\n        layer.disable();\n      }\n      for (const editor of this.#allEditors.values()) {\n        editor.disable();\n      }\n    }\n  }\n  getEditors(pageIndex) {\n    const editors = [];\n    for (const editor of this.#allEditors.values()) {\n      if (editor.pageIndex === pageIndex) {\n        editors.push(editor);\n      }\n    }\n    return editors;\n  }\n  getEditor(id) {\n    return this.#allEditors.get(id);\n  }\n  addEditor(editor) {\n    this.#allEditors.set(editor.id, editor);\n  }\n  removeEditor(editor) {\n    if (editor.div.contains(document.activeElement)) {\n      if (this.#focusMainContainerTimeoutId) {\n        clearTimeout(this.#focusMainContainerTimeoutId);\n      }\n      this.#focusMainContainerTimeoutId = setTimeout(() => {\n        this.focusMainContainer();\n        this.#focusMainContainerTimeoutId = null;\n      }, 0);\n    }\n    this.#allEditors.delete(editor.id);\n    if (editor.annotationElementId) {\n      this.#missingCanvases?.delete(editor.annotationElementId);\n    }\n    this.unselect(editor);\n    if (!editor.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)) {\n      this.#annotationStorage?.remove(editor.id);\n    }\n  }\n  addDeletedAnnotationElement(editor) {\n    this.#deletedAnnotationsElementIds.add(editor.annotationElementId);\n    this.addChangedExistingAnnotation(editor);\n    editor.deleted = true;\n  }\n  isDeletedAnnotationElement(annotationElementId) {\n    return this.#deletedAnnotationsElementIds.has(annotationElementId);\n  }\n  removeDeletedAnnotationElement(editor) {\n    this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);\n    this.removeChangedExistingAnnotation(editor);\n    editor.deleted = false;\n  }\n  #addEditorToLayer(editor) {\n    const layer = this.#allLayers.get(editor.pageIndex);\n    if (layer) {\n      layer.addOrRebuild(editor);\n    } else {\n      this.addEditor(editor);\n      this.addToAnnotationStorage(editor);\n    }\n  }\n  setActiveEditor(editor) {\n    if (this.#activeEditor === editor) {\n      return;\n    }\n    this.#activeEditor = editor;\n    if (editor) {\n      this.#dispatchUpdateUI(editor.propertiesToUpdate);\n    }\n  }\n  get #lastSelectedEditor() {\n    let ed = null;\n    for (ed of this.#selectedEditors) {}\n    return ed;\n  }\n  updateUI(editor) {\n    if (this.#lastSelectedEditor === editor) {\n      this.#dispatchUpdateUI(editor.propertiesToUpdate);\n    }\n  }\n  updateUIForDefaultProperties(editorType) {\n    this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n  }\n  toggleSelected(editor) {\n    if (this.#selectedEditors.has(editor)) {\n      this.#selectedEditors.delete(editor);\n      editor.unselect();\n      this.#dispatchUpdateStates({\n        hasSelectedEditor: this.hasSelection\n      });\n      return;\n    }\n    this.#selectedEditors.add(editor);\n    editor.select();\n    this.#dispatchUpdateUI(editor.propertiesToUpdate);\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: true\n    });\n  }\n  setSelected(editor) {\n    this.updateToolbar({\n      mode: editor.mode,\n      editId: editor.id\n    });\n    this.#currentDrawingSession?.commitOrRemove();\n    for (const ed of this.#selectedEditors) {\n      if (ed !== editor) {\n        ed.unselect();\n      }\n    }\n    this.#selectedEditors.clear();\n    this.#selectedEditors.add(editor);\n    editor.select();\n    this.#dispatchUpdateUI(editor.propertiesToUpdate);\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: true\n    });\n  }\n  isSelected(editor) {\n    return this.#selectedEditors.has(editor);\n  }\n  get firstSelectedEditor() {\n    return this.#selectedEditors.values().next().value;\n  }\n  unselect(editor) {\n    editor.unselect();\n    this.#selectedEditors.delete(editor);\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: this.hasSelection\n    });\n  }\n  get hasSelection() {\n    return this.#selectedEditors.size !== 0;\n  }\n  get isEnterHandled() {\n    return this.#selectedEditors.size === 1 && this.firstSelectedEditor.isEnterHandled;\n  }\n  undo() {\n    this.#commandManager.undo();\n    this.#dispatchUpdateStates({\n      hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n      hasSomethingToRedo: true,\n      isEmpty: this.#isEmpty()\n    });\n    this._editorUndoBar?.hide();\n  }\n  redo() {\n    this.#commandManager.redo();\n    this.#dispatchUpdateStates({\n      hasSomethingToUndo: true,\n      hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n      isEmpty: this.#isEmpty()\n    });\n  }\n  addCommands(params) {\n    this.#commandManager.add(params);\n    this.#dispatchUpdateStates({\n      hasSomethingToUndo: true,\n      hasSomethingToRedo: false,\n      isEmpty: this.#isEmpty()\n    });\n  }\n  cleanUndoStack(type) {\n    this.#commandManager.cleanType(type);\n  }\n  #isEmpty() {\n    if (this.#allEditors.size === 0) {\n      return true;\n    }\n    if (this.#allEditors.size === 1) {\n      for (const editor of this.#allEditors.values()) {\n        return editor.isEmpty();\n      }\n    }\n    return false;\n  }\n  delete() {\n    this.commitOrRemove();\n    const drawingEditor = this.currentLayer?.endDrawingSession(true);\n    if (!this.hasSelection && !drawingEditor) {\n      return;\n    }\n    const editors = drawingEditor ? [drawingEditor] : [...this.#selectedEditors];\n    const cmd = () => {\n      this._editorUndoBar?.show(undo, editors.length === 1 ? editors[0].editorType : editors.length);\n      for (const editor of editors) {\n        editor.remove();\n      }\n    };\n    const undo = () => {\n      for (const editor of editors) {\n        this.#addEditorToLayer(editor);\n      }\n    };\n    this.addCommands({\n      cmd,\n      undo,\n      mustExec: true\n    });\n  }\n  commitOrRemove() {\n    this.#activeEditor?.commitOrRemove();\n  }\n  hasSomethingToControl() {\n    return this.#activeEditor || this.hasSelection;\n  }\n  #selectEditors(editors) {\n    for (const editor of this.#selectedEditors) {\n      editor.unselect();\n    }\n    this.#selectedEditors.clear();\n    for (const editor of editors) {\n      if (editor.isEmpty()) {\n        continue;\n      }\n      this.#selectedEditors.add(editor);\n      editor.select();\n    }\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: this.hasSelection\n    });\n  }\n  selectAll() {\n    for (const editor of this.#selectedEditors) {\n      editor.commit();\n    }\n    this.#selectEditors(this.#allEditors.values());\n  }\n  unselectAll() {\n    if (this.#activeEditor) {\n      this.#activeEditor.commitOrRemove();\n      if (this.#mode !== AnnotationEditorType.NONE) {\n        return;\n      }\n    }\n    if (this.#currentDrawingSession?.commitOrRemove()) {\n      return;\n    }\n    if (!this.hasSelection) {\n      return;\n    }\n    for (const editor of this.#selectedEditors) {\n      editor.unselect();\n    }\n    this.#selectedEditors.clear();\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: false\n    });\n  }\n  translateSelectedEditors(x, y, noCommit = false) {\n    if (!noCommit) {\n      this.commitOrRemove();\n    }\n    if (!this.hasSelection) {\n      return;\n    }\n    this.#translation[0] += x;\n    this.#translation[1] += y;\n    const [totalX, totalY] = this.#translation;\n    const editors = [...this.#selectedEditors];\n    const TIME_TO_WAIT = 1000;\n    if (this.#translationTimeoutId) {\n      clearTimeout(this.#translationTimeoutId);\n    }\n    this.#translationTimeoutId = setTimeout(() => {\n      this.#translationTimeoutId = null;\n      this.#translation[0] = this.#translation[1] = 0;\n      this.addCommands({\n        cmd: () => {\n          for (const editor of editors) {\n            if (this.#allEditors.has(editor.id)) {\n              editor.translateInPage(totalX, totalY);\n              editor.translationDone();\n            }\n          }\n        },\n        undo: () => {\n          for (const editor of editors) {\n            if (this.#allEditors.has(editor.id)) {\n              editor.translateInPage(-totalX, -totalY);\n              editor.translationDone();\n            }\n          }\n        },\n        mustExec: false\n      });\n    }, TIME_TO_WAIT);\n    for (const editor of editors) {\n      editor.translateInPage(x, y);\n      editor.translationDone();\n    }\n  }\n  setUpDragSession() {\n    if (!this.hasSelection) {\n      return;\n    }\n    this.disableUserSelect(true);\n    this.#draggingEditors = new Map();\n    for (const editor of this.#selectedEditors) {\n      this.#draggingEditors.set(editor, {\n        savedX: editor.x,\n        savedY: editor.y,\n        savedPageIndex: editor.pageIndex,\n        newX: 0,\n        newY: 0,\n        newPageIndex: -1\n      });\n    }\n  }\n  endDragSession() {\n    if (!this.#draggingEditors) {\n      return false;\n    }\n    this.disableUserSelect(false);\n    const map = this.#draggingEditors;\n    this.#draggingEditors = null;\n    let mustBeAddedInUndoStack = false;\n    for (const [{\n      x,\n      y,\n      pageIndex\n    }, value] of map) {\n      value.newX = x;\n      value.newY = y;\n      value.newPageIndex = pageIndex;\n      mustBeAddedInUndoStack ||= x !== value.savedX || y !== value.savedY || pageIndex !== value.savedPageIndex;\n    }\n    if (!mustBeAddedInUndoStack) {\n      return false;\n    }\n    const move = (editor, x, y, pageIndex) => {\n      if (this.#allEditors.has(editor.id)) {\n        const parent = this.#allLayers.get(pageIndex);\n        if (parent) {\n          editor._setParentAndPosition(parent, x, y);\n        } else {\n          editor.pageIndex = pageIndex;\n          editor.x = x;\n          editor.y = y;\n        }\n      }\n    };\n    this.addCommands({\n      cmd: () => {\n        for (const [editor, {\n          newX,\n          newY,\n          newPageIndex\n        }] of map) {\n          move(editor, newX, newY, newPageIndex);\n        }\n      },\n      undo: () => {\n        for (const [editor, {\n          savedX,\n          savedY,\n          savedPageIndex\n        }] of map) {\n          move(editor, savedX, savedY, savedPageIndex);\n        }\n      },\n      mustExec: true\n    });\n    return true;\n  }\n  dragSelectedEditors(tx, ty) {\n    if (!this.#draggingEditors) {\n      return;\n    }\n    for (const editor of this.#draggingEditors.keys()) {\n      editor.drag(tx, ty);\n    }\n  }\n  rebuild(editor) {\n    if (editor.parent === null) {\n      const parent = this.getLayer(editor.pageIndex);\n      if (parent) {\n        parent.changeParent(editor);\n        parent.addOrRebuild(editor);\n      } else {\n        this.addEditor(editor);\n        this.addToAnnotationStorage(editor);\n        editor.rebuild();\n      }\n    } else {\n      editor.parent.addOrRebuild(editor);\n    }\n  }\n  get isEditorHandlingKeyboard() {\n    return this.getActive()?.shouldGetKeyboardEvents() || this.#selectedEditors.size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();\n  }\n  isActive(editor) {\n    return this.#activeEditor === editor;\n  }\n  getActive() {\n    return this.#activeEditor;\n  }\n  getMode() {\n    return this.#mode;\n  }\n  get imageManager() {\n    return shadow(this, \"imageManager\", new ImageManager());\n  }\n  getSelectionBoxes(textLayer) {\n    if (!textLayer) {\n      return null;\n    }\n    const selection = document.getSelection();\n    for (let i = 0, ii = selection.rangeCount; i < ii; i++) {\n      if (!textLayer.contains(selection.getRangeAt(i).commonAncestorContainer)) {\n        return null;\n      }\n    }\n    const {\n      x: layerX,\n      y: layerY,\n      width: parentWidth,\n      height: parentHeight\n    } = textLayer.getBoundingClientRect();\n    let rotator;\n    switch (textLayer.getAttribute(\"data-main-rotation\")) {\n      case \"90\":\n        rotator = (x, y, w, h) => ({\n          x: (y - layerY) / parentHeight,\n          y: 1 - (x + w - layerX) / parentWidth,\n          width: h / parentHeight,\n          height: w / parentWidth\n        });\n        break;\n      case \"180\":\n        rotator = (x, y, w, h) => ({\n          x: 1 - (x + w - layerX) / parentWidth,\n          y: 1 - (y + h - layerY) / parentHeight,\n          width: w / parentWidth,\n          height: h / parentHeight\n        });\n        break;\n      case \"270\":\n        rotator = (x, y, w, h) => ({\n          x: 1 - (y + h - layerY) / parentHeight,\n          y: (x - layerX) / parentWidth,\n          width: h / parentHeight,\n          height: w / parentWidth\n        });\n        break;\n      default:\n        rotator = (x, y, w, h) => ({\n          x: (x - layerX) / parentWidth,\n          y: (y - layerY) / parentHeight,\n          width: w / parentWidth,\n          height: h / parentHeight\n        });\n        break;\n    }\n    const boxes = [];\n    for (let i = 0, ii = selection.rangeCount; i < ii; i++) {\n      const range = selection.getRangeAt(i);\n      if (range.collapsed) {\n        continue;\n      }\n      for (const {\n        x,\n        y,\n        width,\n        height\n      } of range.getClientRects()) {\n        if (width === 0 || height === 0) {\n          continue;\n        }\n        boxes.push(rotator(x, y, width, height));\n      }\n    }\n    return boxes.length === 0 ? null : boxes;\n  }\n  addChangedExistingAnnotation({\n    annotationElementId,\n    id\n  }) {\n    (this.#changedExistingAnnotations ||= new Map()).set(annotationElementId, id);\n  }\n  removeChangedExistingAnnotation({\n    annotationElementId\n  }) {\n    this.#changedExistingAnnotations?.delete(annotationElementId);\n  }\n  renderAnnotationElement(annotation) {\n    const editorId = this.#changedExistingAnnotations?.get(annotation.data.id);\n    if (!editorId) {\n      return;\n    }\n    const editor = this.#annotationStorage.getRawValue(editorId);\n    if (!editor) {\n      return;\n    }\n    if (this.#mode === AnnotationEditorType.NONE && !editor.hasBeenModified) {\n      return;\n    }\n    editor.renderAnnotationElement(annotation);\n  }\n  setMissingCanvas(annotationId, annotationElementId, canvas) {\n    const editor = this.#missingCanvases?.get(annotationId);\n    if (!editor) {\n      return;\n    }\n    editor.setCanvas(annotationElementId, canvas);\n    this.#missingCanvases.delete(annotationId);\n  }\n  addMissingCanvas(annotationId, editor) {\n    (this.#missingCanvases ||= new Map()).set(annotationId, editor);\n  }\n}\n\n;// ./src/display/editor/alt_text.js\n\nclass AltText {\n  #altText = null;\n  #altTextDecorative = false;\n  #altTextButton = null;\n  #altTextButtonLabel = null;\n  #altTextTooltip = null;\n  #altTextTooltipTimeout = null;\n  #altTextWasFromKeyBoard = false;\n  #badge = null;\n  #editor = null;\n  #guessedText = null;\n  #textWithDisclaimer = null;\n  #useNewAltTextFlow = false;\n  static #l10nNewButton = null;\n  static _l10n = null;\n  constructor(editor) {\n    this.#editor = editor;\n    this.#useNewAltTextFlow = editor._uiManager.useNewAltTextFlow;\n    AltText.#l10nNewButton ||= Object.freeze({\n      added: \"pdfjs-editor-new-alt-text-added-button\",\n      \"added-label\": \"pdfjs-editor-new-alt-text-added-button-label\",\n      missing: \"pdfjs-editor-new-alt-text-missing-button\",\n      \"missing-label\": \"pdfjs-editor-new-alt-text-missing-button-label\",\n      review: \"pdfjs-editor-new-alt-text-to-review-button\",\n      \"review-label\": \"pdfjs-editor-new-alt-text-to-review-button-label\"\n    });\n  }\n  static initialize(l10n) {\n    AltText._l10n ??= l10n;\n  }\n  async render() {\n    const altText = this.#altTextButton = document.createElement(\"button\");\n    altText.className = \"altText\";\n    altText.tabIndex = \"0\";\n    const label = this.#altTextButtonLabel = document.createElement(\"span\");\n    altText.append(label);\n    if (this.#useNewAltTextFlow) {\n      altText.classList.add(\"new\");\n      altText.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton.missing);\n      label.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[\"missing-label\"]);\n    } else {\n      altText.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-button\");\n      label.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-button-label\");\n    }\n    const signal = this.#editor._uiManager._signal;\n    altText.addEventListener(\"contextmenu\", noContextMenu, {\n      signal\n    });\n    altText.addEventListener(\"pointerdown\", event => event.stopPropagation(), {\n      signal\n    });\n    const onClick = event => {\n      event.preventDefault();\n      this.#editor._uiManager.editAltText(this.#editor);\n      if (this.#useNewAltTextFlow) {\n        this.#editor._reportTelemetry({\n          action: \"pdfjs.image.alt_text.image_status_label_clicked\",\n          data: {\n            label: this.#label\n          }\n        });\n      }\n    };\n    altText.addEventListener(\"click\", onClick, {\n      capture: true,\n      signal\n    });\n    altText.addEventListener(\"keydown\", event => {\n      if (event.target === altText && event.key === \"Enter\") {\n        this.#altTextWasFromKeyBoard = true;\n        onClick(event);\n      }\n    }, {\n      signal\n    });\n    await this.#setState();\n    return altText;\n  }\n  get #label() {\n    return this.#altText && \"added\" || this.#altText === null && this.guessedText && \"review\" || \"missing\";\n  }\n  finish() {\n    if (!this.#altTextButton) {\n      return;\n    }\n    this.#altTextButton.focus({\n      focusVisible: this.#altTextWasFromKeyBoard\n    });\n    this.#altTextWasFromKeyBoard = false;\n  }\n  isEmpty() {\n    if (this.#useNewAltTextFlow) {\n      return this.#altText === null;\n    }\n    return !this.#altText && !this.#altTextDecorative;\n  }\n  hasData() {\n    if (this.#useNewAltTextFlow) {\n      return this.#altText !== null || !!this.#guessedText;\n    }\n    return this.isEmpty();\n  }\n  get guessedText() {\n    return this.#guessedText;\n  }\n  async setGuessedText(guessedText) {\n    if (this.#altText !== null) {\n      return;\n    }\n    this.#guessedText = guessedText;\n    this.#textWithDisclaimer = await AltText._l10n.get(\"pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer\", {\n      generatedAltText: guessedText\n    });\n    this.#setState();\n  }\n  toggleAltTextBadge(visibility = false) {\n    if (!this.#useNewAltTextFlow || this.#altText) {\n      this.#badge?.remove();\n      this.#badge = null;\n      return;\n    }\n    if (!this.#badge) {\n      const badge = this.#badge = document.createElement(\"div\");\n      badge.className = \"noAltTextBadge\";\n      this.#editor.div.append(badge);\n    }\n    this.#badge.classList.toggle(\"hidden\", !visibility);\n  }\n  serialize(isForCopying) {\n    let altText = this.#altText;\n    if (!isForCopying && this.#guessedText === altText) {\n      altText = this.#textWithDisclaimer;\n    }\n    return {\n      altText,\n      decorative: this.#altTextDecorative,\n      guessedText: this.#guessedText,\n      textWithDisclaimer: this.#textWithDisclaimer\n    };\n  }\n  get data() {\n    return {\n      altText: this.#altText,\n      decorative: this.#altTextDecorative\n    };\n  }\n  set data({\n    altText,\n    decorative,\n    guessedText,\n    textWithDisclaimer,\n    cancel = false\n  }) {\n    if (guessedText) {\n      this.#guessedText = guessedText;\n      this.#textWithDisclaimer = textWithDisclaimer;\n    }\n    if (this.#altText === altText && this.#altTextDecorative === decorative) {\n      return;\n    }\n    if (!cancel) {\n      this.#altText = altText;\n      this.#altTextDecorative = decorative;\n    }\n    this.#setState();\n  }\n  toggle(enabled = false) {\n    if (!this.#altTextButton) {\n      return;\n    }\n    if (!enabled && this.#altTextTooltipTimeout) {\n      clearTimeout(this.#altTextTooltipTimeout);\n      this.#altTextTooltipTimeout = null;\n    }\n    this.#altTextButton.disabled = !enabled;\n  }\n  shown() {\n    this.#editor._reportTelemetry({\n      action: \"pdfjs.image.alt_text.image_status_label_displayed\",\n      data: {\n        label: this.#label\n      }\n    });\n  }\n  destroy() {\n    this.#altTextButton?.remove();\n    this.#altTextButton = null;\n    this.#altTextButtonLabel = null;\n    this.#altTextTooltip = null;\n    this.#badge?.remove();\n    this.#badge = null;\n  }\n  async #setState() {\n    const button = this.#altTextButton;\n    if (!button) {\n      return;\n    }\n    if (this.#useNewAltTextFlow) {\n      button.classList.toggle(\"done\", !!this.#altText);\n      button.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[this.#label]);\n      this.#altTextButtonLabel?.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[`${this.#label}-label`]);\n      if (!this.#altText) {\n        this.#altTextTooltip?.remove();\n        return;\n      }\n    } else {\n      if (!this.#altText && !this.#altTextDecorative) {\n        button.classList.remove(\"done\");\n        this.#altTextTooltip?.remove();\n        return;\n      }\n      button.classList.add(\"done\");\n      button.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-edit-button\");\n    }\n    let tooltip = this.#altTextTooltip;\n    if (!tooltip) {\n      this.#altTextTooltip = tooltip = document.createElement(\"span\");\n      tooltip.className = \"tooltip\";\n      tooltip.setAttribute(\"role\", \"tooltip\");\n      tooltip.id = `alt-text-tooltip-${this.#editor.id}`;\n      const DELAY_TO_SHOW_TOOLTIP = 100;\n      const signal = this.#editor._uiManager._signal;\n      signal.addEventListener(\"abort\", () => {\n        clearTimeout(this.#altTextTooltipTimeout);\n        this.#altTextTooltipTimeout = null;\n      }, {\n        once: true\n      });\n      button.addEventListener(\"mouseenter\", () => {\n        this.#altTextTooltipTimeout = setTimeout(() => {\n          this.#altTextTooltipTimeout = null;\n          this.#altTextTooltip.classList.add(\"show\");\n          this.#editor._reportTelemetry({\n            action: \"alt_text_tooltip\"\n          });\n        }, DELAY_TO_SHOW_TOOLTIP);\n      }, {\n        signal\n      });\n      button.addEventListener(\"mouseleave\", () => {\n        if (this.#altTextTooltipTimeout) {\n          clearTimeout(this.#altTextTooltipTimeout);\n          this.#altTextTooltipTimeout = null;\n        }\n        this.#altTextTooltip?.classList.remove(\"show\");\n      }, {\n        signal\n      });\n    }\n    if (this.#altTextDecorative) {\n      tooltip.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-decorative-tooltip\");\n    } else {\n      tooltip.removeAttribute(\"data-l10n-id\");\n      tooltip.textContent = this.#altText;\n    }\n    if (!tooltip.parentNode) {\n      button.append(tooltip);\n    }\n    const element = this.#editor.getElementForAltText();\n    element?.setAttribute(\"aria-describedby\", tooltip.id);\n  }\n}\n\n;// ./src/display/editor/comment.js\n\nclass Comment {\n  #commentButton = null;\n  #commentWasFromKeyBoard = false;\n  #editor = null;\n  #initialText = null;\n  #text = null;\n  #date = null;\n  #deleted = false;\n  constructor(editor) {\n    this.#editor = editor;\n    this.toolbar = null;\n  }\n  render() {\n    if (!this.#editor._uiManager.hasCommentManager()) {\n      return null;\n    }\n    const comment = this.#commentButton = document.createElement(\"button\");\n    comment.className = \"comment\";\n    comment.tabIndex = \"0\";\n    comment.setAttribute(\"data-l10n-id\", \"pdfjs-editor-edit-comment-button\");\n    const signal = this.#editor._uiManager._signal;\n    if (!(signal instanceof AbortSignal) || signal.aborted) {\n      return comment;\n    }\n    comment.addEventListener(\"contextmenu\", noContextMenu, {\n      signal\n    });\n    comment.addEventListener(\"pointerdown\", event => event.stopPropagation(), {\n      signal\n    });\n    const onClick = event => {\n      event.preventDefault();\n      this.edit();\n    };\n    comment.addEventListener(\"click\", onClick, {\n      capture: true,\n      signal\n    });\n    comment.addEventListener(\"keydown\", event => {\n      if (event.target === comment && event.key === \"Enter\") {\n        this.#commentWasFromKeyBoard = true;\n        onClick(event);\n      }\n    }, {\n      signal\n    });\n    return comment;\n  }\n  edit() {\n    const {\n      bottom,\n      left,\n      right\n    } = this.#editor.getClientDimensions();\n    const position = {\n      top: bottom\n    };\n    if (this.#editor._uiManager.direction === \"ltr\") {\n      position.right = right;\n    } else {\n      position.left = left;\n    }\n    this.#editor._uiManager.editComment(this.#editor, position);\n  }\n  finish() {\n    if (!this.#commentButton) {\n      return;\n    }\n    this.#commentButton.focus({\n      focusVisible: this.#commentWasFromKeyBoard\n    });\n    this.#commentWasFromKeyBoard = false;\n  }\n  isDeleted() {\n    return this.#deleted || this.#text === \"\";\n  }\n  hasBeenEdited() {\n    return this.isDeleted() || this.#text !== this.#initialText;\n  }\n  serialize() {\n    return this.data;\n  }\n  get data() {\n    return {\n      text: this.#text,\n      date: this.#date,\n      deleted: this.#deleted\n    };\n  }\n  set data(text) {\n    if (text === null) {\n      this.#text = \"\";\n      this.#deleted = true;\n      return;\n    }\n    this.#text = text;\n    this.#date = new Date();\n    this.#deleted = false;\n  }\n  setInitialText(text) {\n    this.#initialText = text;\n    this.data = text;\n  }\n  toggle(enabled = false) {\n    if (!this.#commentButton) {\n      return;\n    }\n    this.#commentButton.disabled = !enabled;\n  }\n  shown() {}\n  destroy() {\n    this.#commentButton?.remove();\n    this.#commentButton = null;\n    this.#text = \"\";\n    this.#date = null;\n    this.#editor = null;\n    this.#commentWasFromKeyBoard = false;\n    this.#deleted = false;\n  }\n}\n\n;// ./src/display/touch_manager.js\n\nclass TouchManager {\n  #container;\n  #isPinching = false;\n  #isPinchingStopped = null;\n  #isPinchingDisabled;\n  #onPinchStart;\n  #onPinching;\n  #onPinchEnd;\n  #pointerDownAC = null;\n  #signal;\n  #touchInfo = null;\n  #touchManagerAC;\n  #touchMoveAC = null;\n  constructor({\n    container,\n    isPinchingDisabled = null,\n    isPinchingStopped = null,\n    onPinchStart = null,\n    onPinching = null,\n    onPinchEnd = null,\n    signal\n  }) {\n    this.#container = container;\n    this.#isPinchingStopped = isPinchingStopped;\n    this.#isPinchingDisabled = isPinchingDisabled;\n    this.#onPinchStart = onPinchStart;\n    this.#onPinching = onPinching;\n    this.#onPinchEnd = onPinchEnd;\n    this.#touchManagerAC = new AbortController();\n    this.#signal = AbortSignal.any([signal, this.#touchManagerAC.signal]);\n    container.addEventListener(\"touchstart\", this.#onTouchStart.bind(this), {\n      passive: false,\n      signal: this.#signal\n    });\n  }\n  get MIN_TOUCH_DISTANCE_TO_PINCH() {\n    return 35 / OutputScale.pixelRatio;\n  }\n  #onTouchStart(evt) {\n    if (this.#isPinchingDisabled?.()) {\n      return;\n    }\n    if (evt.touches.length === 1) {\n      if (this.#pointerDownAC) {\n        return;\n      }\n      const pointerDownAC = this.#pointerDownAC = new AbortController();\n      const signal = AbortSignal.any([this.#signal, pointerDownAC.signal]);\n      const container = this.#container;\n      const opts = {\n        capture: true,\n        signal,\n        passive: false\n      };\n      const cancelPointerDown = e => {\n        if (e.pointerType === \"touch\") {\n          this.#pointerDownAC?.abort();\n          this.#pointerDownAC = null;\n        }\n      };\n      container.addEventListener(\"pointerdown\", e => {\n        if (e.pointerType === \"touch\") {\n          stopEvent(e);\n          cancelPointerDown(e);\n        }\n      }, opts);\n      container.addEventListener(\"pointerup\", cancelPointerDown, opts);\n      container.addEventListener(\"pointercancel\", cancelPointerDown, opts);\n      return;\n    }\n    if (!this.#touchMoveAC) {\n      this.#touchMoveAC = new AbortController();\n      const signal = AbortSignal.any([this.#signal, this.#touchMoveAC.signal]);\n      const container = this.#container;\n      const opt = {\n        signal,\n        capture: false,\n        passive: false\n      };\n      container.addEventListener(\"touchmove\", this.#onTouchMove.bind(this), opt);\n      const onTouchEnd = this.#onTouchEnd.bind(this);\n      container.addEventListener(\"touchend\", onTouchEnd, opt);\n      container.addEventListener(\"touchcancel\", onTouchEnd, opt);\n      opt.capture = true;\n      container.addEventListener(\"pointerdown\", stopEvent, opt);\n      container.addEventListener(\"pointermove\", stopEvent, opt);\n      container.addEventListener(\"pointercancel\", stopEvent, opt);\n      container.addEventListener(\"pointerup\", stopEvent, opt);\n      this.#onPinchStart?.();\n    }\n    stopEvent(evt);\n    if (evt.touches.length !== 2 || this.#isPinchingStopped?.()) {\n      this.#touchInfo = null;\n      return;\n    }\n    let [touch0, touch1] = evt.touches;\n    if (touch0.identifier > touch1.identifier) {\n      [touch0, touch1] = [touch1, touch0];\n    }\n    this.#touchInfo = {\n      touch0X: touch0.screenX,\n      touch0Y: touch0.screenY,\n      touch1X: touch1.screenX,\n      touch1Y: touch1.screenY\n    };\n  }\n  #onTouchMove(evt) {\n    if (!this.#touchInfo || evt.touches.length !== 2) {\n      return;\n    }\n    stopEvent(evt);\n    let [touch0, touch1] = evt.touches;\n    if (touch0.identifier > touch1.identifier) {\n      [touch0, touch1] = [touch1, touch0];\n    }\n    const {\n      screenX: screen0X,\n      screenY: screen0Y\n    } = touch0;\n    const {\n      screenX: screen1X,\n      screenY: screen1Y\n    } = touch1;\n    const touchInfo = this.#touchInfo;\n    const {\n      touch0X: pTouch0X,\n      touch0Y: pTouch0Y,\n      touch1X: pTouch1X,\n      touch1Y: pTouch1Y\n    } = touchInfo;\n    const prevGapX = pTouch1X - pTouch0X;\n    const prevGapY = pTouch1Y - pTouch0Y;\n    const currGapX = screen1X - screen0X;\n    const currGapY = screen1Y - screen0Y;\n    const distance = Math.hypot(currGapX, currGapY) || 1;\n    const pDistance = Math.hypot(prevGapX, prevGapY) || 1;\n    if (!this.#isPinching && Math.abs(pDistance - distance) <= TouchManager.MIN_TOUCH_DISTANCE_TO_PINCH) {\n      return;\n    }\n    touchInfo.touch0X = screen0X;\n    touchInfo.touch0Y = screen0Y;\n    touchInfo.touch1X = screen1X;\n    touchInfo.touch1Y = screen1Y;\n    if (!this.#isPinching) {\n      this.#isPinching = true;\n      return;\n    }\n    const origin = [(screen0X + screen1X) / 2, (screen0Y + screen1Y) / 2];\n    this.#onPinching?.(origin, pDistance, distance);\n  }\n  #onTouchEnd(evt) {\n    if (evt.touches.length >= 2) {\n      return;\n    }\n    if (this.#touchMoveAC) {\n      this.#touchMoveAC.abort();\n      this.#touchMoveAC = null;\n      this.#onPinchEnd?.();\n    }\n    if (!this.#touchInfo) {\n      return;\n    }\n    stopEvent(evt);\n    this.#touchInfo = null;\n    this.#isPinching = false;\n  }\n  destroy() {\n    this.#touchManagerAC?.abort();\n    this.#touchManagerAC = null;\n    this.#pointerDownAC?.abort();\n    this.#pointerDownAC = null;\n  }\n}\n\n;// ./src/display/editor/editor.js\n\n\n\n\n\n\n\nclass AnnotationEditor {\n  #accessibilityData = null;\n  #allResizerDivs = null;\n  #altText = null;\n  #comment = null;\n  #disabled = false;\n  #dragPointerId = null;\n  #dragPointerType = \"\";\n  #keepAspectRatio = false;\n  #resizersDiv = null;\n  #lastPointerCoords = null;\n  #savedDimensions = null;\n  #focusAC = null;\n  #focusedResizerName = \"\";\n  #hasBeenClicked = false;\n  #initialRect = null;\n  #isEditing = false;\n  #isInEditMode = false;\n  #isResizerEnabledForKeyboard = false;\n  #moveInDOMTimeout = null;\n  #prevDragX = 0;\n  #prevDragY = 0;\n  #telemetryTimeouts = null;\n  #touchManager = null;\n  isSelected = false;\n  _isCopy = false;\n  _editToolbar = null;\n  _initialOptions = Object.create(null);\n  _initialData = null;\n  _isVisible = true;\n  _uiManager = null;\n  _focusEventsAllowed = true;\n  static _l10n = null;\n  static _l10nResizer = null;\n  #isDraggable = false;\n  #zIndex = AnnotationEditor._zIndex++;\n  static _borderLineWidth = -1;\n  static _colorManager = new ColorManager();\n  static _zIndex = 1;\n  static _telemetryTimeout = 1000;\n  static get _resizerKeyboardManager() {\n    const resize = AnnotationEditor.prototype._resizeWithKeyboard;\n    const small = AnnotationEditorUIManager.TRANSLATE_SMALL;\n    const big = AnnotationEditorUIManager.TRANSLATE_BIG;\n    return shadow(this, \"_resizerKeyboardManager\", new KeyboardManager([[[\"ArrowLeft\", \"mac+ArrowLeft\"], resize, {\n      args: [-small, 0]\n    }], [[\"ctrl+ArrowLeft\", \"mac+shift+ArrowLeft\"], resize, {\n      args: [-big, 0]\n    }], [[\"ArrowRight\", \"mac+ArrowRight\"], resize, {\n      args: [small, 0]\n    }], [[\"ctrl+ArrowRight\", \"mac+shift+ArrowRight\"], resize, {\n      args: [big, 0]\n    }], [[\"ArrowUp\", \"mac+ArrowUp\"], resize, {\n      args: [0, -small]\n    }], [[\"ctrl+ArrowUp\", \"mac+shift+ArrowUp\"], resize, {\n      args: [0, -big]\n    }], [[\"ArrowDown\", \"mac+ArrowDown\"], resize, {\n      args: [0, small]\n    }], [[\"ctrl+ArrowDown\", \"mac+shift+ArrowDown\"], resize, {\n      args: [0, big]\n    }], [[\"Escape\", \"mac+Escape\"], AnnotationEditor.prototype._stopResizingWithKeyboard]]));\n  }\n  constructor(parameters) {\n    this.parent = parameters.parent;\n    this.id = parameters.id;\n    this.width = this.height = null;\n    this.pageIndex = parameters.parent.pageIndex;\n    this.name = parameters.name;\n    this.div = null;\n    this._uiManager = parameters.uiManager;\n    this.annotationElementId = null;\n    this._willKeepAspectRatio = false;\n    this._initialOptions.isCentered = parameters.isCentered;\n    this._structTreeParentId = null;\n    this.annotationElementId = parameters.annotationElementId || null;\n    const {\n      rotation,\n      rawDims: {\n        pageWidth,\n        pageHeight,\n        pageX,\n        pageY\n      }\n    } = this.parent.viewport;\n    this.rotation = rotation;\n    this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;\n    this.pageDimensions = [pageWidth, pageHeight];\n    this.pageTranslation = [pageX, pageY];\n    const [width, height] = this.parentDimensions;\n    this.x = parameters.x / width;\n    this.y = parameters.y / height;\n    this.isAttachedToDOM = false;\n    this.deleted = false;\n  }\n  get editorType() {\n    return Object.getPrototypeOf(this).constructor._type;\n  }\n  get mode() {\n    return Object.getPrototypeOf(this).constructor._editorType;\n  }\n  static get isDrawer() {\n    return false;\n  }\n  static get _defaultLineColor() {\n    return shadow(this, \"_defaultLineColor\", this._colorManager.getHexCode(\"CanvasText\"));\n  }\n  static deleteAnnotationElement(editor) {\n    const fakeEditor = new FakeEditor({\n      id: editor.parent.getNextId(),\n      parent: editor.parent,\n      uiManager: editor._uiManager\n    });\n    fakeEditor.annotationElementId = editor.annotationElementId;\n    fakeEditor.deleted = true;\n    fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);\n  }\n  static initialize(l10n, _uiManager) {\n    AnnotationEditor._l10n ??= l10n;\n    AnnotationEditor._l10nResizer ||= Object.freeze({\n      topLeft: \"pdfjs-editor-resizer-top-left\",\n      topMiddle: \"pdfjs-editor-resizer-top-middle\",\n      topRight: \"pdfjs-editor-resizer-top-right\",\n      middleRight: \"pdfjs-editor-resizer-middle-right\",\n      bottomRight: \"pdfjs-editor-resizer-bottom-right\",\n      bottomMiddle: \"pdfjs-editor-resizer-bottom-middle\",\n      bottomLeft: \"pdfjs-editor-resizer-bottom-left\",\n      middleLeft: \"pdfjs-editor-resizer-middle-left\"\n    });\n    if (AnnotationEditor._borderLineWidth !== -1) {\n      return;\n    }\n    const style = getComputedStyle(document.documentElement);\n    AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue(\"--outline-width\")) || 0;\n  }\n  static updateDefaultParams(_type, _value) {}\n  static get defaultPropertiesToUpdate() {\n    return [];\n  }\n  static isHandlingMimeForPasting(mime) {\n    return false;\n  }\n  static paste(item, parent) {\n    unreachable(\"Not implemented\");\n  }\n  get propertiesToUpdate() {\n    return [];\n  }\n  get _isDraggable() {\n    return this.#isDraggable;\n  }\n  set _isDraggable(value) {\n    this.#isDraggable = value;\n    this.div?.classList.toggle(\"draggable\", value);\n  }\n  get isEnterHandled() {\n    return true;\n  }\n  center() {\n    const [pageWidth, pageHeight] = this.pageDimensions;\n    switch (this.parentRotation) {\n      case 90:\n        this.x -= this.height * pageHeight / (pageWidth * 2);\n        this.y += this.width * pageWidth / (pageHeight * 2);\n        break;\n      case 180:\n        this.x += this.width / 2;\n        this.y += this.height / 2;\n        break;\n      case 270:\n        this.x += this.height * pageHeight / (pageWidth * 2);\n        this.y -= this.width * pageWidth / (pageHeight * 2);\n        break;\n      default:\n        this.x -= this.width / 2;\n        this.y -= this.height / 2;\n        break;\n    }\n    this.fixAndSetPosition();\n  }\n  addCommands(params) {\n    this._uiManager.addCommands(params);\n  }\n  get currentLayer() {\n    return this._uiManager.currentLayer;\n  }\n  setInBackground() {\n    this.div.style.zIndex = 0;\n  }\n  setInForeground() {\n    this.div.style.zIndex = this.#zIndex;\n  }\n  setParent(parent) {\n    if (parent !== null) {\n      this.pageIndex = parent.pageIndex;\n      this.pageDimensions = parent.pageDimensions;\n    } else {\n      this.#stopResizing();\n    }\n    this.parent = parent;\n  }\n  focusin(event) {\n    if (!this._focusEventsAllowed) {\n      return;\n    }\n    if (!this.#hasBeenClicked) {\n      this.parent.setSelected(this);\n    } else {\n      this.#hasBeenClicked = false;\n    }\n  }\n  focusout(event) {\n    if (!this._focusEventsAllowed) {\n      return;\n    }\n    if (!this.isAttachedToDOM) {\n      return;\n    }\n    const target = event.relatedTarget;\n    if (target?.closest(`#${this.id}`)) {\n      return;\n    }\n    event.preventDefault();\n    if (!this.parent?.isMultipleSelection) {\n      this.commitOrRemove();\n    }\n  }\n  commitOrRemove() {\n    if (this.isEmpty()) {\n      this.remove();\n    } else {\n      this.commit();\n    }\n  }\n  commit() {\n    if (!this.isInEditMode()) {\n      return;\n    }\n    this.addToAnnotationStorage();\n  }\n  addToAnnotationStorage() {\n    this._uiManager.addToAnnotationStorage(this);\n  }\n  setAt(x, y, tx, ty) {\n    const [width, height] = this.parentDimensions;\n    [tx, ty] = this.screenToPageTranslation(tx, ty);\n    this.x = (x + tx) / width;\n    this.y = (y + ty) / height;\n    this.fixAndSetPosition();\n  }\n  _moveAfterPaste(baseX, baseY) {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n    this._onTranslated();\n  }\n  #translate([width, height], x, y) {\n    [x, y] = this.screenToPageTranslation(x, y);\n    this.x += x / width;\n    this.y += y / height;\n    this._onTranslating(this.x, this.y);\n    this.fixAndSetPosition();\n  }\n  translate(x, y) {\n    this.#translate(this.parentDimensions, x, y);\n  }\n  translateInPage(x, y) {\n    this.#initialRect ||= [this.x, this.y, this.width, this.height];\n    this.#translate(this.pageDimensions, x, y);\n    this.div.scrollIntoView({\n      block: \"nearest\"\n    });\n  }\n  translationDone() {\n    this._onTranslated(this.x, this.y);\n  }\n  drag(tx, ty) {\n    this.#initialRect ||= [this.x, this.y, this.width, this.height];\n    const {\n      div,\n      parentDimensions: [parentWidth, parentHeight]\n    } = this;\n    this.x += tx / parentWidth;\n    this.y += ty / parentHeight;\n    if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {\n      const {\n        x,\n        y\n      } = this.div.getBoundingClientRect();\n      if (this.parent.findNewParent(this, x, y)) {\n        this.x -= Math.floor(this.x);\n        this.y -= Math.floor(this.y);\n      }\n    }\n    let {\n      x,\n      y\n    } = this;\n    const [bx, by] = this.getBaseTranslation();\n    x += bx;\n    y += by;\n    const {\n      style\n    } = div;\n    style.left = `${(100 * x).toFixed(2)}%`;\n    style.top = `${(100 * y).toFixed(2)}%`;\n    this._onTranslating(x, y);\n    div.scrollIntoView({\n      block: \"nearest\"\n    });\n  }\n  _onTranslating(x, y) {}\n  _onTranslated(x, y) {}\n  get _hasBeenMoved() {\n    return !!this.#initialRect && (this.#initialRect[0] !== this.x || this.#initialRect[1] !== this.y);\n  }\n  get _hasBeenResized() {\n    return !!this.#initialRect && (this.#initialRect[2] !== this.width || this.#initialRect[3] !== this.height);\n  }\n  getBaseTranslation() {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    const {\n      _borderLineWidth\n    } = AnnotationEditor;\n    const x = _borderLineWidth / parentWidth;\n    const y = _borderLineWidth / parentHeight;\n    switch (this.rotation) {\n      case 90:\n        return [-x, y];\n      case 180:\n        return [x, y];\n      case 270:\n        return [x, -y];\n      default:\n        return [-x, -y];\n    }\n  }\n  get _mustFixPosition() {\n    return true;\n  }\n  fixAndSetPosition(rotation = this.rotation) {\n    const {\n      div: {\n        style\n      },\n      pageDimensions: [pageWidth, pageHeight]\n    } = this;\n    let {\n      x,\n      y,\n      width,\n      height\n    } = this;\n    width *= pageWidth;\n    height *= pageHeight;\n    x *= pageWidth;\n    y *= pageHeight;\n    if (this._mustFixPosition) {\n      switch (rotation) {\n        case 0:\n          x = MathClamp(x, 0, pageWidth - width);\n          y = MathClamp(y, 0, pageHeight - height);\n          break;\n        case 90:\n          x = MathClamp(x, 0, pageWidth - height);\n          y = MathClamp(y, width, pageHeight);\n          break;\n        case 180:\n          x = MathClamp(x, width, pageWidth);\n          y = MathClamp(y, height, pageHeight);\n          break;\n        case 270:\n          x = MathClamp(x, height, pageWidth);\n          y = MathClamp(y, 0, pageHeight - width);\n          break;\n      }\n    }\n    this.x = x /= pageWidth;\n    this.y = y /= pageHeight;\n    const [bx, by] = this.getBaseTranslation();\n    x += bx;\n    y += by;\n    style.left = `${(100 * x).toFixed(2)}%`;\n    style.top = `${(100 * y).toFixed(2)}%`;\n    this.moveInDOM();\n  }\n  static #rotatePoint(x, y, angle) {\n    switch (angle) {\n      case 90:\n        return [y, -x];\n      case 180:\n        return [-x, -y];\n      case 270:\n        return [-y, x];\n      default:\n        return [x, y];\n    }\n  }\n  screenToPageTranslation(x, y) {\n    return AnnotationEditor.#rotatePoint(x, y, this.parentRotation);\n  }\n  pageTranslationToScreen(x, y) {\n    return AnnotationEditor.#rotatePoint(x, y, 360 - this.parentRotation);\n  }\n  #getRotationMatrix(rotation) {\n    switch (rotation) {\n      case 90:\n        {\n          const [pageWidth, pageHeight] = this.pageDimensions;\n          return [0, -pageWidth / pageHeight, pageHeight / pageWidth, 0];\n        }\n      case 180:\n        return [-1, 0, 0, -1];\n      case 270:\n        {\n          const [pageWidth, pageHeight] = this.pageDimensions;\n          return [0, pageWidth / pageHeight, -pageHeight / pageWidth, 0];\n        }\n      default:\n        return [1, 0, 0, 1];\n    }\n  }\n  get parentScale() {\n    return this._uiManager.viewParameters.realScale;\n  }\n  get parentRotation() {\n    return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;\n  }\n  get parentDimensions() {\n    const {\n      parentScale,\n      pageDimensions: [pageWidth, pageHeight]\n    } = this;\n    return [pageWidth * parentScale, pageHeight * parentScale];\n  }\n  setDims(width, height) {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    const {\n      style\n    } = this.div;\n    style.width = `${(100 * width / parentWidth).toFixed(2)}%`;\n    if (!this.#keepAspectRatio) {\n      style.height = `${(100 * height / parentHeight).toFixed(2)}%`;\n    }\n  }\n  fixDims() {\n    const {\n      style\n    } = this.div;\n    const {\n      height,\n      width\n    } = style;\n    const widthPercent = width.endsWith(\"%\");\n    const heightPercent = !this.#keepAspectRatio && height.endsWith(\"%\");\n    if (widthPercent && heightPercent) {\n      return;\n    }\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    if (!widthPercent) {\n      style.width = `${(100 * parseFloat(width) / parentWidth).toFixed(2)}%`;\n    }\n    if (!this.#keepAspectRatio && !heightPercent) {\n      style.height = `${(100 * parseFloat(height) / parentHeight).toFixed(2)}%`;\n    }\n  }\n  getInitialTranslation() {\n    return [0, 0];\n  }\n  #createResizers() {\n    if (this.#resizersDiv) {\n      return;\n    }\n    this.#resizersDiv = document.createElement(\"div\");\n    this.#resizersDiv.classList.add(\"resizers\");\n    const classes = this._willKeepAspectRatio ? [\"topLeft\", \"topRight\", \"bottomRight\", \"bottomLeft\"] : [\"topLeft\", \"topMiddle\", \"topRight\", \"middleRight\", \"bottomRight\", \"bottomMiddle\", \"bottomLeft\", \"middleLeft\"];\n    const signal = this._uiManager._signal;\n    for (const name of classes) {\n      const div = document.createElement(\"div\");\n      this.#resizersDiv.append(div);\n      div.classList.add(\"resizer\", name);\n      div.setAttribute(\"data-resizer-name\", name);\n      div.addEventListener(\"pointerdown\", this.#resizerPointerdown.bind(this, name), {\n        signal\n      });\n      div.addEventListener(\"contextmenu\", noContextMenu, {\n        signal\n      });\n      div.tabIndex = -1;\n    }\n    this.div.prepend(this.#resizersDiv);\n  }\n  #resizerPointerdown(name, event) {\n    event.preventDefault();\n    const {\n      isMac\n    } = util_FeatureTest.platform;\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      return;\n    }\n    this.#altText?.toggle(false);\n    const savedDraggable = this._isDraggable;\n    this._isDraggable = false;\n    this.#lastPointerCoords = [event.screenX, event.screenY];\n    const ac = new AbortController();\n    const signal = this._uiManager.combinedSignal(ac);\n    this.parent.togglePointerEvents(false);\n    window.addEventListener(\"pointermove\", this.#resizerPointermove.bind(this, name), {\n      passive: true,\n      capture: true,\n      signal\n    });\n    window.addEventListener(\"touchmove\", stopEvent, {\n      passive: false,\n      signal\n    });\n    window.addEventListener(\"contextmenu\", noContextMenu, {\n      signal\n    });\n    this.#savedDimensions = {\n      savedX: this.x,\n      savedY: this.y,\n      savedWidth: this.width,\n      savedHeight: this.height\n    };\n    const savedParentCursor = this.parent.div.style.cursor;\n    const savedCursor = this.div.style.cursor;\n    this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;\n    const pointerUpCallback = () => {\n      ac.abort();\n      this.parent.togglePointerEvents(true);\n      this.#altText?.toggle(true);\n      this._isDraggable = savedDraggable;\n      this.parent.div.style.cursor = savedParentCursor;\n      this.div.style.cursor = savedCursor;\n      this.#addResizeToUndoStack();\n    };\n    window.addEventListener(\"pointerup\", pointerUpCallback, {\n      signal\n    });\n    window.addEventListener(\"blur\", pointerUpCallback, {\n      signal\n    });\n  }\n  #resize(x, y, width, height) {\n    this.width = width;\n    this.height = height;\n    this.x = x;\n    this.y = y;\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.setDims(parentWidth * width, parentHeight * height);\n    this.fixAndSetPosition();\n    this._onResized();\n  }\n  _onResized() {}\n  #addResizeToUndoStack() {\n    if (!this.#savedDimensions) {\n      return;\n    }\n    const {\n      savedX,\n      savedY,\n      savedWidth,\n      savedHeight\n    } = this.#savedDimensions;\n    this.#savedDimensions = null;\n    const newX = this.x;\n    const newY = this.y;\n    const newWidth = this.width;\n    const newHeight = this.height;\n    if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {\n      return;\n    }\n    this.addCommands({\n      cmd: this.#resize.bind(this, newX, newY, newWidth, newHeight),\n      undo: this.#resize.bind(this, savedX, savedY, savedWidth, savedHeight),\n      mustExec: true\n    });\n  }\n  static _round(x) {\n    return Math.round(x * 10000) / 10000;\n  }\n  #resizerPointermove(name, event) {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    const savedX = this.x;\n    const savedY = this.y;\n    const savedWidth = this.width;\n    const savedHeight = this.height;\n    const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;\n    const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;\n    const rotationMatrix = this.#getRotationMatrix(this.rotation);\n    const transf = (x, y) => [rotationMatrix[0] * x + rotationMatrix[2] * y, rotationMatrix[1] * x + rotationMatrix[3] * y];\n    const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);\n    const invTransf = (x, y) => [invRotationMatrix[0] * x + invRotationMatrix[2] * y, invRotationMatrix[1] * x + invRotationMatrix[3] * y];\n    let getPoint;\n    let getOpposite;\n    let isDiagonal = false;\n    let isHorizontal = false;\n    switch (name) {\n      case \"topLeft\":\n        isDiagonal = true;\n        getPoint = (w, h) => [0, 0];\n        getOpposite = (w, h) => [w, h];\n        break;\n      case \"topMiddle\":\n        getPoint = (w, h) => [w / 2, 0];\n        getOpposite = (w, h) => [w / 2, h];\n        break;\n      case \"topRight\":\n        isDiagonal = true;\n        getPoint = (w, h) => [w, 0];\n        getOpposite = (w, h) => [0, h];\n        break;\n      case \"middleRight\":\n        isHorizontal = true;\n        getPoint = (w, h) => [w, h / 2];\n        getOpposite = (w, h) => [0, h / 2];\n        break;\n      case \"bottomRight\":\n        isDiagonal = true;\n        getPoint = (w, h) => [w, h];\n        getOpposite = (w, h) => [0, 0];\n        break;\n      case \"bottomMiddle\":\n        getPoint = (w, h) => [w / 2, h];\n        getOpposite = (w, h) => [w / 2, 0];\n        break;\n      case \"bottomLeft\":\n        isDiagonal = true;\n        getPoint = (w, h) => [0, h];\n        getOpposite = (w, h) => [w, 0];\n        break;\n      case \"middleLeft\":\n        isHorizontal = true;\n        getPoint = (w, h) => [0, h / 2];\n        getOpposite = (w, h) => [w, h / 2];\n        break;\n    }\n    const point = getPoint(savedWidth, savedHeight);\n    const oppositePoint = getOpposite(savedWidth, savedHeight);\n    let transfOppositePoint = transf(...oppositePoint);\n    const oppositeX = AnnotationEditor._round(savedX + transfOppositePoint[0]);\n    const oppositeY = AnnotationEditor._round(savedY + transfOppositePoint[1]);\n    let ratioX = 1;\n    let ratioY = 1;\n    let deltaX, deltaY;\n    if (!event.fromKeyboard) {\n      const {\n        screenX,\n        screenY\n      } = event;\n      const [lastScreenX, lastScreenY] = this.#lastPointerCoords;\n      [deltaX, deltaY] = this.screenToPageTranslation(screenX - lastScreenX, screenY - lastScreenY);\n      this.#lastPointerCoords[0] = screenX;\n      this.#lastPointerCoords[1] = screenY;\n    } else {\n      ({\n        deltaX,\n        deltaY\n      } = event);\n    }\n    [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);\n    if (isDiagonal) {\n      const oldDiag = Math.hypot(savedWidth, savedHeight);\n      ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);\n    } else if (isHorizontal) {\n      ratioX = MathClamp(Math.abs(oppositePoint[0] - point[0] - deltaX), minWidth, 1) / savedWidth;\n    } else {\n      ratioY = MathClamp(Math.abs(oppositePoint[1] - point[1] - deltaY), minHeight, 1) / savedHeight;\n    }\n    const newWidth = AnnotationEditor._round(savedWidth * ratioX);\n    const newHeight = AnnotationEditor._round(savedHeight * ratioY);\n    transfOppositePoint = transf(...getOpposite(newWidth, newHeight));\n    const newX = oppositeX - transfOppositePoint[0];\n    const newY = oppositeY - transfOppositePoint[1];\n    this.#initialRect ||= [this.x, this.y, this.width, this.height];\n    this.width = newWidth;\n    this.height = newHeight;\n    this.x = newX;\n    this.y = newY;\n    this.setDims(parentWidth * newWidth, parentHeight * newHeight);\n    this.fixAndSetPosition();\n    this._onResizing();\n  }\n  _onResizing() {}\n  altTextFinish() {\n    this.#altText?.finish();\n  }\n  get toolbarButtons() {\n    return null;\n  }\n  async addEditToolbar() {\n    if (this._editToolbar || this.#isInEditMode) {\n      return this._editToolbar;\n    }\n    this._editToolbar = new EditorToolbar(this);\n    this.div.append(this._editToolbar.render());\n    const {\n      toolbarButtons\n    } = this;\n    if (toolbarButtons) {\n      for (const [name, tool] of toolbarButtons) {\n        await this._editToolbar.addButton(name, tool);\n      }\n    }\n    this._editToolbar.addButton(\"comment\", this.addCommentButton());\n    this._editToolbar.addButton(\"delete\");\n    return this._editToolbar;\n  }\n  removeEditToolbar() {\n    if (!this._editToolbar) {\n      return;\n    }\n    this._editToolbar.remove();\n    this._editToolbar = null;\n    this.#altText?.destroy();\n  }\n  addContainer(container) {\n    const editToolbarDiv = this._editToolbar?.div;\n    if (editToolbarDiv) {\n      editToolbarDiv.before(container);\n    } else {\n      this.div.append(container);\n    }\n  }\n  getClientDimensions() {\n    return this.div.getBoundingClientRect();\n  }\n  createAltText() {\n    if (!this.#altText) {\n      AltText.initialize(AnnotationEditor._l10n);\n      this.#altText = new AltText(this);\n      if (this.#accessibilityData) {\n        this.#altText.data = this.#accessibilityData;\n        this.#accessibilityData = null;\n      }\n    }\n    return this.#altText;\n  }\n  get altTextData() {\n    return this.#altText?.data;\n  }\n  set altTextData(data) {\n    if (!this.#altText) {\n      return;\n    }\n    this.#altText.data = data;\n  }\n  get guessedAltText() {\n    return this.#altText?.guessedText;\n  }\n  async setGuessedAltText(text) {\n    await this.#altText?.setGuessedText(text);\n  }\n  serializeAltText(isForCopying) {\n    return this.#altText?.serialize(isForCopying);\n  }\n  hasAltText() {\n    return !!this.#altText && !this.#altText.isEmpty();\n  }\n  hasAltTextData() {\n    return this.#altText?.hasData() ?? false;\n  }\n  addCommentButton() {\n    if (this.#comment) {\n      return this.#comment;\n    }\n    return this.#comment = new Comment(this);\n  }\n  get commentColor() {\n    return null;\n  }\n  get comment() {\n    const comment = this.#comment;\n    return {\n      text: comment.data.text,\n      date: comment.data.date,\n      deleted: comment.isDeleted(),\n      color: this.commentColor\n    };\n  }\n  set comment(text) {\n    if (!this.#comment) {\n      this.#comment = new Comment(this);\n    }\n    this.#comment.data = text;\n  }\n  setCommentData(text) {\n    if (!this.#comment) {\n      this.#comment = new Comment(this);\n    }\n    this.#comment.setInitialText(text);\n  }\n  get hasEditedComment() {\n    return this.#comment?.hasBeenEdited();\n  }\n  async editComment() {\n    if (!this.#comment) {\n      this.#comment = new Comment(this);\n    }\n    this.#comment.edit();\n  }\n  addComment(serialized) {\n    if (this.hasEditedComment) {\n      const DEFAULT_POPUP_WIDTH = 180;\n      const DEFAULT_POPUP_HEIGHT = 100;\n      const [,,, trY] = serialized.rect;\n      const [pageWidth] = this.pageDimensions;\n      const [pageX] = this.pageTranslation;\n      const blX = pageX + pageWidth + 1;\n      const blY = trY - DEFAULT_POPUP_HEIGHT;\n      const trX = blX + DEFAULT_POPUP_WIDTH;\n      serialized.popup = {\n        contents: this.comment.text,\n        deleted: this.comment.deleted,\n        rect: [blX, blY, trX, trY]\n      };\n    }\n  }\n  render() {\n    const div = this.div = document.createElement(\"div\");\n    div.setAttribute(\"data-editor-rotation\", (360 - this.rotation) % 360);\n    div.className = this.name;\n    div.setAttribute(\"id\", this.id);\n    div.tabIndex = this.#disabled ? -1 : 0;\n    div.setAttribute(\"role\", \"application\");\n    if (this.defaultL10nId) {\n      div.setAttribute(\"data-l10n-id\", this.defaultL10nId);\n    }\n    if (!this._isVisible) {\n      div.classList.add(\"hidden\");\n    }\n    this.setInForeground();\n    this.#addFocusListeners();\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    if (this.parentRotation % 180 !== 0) {\n      div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;\n      div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;\n    }\n    const [tx, ty] = this.getInitialTranslation();\n    this.translate(tx, ty);\n    bindEvents(this, div, [\"keydown\", \"pointerdown\", \"dblclick\"]);\n    if (this.isResizable && this._uiManager._supportsPinchToZoom) {\n      this.#touchManager ||= new TouchManager({\n        container: div,\n        isPinchingDisabled: () => !this.isSelected,\n        onPinchStart: this.#touchPinchStartCallback.bind(this),\n        onPinching: this.#touchPinchCallback.bind(this),\n        onPinchEnd: this.#touchPinchEndCallback.bind(this),\n        signal: this._uiManager._signal\n      });\n    }\n    this._uiManager._editorUndoBar?.hide();\n    return div;\n  }\n  #touchPinchStartCallback() {\n    this.#savedDimensions = {\n      savedX: this.x,\n      savedY: this.y,\n      savedWidth: this.width,\n      savedHeight: this.height\n    };\n    this.#altText?.toggle(false);\n    this.parent.togglePointerEvents(false);\n  }\n  #touchPinchCallback(_origin, prevDistance, distance) {\n    const slowDownFactor = 0.7;\n    let factor = slowDownFactor * (distance / prevDistance) + 1 - slowDownFactor;\n    if (factor === 1) {\n      return;\n    }\n    const rotationMatrix = this.#getRotationMatrix(this.rotation);\n    const transf = (x, y) => [rotationMatrix[0] * x + rotationMatrix[2] * y, rotationMatrix[1] * x + rotationMatrix[3] * y];\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    const savedX = this.x;\n    const savedY = this.y;\n    const savedWidth = this.width;\n    const savedHeight = this.height;\n    const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;\n    const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;\n    factor = Math.max(Math.min(factor, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);\n    const newWidth = AnnotationEditor._round(savedWidth * factor);\n    const newHeight = AnnotationEditor._round(savedHeight * factor);\n    if (newWidth === savedWidth && newHeight === savedHeight) {\n      return;\n    }\n    this.#initialRect ||= [savedX, savedY, savedWidth, savedHeight];\n    const transfCenterPoint = transf(savedWidth / 2, savedHeight / 2);\n    const centerX = AnnotationEditor._round(savedX + transfCenterPoint[0]);\n    const centerY = AnnotationEditor._round(savedY + transfCenterPoint[1]);\n    const newTransfCenterPoint = transf(newWidth / 2, newHeight / 2);\n    this.x = centerX - newTransfCenterPoint[0];\n    this.y = centerY - newTransfCenterPoint[1];\n    this.width = newWidth;\n    this.height = newHeight;\n    this.setDims(parentWidth * newWidth, parentHeight * newHeight);\n    this.fixAndSetPosition();\n    this._onResizing();\n  }\n  #touchPinchEndCallback() {\n    this.#altText?.toggle(true);\n    this.parent.togglePointerEvents(true);\n    this.#addResizeToUndoStack();\n  }\n  pointerdown(event) {\n    const {\n      isMac\n    } = util_FeatureTest.platform;\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      event.preventDefault();\n      return;\n    }\n    this.#hasBeenClicked = true;\n    if (this._isDraggable) {\n      this.#setUpDragSession(event);\n      return;\n    }\n    this.#selectOnPointerEvent(event);\n  }\n  #selectOnPointerEvent(event) {\n    const {\n      isMac\n    } = util_FeatureTest.platform;\n    if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {\n      this.parent.toggleSelected(this);\n    } else {\n      this.parent.setSelected(this);\n    }\n  }\n  #setUpDragSession(event) {\n    const {\n      isSelected\n    } = this;\n    this._uiManager.setUpDragSession();\n    let hasDraggingStarted = false;\n    const ac = new AbortController();\n    const signal = this._uiManager.combinedSignal(ac);\n    const opts = {\n      capture: true,\n      passive: false,\n      signal\n    };\n    const cancelDrag = e => {\n      ac.abort();\n      this.#dragPointerId = null;\n      this.#hasBeenClicked = false;\n      if (!this._uiManager.endDragSession()) {\n        this.#selectOnPointerEvent(e);\n      }\n      if (hasDraggingStarted) {\n        this._onStopDragging();\n      }\n    };\n    if (isSelected) {\n      this.#prevDragX = event.clientX;\n      this.#prevDragY = event.clientY;\n      this.#dragPointerId = event.pointerId;\n      this.#dragPointerType = event.pointerType;\n      window.addEventListener(\"pointermove\", e => {\n        if (!hasDraggingStarted) {\n          hasDraggingStarted = true;\n          this._onStartDragging();\n        }\n        const {\n          clientX: x,\n          clientY: y,\n          pointerId\n        } = e;\n        if (pointerId !== this.#dragPointerId) {\n          stopEvent(e);\n          return;\n        }\n        const [tx, ty] = this.screenToPageTranslation(x - this.#prevDragX, y - this.#prevDragY);\n        this.#prevDragX = x;\n        this.#prevDragY = y;\n        this._uiManager.dragSelectedEditors(tx, ty);\n      }, opts);\n      window.addEventListener(\"touchmove\", stopEvent, opts);\n      window.addEventListener(\"pointerdown\", e => {\n        if (e.pointerType === this.#dragPointerType) {\n          if (this.#touchManager || e.isPrimary) {\n            cancelDrag(e);\n          }\n        }\n        stopEvent(e);\n      }, opts);\n    }\n    const pointerUpCallback = e => {\n      if (!this.#dragPointerId || this.#dragPointerId === e.pointerId) {\n        cancelDrag(e);\n        return;\n      }\n      stopEvent(e);\n    };\n    window.addEventListener(\"pointerup\", pointerUpCallback, {\n      signal\n    });\n    window.addEventListener(\"blur\", pointerUpCallback, {\n      signal\n    });\n  }\n  _onStartDragging() {}\n  _onStopDragging() {}\n  moveInDOM() {\n    if (this.#moveInDOMTimeout) {\n      clearTimeout(this.#moveInDOMTimeout);\n    }\n    this.#moveInDOMTimeout = setTimeout(() => {\n      this.#moveInDOMTimeout = null;\n      this.parent?.moveEditorInDOM(this);\n    }, 0);\n  }\n  _setParentAndPosition(parent, x, y) {\n    parent.changeParent(this);\n    this.x = x;\n    this.y = y;\n    this.fixAndSetPosition();\n    this._onTranslated();\n  }\n  getRect(tx, ty, rotation = this.rotation) {\n    const scale = this.parentScale;\n    const [pageWidth, pageHeight] = this.pageDimensions;\n    const [pageX, pageY] = this.pageTranslation;\n    const shiftX = tx / scale;\n    const shiftY = ty / scale;\n    const x = this.x * pageWidth;\n    const y = this.y * pageHeight;\n    const width = this.width * pageWidth;\n    const height = this.height * pageHeight;\n    switch (rotation) {\n      case 0:\n        return [x + shiftX + pageX, pageHeight - y - shiftY - height + pageY, x + shiftX + width + pageX, pageHeight - y - shiftY + pageY];\n      case 90:\n        return [x + shiftY + pageX, pageHeight - y + shiftX + pageY, x + shiftY + height + pageX, pageHeight - y + shiftX + width + pageY];\n      case 180:\n        return [x - shiftX - width + pageX, pageHeight - y + shiftY + pageY, x - shiftX + pageX, pageHeight - y + shiftY + height + pageY];\n      case 270:\n        return [x - shiftY - height + pageX, pageHeight - y - shiftX - width + pageY, x - shiftY + pageX, pageHeight - y - shiftX + pageY];\n      default:\n        throw new Error(\"Invalid rotation\");\n    }\n  }\n  getRectInCurrentCoords(rect, pageHeight) {\n    const [x1, y1, x2, y2] = rect;\n    const width = x2 - x1;\n    const height = y2 - y1;\n    switch (this.rotation) {\n      case 0:\n        return [x1, pageHeight - y2, width, height];\n      case 90:\n        return [x1, pageHeight - y1, height, width];\n      case 180:\n        return [x2, pageHeight - y1, width, height];\n      case 270:\n        return [x2, pageHeight - y2, height, width];\n      default:\n        throw new Error(\"Invalid rotation\");\n    }\n  }\n  getPDFRect() {\n    return this.getRect(0, 0);\n  }\n  onceAdded(focus) {}\n  isEmpty() {\n    return false;\n  }\n  enableEditMode() {\n    if (this.isInEditMode()) {\n      return false;\n    }\n    this.parent.setEditingState(false);\n    this.#isInEditMode = true;\n    return true;\n  }\n  disableEditMode() {\n    if (!this.isInEditMode()) {\n      return false;\n    }\n    this.parent.setEditingState(true);\n    this.#isInEditMode = false;\n    return true;\n  }\n  isInEditMode() {\n    return this.#isInEditMode;\n  }\n  shouldGetKeyboardEvents() {\n    return this.#isResizerEnabledForKeyboard;\n  }\n  needsToBeRebuilt() {\n    return this.div && !this.isAttachedToDOM;\n  }\n  get isOnScreen() {\n    const {\n      top,\n      left,\n      bottom,\n      right\n    } = this.getClientDimensions();\n    const {\n      innerHeight,\n      innerWidth\n    } = window;\n    return left < innerWidth && right > 0 && top < innerHeight && bottom > 0;\n  }\n  #addFocusListeners() {\n    if (this.#focusAC || !this.div) {\n      return;\n    }\n    this.#focusAC = new AbortController();\n    const signal = this._uiManager.combinedSignal(this.#focusAC);\n    this.div.addEventListener(\"focusin\", this.focusin.bind(this), {\n      signal\n    });\n    this.div.addEventListener(\"focusout\", this.focusout.bind(this), {\n      signal\n    });\n  }\n  rebuild() {\n    this.#addFocusListeners();\n  }\n  rotate(_angle) {}\n  resize() {}\n  serializeDeleted() {\n    return {\n      id: this.annotationElementId,\n      deleted: true,\n      pageIndex: this.pageIndex,\n      popupRef: this._initialData?.popupRef || \"\"\n    };\n  }\n  serialize(isForCopying = false, context = null) {\n    unreachable(\"An editor must be serializable\");\n  }\n  static async deserialize(data, parent, uiManager) {\n    const editor = new this.prototype.constructor({\n      parent,\n      id: parent.getNextId(),\n      uiManager,\n      annotationElementId: data.annotationElementId\n    });\n    editor.rotation = data.rotation;\n    editor.#accessibilityData = data.accessibilityData;\n    editor._isCopy = data.isCopy || false;\n    const [pageWidth, pageHeight] = editor.pageDimensions;\n    const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);\n    editor.x = x / pageWidth;\n    editor.y = y / pageHeight;\n    editor.width = width / pageWidth;\n    editor.height = height / pageHeight;\n    return editor;\n  }\n  get hasBeenModified() {\n    return !!this.annotationElementId && (this.deleted || this.serialize() !== null);\n  }\n  remove() {\n    this.#focusAC?.abort();\n    this.#focusAC = null;\n    if (!this.isEmpty()) {\n      this.commit();\n    }\n    if (this.parent) {\n      this.parent.remove(this);\n    } else {\n      this._uiManager.removeEditor(this);\n    }\n    if (this.#moveInDOMTimeout) {\n      clearTimeout(this.#moveInDOMTimeout);\n      this.#moveInDOMTimeout = null;\n    }\n    this.#stopResizing();\n    this.removeEditToolbar();\n    if (this.#telemetryTimeouts) {\n      for (const timeout of this.#telemetryTimeouts.values()) {\n        clearTimeout(timeout);\n      }\n      this.#telemetryTimeouts = null;\n    }\n    this.parent = null;\n    this.#touchManager?.destroy();\n    this.#touchManager = null;\n  }\n  get isResizable() {\n    return false;\n  }\n  makeResizable() {\n    if (this.isResizable) {\n      this.#createResizers();\n      this.#resizersDiv.classList.remove(\"hidden\");\n    }\n  }\n  get toolbarPosition() {\n    return null;\n  }\n  keydown(event) {\n    if (!this.isResizable || event.target !== this.div || event.key !== \"Enter\") {\n      return;\n    }\n    this._uiManager.setSelected(this);\n    this.#savedDimensions = {\n      savedX: this.x,\n      savedY: this.y,\n      savedWidth: this.width,\n      savedHeight: this.height\n    };\n    const children = this.#resizersDiv.children;\n    if (!this.#allResizerDivs) {\n      this.#allResizerDivs = Array.from(children);\n      const boundResizerKeydown = this.#resizerKeydown.bind(this);\n      const boundResizerBlur = this.#resizerBlur.bind(this);\n      const signal = this._uiManager._signal;\n      for (const div of this.#allResizerDivs) {\n        const name = div.getAttribute(\"data-resizer-name\");\n        div.setAttribute(\"role\", \"spinbutton\");\n        div.addEventListener(\"keydown\", boundResizerKeydown, {\n          signal\n        });\n        div.addEventListener(\"blur\", boundResizerBlur, {\n          signal\n        });\n        div.addEventListener(\"focus\", this.#resizerFocus.bind(this, name), {\n          signal\n        });\n        div.setAttribute(\"data-l10n-id\", AnnotationEditor._l10nResizer[name]);\n      }\n    }\n    const first = this.#allResizerDivs[0];\n    let firstPosition = 0;\n    for (const div of children) {\n      if (div === first) {\n        break;\n      }\n      firstPosition++;\n    }\n    const nextFirstPosition = (360 - this.rotation + this.parentRotation) % 360 / 90 * (this.#allResizerDivs.length / 4);\n    if (nextFirstPosition !== firstPosition) {\n      if (nextFirstPosition < firstPosition) {\n        for (let i = 0; i < firstPosition - nextFirstPosition; i++) {\n          this.#resizersDiv.append(this.#resizersDiv.firstChild);\n        }\n      } else if (nextFirstPosition > firstPosition) {\n        for (let i = 0; i < nextFirstPosition - firstPosition; i++) {\n          this.#resizersDiv.firstChild.before(this.#resizersDiv.lastChild);\n        }\n      }\n      let i = 0;\n      for (const child of children) {\n        const div = this.#allResizerDivs[i++];\n        const name = div.getAttribute(\"data-resizer-name\");\n        child.setAttribute(\"data-l10n-id\", AnnotationEditor._l10nResizer[name]);\n      }\n    }\n    this.#setResizerTabIndex(0);\n    this.#isResizerEnabledForKeyboard = true;\n    this.#resizersDiv.firstChild.focus({\n      focusVisible: true\n    });\n    event.preventDefault();\n    event.stopImmediatePropagation();\n  }\n  #resizerKeydown(event) {\n    AnnotationEditor._resizerKeyboardManager.exec(this, event);\n  }\n  #resizerBlur(event) {\n    if (this.#isResizerEnabledForKeyboard && event.relatedTarget?.parentNode !== this.#resizersDiv) {\n      this.#stopResizing();\n    }\n  }\n  #resizerFocus(name) {\n    this.#focusedResizerName = this.#isResizerEnabledForKeyboard ? name : \"\";\n  }\n  #setResizerTabIndex(value) {\n    if (!this.#allResizerDivs) {\n      return;\n    }\n    for (const div of this.#allResizerDivs) {\n      div.tabIndex = value;\n    }\n  }\n  _resizeWithKeyboard(x, y) {\n    if (!this.#isResizerEnabledForKeyboard) {\n      return;\n    }\n    this.#resizerPointermove(this.#focusedResizerName, {\n      deltaX: x,\n      deltaY: y,\n      fromKeyboard: true\n    });\n  }\n  #stopResizing() {\n    this.#isResizerEnabledForKeyboard = false;\n    this.#setResizerTabIndex(-1);\n    this.#addResizeToUndoStack();\n  }\n  _stopResizingWithKeyboard() {\n    this.#stopResizing();\n    this.div.focus();\n  }\n  select() {\n    if (this.isSelected && this._editToolbar) {\n      return;\n    }\n    this.isSelected = true;\n    this.makeResizable();\n    this.div?.classList.add(\"selectedEditor\");\n    if (!this._editToolbar) {\n      this.addEditToolbar().then(() => {\n        if (this.div?.classList.contains(\"selectedEditor\")) {\n          this._editToolbar?.show();\n        }\n      });\n      return;\n    }\n    this._editToolbar?.show();\n    this.#altText?.toggleAltTextBadge(false);\n  }\n  unselect() {\n    if (!this.isSelected) {\n      return;\n    }\n    this.isSelected = false;\n    this.#resizersDiv?.classList.add(\"hidden\");\n    this.div?.classList.remove(\"selectedEditor\");\n    if (this.div?.contains(document.activeElement)) {\n      this._uiManager.currentLayer.div.focus({\n        preventScroll: true\n      });\n    }\n    this._editToolbar?.hide();\n    this.#altText?.toggleAltTextBadge(true);\n  }\n  updateParams(type, value) {}\n  disableEditing() {}\n  enableEditing() {}\n  get canChangeContent() {\n    return false;\n  }\n  enterInEditMode() {\n    if (!this.canChangeContent) {\n      return;\n    }\n    this.enableEditMode();\n    this.div.focus();\n  }\n  dblclick(event) {\n    this.enterInEditMode();\n    this.parent.updateToolbar({\n      mode: this.constructor._editorType,\n      editId: this.id\n    });\n  }\n  getElementForAltText() {\n    return this.div;\n  }\n  get contentDiv() {\n    return this.div;\n  }\n  get isEditing() {\n    return this.#isEditing;\n  }\n  set isEditing(value) {\n    this.#isEditing = value;\n    if (!this.parent) {\n      return;\n    }\n    if (value) {\n      this.parent.setSelected(this);\n      this.parent.setActiveEditor(this);\n    } else {\n      this.parent.setActiveEditor(null);\n    }\n  }\n  setAspectRatio(width, height) {\n    this.#keepAspectRatio = true;\n    const aspectRatio = width / height;\n    const {\n      style\n    } = this.div;\n    style.aspectRatio = aspectRatio;\n    style.height = \"auto\";\n  }\n  static get MIN_SIZE() {\n    return 16;\n  }\n  static canCreateNewEmptyEditor() {\n    return true;\n  }\n  get telemetryInitialData() {\n    return {\n      action: \"added\"\n    };\n  }\n  get telemetryFinalData() {\n    return null;\n  }\n  _reportTelemetry(data, mustWait = false) {\n    if (mustWait) {\n      this.#telemetryTimeouts ||= new Map();\n      const {\n        action\n      } = data;\n      let timeout = this.#telemetryTimeouts.get(action);\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n      timeout = setTimeout(() => {\n        this._reportTelemetry(data);\n        this.#telemetryTimeouts.delete(action);\n        if (this.#telemetryTimeouts.size === 0) {\n          this.#telemetryTimeouts = null;\n        }\n      }, AnnotationEditor._telemetryTimeout);\n      this.#telemetryTimeouts.set(action, timeout);\n      return;\n    }\n    data.type ||= this.editorType;\n    this._uiManager._eventBus.dispatch(\"reporttelemetry\", {\n      source: this,\n      details: {\n        type: \"editing\",\n        data\n      }\n    });\n  }\n  show(visible = this._isVisible) {\n    this.div.classList.toggle(\"hidden\", !visible);\n    this._isVisible = visible;\n  }\n  enable() {\n    if (this.div) {\n      this.div.tabIndex = 0;\n    }\n    this.#disabled = false;\n  }\n  disable() {\n    if (this.div) {\n      this.div.tabIndex = -1;\n    }\n    this.#disabled = true;\n  }\n  renderAnnotationElement(annotation) {\n    if (this.deleted) {\n      annotation.hide();\n      return null;\n    }\n    let content = annotation.container.querySelector(\".annotationContent\");\n    if (!content) {\n      content = document.createElement(\"div\");\n      content.classList.add(\"annotationContent\", this.editorType);\n      annotation.container.prepend(content);\n    } else if (content.nodeName === \"CANVAS\") {\n      const canvas = content;\n      content = document.createElement(\"div\");\n      content.classList.add(\"annotationContent\", this.editorType);\n      canvas.before(content);\n    }\n    return content;\n  }\n  resetAnnotationElement(annotation) {\n    const {\n      firstChild\n    } = annotation.container;\n    if (firstChild?.nodeName === \"DIV\" && firstChild.classList.contains(\"annotationContent\")) {\n      firstChild.remove();\n    }\n  }\n}\nclass FakeEditor extends AnnotationEditor {\n  constructor(params) {\n    super(params);\n    this.annotationElementId = params.annotationElementId;\n    this.deleted = true;\n  }\n  serialize() {\n    return this.serializeDeleted();\n  }\n}\n\n;// ./src/shared/murmurhash3.js\nconst SEED = 0xc3d2e1f0;\nconst MASK_HIGH = 0xffff0000;\nconst MASK_LOW = 0xffff;\nclass MurmurHash3_64 {\n  constructor(seed) {\n    this.h1 = seed ? seed & 0xffffffff : SEED;\n    this.h2 = seed ? seed & 0xffffffff : SEED;\n  }\n  update(input) {\n    let data, length;\n    if (typeof input === \"string\") {\n      data = new Uint8Array(input.length * 2);\n      length = 0;\n      for (let i = 0, ii = input.length; i < ii; i++) {\n        const code = input.charCodeAt(i);\n        if (code <= 0xff) {\n          data[length++] = code;\n        } else {\n          data[length++] = code >>> 8;\n          data[length++] = code & 0xff;\n        }\n      }\n    } else if (ArrayBuffer.isView(input)) {\n      data = input.slice();\n      length = data.byteLength;\n    } else {\n      throw new Error(\"Invalid data format, must be a string or TypedArray.\");\n    }\n    const blockCounts = length >> 2;\n    const tailLength = length - blockCounts * 4;\n    const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);\n    let k1 = 0,\n      k2 = 0;\n    let h1 = this.h1,\n      h2 = this.h2;\n    const C1 = 0xcc9e2d51,\n      C2 = 0x1b873593;\n    const C1_LOW = C1 & MASK_LOW,\n      C2_LOW = C2 & MASK_LOW;\n    for (let i = 0; i < blockCounts; i++) {\n      if (i & 1) {\n        k1 = dataUint32[i];\n        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n        k1 = k1 << 15 | k1 >>> 17;\n        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n        h1 ^= k1;\n        h1 = h1 << 13 | h1 >>> 19;\n        h1 = h1 * 5 + 0xe6546b64;\n      } else {\n        k2 = dataUint32[i];\n        k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;\n        k2 = k2 << 15 | k2 >>> 17;\n        k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;\n        h2 ^= k2;\n        h2 = h2 << 13 | h2 >>> 19;\n        h2 = h2 * 5 + 0xe6546b64;\n      }\n    }\n    k1 = 0;\n    switch (tailLength) {\n      case 3:\n        k1 ^= data[blockCounts * 4 + 2] << 16;\n      case 2:\n        k1 ^= data[blockCounts * 4 + 1] << 8;\n      case 1:\n        k1 ^= data[blockCounts * 4];\n        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n        k1 = k1 << 15 | k1 >>> 17;\n        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n        if (blockCounts & 1) {\n          h1 ^= k1;\n        } else {\n          h2 ^= k1;\n        }\n    }\n    this.h1 = h1;\n    this.h2 = h2;\n  }\n  hexdigest() {\n    let h1 = this.h1,\n      h2 = this.h2;\n    h1 ^= h2 >>> 1;\n    h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;\n    h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;\n    h1 ^= h2 >>> 1;\n    h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;\n    h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;\n    h1 ^= h2 >>> 1;\n    return (h1 >>> 0).toString(16).padStart(8, \"0\") + (h2 >>> 0).toString(16).padStart(8, \"0\");\n  }\n}\n\n;// ./src/display/annotation_storage.js\n\n\n\nconst SerializableEmpty = Object.freeze({\n  map: null,\n  hash: \"\",\n  transfer: undefined\n});\nclass AnnotationStorage {\n  #modified = false;\n  #modifiedIds = null;\n  #storage = new Map();\n  constructor() {\n    this.onSetModified = null;\n    this.onResetModified = null;\n    this.onAnnotationEditor = null;\n  }\n  getValue(key, defaultValue) {\n    const value = this.#storage.get(key);\n    if (value === undefined) {\n      return defaultValue;\n    }\n    return Object.assign(defaultValue, value);\n  }\n  getRawValue(key) {\n    return this.#storage.get(key);\n  }\n  remove(key) {\n    this.#storage.delete(key);\n    if (this.#storage.size === 0) {\n      this.resetModified();\n    }\n    if (typeof this.onAnnotationEditor === \"function\") {\n      for (const value of this.#storage.values()) {\n        if (value instanceof AnnotationEditor) {\n          return;\n        }\n      }\n      this.onAnnotationEditor(null);\n    }\n  }\n  setValue(key, value) {\n    const obj = this.#storage.get(key);\n    let modified = false;\n    if (obj !== undefined) {\n      for (const [entry, val] of Object.entries(value)) {\n        if (obj[entry] !== val) {\n          modified = true;\n          obj[entry] = val;\n        }\n      }\n    } else {\n      modified = true;\n      this.#storage.set(key, value);\n    }\n    if (modified) {\n      this.#setModified();\n    }\n    if (value instanceof AnnotationEditor && typeof this.onAnnotationEditor === \"function\") {\n      this.onAnnotationEditor(value.constructor._type);\n    }\n  }\n  has(key) {\n    return this.#storage.has(key);\n  }\n  get size() {\n    return this.#storage.size;\n  }\n  #setModified() {\n    if (!this.#modified) {\n      this.#modified = true;\n      if (typeof this.onSetModified === \"function\") {\n        this.onSetModified();\n      }\n    }\n  }\n  resetModified() {\n    if (this.#modified) {\n      this.#modified = false;\n      if (typeof this.onResetModified === \"function\") {\n        this.onResetModified();\n      }\n    }\n  }\n  get print() {\n    return new PrintAnnotationStorage(this);\n  }\n  get serializable() {\n    if (this.#storage.size === 0) {\n      return SerializableEmpty;\n    }\n    const map = new Map(),\n      hash = new MurmurHash3_64(),\n      transfer = [];\n    const context = Object.create(null);\n    let hasBitmap = false;\n    for (const [key, val] of this.#storage) {\n      const serialized = val instanceof AnnotationEditor ? val.serialize(false, context) : val;\n      if (serialized) {\n        map.set(key, serialized);\n        hash.update(`${key}:${JSON.stringify(serialized)}`);\n        hasBitmap ||= !!serialized.bitmap;\n      }\n    }\n    if (hasBitmap) {\n      for (const value of map.values()) {\n        if (value.bitmap) {\n          transfer.push(value.bitmap);\n        }\n      }\n    }\n    return map.size > 0 ? {\n      map,\n      hash: hash.hexdigest(),\n      transfer\n    } : SerializableEmpty;\n  }\n  get editorStats() {\n    let stats = null;\n    const typeToEditor = new Map();\n    for (const value of this.#storage.values()) {\n      if (!(value instanceof AnnotationEditor)) {\n        continue;\n      }\n      const editorStats = value.telemetryFinalData;\n      if (!editorStats) {\n        continue;\n      }\n      const {\n        type\n      } = editorStats;\n      if (!typeToEditor.has(type)) {\n        typeToEditor.set(type, Object.getPrototypeOf(value).constructor);\n      }\n      stats ||= Object.create(null);\n      const map = stats[type] ||= new Map();\n      for (const [key, val] of Object.entries(editorStats)) {\n        if (key === \"type\") {\n          continue;\n        }\n        let counters = map.get(key);\n        if (!counters) {\n          counters = new Map();\n          map.set(key, counters);\n        }\n        const count = counters.get(val) ?? 0;\n        counters.set(val, count + 1);\n      }\n    }\n    for (const [type, editor] of typeToEditor) {\n      stats[type] = editor.computeTelemetryFinalData(stats[type]);\n    }\n    return stats;\n  }\n  resetModifiedIds() {\n    this.#modifiedIds = null;\n  }\n  get modifiedIds() {\n    if (this.#modifiedIds) {\n      return this.#modifiedIds;\n    }\n    const ids = [];\n    for (const value of this.#storage.values()) {\n      if (!(value instanceof AnnotationEditor) || !value.annotationElementId || !value.serialize()) {\n        continue;\n      }\n      ids.push(value.annotationElementId);\n    }\n    return this.#modifiedIds = {\n      ids: new Set(ids),\n      hash: ids.join(\",\")\n    };\n  }\n  [Symbol.iterator]() {\n    return this.#storage.entries();\n  }\n}\nclass PrintAnnotationStorage extends AnnotationStorage {\n  #serializable;\n  constructor(parent) {\n    super();\n    const {\n      map,\n      hash,\n      transfer\n    } = parent.serializable;\n    const clone = structuredClone(map, transfer ? {\n      transfer\n    } : null);\n    this.#serializable = {\n      map: clone,\n      hash,\n      transfer\n    };\n  }\n  get print() {\n    unreachable(\"Should not call PrintAnnotationStorage.print\");\n  }\n  get serializable() {\n    return this.#serializable;\n  }\n  get modifiedIds() {\n    return shadow(this, \"modifiedIds\", {\n      ids: new Set(),\n      hash: \"\"\n    });\n  }\n}\n\n;// ./src/display/font_loader.js\n\nclass FontLoader {\n  #systemFonts = new Set();\n  constructor({\n    ownerDocument = globalThis.document,\n    styleElement = null\n  }) {\n    this._document = ownerDocument;\n    this.nativeFontFaces = new Set();\n    this.styleElement = null;\n    this.loadingRequests = [];\n    this.loadTestFontId = 0;\n  }\n  addNativeFontFace(nativeFontFace) {\n    this.nativeFontFaces.add(nativeFontFace);\n    this._document.fonts.add(nativeFontFace);\n  }\n  removeNativeFontFace(nativeFontFace) {\n    this.nativeFontFaces.delete(nativeFontFace);\n    this._document.fonts.delete(nativeFontFace);\n  }\n  insertRule(rule) {\n    if (!this.styleElement) {\n      this.styleElement = this._document.createElement(\"style\");\n      this._document.documentElement.getElementsByTagName(\"head\")[0].append(this.styleElement);\n    }\n    const styleSheet = this.styleElement.sheet;\n    styleSheet.insertRule(rule, styleSheet.cssRules.length);\n  }\n  clear() {\n    for (const nativeFontFace of this.nativeFontFaces) {\n      this._document.fonts.delete(nativeFontFace);\n    }\n    this.nativeFontFaces.clear();\n    this.#systemFonts.clear();\n    if (this.styleElement) {\n      this.styleElement.remove();\n      this.styleElement = null;\n    }\n  }\n  async loadSystemFont({\n    systemFontInfo: info,\n    disableFontFace,\n    _inspectFont\n  }) {\n    if (!info || this.#systemFonts.has(info.loadedName)) {\n      return;\n    }\n    assert(!disableFontFace, \"loadSystemFont shouldn't be called when `disableFontFace` is set.\");\n    if (this.isFontLoadingAPISupported) {\n      const {\n        loadedName,\n        src,\n        style\n      } = info;\n      const fontFace = new FontFace(loadedName, src, style);\n      this.addNativeFontFace(fontFace);\n      try {\n        await fontFace.load();\n        this.#systemFonts.add(loadedName);\n        _inspectFont?.(info);\n      } catch {\n        warn(`Cannot load system font: ${info.baseFontName}, installing it could help to improve PDF rendering.`);\n        this.removeNativeFontFace(fontFace);\n      }\n      return;\n    }\n    unreachable(\"Not implemented: loadSystemFont without the Font Loading API.\");\n  }\n  async bind(font) {\n    if (font.attached || font.missingFile && !font.systemFontInfo) {\n      return;\n    }\n    font.attached = true;\n    if (font.systemFontInfo) {\n      await this.loadSystemFont(font);\n      return;\n    }\n    if (this.isFontLoadingAPISupported) {\n      const nativeFontFace = font.createNativeFontFace();\n      if (nativeFontFace) {\n        this.addNativeFontFace(nativeFontFace);\n        try {\n          await nativeFontFace.loaded;\n        } catch (ex) {\n          warn(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);\n          font.disableFontFace = true;\n          throw ex;\n        }\n      }\n      return;\n    }\n    const rule = font.createFontFaceRule();\n    if (rule) {\n      this.insertRule(rule);\n      if (this.isSyncFontLoadingSupported) {\n        return;\n      }\n      await new Promise(resolve => {\n        const request = this._queueLoadingCallback(resolve);\n        this._prepareFontLoadEvent(font, request);\n      });\n    }\n  }\n  get isFontLoadingAPISupported() {\n    const hasFonts = !!this._document?.fonts;\n    return shadow(this, \"isFontLoadingAPISupported\", hasFonts);\n  }\n  get isSyncFontLoadingSupported() {\n    return shadow(this, \"isSyncFontLoadingSupported\", isNodeJS || util_FeatureTest.platform.isFirefox);\n  }\n  _queueLoadingCallback(callback) {\n    function completeRequest() {\n      assert(!request.done, \"completeRequest() cannot be called twice.\");\n      request.done = true;\n      while (loadingRequests.length > 0 && loadingRequests[0].done) {\n        const otherRequest = loadingRequests.shift();\n        setTimeout(otherRequest.callback, 0);\n      }\n    }\n    const {\n      loadingRequests\n    } = this;\n    const request = {\n      done: false,\n      complete: completeRequest,\n      callback\n    };\n    loadingRequests.push(request);\n    return request;\n  }\n  get _loadTestFont() {\n    const testFont = atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n    return shadow(this, \"_loadTestFont\", testFont);\n  }\n  _prepareFontLoadEvent(font, request) {\n    function int32(data, offset) {\n      return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n    }\n    function spliceString(s, offset, remove, insert) {\n      const chunk1 = s.substring(0, offset);\n      const chunk2 = s.substring(offset + remove);\n      return chunk1 + insert + chunk2;\n    }\n    let i, ii;\n    const canvas = this._document.createElement(\"canvas\");\n    canvas.width = 1;\n    canvas.height = 1;\n    const ctx = canvas.getContext(\"2d\");\n    let called = 0;\n    function isFontReady(name, callback) {\n      if (++called > 30) {\n        warn(\"Load test font never loaded.\");\n        callback();\n        return;\n      }\n      ctx.font = \"30px \" + name;\n      ctx.fillText(\".\", 0, 20);\n      const imageData = ctx.getImageData(0, 0, 1, 1);\n      if (imageData.data[3] > 0) {\n        callback();\n        return;\n      }\n      setTimeout(isFontReady.bind(null, name, callback));\n    }\n    const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\n    let data = this._loadTestFont;\n    const COMMENT_OFFSET = 976;\n    data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n    const CFF_CHECKSUM_OFFSET = 16;\n    const XXXX_VALUE = 0x58585858;\n    let checksum = int32(data, CFF_CHECKSUM_OFFSET);\n    for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {\n      checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n    }\n    if (i < loadTestFontId.length) {\n      checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n    }\n    data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));\n    const url = `url(data:font/opentype;base64,${btoa(data)});`;\n    const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`;\n    this.insertRule(rule);\n    const div = this._document.createElement(\"div\");\n    div.style.visibility = \"hidden\";\n    div.style.width = div.style.height = \"10px\";\n    div.style.position = \"absolute\";\n    div.style.top = div.style.left = \"0px\";\n    for (const name of [font.loadedName, loadTestFontId]) {\n      const span = this._document.createElement(\"span\");\n      span.textContent = \"Hi\";\n      span.style.fontFamily = name;\n      div.append(span);\n    }\n    this._document.body.append(div);\n    isFontReady(loadTestFontId, () => {\n      div.remove();\n      request.complete();\n    });\n  }\n}\nclass FontFaceObject {\n  constructor(translatedData, inspectFont = null) {\n    this.compiledGlyphs = Object.create(null);\n    for (const i in translatedData) {\n      this[i] = translatedData[i];\n    }\n    this._inspectFont = inspectFont;\n  }\n  createNativeFontFace() {\n    if (!this.data || this.disableFontFace) {\n      return null;\n    }\n    let nativeFontFace;\n    if (!this.cssFontInfo) {\n      nativeFontFace = new FontFace(this.loadedName, this.data, {});\n    } else {\n      const css = {\n        weight: this.cssFontInfo.fontWeight\n      };\n      if (this.cssFontInfo.italicAngle) {\n        css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;\n      }\n      nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);\n    }\n    this._inspectFont?.(this);\n    return nativeFontFace;\n  }\n  createFontFaceRule() {\n    if (!this.data || this.disableFontFace) {\n      return null;\n    }\n    const url = `url(data:${this.mimetype};base64,${toBase64Util(this.data)});`;\n    let rule;\n    if (!this.cssFontInfo) {\n      rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`;\n    } else {\n      let css = `font-weight: ${this.cssFontInfo.fontWeight};`;\n      if (this.cssFontInfo.italicAngle) {\n        css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;\n      }\n      rule = `@font-face {font-family:\"${this.cssFontInfo.fontFamily}\";${css}src:${url}}`;\n    }\n    this._inspectFont?.(this, url);\n    return rule;\n  }\n  getPathGenerator(objs, character) {\n    if (this.compiledGlyphs[character] !== undefined) {\n      return this.compiledGlyphs[character];\n    }\n    const objId = this.loadedName + \"_path_\" + character;\n    let cmds;\n    try {\n      cmds = objs.get(objId);\n    } catch (ex) {\n      warn(`getPathGenerator - ignoring character: \"${ex}\".`);\n    }\n    const path = new Path2D(cmds || \"\");\n    if (!this.fontExtraProperties) {\n      objs.delete(objId);\n    }\n    return this.compiledGlyphs[character] = path;\n  }\n}\n\n;// ./src/display/api_utils.js\n\nfunction getUrlProp(val) {\n  if (val instanceof URL) {\n    return val.href;\n  }\n  if (typeof val === \"string\") {\n    if (isNodeJS) {\n      return val;\n    }\n    const url = URL.parse(val, window.location);\n    if (url) {\n      return url.href;\n    }\n  }\n  throw new Error(\"Invalid PDF url data: \" + \"either string or URL-object is expected in the url property.\");\n}\nfunction getDataProp(val) {\n  if (isNodeJS && typeof Buffer !== \"undefined\" && val instanceof Buffer) {\n    throw new Error(\"Please provide binary data as `Uint8Array`, rather than `Buffer`.\");\n  }\n  if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {\n    return val;\n  }\n  if (typeof val === \"string\") {\n    return stringToBytes(val);\n  }\n  if (val instanceof ArrayBuffer || ArrayBuffer.isView(val) || typeof val === \"object\" && !isNaN(val?.length)) {\n    return new Uint8Array(val);\n  }\n  throw new Error(\"Invalid PDF binary data: either TypedArray, \" + \"string, or array-like object is expected in the data property.\");\n}\nfunction getFactoryUrlProp(val) {\n  if (typeof val !== \"string\") {\n    return null;\n  }\n  if (val.endsWith(\"/\")) {\n    return val;\n  }\n  throw new Error(`Invalid factory url: \"${val}\" must include trailing slash.`);\n}\nconst isRefProxy = v => typeof v === \"object\" && Number.isInteger(v?.num) && v.num >= 0 && Number.isInteger(v?.gen) && v.gen >= 0;\nconst isNameProxy = v => typeof v === \"object\" && typeof v?.name === \"string\";\nconst isValidExplicitDest = _isValidExplicitDest.bind(null, isRefProxy, isNameProxy);\nclass LoopbackPort {\n  #listeners = new Map();\n  #deferred = Promise.resolve();\n  postMessage(obj, transfer) {\n    const event = {\n      data: structuredClone(obj, transfer ? {\n        transfer\n      } : null)\n    };\n    this.#deferred.then(() => {\n      for (const [listener] of this.#listeners) {\n        listener.call(this, event);\n      }\n    });\n  }\n  addEventListener(name, listener, options = null) {\n    let rmAbort = null;\n    if (options?.signal instanceof AbortSignal) {\n      const {\n        signal\n      } = options;\n      if (signal.aborted) {\n        warn(\"LoopbackPort - cannot use an `aborted` signal.\");\n        return;\n      }\n      const onAbort = () => this.removeEventListener(name, listener);\n      rmAbort = () => signal.removeEventListener(\"abort\", onAbort);\n      signal.addEventListener(\"abort\", onAbort);\n    }\n    this.#listeners.set(listener, rmAbort);\n  }\n  removeEventListener(name, listener) {\n    const rmAbort = this.#listeners.get(listener);\n    rmAbort?.();\n    this.#listeners.delete(listener);\n  }\n  terminate() {\n    for (const [, rmAbort] of this.#listeners) {\n      rmAbort?.();\n    }\n    this.#listeners.clear();\n  }\n}\n\n;// ./src/shared/message_handler.js\n\nconst CallbackKind = {\n  DATA: 1,\n  ERROR: 2\n};\nconst StreamKind = {\n  CANCEL: 1,\n  CANCEL_COMPLETE: 2,\n  CLOSE: 3,\n  ENQUEUE: 4,\n  ERROR: 5,\n  PULL: 6,\n  PULL_COMPLETE: 7,\n  START_COMPLETE: 8\n};\nfunction onFn() {}\nfunction wrapReason(ex) {\n  if (ex instanceof AbortException || ex instanceof InvalidPDFException || ex instanceof PasswordException || ex instanceof ResponseException || ex instanceof UnknownErrorException) {\n    return ex;\n  }\n  if (!(ex instanceof Error || typeof ex === \"object\" && ex !== null)) {\n    unreachable('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n  }\n  switch (ex.name) {\n    case \"AbortException\":\n      return new AbortException(ex.message);\n    case \"InvalidPDFException\":\n      return new InvalidPDFException(ex.message);\n    case \"PasswordException\":\n      return new PasswordException(ex.message, ex.code);\n    case \"ResponseException\":\n      return new ResponseException(ex.message, ex.status, ex.missing);\n    case \"UnknownErrorException\":\n      return new UnknownErrorException(ex.message, ex.details);\n  }\n  return new UnknownErrorException(ex.message, ex.toString());\n}\nclass MessageHandler {\n  #messageAC = new AbortController();\n  constructor(sourceName, targetName, comObj) {\n    this.sourceName = sourceName;\n    this.targetName = targetName;\n    this.comObj = comObj;\n    this.callbackId = 1;\n    this.streamId = 1;\n    this.streamSinks = Object.create(null);\n    this.streamControllers = Object.create(null);\n    this.callbackCapabilities = Object.create(null);\n    this.actionHandler = Object.create(null);\n    comObj.addEventListener(\"message\", this.#onMessage.bind(this), {\n      signal: this.#messageAC.signal\n    });\n  }\n  #onMessage({\n    data\n  }) {\n    if (data.targetName !== this.sourceName) {\n      return;\n    }\n    if (data.stream) {\n      this.#processStreamMessage(data);\n      return;\n    }\n    if (data.callback) {\n      const callbackId = data.callbackId;\n      const capability = this.callbackCapabilities[callbackId];\n      if (!capability) {\n        throw new Error(`Cannot resolve callback ${callbackId}`);\n      }\n      delete this.callbackCapabilities[callbackId];\n      if (data.callback === CallbackKind.DATA) {\n        capability.resolve(data.data);\n      } else if (data.callback === CallbackKind.ERROR) {\n        capability.reject(wrapReason(data.reason));\n      } else {\n        throw new Error(\"Unexpected callback case\");\n      }\n      return;\n    }\n    const action = this.actionHandler[data.action];\n    if (!action) {\n      throw new Error(`Unknown action from worker: ${data.action}`);\n    }\n    if (data.callbackId) {\n      const sourceName = this.sourceName,\n        targetName = data.sourceName,\n        comObj = this.comObj;\n      Promise.try(action, data.data).then(function (result) {\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          callback: CallbackKind.DATA,\n          callbackId: data.callbackId,\n          data: result\n        });\n      }, function (reason) {\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          callback: CallbackKind.ERROR,\n          callbackId: data.callbackId,\n          reason: wrapReason(reason)\n        });\n      });\n      return;\n    }\n    if (data.streamId) {\n      this.#createStreamSink(data);\n      return;\n    }\n    action(data.data);\n  }\n  on(actionName, handler) {\n    const ah = this.actionHandler;\n    if (ah[actionName]) {\n      throw new Error(`There is already an actionName called \"${actionName}\"`);\n    }\n    ah[actionName] = handler;\n  }\n  send(actionName, data, transfers) {\n    this.comObj.postMessage({\n      sourceName: this.sourceName,\n      targetName: this.targetName,\n      action: actionName,\n      data\n    }, transfers);\n  }\n  sendWithPromise(actionName, data, transfers) {\n    const callbackId = this.callbackId++;\n    const capability = Promise.withResolvers();\n    this.callbackCapabilities[callbackId] = capability;\n    try {\n      this.comObj.postMessage({\n        sourceName: this.sourceName,\n        targetName: this.targetName,\n        action: actionName,\n        callbackId,\n        data\n      }, transfers);\n    } catch (ex) {\n      capability.reject(ex);\n    }\n    return capability.promise;\n  }\n  sendWithStream(actionName, data, queueingStrategy, transfers) {\n    const streamId = this.streamId++,\n      sourceName = this.sourceName,\n      targetName = this.targetName,\n      comObj = this.comObj;\n    return new ReadableStream({\n      start: controller => {\n        const startCapability = Promise.withResolvers();\n        this.streamControllers[streamId] = {\n          controller,\n          startCall: startCapability,\n          pullCall: null,\n          cancelCall: null,\n          isClosed: false\n        };\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          action: actionName,\n          streamId,\n          data,\n          desiredSize: controller.desiredSize\n        }, transfers);\n        return startCapability.promise;\n      },\n      pull: controller => {\n        const pullCapability = Promise.withResolvers();\n        this.streamControllers[streamId].pullCall = pullCapability;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.PULL,\n          streamId,\n          desiredSize: controller.desiredSize\n        });\n        return pullCapability.promise;\n      },\n      cancel: reason => {\n        assert(reason instanceof Error, \"cancel must have a valid reason\");\n        const cancelCapability = Promise.withResolvers();\n        this.streamControllers[streamId].cancelCall = cancelCapability;\n        this.streamControllers[streamId].isClosed = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.CANCEL,\n          streamId,\n          reason: wrapReason(reason)\n        });\n        return cancelCapability.promise;\n      }\n    }, queueingStrategy);\n  }\n  #createStreamSink(data) {\n    const streamId = data.streamId,\n      sourceName = this.sourceName,\n      targetName = data.sourceName,\n      comObj = this.comObj;\n    const self = this,\n      action = this.actionHandler[data.action];\n    const streamSink = {\n      enqueue(chunk, size = 1, transfers) {\n        if (this.isCancelled) {\n          return;\n        }\n        const lastDesiredSize = this.desiredSize;\n        this.desiredSize -= size;\n        if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n          this.sinkCapability = Promise.withResolvers();\n          this.ready = this.sinkCapability.promise;\n        }\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.ENQUEUE,\n          streamId,\n          chunk\n        }, transfers);\n      },\n      close() {\n        if (this.isCancelled) {\n          return;\n        }\n        this.isCancelled = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.CLOSE,\n          streamId\n        });\n        delete self.streamSinks[streamId];\n      },\n      error(reason) {\n        assert(reason instanceof Error, \"error must have a valid reason\");\n        if (this.isCancelled) {\n          return;\n        }\n        this.isCancelled = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.ERROR,\n          streamId,\n          reason: wrapReason(reason)\n        });\n      },\n      sinkCapability: Promise.withResolvers(),\n      onPull: null,\n      onCancel: null,\n      isCancelled: false,\n      desiredSize: data.desiredSize,\n      ready: null\n    };\n    streamSink.sinkCapability.resolve();\n    streamSink.ready = streamSink.sinkCapability.promise;\n    this.streamSinks[streamId] = streamSink;\n    Promise.try(action, data.data, streamSink).then(function () {\n      comObj.postMessage({\n        sourceName,\n        targetName,\n        stream: StreamKind.START_COMPLETE,\n        streamId,\n        success: true\n      });\n    }, function (reason) {\n      comObj.postMessage({\n        sourceName,\n        targetName,\n        stream: StreamKind.START_COMPLETE,\n        streamId,\n        reason: wrapReason(reason)\n      });\n    });\n  }\n  #processStreamMessage(data) {\n    const streamId = data.streamId,\n      sourceName = this.sourceName,\n      targetName = data.sourceName,\n      comObj = this.comObj;\n    const streamController = this.streamControllers[streamId],\n      streamSink = this.streamSinks[streamId];\n    switch (data.stream) {\n      case StreamKind.START_COMPLETE:\n        if (data.success) {\n          streamController.startCall.resolve();\n        } else {\n          streamController.startCall.reject(wrapReason(data.reason));\n        }\n        break;\n      case StreamKind.PULL_COMPLETE:\n        if (data.success) {\n          streamController.pullCall.resolve();\n        } else {\n          streamController.pullCall.reject(wrapReason(data.reason));\n        }\n        break;\n      case StreamKind.PULL:\n        if (!streamSink) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            success: true\n          });\n          break;\n        }\n        if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {\n          streamSink.sinkCapability.resolve();\n        }\n        streamSink.desiredSize = data.desiredSize;\n        Promise.try(streamSink.onPull || onFn).then(function () {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            success: true\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            reason: wrapReason(reason)\n          });\n        });\n        break;\n      case StreamKind.ENQUEUE:\n        assert(streamController, \"enqueue should have stream controller\");\n        if (streamController.isClosed) {\n          break;\n        }\n        streamController.controller.enqueue(data.chunk);\n        break;\n      case StreamKind.CLOSE:\n        assert(streamController, \"close should have stream controller\");\n        if (streamController.isClosed) {\n          break;\n        }\n        streamController.isClosed = true;\n        streamController.controller.close();\n        this.#deleteStreamController(streamController, streamId);\n        break;\n      case StreamKind.ERROR:\n        assert(streamController, \"error should have stream controller\");\n        streamController.controller.error(wrapReason(data.reason));\n        this.#deleteStreamController(streamController, streamId);\n        break;\n      case StreamKind.CANCEL_COMPLETE:\n        if (data.success) {\n          streamController.cancelCall.resolve();\n        } else {\n          streamController.cancelCall.reject(wrapReason(data.reason));\n        }\n        this.#deleteStreamController(streamController, streamId);\n        break;\n      case StreamKind.CANCEL:\n        if (!streamSink) {\n          break;\n        }\n        const dataReason = wrapReason(data.reason);\n        Promise.try(streamSink.onCancel || onFn, dataReason).then(function () {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CANCEL_COMPLETE,\n            streamId,\n            success: true\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CANCEL_COMPLETE,\n            streamId,\n            reason: wrapReason(reason)\n          });\n        });\n        streamSink.sinkCapability.reject(dataReason);\n        streamSink.isCancelled = true;\n        delete this.streamSinks[streamId];\n        break;\n      default:\n        throw new Error(\"Unexpected stream case\");\n    }\n  }\n  async #deleteStreamController(streamController, streamId) {\n    await Promise.allSettled([streamController.startCall?.promise, streamController.pullCall?.promise, streamController.cancelCall?.promise]);\n    delete this.streamControllers[streamId];\n  }\n  destroy() {\n    this.#messageAC?.abort();\n    this.#messageAC = null;\n  }\n}\n\n;// ./src/display/canvas_factory.js\n\nclass BaseCanvasFactory {\n  #enableHWA = false;\n  constructor({\n    enableHWA = false\n  }) {\n    this.#enableHWA = enableHWA;\n  }\n  create(width, height) {\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid canvas size\");\n    }\n    const canvas = this._createCanvas(width, height);\n    return {\n      canvas,\n      context: canvas.getContext(\"2d\", {\n        willReadFrequently: !this.#enableHWA\n      })\n    };\n  }\n  reset(canvasAndContext, width, height) {\n    if (!canvasAndContext.canvas) {\n      throw new Error(\"Canvas is not specified\");\n    }\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid canvas size\");\n    }\n    canvasAndContext.canvas.width = width;\n    canvasAndContext.canvas.height = height;\n  }\n  destroy(canvasAndContext) {\n    if (!canvasAndContext.canvas) {\n      throw new Error(\"Canvas is not specified\");\n    }\n    canvasAndContext.canvas.width = 0;\n    canvasAndContext.canvas.height = 0;\n    canvasAndContext.canvas = null;\n    canvasAndContext.context = null;\n  }\n  _createCanvas(width, height) {\n    unreachable(\"Abstract method `_createCanvas` called.\");\n  }\n}\nclass DOMCanvasFactory extends BaseCanvasFactory {\n  constructor({\n    ownerDocument = globalThis.document,\n    enableHWA = false\n  }) {\n    super({\n      enableHWA\n    });\n    this._document = ownerDocument;\n  }\n  _createCanvas(width, height) {\n    const canvas = this._document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  }\n}\n\n;// ./src/display/cmap_reader_factory.js\n\n\nclass BaseCMapReaderFactory {\n  constructor({\n    baseUrl = null,\n    isCompressed = true\n  }) {\n    this.baseUrl = baseUrl;\n    this.isCompressed = isCompressed;\n  }\n  async fetch({\n    name\n  }) {\n    if (!this.baseUrl) {\n      throw new Error(\"Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.\");\n    }\n    if (!name) {\n      throw new Error(\"CMap name must be specified.\");\n    }\n    const url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n    return this._fetch(url).then(cMapData => ({\n      cMapData,\n      isCompressed: this.isCompressed\n    })).catch(reason => {\n      throw new Error(`Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url}`);\n    });\n  }\n  async _fetch(url) {\n    unreachable(\"Abstract method `_fetch` called.\");\n  }\n}\nclass DOMCMapReaderFactory extends BaseCMapReaderFactory {\n  async _fetch(url) {\n    const data = await fetchData(url, this.isCompressed ? \"arraybuffer\" : \"text\");\n    return data instanceof ArrayBuffer ? new Uint8Array(data) : stringToBytes(data);\n  }\n}\n\n;// ./src/display/filter_factory.js\n\n\nclass BaseFilterFactory {\n  addFilter(maps) {\n    return \"none\";\n  }\n  addHCMFilter(fgColor, bgColor) {\n    return \"none\";\n  }\n  addAlphaFilter(map) {\n    return \"none\";\n  }\n  addLuminosityFilter(map) {\n    return \"none\";\n  }\n  addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {\n    return \"none\";\n  }\n  destroy(keepHCM = false) {}\n}\nclass DOMFilterFactory extends BaseFilterFactory {\n  #baseUrl;\n  #_cache;\n  #_defs;\n  #docId;\n  #document;\n  #_hcmCache;\n  #id = 0;\n  constructor({\n    docId,\n    ownerDocument = globalThis.document\n  }) {\n    super();\n    this.#docId = docId;\n    this.#document = ownerDocument;\n  }\n  get #cache() {\n    return this.#_cache ||= new Map();\n  }\n  get #hcmCache() {\n    return this.#_hcmCache ||= new Map();\n  }\n  get #defs() {\n    if (!this.#_defs) {\n      const div = this.#document.createElement(\"div\");\n      const {\n        style\n      } = div;\n      style.visibility = \"hidden\";\n      style.contain = \"strict\";\n      style.width = style.height = 0;\n      style.position = \"absolute\";\n      style.top = style.left = 0;\n      style.zIndex = -1;\n      const svg = this.#document.createElementNS(SVG_NS, \"svg\");\n      svg.setAttribute(\"width\", 0);\n      svg.setAttribute(\"height\", 0);\n      this.#_defs = this.#document.createElementNS(SVG_NS, \"defs\");\n      div.append(svg);\n      svg.append(this.#_defs);\n      this.#document.body.append(div);\n    }\n    return this.#_defs;\n  }\n  #createTables(maps) {\n    if (maps.length === 1) {\n      const mapR = maps[0];\n      const buffer = new Array(256);\n      for (let i = 0; i < 256; i++) {\n        buffer[i] = mapR[i] / 255;\n      }\n      const table = buffer.join(\",\");\n      return [table, table, table];\n    }\n    const [mapR, mapG, mapB] = maps;\n    const bufferR = new Array(256);\n    const bufferG = new Array(256);\n    const bufferB = new Array(256);\n    for (let i = 0; i < 256; i++) {\n      bufferR[i] = mapR[i] / 255;\n      bufferG[i] = mapG[i] / 255;\n      bufferB[i] = mapB[i] / 255;\n    }\n    return [bufferR.join(\",\"), bufferG.join(\",\"), bufferB.join(\",\")];\n  }\n  #createUrl(id) {\n    if (this.#baseUrl === undefined) {\n      this.#baseUrl = \"\";\n      const url = this.#document.URL;\n      if (url !== this.#document.baseURI) {\n        if (isDataScheme(url)) {\n          warn('#createUrl: ignore \"data:\"-URL for performance reasons.');\n        } else {\n          this.#baseUrl = updateUrlHash(url, \"\");\n        }\n      }\n    }\n    return `url(${this.#baseUrl}#${id})`;\n  }\n  addFilter(maps) {\n    if (!maps) {\n      return \"none\";\n    }\n    let value = this.#cache.get(maps);\n    if (value) {\n      return value;\n    }\n    const [tableR, tableG, tableB] = this.#createTables(maps);\n    const key = maps.length === 1 ? tableR : `${tableR}${tableG}${tableB}`;\n    value = this.#cache.get(key);\n    if (value) {\n      this.#cache.set(maps, value);\n      return value;\n    }\n    const id = `g_${this.#docId}_transfer_map_${this.#id++}`;\n    const url = this.#createUrl(id);\n    this.#cache.set(maps, url);\n    this.#cache.set(key, url);\n    const filter = this.#createFilter(id);\n    this.#addTransferMapConversion(tableR, tableG, tableB, filter);\n    return url;\n  }\n  addHCMFilter(fgColor, bgColor) {\n    const key = `${fgColor}-${bgColor}`;\n    const filterName = \"base\";\n    let info = this.#hcmCache.get(filterName);\n    if (info?.key === key) {\n      return info.url;\n    }\n    if (info) {\n      info.filter?.remove();\n      info.key = key;\n      info.url = \"none\";\n      info.filter = null;\n    } else {\n      info = {\n        key,\n        url: \"none\",\n        filter: null\n      };\n      this.#hcmCache.set(filterName, info);\n    }\n    if (!fgColor || !bgColor) {\n      return info.url;\n    }\n    const fgRGB = this.#getRGB(fgColor);\n    fgColor = Util.makeHexColor(...fgRGB);\n    const bgRGB = this.#getRGB(bgColor);\n    bgColor = Util.makeHexColor(...bgRGB);\n    this.#defs.style.color = \"\";\n    if (fgColor === \"#000000\" && bgColor === \"#ffffff\" || fgColor === bgColor) {\n      return info.url;\n    }\n    const map = new Array(256);\n    for (let i = 0; i <= 255; i++) {\n      const x = i / 255;\n      map[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;\n    }\n    const table = map.join(\",\");\n    const id = `g_${this.#docId}_hcm_filter`;\n    const filter = info.filter = this.#createFilter(id);\n    this.#addTransferMapConversion(table, table, table, filter);\n    this.#addGrayConversion(filter);\n    const getSteps = (c, n) => {\n      const start = fgRGB[c] / 255;\n      const end = bgRGB[c] / 255;\n      const arr = new Array(n + 1);\n      for (let i = 0; i <= n; i++) {\n        arr[i] = start + i / n * (end - start);\n      }\n      return arr.join(\",\");\n    };\n    this.#addTransferMapConversion(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);\n    info.url = this.#createUrl(id);\n    return info.url;\n  }\n  addAlphaFilter(map) {\n    let value = this.#cache.get(map);\n    if (value) {\n      return value;\n    }\n    const [tableA] = this.#createTables([map]);\n    const key = `alpha_${tableA}`;\n    value = this.#cache.get(key);\n    if (value) {\n      this.#cache.set(map, value);\n      return value;\n    }\n    const id = `g_${this.#docId}_alpha_map_${this.#id++}`;\n    const url = this.#createUrl(id);\n    this.#cache.set(map, url);\n    this.#cache.set(key, url);\n    const filter = this.#createFilter(id);\n    this.#addTransferMapAlphaConversion(tableA, filter);\n    return url;\n  }\n  addLuminosityFilter(map) {\n    let value = this.#cache.get(map || \"luminosity\");\n    if (value) {\n      return value;\n    }\n    let tableA, key;\n    if (map) {\n      [tableA] = this.#createTables([map]);\n      key = `luminosity_${tableA}`;\n    } else {\n      key = \"luminosity\";\n    }\n    value = this.#cache.get(key);\n    if (value) {\n      this.#cache.set(map, value);\n      return value;\n    }\n    const id = `g_${this.#docId}_luminosity_map_${this.#id++}`;\n    const url = this.#createUrl(id);\n    this.#cache.set(map, url);\n    this.#cache.set(key, url);\n    const filter = this.#createFilter(id);\n    this.#addLuminosityConversion(filter);\n    if (map) {\n      this.#addTransferMapAlphaConversion(tableA, filter);\n    }\n    return url;\n  }\n  addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {\n    const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;\n    let info = this.#hcmCache.get(filterName);\n    if (info?.key === key) {\n      return info.url;\n    }\n    if (info) {\n      info.filter?.remove();\n      info.key = key;\n      info.url = \"none\";\n      info.filter = null;\n    } else {\n      info = {\n        key,\n        url: \"none\",\n        filter: null\n      };\n      this.#hcmCache.set(filterName, info);\n    }\n    if (!fgColor || !bgColor) {\n      return info.url;\n    }\n    const [fgRGB, bgRGB] = [fgColor, bgColor].map(this.#getRGB.bind(this));\n    let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);\n    let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);\n    let [newFgRGB, newBgRGB] = [newFgColor, newBgColor].map(this.#getRGB.bind(this));\n    if (bgGray < fgGray) {\n      [fgGray, bgGray, newFgRGB, newBgRGB] = [bgGray, fgGray, newBgRGB, newFgRGB];\n    }\n    this.#defs.style.color = \"\";\n    const getSteps = (fg, bg, n) => {\n      const arr = new Array(256);\n      const step = (bgGray - fgGray) / n;\n      const newStart = fg / 255;\n      const newStep = (bg - fg) / (255 * n);\n      let prev = 0;\n      for (let i = 0; i <= n; i++) {\n        const k = Math.round(fgGray + i * step);\n        const value = newStart + i * newStep;\n        for (let j = prev; j <= k; j++) {\n          arr[j] = value;\n        }\n        prev = k + 1;\n      }\n      for (let i = prev; i < 256; i++) {\n        arr[i] = arr[prev - 1];\n      }\n      return arr.join(\",\");\n    };\n    const id = `g_${this.#docId}_hcm_${filterName}_filter`;\n    const filter = info.filter = this.#createFilter(id);\n    this.#addGrayConversion(filter);\n    this.#addTransferMapConversion(getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);\n    info.url = this.#createUrl(id);\n    return info.url;\n  }\n  destroy(keepHCM = false) {\n    if (keepHCM && this.#_hcmCache?.size) {\n      return;\n    }\n    this.#_defs?.parentNode.parentNode.remove();\n    this.#_defs = null;\n    this.#_cache?.clear();\n    this.#_cache = null;\n    this.#_hcmCache?.clear();\n    this.#_hcmCache = null;\n    this.#id = 0;\n  }\n  #addLuminosityConversion(filter) {\n    const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n    feColorMatrix.setAttribute(\"type\", \"matrix\");\n    feColorMatrix.setAttribute(\"values\", \"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0\");\n    filter.append(feColorMatrix);\n  }\n  #addGrayConversion(filter) {\n    const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n    feColorMatrix.setAttribute(\"type\", \"matrix\");\n    feColorMatrix.setAttribute(\"values\", \"0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0\");\n    filter.append(feColorMatrix);\n  }\n  #createFilter(id) {\n    const filter = this.#document.createElementNS(SVG_NS, \"filter\");\n    filter.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n    filter.setAttribute(\"id\", id);\n    this.#defs.append(filter);\n    return filter;\n  }\n  #appendFeFunc(feComponentTransfer, func, table) {\n    const feFunc = this.#document.createElementNS(SVG_NS, func);\n    feFunc.setAttribute(\"type\", \"discrete\");\n    feFunc.setAttribute(\"tableValues\", table);\n    feComponentTransfer.append(feFunc);\n  }\n  #addTransferMapConversion(rTable, gTable, bTable, filter) {\n    const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n    filter.append(feComponentTransfer);\n    this.#appendFeFunc(feComponentTransfer, \"feFuncR\", rTable);\n    this.#appendFeFunc(feComponentTransfer, \"feFuncG\", gTable);\n    this.#appendFeFunc(feComponentTransfer, \"feFuncB\", bTable);\n  }\n  #addTransferMapAlphaConversion(aTable, filter) {\n    const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n    filter.append(feComponentTransfer);\n    this.#appendFeFunc(feComponentTransfer, \"feFuncA\", aTable);\n  }\n  #getRGB(color) {\n    this.#defs.style.color = color;\n    return getRGB(getComputedStyle(this.#defs).getPropertyValue(\"color\"));\n  }\n}\n\n;// ./src/display/standard_fontdata_factory.js\n\n\nclass BaseStandardFontDataFactory {\n  constructor({\n    baseUrl = null\n  }) {\n    this.baseUrl = baseUrl;\n  }\n  async fetch({\n    filename\n  }) {\n    if (!this.baseUrl) {\n      throw new Error(\"Ensure that the `standardFontDataUrl` API parameter is provided.\");\n    }\n    if (!filename) {\n      throw new Error(\"Font filename must be specified.\");\n    }\n    const url = `${this.baseUrl}${filename}`;\n    return this._fetch(url).catch(reason => {\n      throw new Error(`Unable to load font data at: ${url}`);\n    });\n  }\n  async _fetch(url) {\n    unreachable(\"Abstract method `_fetch` called.\");\n  }\n}\nclass DOMStandardFontDataFactory extends BaseStandardFontDataFactory {\n  async _fetch(url) {\n    const data = await fetchData(url, \"arraybuffer\");\n    return new Uint8Array(data);\n  }\n}\n\n;// ./src/display/wasm_factory.js\n\n\nclass BaseWasmFactory {\n  constructor({\n    baseUrl = null\n  }) {\n    this.baseUrl = baseUrl;\n  }\n  async fetch({\n    filename\n  }) {\n    if (!this.baseUrl) {\n      throw new Error(\"Ensure that the `wasmUrl` API parameter is provided.\");\n    }\n    if (!filename) {\n      throw new Error(\"Wasm filename must be specified.\");\n    }\n    const url = `${this.baseUrl}${filename}`;\n    return this._fetch(url).catch(reason => {\n      throw new Error(`Unable to load wasm data at: ${url}`);\n    });\n  }\n  async _fetch(url) {\n    unreachable(\"Abstract method `_fetch` called.\");\n  }\n}\nclass DOMWasmFactory extends BaseWasmFactory {\n  async _fetch(url) {\n    const data = await fetchData(url, \"arraybuffer\");\n    return new Uint8Array(data);\n  }\n}\n\n;// ./src/display/node_utils.js\n\n\n\n\n\n\nif (isNodeJS) {\n  warn(\"Please use the `legacy` build in Node.js environments.\");\n}\nasync function node_utils_fetchData(url) {\n  const fs = process.getBuiltinModule(\"fs\");\n  const data = await fs.promises.readFile(url);\n  return new Uint8Array(data);\n}\nclass NodeFilterFactory extends BaseFilterFactory {}\nclass NodeCanvasFactory extends BaseCanvasFactory {\n  _createCanvas(width, height) {\n    const require = process.getBuiltinModule(\"module\").createRequire(\"file:///C:/Users/Laptop/Downloads/studybuddy-ai-mvp/node_modules/pdfjs-dist/build/pdf.mjs\");\n    const canvas = require(\"@napi-rs/canvas\");\n    return canvas.createCanvas(width, height);\n  }\n}\nclass NodeCMapReaderFactory extends BaseCMapReaderFactory {\n  async _fetch(url) {\n    return node_utils_fetchData(url);\n  }\n}\nclass NodeStandardFontDataFactory extends BaseStandardFontDataFactory {\n  async _fetch(url) {\n    return node_utils_fetchData(url);\n  }\n}\nclass NodeWasmFactory extends BaseWasmFactory {\n  async _fetch(url) {\n    return node_utils_fetchData(url);\n  }\n}\n\n;// ./src/display/canvas_dependency_tracker.js\n\nconst FORCED_DEPENDENCY_LABEL = \"__forcedDependency\";\nclass CanvasDependencyTracker {\n  #simple = {\n    __proto__: null\n  };\n  #incremental = {\n    __proto__: null,\n    transform: [],\n    moveText: [],\n    sameLineText: [],\n    [FORCED_DEPENDENCY_LABEL]: []\n  };\n  #namedDependencies = new Map();\n  #savesStack = [];\n  #markedContentStack = [];\n  #baseTransformStack = [[1, 0, 0, 1, 0, 0]];\n  #clipBox = [-Infinity, -Infinity, Infinity, Infinity];\n  #pendingBBox = new Float64Array([Infinity, Infinity, -Infinity, -Infinity]);\n  #pendingBBoxIdx = -1;\n  #pendingDependencies = new Set();\n  #operations = new Map();\n  #fontBBoxTrustworthy = new Map();\n  #canvasWidth;\n  #canvasHeight;\n  constructor(canvas) {\n    this.#canvasWidth = canvas.width;\n    this.#canvasHeight = canvas.height;\n  }\n  save(opIdx) {\n    this.#simple = {\n      __proto__: this.#simple\n    };\n    this.#incremental = {\n      __proto__: this.#incremental,\n      transform: {\n        __proto__: this.#incremental.transform\n      },\n      moveText: {\n        __proto__: this.#incremental.moveText\n      },\n      sameLineText: {\n        __proto__: this.#incremental.sameLineText\n      },\n      [FORCED_DEPENDENCY_LABEL]: {\n        __proto__: this.#incremental[FORCED_DEPENDENCY_LABEL]\n      }\n    };\n    this.#clipBox = {\n      __proto__: this.#clipBox\n    };\n    this.#savesStack.push([opIdx, null]);\n    return this;\n  }\n  restore(opIdx) {\n    const previous = Object.getPrototypeOf(this.#simple);\n    if (previous === null) {\n      return this;\n    }\n    this.#simple = previous;\n    this.#incremental = Object.getPrototypeOf(this.#incremental);\n    this.#clipBox = Object.getPrototypeOf(this.#clipBox);\n    const lastPair = this.#savesStack.pop();\n    if (lastPair !== undefined) {\n      lastPair[1] = opIdx;\n    }\n    return this;\n  }\n  recordOpenMarker(idx) {\n    this.#savesStack.push([idx, null]);\n    return this;\n  }\n  getOpenMarker() {\n    if (this.#savesStack.length === 0) {\n      return null;\n    }\n    return this.#savesStack.at(-1)[0];\n  }\n  recordCloseMarker(idx) {\n    const lastPair = this.#savesStack.pop();\n    if (lastPair !== undefined) {\n      lastPair[1] = idx;\n    }\n    return this;\n  }\n  beginMarkedContent(opIdx) {\n    this.#markedContentStack.push([opIdx, null]);\n    return this;\n  }\n  endMarkedContent(opIdx) {\n    const lastPair = this.#markedContentStack.pop();\n    if (lastPair !== undefined) {\n      lastPair[1] = opIdx;\n    }\n    return this;\n  }\n  pushBaseTransform(ctx) {\n    this.#baseTransformStack.push(Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform()));\n    return this;\n  }\n  popBaseTransform() {\n    if (this.#baseTransformStack.length > 1) {\n      this.#baseTransformStack.pop();\n    }\n    return this;\n  }\n  recordSimpleData(name, idx) {\n    this.#simple[name] = idx;\n    return this;\n  }\n  recordIncrementalData(name, idx) {\n    this.#incremental[name].push(idx);\n    return this;\n  }\n  resetIncrementalData(name, idx) {\n    this.#incremental[name].length = 0;\n    return this;\n  }\n  recordNamedData(name, idx) {\n    this.#namedDependencies.set(name, idx);\n    return this;\n  }\n  recordFutureForcedDependency(name, idx) {\n    this.recordIncrementalData(FORCED_DEPENDENCY_LABEL, idx);\n    return this;\n  }\n  inheritSimpleDataAsFutureForcedDependencies(names) {\n    for (const name of names) {\n      if (name in this.#simple) {\n        this.recordFutureForcedDependency(name, this.#simple[name]);\n      }\n    }\n    return this;\n  }\n  inheritPendingDependenciesAsFutureForcedDependencies() {\n    for (const dep of this.#pendingDependencies) {\n      this.recordFutureForcedDependency(FORCED_DEPENDENCY_LABEL, dep);\n    }\n    return this;\n  }\n  resetBBox(idx) {\n    this.#pendingBBoxIdx = idx;\n    this.#pendingBBox[0] = Infinity;\n    this.#pendingBBox[1] = Infinity;\n    this.#pendingBBox[2] = -Infinity;\n    this.#pendingBBox[3] = -Infinity;\n    return this;\n  }\n  get hasPendingBBox() {\n    return this.#pendingBBoxIdx !== -1;\n  }\n  recordClipBox(idx, ctx, minX, maxX, minY, maxY) {\n    const transform = Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform());\n    const clipBox = [Infinity, Infinity, -Infinity, -Infinity];\n    Util.axialAlignedBoundingBox([minX, minY, maxX, maxY], transform, clipBox);\n    const intersection = Util.intersect(this.#clipBox, clipBox);\n    if (intersection) {\n      this.#clipBox[0] = intersection[0];\n      this.#clipBox[1] = intersection[1];\n      this.#clipBox[2] = intersection[2];\n      this.#clipBox[3] = intersection[3];\n    } else {\n      this.#clipBox[0] = this.#clipBox[1] = Infinity;\n      this.#clipBox[2] = this.#clipBox[3] = -Infinity;\n    }\n    return this;\n  }\n  recordBBox(idx, ctx, minX, maxX, minY, maxY) {\n    const clipBox = this.#clipBox;\n    if (clipBox[0] === Infinity) {\n      return this;\n    }\n    const transform = Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform());\n    if (clipBox[0] === -Infinity) {\n      Util.axialAlignedBoundingBox([minX, minY, maxX, maxY], transform, this.#pendingBBox);\n      return this;\n    }\n    const bbox = [Infinity, Infinity, -Infinity, -Infinity];\n    Util.axialAlignedBoundingBox([minX, minY, maxX, maxY], transform, bbox);\n    this.#pendingBBox[0] = Math.min(this.#pendingBBox[0], Math.max(bbox[0], clipBox[0]));\n    this.#pendingBBox[1] = Math.min(this.#pendingBBox[1], Math.max(bbox[1], clipBox[1]));\n    this.#pendingBBox[2] = Math.max(this.#pendingBBox[2], Math.min(bbox[2], clipBox[2]));\n    this.#pendingBBox[3] = Math.max(this.#pendingBBox[3], Math.min(bbox[3], clipBox[3]));\n    return this;\n  }\n  recordCharacterBBox(idx, ctx, font, scale = 1, x = 0, y = 0, getMeasure) {\n    const fontBBox = font.bbox;\n    let isBBoxTrustworthy;\n    let computedBBox;\n    if (fontBBox) {\n      isBBoxTrustworthy = fontBBox[2] !== fontBBox[0] && fontBBox[3] !== fontBBox[1] && this.#fontBBoxTrustworthy.get(font);\n      if (isBBoxTrustworthy !== false) {\n        computedBBox = [0, 0, 0, 0];\n        Util.axialAlignedBoundingBox(fontBBox, font.fontMatrix, computedBBox);\n        if (scale !== 1 || x !== 0 || y !== 0) {\n          Util.scaleMinMax([scale, 0, 0, -scale, x, y], computedBBox);\n        }\n        if (isBBoxTrustworthy) {\n          return this.recordBBox(idx, ctx, computedBBox[0], computedBBox[2], computedBBox[1], computedBBox[3]);\n        }\n      }\n    }\n    if (!getMeasure) {\n      return this.recordFullPageBBox(idx);\n    }\n    const measure = getMeasure();\n    if (fontBBox && computedBBox && isBBoxTrustworthy === undefined) {\n      isBBoxTrustworthy = computedBBox[0] <= x - measure.actualBoundingBoxLeft && computedBBox[2] >= x + measure.actualBoundingBoxRight && computedBBox[1] <= y - measure.actualBoundingBoxAscent && computedBBox[3] >= y + measure.actualBoundingBoxDescent;\n      this.#fontBBoxTrustworthy.set(font, isBBoxTrustworthy);\n      if (isBBoxTrustworthy) {\n        return this.recordBBox(idx, ctx, computedBBox[0], computedBBox[2], computedBBox[1], computedBBox[3]);\n      }\n    }\n    return this.recordBBox(idx, ctx, x - measure.actualBoundingBoxLeft, x + measure.actualBoundingBoxRight, y - measure.actualBoundingBoxAscent, y + measure.actualBoundingBoxDescent);\n  }\n  recordFullPageBBox(idx) {\n    this.#pendingBBox[0] = Math.max(0, this.#clipBox[0]);\n    this.#pendingBBox[1] = Math.max(0, this.#clipBox[1]);\n    this.#pendingBBox[2] = Math.min(this.#canvasWidth, this.#clipBox[2]);\n    this.#pendingBBox[3] = Math.min(this.#canvasHeight, this.#clipBox[3]);\n    return this;\n  }\n  getSimpleIndex(dependencyName) {\n    return this.#simple[dependencyName];\n  }\n  recordDependencies(idx, dependencyNames) {\n    const pendingDependencies = this.#pendingDependencies;\n    const simple = this.#simple;\n    const incremental = this.#incremental;\n    for (const name of dependencyNames) {\n      if (name in this.#simple) {\n        pendingDependencies.add(simple[name]);\n      } else if (name in incremental) {\n        incremental[name].forEach(pendingDependencies.add, pendingDependencies);\n      }\n    }\n    return this;\n  }\n  copyDependenciesFromIncrementalOperation(idx, name) {\n    const operations = this.#operations;\n    const pendingDependencies = this.#pendingDependencies;\n    for (const depIdx of this.#incremental[name]) {\n      operations.get(depIdx).dependencies.forEach(pendingDependencies.add, pendingDependencies.add(depIdx));\n    }\n    return this;\n  }\n  recordNamedDependency(idx, name) {\n    if (this.#namedDependencies.has(name)) {\n      this.#pendingDependencies.add(this.#namedDependencies.get(name));\n    }\n    return this;\n  }\n  recordOperation(idx, preserveBbox = false) {\n    this.recordDependencies(idx, [FORCED_DEPENDENCY_LABEL]);\n    const dependencies = new Set(this.#pendingDependencies);\n    const pairs = this.#savesStack.concat(this.#markedContentStack);\n    const bbox = this.#pendingBBoxIdx === idx ? {\n      minX: this.#pendingBBox[0],\n      minY: this.#pendingBBox[1],\n      maxX: this.#pendingBBox[2],\n      maxY: this.#pendingBBox[3]\n    } : null;\n    this.#operations.set(idx, {\n      bbox,\n      pairs,\n      dependencies\n    });\n    if (!preserveBbox) {\n      this.#pendingBBoxIdx = -1;\n    }\n    this.#pendingDependencies.clear();\n    return this;\n  }\n  bboxToClipBoxDropOperation(idx) {\n    if (this.#pendingBBoxIdx !== -1) {\n      this.#pendingBBoxIdx = -1;\n      this.#clipBox[0] = Math.max(this.#clipBox[0], this.#pendingBBox[0]);\n      this.#clipBox[1] = Math.max(this.#clipBox[1], this.#pendingBBox[1]);\n      this.#clipBox[2] = Math.min(this.#clipBox[2], this.#pendingBBox[2]);\n      this.#clipBox[3] = Math.min(this.#clipBox[3], this.#pendingBBox[3]);\n    }\n    this.#pendingDependencies.clear();\n    return this;\n  }\n  _takePendingDependencies() {\n    const pendingDependencies = this.#pendingDependencies;\n    this.#pendingDependencies = new Set();\n    return pendingDependencies;\n  }\n  _extractOperation(idx) {\n    const operation = this.#operations.get(idx);\n    this.#operations.delete(idx);\n    return operation;\n  }\n  _pushPendingDependencies(dependencies) {\n    for (const dep of dependencies) {\n      this.#pendingDependencies.add(dep);\n    }\n  }\n  take() {\n    this.#fontBBoxTrustworthy.clear();\n    return Array.from(this.#operations, ([idx, {\n      bbox,\n      pairs,\n      dependencies\n    }]) => {\n      pairs.forEach(pair => pair.forEach(dependencies.add, dependencies));\n      dependencies.delete(idx);\n      return {\n        minX: (bbox?.minX ?? 0) / this.#canvasWidth,\n        maxX: (bbox?.maxX ?? this.#canvasWidth) / this.#canvasWidth,\n        minY: (bbox?.minY ?? 0) / this.#canvasHeight,\n        maxY: (bbox?.maxY ?? this.#canvasHeight) / this.#canvasHeight,\n        dependencies: Array.from(dependencies).sort((a, b) => a - b),\n        idx\n      };\n    });\n  }\n}\nclass CanvasNestedDependencyTracker {\n  #dependencyTracker;\n  #opIdx;\n  #nestingLevel = 0;\n  #outerDependencies;\n  #savesLevel = 0;\n  constructor(dependencyTracker, opIdx) {\n    if (dependencyTracker instanceof CanvasNestedDependencyTracker) {\n      return dependencyTracker;\n    }\n    this.#dependencyTracker = dependencyTracker;\n    this.#outerDependencies = dependencyTracker._takePendingDependencies();\n    this.#opIdx = opIdx;\n  }\n  save(opIdx) {\n    this.#savesLevel++;\n    this.#dependencyTracker.save(this.#opIdx);\n    return this;\n  }\n  restore(opIdx) {\n    if (this.#savesLevel > 0) {\n      this.#dependencyTracker.restore(this.#opIdx);\n      this.#savesLevel--;\n    }\n    return this;\n  }\n  recordOpenMarker(idx) {\n    this.#nestingLevel++;\n    return this;\n  }\n  getOpenMarker() {\n    return this.#nestingLevel > 0 ? this.#opIdx : this.#dependencyTracker.getOpenMarker();\n  }\n  recordCloseMarker(idx) {\n    this.#nestingLevel--;\n    return this;\n  }\n  beginMarkedContent(opIdx) {\n    return this;\n  }\n  endMarkedContent(opIdx) {\n    return this;\n  }\n  pushBaseTransform(ctx) {\n    this.#dependencyTracker.pushBaseTransform(ctx);\n    return this;\n  }\n  popBaseTransform() {\n    this.#dependencyTracker.popBaseTransform();\n    return this;\n  }\n  recordSimpleData(name, idx) {\n    this.#dependencyTracker.recordSimpleData(name, this.#opIdx);\n    return this;\n  }\n  recordIncrementalData(name, idx) {\n    this.#dependencyTracker.recordIncrementalData(name, this.#opIdx);\n    return this;\n  }\n  resetIncrementalData(name, idx) {\n    this.#dependencyTracker.resetIncrementalData(name, this.#opIdx);\n    return this;\n  }\n  recordNamedData(name, idx) {\n    return this;\n  }\n  recordFutureForcedDependency(name, idx) {\n    this.#dependencyTracker.recordFutureForcedDependency(name, this.#opIdx);\n    return this;\n  }\n  inheritSimpleDataAsFutureForcedDependencies(names) {\n    this.#dependencyTracker.inheritSimpleDataAsFutureForcedDependencies(names);\n    return this;\n  }\n  inheritPendingDependenciesAsFutureForcedDependencies() {\n    this.#dependencyTracker.inheritPendingDependenciesAsFutureForcedDependencies();\n    return this;\n  }\n  resetBBox(idx) {\n    if (!this.#dependencyTracker.hasPendingBBox) {\n      this.#dependencyTracker.resetBBox(this.#opIdx);\n    }\n    return this;\n  }\n  get hasPendingBBox() {\n    return this.#dependencyTracker.hasPendingBBox;\n  }\n  recordClipBox(idx, ctx, minX, maxX, minY, maxY) {\n    this.#dependencyTracker.recordClipBox(this.#opIdx, ctx, minX, maxX, minY, maxY);\n    return this;\n  }\n  recordBBox(idx, ctx, minX, maxX, minY, maxY) {\n    this.#dependencyTracker.recordBBox(this.#opIdx, ctx, minX, maxX, minY, maxY);\n    return this;\n  }\n  recordCharacterBBox(idx, ctx, font, scale, x, y, getMeasure) {\n    this.#dependencyTracker.recordCharacterBBox(this.#opIdx, ctx, font, scale, x, y, getMeasure);\n    return this;\n  }\n  recordFullPageBBox(idx) {\n    this.#dependencyTracker.recordFullPageBBox(this.#opIdx);\n    return this;\n  }\n  getSimpleIndex(dependencyName) {\n    return this.#dependencyTracker.getSimpleIndex(dependencyName);\n  }\n  recordDependencies(idx, dependencyNames) {\n    this.#dependencyTracker.recordDependencies(this.#opIdx, dependencyNames);\n    return this;\n  }\n  copyDependenciesFromIncrementalOperation(idx, name) {\n    this.#dependencyTracker.copyDependenciesFromIncrementalOperation(this.#opIdx, name);\n    return this;\n  }\n  recordNamedDependency(idx, name) {\n    this.#dependencyTracker.recordNamedDependency(this.#opIdx, name);\n    return this;\n  }\n  recordOperation(idx) {\n    this.#dependencyTracker.recordOperation(this.#opIdx, true);\n    const operation = this.#dependencyTracker._extractOperation(this.#opIdx);\n    for (const depIdx of operation.dependencies) {\n      this.#outerDependencies.add(depIdx);\n    }\n    this.#outerDependencies.delete(this.#opIdx);\n    this.#outerDependencies.delete(null);\n    return this;\n  }\n  bboxToClipBoxDropOperation(idx) {\n    this.#dependencyTracker.bboxToClipBoxDropOperation(this.#opIdx);\n    return this;\n  }\n  recordNestedDependencies() {\n    this.#dependencyTracker._pushPendingDependencies(this.#outerDependencies);\n  }\n  take() {\n    throw new Error(\"Unreachable\");\n  }\n}\nconst Dependencies = {\n  stroke: [\"path\", \"transform\", \"filter\", \"strokeColor\", \"strokeAlpha\", \"lineWidth\", \"lineCap\", \"lineJoin\", \"miterLimit\", \"dash\"],\n  fill: [\"path\", \"transform\", \"filter\", \"fillColor\", \"fillAlpha\", \"globalCompositeOperation\", \"SMask\"],\n  imageXObject: [\"transform\", \"SMask\", \"filter\", \"fillAlpha\", \"strokeAlpha\", \"globalCompositeOperation\"],\n  rawFillPath: [\"filter\", \"fillColor\", \"fillAlpha\"],\n  showText: [\"transform\", \"leading\", \"charSpacing\", \"wordSpacing\", \"hScale\", \"textRise\", \"moveText\", \"textMatrix\", \"font\", \"filter\", \"fillColor\", \"textRenderingMode\", \"SMask\", \"fillAlpha\", \"strokeAlpha\", \"globalCompositeOperation\"],\n  transform: [\"transform\"],\n  transformAndFill: [\"transform\", \"fillColor\"]\n};\n\n;// ./src/display/pattern_helper.js\n\n\nconst PathType = {\n  FILL: \"Fill\",\n  STROKE: \"Stroke\",\n  SHADING: \"Shading\"\n};\nfunction applyBoundingBox(ctx, bbox) {\n  if (!bbox) {\n    return;\n  }\n  const width = bbox[2] - bbox[0];\n  const height = bbox[3] - bbox[1];\n  const region = new Path2D();\n  region.rect(bbox[0], bbox[1], width, height);\n  ctx.clip(region);\n}\nclass BaseShadingPattern {\n  isModifyingCurrentTransform() {\n    return false;\n  }\n  getPattern() {\n    unreachable(\"Abstract method `getPattern` called.\");\n  }\n}\nclass RadialAxialShadingPattern extends BaseShadingPattern {\n  constructor(IR) {\n    super();\n    this._type = IR[1];\n    this._bbox = IR[2];\n    this._colorStops = IR[3];\n    this._p0 = IR[4];\n    this._p1 = IR[5];\n    this._r0 = IR[6];\n    this._r1 = IR[7];\n    this.matrix = null;\n  }\n  _createGradient(ctx) {\n    let grad;\n    if (this._type === \"axial\") {\n      grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);\n    } else if (this._type === \"radial\") {\n      grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);\n    }\n    for (const colorStop of this._colorStops) {\n      grad.addColorStop(colorStop[0], colorStop[1]);\n    }\n    return grad;\n  }\n  getPattern(ctx, owner, inverse, pathType) {\n    let pattern;\n    if (pathType === PathType.STROKE || pathType === PathType.FILL) {\n      const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, getCurrentTransform(ctx)) || [0, 0, 0, 0];\n      const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;\n      const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;\n      const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", width, height);\n      const tmpCtx = tmpCanvas.context;\n      tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n      tmpCtx.beginPath();\n      tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n      tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);\n      inverse = Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);\n      tmpCtx.transform(...owner.baseTransform);\n      if (this.matrix) {\n        tmpCtx.transform(...this.matrix);\n      }\n      applyBoundingBox(tmpCtx, this._bbox);\n      tmpCtx.fillStyle = this._createGradient(tmpCtx);\n      tmpCtx.fill();\n      pattern = ctx.createPattern(tmpCanvas.canvas, \"no-repeat\");\n      const domMatrix = new DOMMatrix(inverse);\n      pattern.setTransform(domMatrix);\n    } else {\n      applyBoundingBox(ctx, this._bbox);\n      pattern = this._createGradient(ctx);\n    }\n    return pattern;\n  }\n}\nfunction drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n  const coords = context.coords,\n    colors = context.colors;\n  const bytes = data.data,\n    rowSize = data.width * 4;\n  let tmp;\n  if (coords[p1 + 1] > coords[p2 + 1]) {\n    tmp = p1;\n    p1 = p2;\n    p2 = tmp;\n    tmp = c1;\n    c1 = c2;\n    c2 = tmp;\n  }\n  if (coords[p2 + 1] > coords[p3 + 1]) {\n    tmp = p2;\n    p2 = p3;\n    p3 = tmp;\n    tmp = c2;\n    c2 = c3;\n    c3 = tmp;\n  }\n  if (coords[p1 + 1] > coords[p2 + 1]) {\n    tmp = p1;\n    p1 = p2;\n    p2 = tmp;\n    tmp = c1;\n    c1 = c2;\n    c2 = tmp;\n  }\n  const x1 = (coords[p1] + context.offsetX) * context.scaleX;\n  const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n  const x2 = (coords[p2] + context.offsetX) * context.scaleX;\n  const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n  const x3 = (coords[p3] + context.offsetX) * context.scaleX;\n  const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n  if (y1 >= y3) {\n    return;\n  }\n  const c1r = colors[c1],\n    c1g = colors[c1 + 1],\n    c1b = colors[c1 + 2];\n  const c2r = colors[c2],\n    c2g = colors[c2 + 1],\n    c2b = colors[c2 + 2];\n  const c3r = colors[c3],\n    c3g = colors[c3 + 1],\n    c3b = colors[c3 + 2];\n  const minY = Math.round(y1),\n    maxY = Math.round(y3);\n  let xa, car, cag, cab;\n  let xb, cbr, cbg, cbb;\n  for (let y = minY; y <= maxY; y++) {\n    if (y < y2) {\n      const k = y < y1 ? 0 : (y1 - y) / (y1 - y2);\n      xa = x1 - (x1 - x2) * k;\n      car = c1r - (c1r - c2r) * k;\n      cag = c1g - (c1g - c2g) * k;\n      cab = c1b - (c1b - c2b) * k;\n    } else {\n      let k;\n      if (y > y3) {\n        k = 1;\n      } else if (y2 === y3) {\n        k = 0;\n      } else {\n        k = (y2 - y) / (y2 - y3);\n      }\n      xa = x2 - (x2 - x3) * k;\n      car = c2r - (c2r - c3r) * k;\n      cag = c2g - (c2g - c3g) * k;\n      cab = c2b - (c2b - c3b) * k;\n    }\n    let k;\n    if (y < y1) {\n      k = 0;\n    } else if (y > y3) {\n      k = 1;\n    } else {\n      k = (y1 - y) / (y1 - y3);\n    }\n    xb = x1 - (x1 - x3) * k;\n    cbr = c1r - (c1r - c3r) * k;\n    cbg = c1g - (c1g - c3g) * k;\n    cbb = c1b - (c1b - c3b) * k;\n    const x1_ = Math.round(Math.min(xa, xb));\n    const x2_ = Math.round(Math.max(xa, xb));\n    let j = rowSize * y + x1_ * 4;\n    for (let x = x1_; x <= x2_; x++) {\n      k = (xa - x) / (xa - xb);\n      if (k < 0) {\n        k = 0;\n      } else if (k > 1) {\n        k = 1;\n      }\n      bytes[j++] = car - (car - cbr) * k | 0;\n      bytes[j++] = cag - (cag - cbg) * k | 0;\n      bytes[j++] = cab - (cab - cbb) * k | 0;\n      bytes[j++] = 255;\n    }\n  }\n}\nfunction drawFigure(data, figure, context) {\n  const ps = figure.coords;\n  const cs = figure.colors;\n  let i, ii;\n  switch (figure.type) {\n    case \"lattice\":\n      const verticesPerRow = figure.verticesPerRow;\n      const rows = Math.floor(ps.length / verticesPerRow) - 1;\n      const cols = verticesPerRow - 1;\n      for (i = 0; i < rows; i++) {\n        let q = i * verticesPerRow;\n        for (let j = 0; j < cols; j++, q++) {\n          drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n          drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n        }\n      }\n      break;\n    case \"triangles\":\n      for (i = 0, ii = ps.length; i < ii; i += 3) {\n        drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n      }\n      break;\n    default:\n      throw new Error(\"illegal figure\");\n  }\n}\nclass MeshShadingPattern extends BaseShadingPattern {\n  constructor(IR) {\n    super();\n    this._coords = IR[2];\n    this._colors = IR[3];\n    this._figures = IR[4];\n    this._bounds = IR[5];\n    this._bbox = IR[6];\n    this._background = IR[7];\n    this.matrix = null;\n  }\n  _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {\n    const EXPECTED_SCALE = 1.1;\n    const MAX_PATTERN_SIZE = 3000;\n    const BORDER_SIZE = 2;\n    const offsetX = Math.floor(this._bounds[0]);\n    const offsetY = Math.floor(this._bounds[1]);\n    const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;\n    const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;\n    const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    const scaleX = boundsWidth / width;\n    const scaleY = boundsHeight / height;\n    const context = {\n      coords: this._coords,\n      colors: this._colors,\n      offsetX: -offsetX,\n      offsetY: -offsetY,\n      scaleX: 1 / scaleX,\n      scaleY: 1 / scaleY\n    };\n    const paddedWidth = width + BORDER_SIZE * 2;\n    const paddedHeight = height + BORDER_SIZE * 2;\n    const tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight);\n    const tmpCtx = tmpCanvas.context;\n    const data = tmpCtx.createImageData(width, height);\n    if (backgroundColor) {\n      const bytes = data.data;\n      for (let i = 0, ii = bytes.length; i < ii; i += 4) {\n        bytes[i] = backgroundColor[0];\n        bytes[i + 1] = backgroundColor[1];\n        bytes[i + 2] = backgroundColor[2];\n        bytes[i + 3] = 255;\n      }\n    }\n    for (const figure of this._figures) {\n      drawFigure(data, figure, context);\n    }\n    tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n    const canvas = tmpCanvas.canvas;\n    return {\n      canvas,\n      offsetX: offsetX - BORDER_SIZE * scaleX,\n      offsetY: offsetY - BORDER_SIZE * scaleY,\n      scaleX,\n      scaleY\n    };\n  }\n  isModifyingCurrentTransform() {\n    return true;\n  }\n  getPattern(ctx, owner, inverse, pathType) {\n    applyBoundingBox(ctx, this._bbox);\n    const scale = new Float32Array(2);\n    if (pathType === PathType.SHADING) {\n      Util.singularValueDecompose2dScale(getCurrentTransform(ctx), scale);\n    } else if (this.matrix) {\n      Util.singularValueDecompose2dScale(this.matrix, scale);\n      const [matrixScaleX, matrixScaleY] = scale;\n      Util.singularValueDecompose2dScale(owner.baseTransform, scale);\n      scale[0] *= matrixScaleX;\n      scale[1] *= matrixScaleY;\n    } else {\n      Util.singularValueDecompose2dScale(owner.baseTransform, scale);\n    }\n    const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);\n    if (pathType !== PathType.SHADING) {\n      ctx.setTransform(...owner.baseTransform);\n      if (this.matrix) {\n        ctx.transform(...this.matrix);\n      }\n    }\n    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n    return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n  }\n}\nclass DummyShadingPattern extends BaseShadingPattern {\n  getPattern() {\n    return \"hotpink\";\n  }\n}\nfunction getShadingPattern(IR) {\n  switch (IR[0]) {\n    case \"RadialAxial\":\n      return new RadialAxialShadingPattern(IR);\n    case \"Mesh\":\n      return new MeshShadingPattern(IR);\n    case \"Dummy\":\n      return new DummyShadingPattern();\n  }\n  throw new Error(`Unknown IR type: ${IR[0]}`);\n}\nconst PaintType = {\n  COLORED: 1,\n  UNCOLORED: 2\n};\nclass TilingPattern {\n  static MAX_PATTERN_SIZE = 3000;\n  constructor(IR, ctx, canvasGraphicsFactory, baseTransform) {\n    this.color = IR[1];\n    this.operatorList = IR[2];\n    this.matrix = IR[3];\n    this.bbox = IR[4];\n    this.xstep = IR[5];\n    this.ystep = IR[6];\n    this.paintType = IR[7];\n    this.tilingType = IR[8];\n    this.ctx = ctx;\n    this.canvasGraphicsFactory = canvasGraphicsFactory;\n    this.baseTransform = baseTransform;\n  }\n  createPatternCanvas(owner) {\n    const {\n      bbox,\n      operatorList,\n      paintType,\n      tilingType,\n      color,\n      canvasGraphicsFactory\n    } = this;\n    let {\n      xstep,\n      ystep\n    } = this;\n    xstep = Math.abs(xstep);\n    ystep = Math.abs(ystep);\n    info(\"TilingType: \" + tilingType);\n    const x0 = bbox[0],\n      y0 = bbox[1],\n      x1 = bbox[2],\n      y1 = bbox[3];\n    const width = x1 - x0;\n    const height = y1 - y0;\n    const scale = new Float32Array(2);\n    Util.singularValueDecompose2dScale(this.matrix, scale);\n    const [matrixScaleX, matrixScaleY] = scale;\n    Util.singularValueDecompose2dScale(this.baseTransform, scale);\n    const combinedScaleX = matrixScaleX * scale[0];\n    const combinedScaleY = matrixScaleY * scale[1];\n    let canvasWidth = width,\n      canvasHeight = height,\n      redrawHorizontally = false,\n      redrawVertically = false;\n    const xScaledStep = Math.ceil(xstep * combinedScaleX);\n    const yScaledStep = Math.ceil(ystep * combinedScaleY);\n    const xScaledWidth = Math.ceil(width * combinedScaleX);\n    const yScaledHeight = Math.ceil(height * combinedScaleY);\n    if (xScaledStep >= xScaledWidth) {\n      canvasWidth = xstep;\n    } else {\n      redrawHorizontally = true;\n    }\n    if (yScaledStep >= yScaledHeight) {\n      canvasHeight = ystep;\n    } else {\n      redrawVertically = true;\n    }\n    const dimx = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);\n    const dimy = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);\n    const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size);\n    const tmpCtx = tmpCanvas.context;\n    const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\n    graphics.groupLevel = owner.groupLevel;\n    this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n    tmpCtx.translate(-dimx.scale * x0, -dimy.scale * y0);\n    graphics.transform(0, dimx.scale, 0, 0, dimy.scale, 0, 0);\n    tmpCtx.save();\n    graphics.dependencyTracker?.save();\n    this.clipBbox(graphics, x0, y0, x1, y1);\n    graphics.baseTransform = getCurrentTransform(graphics.ctx);\n    graphics.executeOperatorList(operatorList);\n    graphics.endDrawing();\n    graphics.dependencyTracker?.restore().recordNestedDependencies?.();\n    tmpCtx.restore();\n    if (redrawHorizontally || redrawVertically) {\n      const image = tmpCanvas.canvas;\n      if (redrawHorizontally) {\n        canvasWidth = xstep;\n      }\n      if (redrawVertically) {\n        canvasHeight = ystep;\n      }\n      const dimx2 = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);\n      const dimy2 = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);\n      const xSize = dimx2.size;\n      const ySize = dimy2.size;\n      const tmpCanvas2 = owner.cachedCanvases.getCanvas(\"pattern-workaround\", xSize, ySize);\n      const tmpCtx2 = tmpCanvas2.context;\n      const ii = redrawHorizontally ? Math.floor(width / xstep) : 0;\n      const jj = redrawVertically ? Math.floor(height / ystep) : 0;\n      for (let i = 0; i <= ii; i++) {\n        for (let j = 0; j <= jj; j++) {\n          tmpCtx2.drawImage(image, xSize * i, ySize * j, xSize, ySize, 0, 0, xSize, ySize);\n        }\n      }\n      return {\n        canvas: tmpCanvas2.canvas,\n        scaleX: dimx2.scale,\n        scaleY: dimy2.scale,\n        offsetX: x0,\n        offsetY: y0\n      };\n    }\n    return {\n      canvas: tmpCanvas.canvas,\n      scaleX: dimx.scale,\n      scaleY: dimy.scale,\n      offsetX: x0,\n      offsetY: y0\n    };\n  }\n  getSizeAndScale(step, realOutputSize, scale) {\n    const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);\n    let size = Math.ceil(step * scale);\n    if (size >= maxSize) {\n      size = maxSize;\n    } else {\n      scale = size / step;\n    }\n    return {\n      scale,\n      size\n    };\n  }\n  clipBbox(graphics, x0, y0, x1, y1) {\n    const bboxWidth = x1 - x0;\n    const bboxHeight = y1 - y0;\n    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n    Util.axialAlignedBoundingBox([x0, y0, x1, y1], getCurrentTransform(graphics.ctx), graphics.current.minMax);\n    graphics.clip();\n    graphics.endPath();\n  }\n  setFillAndStrokeStyleToContext(graphics, paintType, color) {\n    const context = graphics.ctx,\n      current = graphics.current;\n    switch (paintType) {\n      case PaintType.COLORED:\n        const {\n          fillStyle,\n          strokeStyle\n        } = this.ctx;\n        context.fillStyle = current.fillColor = fillStyle;\n        context.strokeStyle = current.strokeColor = strokeStyle;\n        break;\n      case PaintType.UNCOLORED:\n        context.fillStyle = context.strokeStyle = color;\n        current.fillColor = current.strokeColor = color;\n        break;\n      default:\n        throw new FormatError(`Unsupported paint type: ${paintType}`);\n    }\n  }\n  isModifyingCurrentTransform() {\n    return false;\n  }\n  getPattern(ctx, owner, inverse, pathType) {\n    let matrix = inverse;\n    if (pathType !== PathType.SHADING) {\n      matrix = Util.transform(matrix, owner.baseTransform);\n      if (this.matrix) {\n        matrix = Util.transform(matrix, this.matrix);\n      }\n    }\n    const temporaryPatternCanvas = this.createPatternCanvas(owner);\n    let domMatrix = new DOMMatrix(matrix);\n    domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n    domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);\n    const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, \"repeat\");\n    pattern.setTransform(domMatrix);\n    return pattern;\n  }\n}\n\n;// ./src/shared/image_utils.js\n\nfunction convertToRGBA(params) {\n  switch (params.kind) {\n    case ImageKind.GRAYSCALE_1BPP:\n      return convertBlackAndWhiteToRGBA(params);\n    case ImageKind.RGB_24BPP:\n      return convertRGBToRGBA(params);\n  }\n  return null;\n}\nfunction convertBlackAndWhiteToRGBA({\n  src,\n  srcPos = 0,\n  dest,\n  width,\n  height,\n  nonBlackColor = 0xffffffff,\n  inverseDecode = false\n}) {\n  const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n  const [zeroMapping, oneMapping] = inverseDecode ? [nonBlackColor, black] : [black, nonBlackColor];\n  const widthInSource = width >> 3;\n  const widthRemainder = width & 7;\n  const srcLength = src.length;\n  dest = new Uint32Array(dest.buffer);\n  let destPos = 0;\n  for (let i = 0; i < height; i++) {\n    for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {\n      const elem = srcPos < srcLength ? src[srcPos] : 255;\n      dest[destPos++] = elem & 0b10000000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b1000000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b100000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b10000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b1000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b100 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b10 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b1 ? oneMapping : zeroMapping;\n    }\n    if (widthRemainder === 0) {\n      continue;\n    }\n    const elem = srcPos < srcLength ? src[srcPos++] : 255;\n    for (let j = 0; j < widthRemainder; j++) {\n      dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;\n    }\n  }\n  return {\n    srcPos,\n    destPos\n  };\n}\nfunction convertRGBToRGBA({\n  src,\n  srcPos = 0,\n  dest,\n  destPos = 0,\n  width,\n  height\n}) {\n  let i = 0;\n  const len = width * height * 3;\n  const len32 = len >> 2;\n  const src32 = new Uint32Array(src.buffer, srcPos, len32);\n  if (FeatureTest.isLittleEndian) {\n    for (; i < len32 - 2; i += 3, destPos += 4) {\n      const s1 = src32[i];\n      const s2 = src32[i + 1];\n      const s3 = src32[i + 2];\n      dest[destPos] = s1 | 0xff000000;\n      dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 0xff000000;\n      dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 0xff000000;\n      dest[destPos + 3] = s3 >>> 8 | 0xff000000;\n    }\n    for (let j = i * 4, jj = srcPos + len; j < jj; j += 3) {\n      dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 0xff000000;\n    }\n  } else {\n    for (; i < len32 - 2; i += 3, destPos += 4) {\n      const s1 = src32[i];\n      const s2 = src32[i + 1];\n      const s3 = src32[i + 2];\n      dest[destPos] = s1 | 0xff;\n      dest[destPos + 1] = s1 << 24 | s2 >>> 8 | 0xff;\n      dest[destPos + 2] = s2 << 16 | s3 >>> 16 | 0xff;\n      dest[destPos + 3] = s3 << 8 | 0xff;\n    }\n    for (let j = i * 4, jj = srcPos + len; j < jj; j += 3) {\n      dest[destPos++] = src[j] << 24 | src[j + 1] << 16 | src[j + 2] << 8 | 0xff;\n    }\n  }\n  return {\n    srcPos: srcPos + len,\n    destPos\n  };\n}\nfunction grayToRGBA(src, dest) {\n  if (FeatureTest.isLittleEndian) {\n    for (let i = 0, ii = src.length; i < ii; i++) {\n      dest[i] = src[i] * 0x10101 | 0xff000000;\n    }\n  } else {\n    for (let i = 0, ii = src.length; i < ii; i++) {\n      dest[i] = src[i] * 0x1010100 | 0x000000ff;\n    }\n  }\n}\n\n;// ./src/display/canvas.js\n\n\n\n\n\nconst MIN_FONT_SIZE = 16;\nconst MAX_FONT_SIZE = 100;\nconst EXECUTION_TIME = 15;\nconst EXECUTION_STEPS = 10;\nconst FULL_CHUNK_HEIGHT = 16;\nconst SCALE_MATRIX = new DOMMatrix();\nconst XY = new Float32Array(2);\nconst MIN_MAX_INIT = new Float32Array([Infinity, Infinity, -Infinity, -Infinity]);\nfunction mirrorContextOperations(ctx, destCtx) {\n  if (ctx._removeMirroring) {\n    throw new Error(\"Context is already forwarding operations.\");\n  }\n  ctx.__originalSave = ctx.save;\n  ctx.__originalRestore = ctx.restore;\n  ctx.__originalRotate = ctx.rotate;\n  ctx.__originalScale = ctx.scale;\n  ctx.__originalTranslate = ctx.translate;\n  ctx.__originalTransform = ctx.transform;\n  ctx.__originalSetTransform = ctx.setTransform;\n  ctx.__originalResetTransform = ctx.resetTransform;\n  ctx.__originalClip = ctx.clip;\n  ctx.__originalMoveTo = ctx.moveTo;\n  ctx.__originalLineTo = ctx.lineTo;\n  ctx.__originalBezierCurveTo = ctx.bezierCurveTo;\n  ctx.__originalRect = ctx.rect;\n  ctx.__originalClosePath = ctx.closePath;\n  ctx.__originalBeginPath = ctx.beginPath;\n  ctx._removeMirroring = () => {\n    ctx.save = ctx.__originalSave;\n    ctx.restore = ctx.__originalRestore;\n    ctx.rotate = ctx.__originalRotate;\n    ctx.scale = ctx.__originalScale;\n    ctx.translate = ctx.__originalTranslate;\n    ctx.transform = ctx.__originalTransform;\n    ctx.setTransform = ctx.__originalSetTransform;\n    ctx.resetTransform = ctx.__originalResetTransform;\n    ctx.clip = ctx.__originalClip;\n    ctx.moveTo = ctx.__originalMoveTo;\n    ctx.lineTo = ctx.__originalLineTo;\n    ctx.bezierCurveTo = ctx.__originalBezierCurveTo;\n    ctx.rect = ctx.__originalRect;\n    ctx.closePath = ctx.__originalClosePath;\n    ctx.beginPath = ctx.__originalBeginPath;\n    delete ctx._removeMirroring;\n  };\n  ctx.save = function () {\n    destCtx.save();\n    this.__originalSave();\n  };\n  ctx.restore = function () {\n    destCtx.restore();\n    this.__originalRestore();\n  };\n  ctx.translate = function (x, y) {\n    destCtx.translate(x, y);\n    this.__originalTranslate(x, y);\n  };\n  ctx.scale = function (x, y) {\n    destCtx.scale(x, y);\n    this.__originalScale(x, y);\n  };\n  ctx.transform = function (a, b, c, d, e, f) {\n    destCtx.transform(a, b, c, d, e, f);\n    this.__originalTransform(a, b, c, d, e, f);\n  };\n  ctx.setTransform = function (a, b, c, d, e, f) {\n    destCtx.setTransform(a, b, c, d, e, f);\n    this.__originalSetTransform(a, b, c, d, e, f);\n  };\n  ctx.resetTransform = function () {\n    destCtx.resetTransform();\n    this.__originalResetTransform();\n  };\n  ctx.rotate = function (angle) {\n    destCtx.rotate(angle);\n    this.__originalRotate(angle);\n  };\n  ctx.clip = function (rule) {\n    destCtx.clip(rule);\n    this.__originalClip(rule);\n  };\n  ctx.moveTo = function (x, y) {\n    destCtx.moveTo(x, y);\n    this.__originalMoveTo(x, y);\n  };\n  ctx.lineTo = function (x, y) {\n    destCtx.lineTo(x, y);\n    this.__originalLineTo(x, y);\n  };\n  ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {\n    destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n    this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n  };\n  ctx.rect = function (x, y, width, height) {\n    destCtx.rect(x, y, width, height);\n    this.__originalRect(x, y, width, height);\n  };\n  ctx.closePath = function () {\n    destCtx.closePath();\n    this.__originalClosePath();\n  };\n  ctx.beginPath = function () {\n    destCtx.beginPath();\n    this.__originalBeginPath();\n  };\n}\nclass CachedCanvases {\n  constructor(canvasFactory) {\n    this.canvasFactory = canvasFactory;\n    this.cache = Object.create(null);\n  }\n  getCanvas(id, width, height) {\n    let canvasEntry;\n    if (this.cache[id] !== undefined) {\n      canvasEntry = this.cache[id];\n      this.canvasFactory.reset(canvasEntry, width, height);\n    } else {\n      canvasEntry = this.canvasFactory.create(width, height);\n      this.cache[id] = canvasEntry;\n    }\n    return canvasEntry;\n  }\n  delete(id) {\n    delete this.cache[id];\n  }\n  clear() {\n    for (const id in this.cache) {\n      const canvasEntry = this.cache[id];\n      this.canvasFactory.destroy(canvasEntry);\n      delete this.cache[id];\n    }\n  }\n}\nfunction drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {\n  const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);\n  if (b === 0 && c === 0) {\n    const tlX = destX * a + tx;\n    const rTlX = Math.round(tlX);\n    const tlY = destY * d + ty;\n    const rTlY = Math.round(tlY);\n    const brX = (destX + destW) * a + tx;\n    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n    const brY = (destY + destH) * d + ty;\n    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n    ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);\n    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);\n    ctx.setTransform(a, b, c, d, tx, ty);\n    return [rWidth, rHeight];\n  }\n  if (a === 0 && d === 0) {\n    const tlX = destY * c + tx;\n    const rTlX = Math.round(tlX);\n    const tlY = destX * b + ty;\n    const rTlY = Math.round(tlY);\n    const brX = (destY + destH) * c + tx;\n    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n    const brY = (destX + destW) * b + ty;\n    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n    ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);\n    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);\n    ctx.setTransform(a, b, c, d, tx, ty);\n    return [rHeight, rWidth];\n  }\n  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);\n  const scaleX = Math.hypot(a, b);\n  const scaleY = Math.hypot(c, d);\n  return [scaleX * destW, scaleY * destH];\n}\nclass CanvasExtraState {\n  alphaIsShape = false;\n  fontSize = 0;\n  fontSizeScale = 1;\n  textMatrix = null;\n  textMatrixScale = 1;\n  fontMatrix = FONT_IDENTITY_MATRIX;\n  leading = 0;\n  x = 0;\n  y = 0;\n  lineX = 0;\n  lineY = 0;\n  charSpacing = 0;\n  wordSpacing = 0;\n  textHScale = 1;\n  textRenderingMode = TextRenderingMode.FILL;\n  textRise = 0;\n  fillColor = \"#000000\";\n  strokeColor = \"#000000\";\n  patternFill = false;\n  patternStroke = false;\n  fillAlpha = 1;\n  strokeAlpha = 1;\n  lineWidth = 1;\n  activeSMask = null;\n  transferMaps = \"none\";\n  constructor(width, height, preInit) {\n    preInit?.(this);\n    this.clipBox = new Float32Array([0, 0, width, height]);\n    this.minMax = MIN_MAX_INIT.slice();\n  }\n  clone() {\n    const clone = Object.create(this);\n    clone.clipBox = this.clipBox.slice();\n    clone.minMax = this.minMax.slice();\n    return clone;\n  }\n  getPathBoundingBox(pathType = PathType.FILL, transform = null) {\n    const box = this.minMax.slice();\n    if (pathType === PathType.STROKE) {\n      if (!transform) {\n        unreachable(\"Stroke bounding box must include transform.\");\n      }\n      Util.singularValueDecompose2dScale(transform, XY);\n      const xStrokePad = XY[0] * this.lineWidth / 2;\n      const yStrokePad = XY[1] * this.lineWidth / 2;\n      box[0] -= xStrokePad;\n      box[1] -= yStrokePad;\n      box[2] += xStrokePad;\n      box[3] += yStrokePad;\n    }\n    return box;\n  }\n  updateClipFromPath() {\n    const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());\n    this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);\n  }\n  isEmptyClip() {\n    return this.minMax[0] === Infinity;\n  }\n  startNewPathAndClipBox(box) {\n    this.clipBox.set(box, 0);\n    this.minMax.set(MIN_MAX_INIT, 0);\n  }\n  getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {\n    return Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));\n  }\n}\nfunction putBinaryImageData(ctx, imgData) {\n  if (imgData instanceof ImageData) {\n    ctx.putImageData(imgData, 0, 0);\n    return;\n  }\n  const height = imgData.height,\n    width = imgData.width;\n  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n  let srcPos = 0,\n    destPos;\n  const src = imgData.data;\n  const dest = chunkImgData.data;\n  let i, j, thisChunkHeight, elemsInThisChunk;\n  if (imgData.kind === util_ImageKind.GRAYSCALE_1BPP) {\n    const srcLength = src.byteLength;\n    const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n    const dest32DataLength = dest32.length;\n    const fullSrcDiff = width + 7 >> 3;\n    const white = 0xffffffff;\n    const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n    for (i = 0; i < totalChunks; i++) {\n      thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n      destPos = 0;\n      for (j = 0; j < thisChunkHeight; j++) {\n        const srcDiff = srcLength - srcPos;\n        let k = 0;\n        const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n        const kEndUnrolled = kEnd & ~7;\n        let mask = 0;\n        let srcByte = 0;\n        for (; k < kEndUnrolled; k += 8) {\n          srcByte = src[srcPos++];\n          dest32[destPos++] = srcByte & 128 ? white : black;\n          dest32[destPos++] = srcByte & 64 ? white : black;\n          dest32[destPos++] = srcByte & 32 ? white : black;\n          dest32[destPos++] = srcByte & 16 ? white : black;\n          dest32[destPos++] = srcByte & 8 ? white : black;\n          dest32[destPos++] = srcByte & 4 ? white : black;\n          dest32[destPos++] = srcByte & 2 ? white : black;\n          dest32[destPos++] = srcByte & 1 ? white : black;\n        }\n        for (; k < kEnd; k++) {\n          if (mask === 0) {\n            srcByte = src[srcPos++];\n            mask = 128;\n          }\n          dest32[destPos++] = srcByte & mask ? white : black;\n          mask >>= 1;\n        }\n      }\n      while (destPos < dest32DataLength) {\n        dest32[destPos++] = 0;\n      }\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n  } else if (imgData.kind === util_ImageKind.RGBA_32BPP) {\n    j = 0;\n    elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n    for (i = 0; i < fullChunks; i++) {\n      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n      srcPos += elemsInThisChunk;\n      ctx.putImageData(chunkImgData, 0, j);\n      j += FULL_CHUNK_HEIGHT;\n    }\n    if (i < totalChunks) {\n      elemsInThisChunk = width * partialChunkHeight * 4;\n      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n      ctx.putImageData(chunkImgData, 0, j);\n    }\n  } else if (imgData.kind === util_ImageKind.RGB_24BPP) {\n    thisChunkHeight = FULL_CHUNK_HEIGHT;\n    elemsInThisChunk = width * thisChunkHeight;\n    for (i = 0; i < totalChunks; i++) {\n      if (i >= fullChunks) {\n        thisChunkHeight = partialChunkHeight;\n        elemsInThisChunk = width * thisChunkHeight;\n      }\n      destPos = 0;\n      for (j = elemsInThisChunk; j--;) {\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = 255;\n      }\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n  } else {\n    throw new Error(`bad image kind: ${imgData.kind}`);\n  }\n}\nfunction putBinaryImageMask(ctx, imgData) {\n  if (imgData.bitmap) {\n    ctx.drawImage(imgData.bitmap, 0, 0);\n    return;\n  }\n  const height = imgData.height,\n    width = imgData.width;\n  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n  let srcPos = 0;\n  const src = imgData.data;\n  const dest = chunkImgData.data;\n  for (let i = 0; i < totalChunks; i++) {\n    const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n    ({\n      srcPos\n    } = convertBlackAndWhiteToRGBA({\n      src,\n      srcPos,\n      dest,\n      width,\n      height: thisChunkHeight,\n      nonBlackColor: 0\n    }));\n    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n  }\n}\nfunction copyCtxState(sourceCtx, destCtx) {\n  const properties = [\"strokeStyle\", \"fillStyle\", \"fillRule\", \"globalAlpha\", \"lineWidth\", \"lineCap\", \"lineJoin\", \"miterLimit\", \"globalCompositeOperation\", \"font\", \"filter\"];\n  for (const property of properties) {\n    if (sourceCtx[property] !== undefined) {\n      destCtx[property] = sourceCtx[property];\n    }\n  }\n  if (sourceCtx.setLineDash !== undefined) {\n    destCtx.setLineDash(sourceCtx.getLineDash());\n    destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n  }\n}\nfunction resetCtxToDefault(ctx) {\n  ctx.strokeStyle = ctx.fillStyle = \"#000000\";\n  ctx.fillRule = \"nonzero\";\n  ctx.globalAlpha = 1;\n  ctx.lineWidth = 1;\n  ctx.lineCap = \"butt\";\n  ctx.lineJoin = \"miter\";\n  ctx.miterLimit = 10;\n  ctx.globalCompositeOperation = \"source-over\";\n  ctx.font = \"10px sans-serif\";\n  if (ctx.setLineDash !== undefined) {\n    ctx.setLineDash([]);\n    ctx.lineDashOffset = 0;\n  }\n  const {\n    filter\n  } = ctx;\n  if (filter !== \"none\" && filter !== \"\") {\n    ctx.filter = \"none\";\n  }\n}\nfunction getImageSmoothingEnabled(transform, interpolate) {\n  if (interpolate) {\n    return true;\n  }\n  Util.singularValueDecompose2dScale(transform, XY);\n  const actualScale = Math.fround(OutputScale.pixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  return XY[0] <= actualScale && XY[1] <= actualScale;\n}\nconst LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\nconst LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\nconst NORMAL_CLIP = {};\nconst EO_CLIP = {};\nclass CanvasGraphics {\n  constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, {\n    optionalContentConfig,\n    markedContentStack = null\n  }, annotationCanvasMap, pageColors, dependencyTracker) {\n    this.ctx = canvasCtx;\n    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n    this.stateStack = [];\n    this.pendingClip = null;\n    this.pendingEOFill = false;\n    this.res = null;\n    this.xobjs = null;\n    this.commonObjs = commonObjs;\n    this.objs = objs;\n    this.canvasFactory = canvasFactory;\n    this.filterFactory = filterFactory;\n    this.groupStack = [];\n    this.baseTransform = null;\n    this.baseTransformStack = [];\n    this.groupLevel = 0;\n    this.smaskStack = [];\n    this.smaskCounter = 0;\n    this.tempSMask = null;\n    this.suspendedCtx = null;\n    this.contentVisible = true;\n    this.markedContentStack = markedContentStack || [];\n    this.optionalContentConfig = optionalContentConfig;\n    this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n    this.cachedPatterns = new Map();\n    this.annotationCanvasMap = annotationCanvasMap;\n    this.viewportScale = 1;\n    this.outputScaleX = 1;\n    this.outputScaleY = 1;\n    this.pageColors = pageColors;\n    this._cachedScaleForStroking = [-1, 0];\n    this._cachedGetSinglePixelWidth = null;\n    this._cachedBitmapsMap = new Map();\n    this.dependencyTracker = dependencyTracker ?? null;\n  }\n  getObject(opIdx, data, fallback = null) {\n    if (typeof data === \"string\") {\n      this.dependencyTracker?.recordNamedDependency(opIdx, data);\n      return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data);\n    }\n    return fallback;\n  }\n  beginDrawing({\n    transform,\n    viewport,\n    transparency = false,\n    background = null\n  }) {\n    const width = this.ctx.canvas.width;\n    const height = this.ctx.canvas.height;\n    const savedFillStyle = this.ctx.fillStyle;\n    this.ctx.fillStyle = background || \"#ffffff\";\n    this.ctx.fillRect(0, 0, width, height);\n    this.ctx.fillStyle = savedFillStyle;\n    if (transparency) {\n      const transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height);\n      this.compositeCtx = this.ctx;\n      this.transparentCanvas = transparentCanvas.canvas;\n      this.ctx = transparentCanvas.context;\n      this.ctx.save();\n      this.ctx.transform(...getCurrentTransform(this.compositeCtx));\n    }\n    this.ctx.save();\n    resetCtxToDefault(this.ctx);\n    if (transform) {\n      this.ctx.transform(...transform);\n      this.outputScaleX = transform[0];\n      this.outputScaleY = transform[0];\n    }\n    this.ctx.transform(...viewport.transform);\n    this.viewportScale = viewport.scale;\n    this.baseTransform = getCurrentTransform(this.ctx);\n  }\n  executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper, filteredOperationIndexes) {\n    const argsArray = operatorList.argsArray;\n    const fnArray = operatorList.fnArray;\n    let i = executionStartIdx || 0;\n    const argsArrayLen = argsArray.length;\n    if (argsArrayLen === i) {\n      return i;\n    }\n    const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n    const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n    let steps = 0;\n    const commonObjs = this.commonObjs;\n    const objs = this.objs;\n    let fnId, fnArgs;\n    while (true) {\n      if (stepper !== undefined && i === stepper.nextBreakPoint) {\n        stepper.breakIt(i, continueCallback);\n        return i;\n      }\n      if (!filteredOperationIndexes || filteredOperationIndexes.has(i)) {\n        fnId = fnArray[i];\n        fnArgs = argsArray[i] ?? null;\n        if (fnId !== OPS.dependency) {\n          if (fnArgs === null) {\n            this[fnId](i);\n          } else {\n            this[fnId](i, ...fnArgs);\n          }\n        } else {\n          for (const depObjId of fnArgs) {\n            this.dependencyTracker?.recordNamedData(depObjId, i);\n            const objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n            if (!objsPool.has(depObjId)) {\n              objsPool.get(depObjId, continueCallback);\n              return i;\n            }\n          }\n        }\n      }\n      i++;\n      if (i === argsArrayLen) {\n        return i;\n      }\n      if (chunkOperations && ++steps > EXECUTION_STEPS) {\n        if (Date.now() > endTime) {\n          continueCallback();\n          return i;\n        }\n        steps = 0;\n      }\n    }\n  }\n  #restoreInitialState() {\n    while (this.stateStack.length || this.inSMaskMode) {\n      this.restore();\n    }\n    this.current.activeSMask = null;\n    this.ctx.restore();\n    if (this.transparentCanvas) {\n      this.ctx = this.compositeCtx;\n      this.ctx.save();\n      this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n      this.ctx.drawImage(this.transparentCanvas, 0, 0);\n      this.ctx.restore();\n      this.transparentCanvas = null;\n    }\n  }\n  endDrawing() {\n    this.#restoreInitialState();\n    this.cachedCanvases.clear();\n    this.cachedPatterns.clear();\n    for (const cache of this._cachedBitmapsMap.values()) {\n      for (const canvas of cache.values()) {\n        if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement) {\n          canvas.width = canvas.height = 0;\n        }\n      }\n      cache.clear();\n    }\n    this._cachedBitmapsMap.clear();\n    this.#drawFilter();\n  }\n  #drawFilter() {\n    if (this.pageColors) {\n      const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);\n      if (hcmFilterId !== \"none\") {\n        const savedFilter = this.ctx.filter;\n        this.ctx.filter = hcmFilterId;\n        this.ctx.drawImage(this.ctx.canvas, 0, 0);\n        this.ctx.filter = savedFilter;\n      }\n    }\n  }\n  _scaleImage(img, inverseTransform) {\n    const width = img.width ?? img.displayWidth;\n    const height = img.height ?? img.displayHeight;\n    let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);\n    let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);\n    let paintWidth = width,\n      paintHeight = height;\n    let tmpCanvasId = \"prescale1\";\n    let tmpCanvas, tmpCtx;\n    while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {\n      let newWidth = paintWidth,\n        newHeight = paintHeight;\n      if (widthScale > 2 && paintWidth > 1) {\n        newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);\n        widthScale /= paintWidth / newWidth;\n      }\n      if (heightScale > 2 && paintHeight > 1) {\n        newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;\n        heightScale /= paintHeight / newHeight;\n      }\n      tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n      tmpCtx = tmpCanvas.context;\n      tmpCtx.clearRect(0, 0, newWidth, newHeight);\n      tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n      img = tmpCanvas.canvas;\n      paintWidth = newWidth;\n      paintHeight = newHeight;\n      tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n    }\n    return {\n      img,\n      paintWidth,\n      paintHeight\n    };\n  }\n  _createMaskCanvas(opIdx, img) {\n    const ctx = this.ctx;\n    const {\n      width,\n      height\n    } = img;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    const currentTransform = getCurrentTransform(ctx);\n    let cache, cacheKey, scaled, maskCanvas;\n    if ((img.bitmap || img.data) && img.count > 1) {\n      const mainKey = img.bitmap || img.data.buffer;\n      cacheKey = JSON.stringify(isPatternFill ? currentTransform : [currentTransform.slice(0, 4), fillColor]);\n      cache = this._cachedBitmapsMap.get(mainKey);\n      if (!cache) {\n        cache = new Map();\n        this._cachedBitmapsMap.set(mainKey, cache);\n      }\n      const cachedImage = cache.get(cacheKey);\n      if (cachedImage && !isPatternFill) {\n        const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);\n        const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);\n        this.dependencyTracker?.recordDependencies(opIdx, Dependencies.transformAndFill);\n        return {\n          canvas: cachedImage,\n          offsetX,\n          offsetY\n        };\n      }\n      scaled = cachedImage;\n    }\n    if (!scaled) {\n      maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n      putBinaryImageMask(maskCanvas.context, img);\n    }\n    let maskToCanvas = Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);\n    maskToCanvas = Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);\n    const minMax = MIN_MAX_INIT.slice();\n    Util.axialAlignedBoundingBox([0, 0, width, height], maskToCanvas, minMax);\n    const [minX, minY, maxX, maxY] = minMax;\n    const drawnWidth = Math.round(maxX - minX) || 1;\n    const drawnHeight = Math.round(maxY - minY) || 1;\n    const fillCanvas = this.cachedCanvases.getCanvas(\"fillCanvas\", drawnWidth, drawnHeight);\n    const fillCtx = fillCanvas.context;\n    const offsetX = minX;\n    const offsetY = minY;\n    fillCtx.translate(-offsetX, -offsetY);\n    fillCtx.transform(...maskToCanvas);\n    if (!scaled) {\n      scaled = this._scaleImage(maskCanvas.canvas, getCurrentTransformInverse(fillCtx));\n      scaled = scaled.img;\n      if (cache && isPatternFill) {\n        cache.set(cacheKey, scaled);\n      }\n    }\n    fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(fillCtx), img.interpolate);\n    drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);\n    fillCtx.globalCompositeOperation = \"source-in\";\n    const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);\n    fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, PathType.FILL) : fillColor;\n    fillCtx.fillRect(0, 0, width, height);\n    if (cache && !isPatternFill) {\n      this.cachedCanvases.delete(\"fillCanvas\");\n      cache.set(cacheKey, fillCanvas.canvas);\n    }\n    this.dependencyTracker?.recordDependencies(opIdx, Dependencies.transformAndFill);\n    return {\n      canvas: fillCanvas.canvas,\n      offsetX: Math.round(offsetX),\n      offsetY: Math.round(offsetY)\n    };\n  }\n  setLineWidth(opIdx, width) {\n    this.dependencyTracker?.recordSimpleData(\"lineWidth\", opIdx);\n    if (width !== this.current.lineWidth) {\n      this._cachedScaleForStroking[0] = -1;\n    }\n    this.current.lineWidth = width;\n    this.ctx.lineWidth = width;\n  }\n  setLineCap(opIdx, style) {\n    this.dependencyTracker?.recordSimpleData(\"lineCap\", opIdx);\n    this.ctx.lineCap = LINE_CAP_STYLES[style];\n  }\n  setLineJoin(opIdx, style) {\n    this.dependencyTracker?.recordSimpleData(\"lineJoin\", opIdx);\n    this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n  }\n  setMiterLimit(opIdx, limit) {\n    this.dependencyTracker?.recordSimpleData(\"miterLimit\", opIdx);\n    this.ctx.miterLimit = limit;\n  }\n  setDash(opIdx, dashArray, dashPhase) {\n    this.dependencyTracker?.recordSimpleData(\"dash\", opIdx);\n    const ctx = this.ctx;\n    if (ctx.setLineDash !== undefined) {\n      ctx.setLineDash(dashArray);\n      ctx.lineDashOffset = dashPhase;\n    }\n  }\n  setRenderingIntent(opIdx, intent) {}\n  setFlatness(opIdx, flatness) {}\n  setGState(opIdx, states) {\n    for (const [key, value] of states) {\n      switch (key) {\n        case \"LW\":\n          this.setLineWidth(opIdx, value);\n          break;\n        case \"LC\":\n          this.setLineCap(opIdx, value);\n          break;\n        case \"LJ\":\n          this.setLineJoin(opIdx, value);\n          break;\n        case \"ML\":\n          this.setMiterLimit(opIdx, value);\n          break;\n        case \"D\":\n          this.setDash(opIdx, value[0], value[1]);\n          break;\n        case \"RI\":\n          this.setRenderingIntent(opIdx, value);\n          break;\n        case \"FL\":\n          this.setFlatness(opIdx, value);\n          break;\n        case \"Font\":\n          this.setFont(opIdx, value[0], value[1]);\n          break;\n        case \"CA\":\n          this.dependencyTracker?.recordSimpleData(\"strokeAlpha\", opIdx);\n          this.current.strokeAlpha = value;\n          break;\n        case \"ca\":\n          this.dependencyTracker?.recordSimpleData(\"fillAlpha\", opIdx);\n          this.ctx.globalAlpha = this.current.fillAlpha = value;\n          break;\n        case \"BM\":\n          this.dependencyTracker?.recordSimpleData(\"globalCompositeOperation\", opIdx);\n          this.ctx.globalCompositeOperation = value;\n          break;\n        case \"SMask\":\n          this.dependencyTracker?.recordSimpleData(\"SMask\", opIdx);\n          this.current.activeSMask = value ? this.tempSMask : null;\n          this.tempSMask = null;\n          this.checkSMaskState();\n          break;\n        case \"TR\":\n          this.dependencyTracker?.recordSimpleData(\"filter\", opIdx);\n          this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);\n          break;\n      }\n    }\n  }\n  get inSMaskMode() {\n    return !!this.suspendedCtx;\n  }\n  checkSMaskState() {\n    const inSMaskMode = this.inSMaskMode;\n    if (this.current.activeSMask && !inSMaskMode) {\n      this.beginSMaskMode();\n    } else if (!this.current.activeSMask && inSMaskMode) {\n      this.endSMaskMode();\n    }\n  }\n  beginSMaskMode(opIdx) {\n    if (this.inSMaskMode) {\n      throw new Error(\"beginSMaskMode called while already in smask mode\");\n    }\n    const drawnWidth = this.ctx.canvas.width;\n    const drawnHeight = this.ctx.canvas.height;\n    const cacheId = \"smaskGroupAt\" + this.groupLevel;\n    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n    this.suspendedCtx = this.ctx;\n    const ctx = this.ctx = scratchCanvas.context;\n    ctx.setTransform(this.suspendedCtx.getTransform());\n    copyCtxState(this.suspendedCtx, ctx);\n    mirrorContextOperations(ctx, this.suspendedCtx);\n    this.setGState(opIdx, [[\"BM\", \"source-over\"]]);\n  }\n  endSMaskMode() {\n    if (!this.inSMaskMode) {\n      throw new Error(\"endSMaskMode called while not in smask mode\");\n    }\n    this.ctx._removeMirroring();\n    copyCtxState(this.ctx, this.suspendedCtx);\n    this.ctx = this.suspendedCtx;\n    this.suspendedCtx = null;\n  }\n  compose(dirtyBox) {\n    if (!this.current.activeSMask) {\n      return;\n    }\n    if (!dirtyBox) {\n      dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];\n    } else {\n      dirtyBox[0] = Math.floor(dirtyBox[0]);\n      dirtyBox[1] = Math.floor(dirtyBox[1]);\n      dirtyBox[2] = Math.ceil(dirtyBox[2]);\n      dirtyBox[3] = Math.ceil(dirtyBox[3]);\n    }\n    const smask = this.current.activeSMask;\n    const suspendedCtx = this.suspendedCtx;\n    this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);\n    this.ctx.save();\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n    this.ctx.restore();\n  }\n  composeSMask(ctx, smask, layerCtx, layerBox) {\n    const layerOffsetX = layerBox[0];\n    const layerOffsetY = layerBox[1];\n    const layerWidth = layerBox[2] - layerOffsetX;\n    const layerHeight = layerBox[3] - layerOffsetY;\n    if (layerWidth === 0 || layerHeight === 0) {\n      return;\n    }\n    this.genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);\n    ctx.save();\n    ctx.globalAlpha = 1;\n    ctx.globalCompositeOperation = \"source-over\";\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.drawImage(layerCtx.canvas, 0, 0);\n    ctx.restore();\n  }\n  genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {\n    let maskCanvas = maskCtx.canvas;\n    let maskX = layerOffsetX - maskOffsetX;\n    let maskY = layerOffsetY - maskOffsetY;\n    if (backdrop) {\n      if (maskX < 0 || maskY < 0 || maskX + width > maskCanvas.width || maskY + height > maskCanvas.height) {\n        const canvas = this.cachedCanvases.getCanvas(\"maskExtension\", width, height);\n        const ctx = canvas.context;\n        ctx.drawImage(maskCanvas, -maskX, -maskY);\n        ctx.globalCompositeOperation = \"destination-atop\";\n        ctx.fillStyle = backdrop;\n        ctx.fillRect(0, 0, width, height);\n        ctx.globalCompositeOperation = \"source-over\";\n        maskCanvas = canvas.canvas;\n        maskX = maskY = 0;\n      } else {\n        maskCtx.save();\n        maskCtx.globalAlpha = 1;\n        maskCtx.setTransform(1, 0, 0, 1, 0, 0);\n        const clip = new Path2D();\n        clip.rect(maskX, maskY, width, height);\n        maskCtx.clip(clip);\n        maskCtx.globalCompositeOperation = \"destination-atop\";\n        maskCtx.fillStyle = backdrop;\n        maskCtx.fillRect(maskX, maskY, width, height);\n        maskCtx.restore();\n      }\n    }\n    layerCtx.save();\n    layerCtx.globalAlpha = 1;\n    layerCtx.setTransform(1, 0, 0, 1, 0, 0);\n    if (subtype === \"Alpha\" && transferMap) {\n      layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);\n    } else if (subtype === \"Luminosity\") {\n      layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);\n    }\n    const clip = new Path2D();\n    clip.rect(layerOffsetX, layerOffsetY, width, height);\n    layerCtx.clip(clip);\n    layerCtx.globalCompositeOperation = \"destination-in\";\n    layerCtx.drawImage(maskCanvas, maskX, maskY, width, height, layerOffsetX, layerOffsetY, width, height);\n    layerCtx.restore();\n  }\n  save(opIdx) {\n    if (this.inSMaskMode) {\n      copyCtxState(this.ctx, this.suspendedCtx);\n    }\n    this.ctx.save();\n    const old = this.current;\n    this.stateStack.push(old);\n    this.current = old.clone();\n    this.dependencyTracker?.save(opIdx);\n  }\n  restore(opIdx) {\n    this.dependencyTracker?.restore(opIdx);\n    if (this.stateStack.length === 0) {\n      if (this.inSMaskMode) {\n        this.endSMaskMode();\n      }\n      return;\n    }\n    this.current = this.stateStack.pop();\n    this.ctx.restore();\n    if (this.inSMaskMode) {\n      copyCtxState(this.suspendedCtx, this.ctx);\n    }\n    this.checkSMaskState();\n    this.pendingClip = null;\n    this._cachedScaleForStroking[0] = -1;\n    this._cachedGetSinglePixelWidth = null;\n  }\n  transform(opIdx, a, b, c, d, e, f) {\n    this.dependencyTracker?.recordIncrementalData(\"transform\", opIdx);\n    this.ctx.transform(a, b, c, d, e, f);\n    this._cachedScaleForStroking[0] = -1;\n    this._cachedGetSinglePixelWidth = null;\n  }\n  constructPath(opIdx, op, data, minMax) {\n    let [path] = data;\n    if (!minMax) {\n      path ||= data[0] = new Path2D();\n      this[op](opIdx, path);\n      return;\n    }\n    if (this.dependencyTracker !== null) {\n      const outerExtraSize = op === OPS.stroke ? this.current.lineWidth / 2 : 0;\n      this.dependencyTracker.resetBBox(opIdx).recordBBox(opIdx, this.ctx, minMax[0] - outerExtraSize, minMax[2] + outerExtraSize, minMax[1] - outerExtraSize, minMax[3] + outerExtraSize).recordDependencies(opIdx, [\"transform\"]);\n    }\n    if (!(path instanceof Path2D)) {\n      const path2d = data[0] = new Path2D();\n      for (let i = 0, ii = path.length; i < ii;) {\n        switch (path[i++]) {\n          case DrawOPS.moveTo:\n            path2d.moveTo(path[i++], path[i++]);\n            break;\n          case DrawOPS.lineTo:\n            path2d.lineTo(path[i++], path[i++]);\n            break;\n          case DrawOPS.curveTo:\n            path2d.bezierCurveTo(path[i++], path[i++], path[i++], path[i++], path[i++], path[i++]);\n            break;\n          case DrawOPS.closePath:\n            path2d.closePath();\n            break;\n          default:\n            warn(`Unrecognized drawing path operator: ${path[i - 1]}`);\n            break;\n        }\n      }\n      path = path2d;\n    }\n    Util.axialAlignedBoundingBox(minMax, getCurrentTransform(this.ctx), this.current.minMax);\n    this[op](opIdx, path);\n    this._pathStartIdx = opIdx;\n  }\n  closePath(opIdx) {\n    this.ctx.closePath();\n  }\n  stroke(opIdx, path, consumePath = true) {\n    const ctx = this.ctx;\n    const strokeColor = this.current.strokeColor;\n    ctx.globalAlpha = this.current.strokeAlpha;\n    if (this.contentVisible) {\n      if (typeof strokeColor === \"object\" && strokeColor?.getPattern) {\n        const baseTransform = strokeColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;\n        ctx.save();\n        ctx.strokeStyle = strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE);\n        if (baseTransform) {\n          const newPath = new Path2D();\n          newPath.addPath(path, ctx.getTransform().invertSelf().multiplySelf(baseTransform));\n          path = newPath;\n        }\n        this.rescaleAndStroke(path, false);\n        ctx.restore();\n      } else {\n        this.rescaleAndStroke(path, true);\n      }\n    }\n    this.dependencyTracker?.recordDependencies(opIdx, Dependencies.stroke);\n    if (consumePath) {\n      this.consumePath(opIdx, path, this.current.getClippedPathBoundingBox(PathType.STROKE, getCurrentTransform(this.ctx)));\n    }\n    ctx.globalAlpha = this.current.fillAlpha;\n  }\n  closeStroke(opIdx, path) {\n    this.stroke(opIdx, path);\n  }\n  fill(opIdx, path, consumePath = true) {\n    const ctx = this.ctx;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    let needRestore = false;\n    if (isPatternFill) {\n      const baseTransform = fillColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;\n      this.dependencyTracker?.save(opIdx);\n      ctx.save();\n      ctx.fillStyle = fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL);\n      if (baseTransform) {\n        const newPath = new Path2D();\n        newPath.addPath(path, ctx.getTransform().invertSelf().multiplySelf(baseTransform));\n        path = newPath;\n      }\n      needRestore = true;\n    }\n    const intersect = this.current.getClippedPathBoundingBox();\n    if (this.contentVisible && intersect !== null) {\n      if (this.pendingEOFill) {\n        ctx.fill(path, \"evenodd\");\n        this.pendingEOFill = false;\n      } else {\n        ctx.fill(path);\n      }\n    }\n    this.dependencyTracker?.recordDependencies(opIdx, Dependencies.fill);\n    if (needRestore) {\n      ctx.restore();\n      this.dependencyTracker?.restore(opIdx);\n    }\n    if (consumePath) {\n      this.consumePath(opIdx, path, intersect);\n    }\n  }\n  eoFill(opIdx, path) {\n    this.pendingEOFill = true;\n    this.fill(opIdx, path);\n  }\n  fillStroke(opIdx, path) {\n    this.fill(opIdx, path, false);\n    this.stroke(opIdx, path, false);\n    this.consumePath(opIdx, path);\n  }\n  eoFillStroke(opIdx, path) {\n    this.pendingEOFill = true;\n    this.fillStroke(opIdx, path);\n  }\n  closeFillStroke(opIdx, path) {\n    this.fillStroke(opIdx, path);\n  }\n  closeEOFillStroke(opIdx, path) {\n    this.pendingEOFill = true;\n    this.fillStroke(opIdx, path);\n  }\n  endPath(opIdx, path) {\n    this.consumePath(opIdx, path);\n  }\n  rawFillPath(opIdx, path) {\n    this.ctx.fill(path);\n    this.dependencyTracker?.recordDependencies(opIdx, Dependencies.rawFillPath).recordOperation(opIdx);\n  }\n  clip(opIdx) {\n    this.dependencyTracker?.recordFutureForcedDependency(\"clipMode\", opIdx);\n    this.pendingClip = NORMAL_CLIP;\n  }\n  eoClip(opIdx) {\n    this.dependencyTracker?.recordFutureForcedDependency(\"clipMode\", opIdx);\n    this.pendingClip = EO_CLIP;\n  }\n  beginText(opIdx) {\n    this.current.textMatrix = null;\n    this.current.textMatrixScale = 1;\n    this.current.x = this.current.lineX = 0;\n    this.current.y = this.current.lineY = 0;\n    this.dependencyTracker?.recordOpenMarker(opIdx).resetIncrementalData(\"sameLineText\").resetIncrementalData(\"moveText\", opIdx);\n  }\n  endText(opIdx) {\n    const paths = this.pendingTextPaths;\n    const ctx = this.ctx;\n    if (this.dependencyTracker) {\n      const {\n        dependencyTracker\n      } = this;\n      if (paths !== undefined) {\n        dependencyTracker.recordFutureForcedDependency(\"textClip\", dependencyTracker.getOpenMarker()).recordFutureForcedDependency(\"textClip\", opIdx);\n      }\n      dependencyTracker.recordCloseMarker(opIdx);\n    }\n    if (paths !== undefined) {\n      const newPath = new Path2D();\n      const invTransf = ctx.getTransform().invertSelf();\n      for (const {\n        transform,\n        x,\n        y,\n        fontSize,\n        path\n      } of paths) {\n        if (!path) {\n          continue;\n        }\n        newPath.addPath(path, new DOMMatrix(transform).preMultiplySelf(invTransf).translate(x, y).scale(fontSize, -fontSize));\n      }\n      ctx.clip(newPath);\n    }\n    delete this.pendingTextPaths;\n  }\n  setCharSpacing(opIdx, spacing) {\n    this.dependencyTracker?.recordSimpleData(\"charSpacing\", opIdx);\n    this.current.charSpacing = spacing;\n  }\n  setWordSpacing(opIdx, spacing) {\n    this.dependencyTracker?.recordSimpleData(\"wordSpacing\", opIdx);\n    this.current.wordSpacing = spacing;\n  }\n  setHScale(opIdx, scale) {\n    this.dependencyTracker?.recordSimpleData(\"hScale\", opIdx);\n    this.current.textHScale = scale / 100;\n  }\n  setLeading(opIdx, leading) {\n    this.dependencyTracker?.recordSimpleData(\"leading\", opIdx);\n    this.current.leading = -leading;\n  }\n  setFont(opIdx, fontRefName, size) {\n    this.dependencyTracker?.recordSimpleData(\"font\", opIdx).recordNamedDependency(opIdx, fontRefName);\n    const fontObj = this.commonObjs.get(fontRefName);\n    const current = this.current;\n    if (!fontObj) {\n      throw new Error(`Can't find font for ${fontRefName}`);\n    }\n    current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;\n    if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n      warn(\"Invalid font matrix for font \" + fontRefName);\n    }\n    if (size < 0) {\n      size = -size;\n      current.fontDirection = -1;\n    } else {\n      current.fontDirection = 1;\n    }\n    this.current.font = fontObj;\n    this.current.fontSize = size;\n    if (fontObj.isType3Font) {\n      return;\n    }\n    const name = fontObj.loadedName || \"sans-serif\";\n    const typeface = fontObj.systemFontInfo?.css || `\"${name}\", ${fontObj.fallbackName}`;\n    let bold = \"normal\";\n    if (fontObj.black) {\n      bold = \"900\";\n    } else if (fontObj.bold) {\n      bold = \"bold\";\n    }\n    const italic = fontObj.italic ? \"italic\" : \"normal\";\n    let browserFontSize = size;\n    if (size < MIN_FONT_SIZE) {\n      browserFontSize = MIN_FONT_SIZE;\n    } else if (size > MAX_FONT_SIZE) {\n      browserFontSize = MAX_FONT_SIZE;\n    }\n    this.current.fontSizeScale = size / browserFontSize;\n    this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\n  }\n  setTextRenderingMode(opIdx, mode) {\n    this.dependencyTracker?.recordSimpleData(\"textRenderingMode\", opIdx);\n    this.current.textRenderingMode = mode;\n  }\n  setTextRise(opIdx, rise) {\n    this.dependencyTracker?.recordSimpleData(\"textRise\", opIdx);\n    this.current.textRise = rise;\n  }\n  moveText(opIdx, x, y) {\n    this.dependencyTracker?.resetIncrementalData(\"sameLineText\").recordIncrementalData(\"moveText\", opIdx);\n    this.current.x = this.current.lineX += x;\n    this.current.y = this.current.lineY += y;\n  }\n  setLeadingMoveText(opIdx, x, y) {\n    this.setLeading(opIdx, -y);\n    this.moveText(opIdx, x, y);\n  }\n  setTextMatrix(opIdx, matrix) {\n    this.dependencyTracker?.recordSimpleData(\"textMatrix\", opIdx);\n    const {\n      current\n    } = this;\n    current.textMatrix = matrix;\n    current.textMatrixScale = Math.hypot(matrix[0], matrix[1]);\n    current.x = current.lineX = 0;\n    current.y = current.lineY = 0;\n  }\n  nextLine(opIdx) {\n    this.moveText(opIdx, 0, this.current.leading);\n    this.dependencyTracker?.recordIncrementalData(\"moveText\", this.dependencyTracker.getSimpleIndex(\"leading\") ?? opIdx);\n  }\n  #getScaledPath(path, currentTransform, transform) {\n    const newPath = new Path2D();\n    newPath.addPath(path, new DOMMatrix(transform).invertSelf().multiplySelf(currentTransform));\n    return newPath;\n  }\n  paintChar(opIdx, character, x, y, patternFillTransform, patternStrokeTransform) {\n    const ctx = this.ctx;\n    const current = this.current;\n    const font = current.font;\n    const textRenderingMode = current.textRenderingMode;\n    const fontSize = current.fontSize / current.fontSizeScale;\n    const fillStrokeMode = textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n    const isAddToPathSet = !!(textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);\n    const patternFill = current.patternFill && !font.missingFile;\n    const patternStroke = current.patternStroke && !font.missingFile;\n    let path;\n    if ((font.disableFontFace || isAddToPathSet || patternFill || patternStroke) && !font.missingFile) {\n      path = font.getPathGenerator(this.commonObjs, character);\n    }\n    if (path && (font.disableFontFace || patternFill || patternStroke)) {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.scale(fontSize, -fontSize);\n      this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font);\n      let currentTransform;\n      if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n        if (patternFillTransform) {\n          currentTransform = ctx.getTransform();\n          ctx.setTransform(...patternFillTransform);\n          const scaledPath = this.#getScaledPath(path, currentTransform, patternFillTransform);\n          ctx.fill(scaledPath);\n        } else {\n          ctx.fill(path);\n        }\n      }\n      if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n        if (patternStrokeTransform) {\n          currentTransform ||= ctx.getTransform();\n          ctx.setTransform(...patternStrokeTransform);\n          const {\n            a,\n            b,\n            c,\n            d\n          } = currentTransform;\n          const invPatternTransform = Util.inverseTransform(patternStrokeTransform);\n          const transf = Util.transform([a, b, c, d, 0, 0], invPatternTransform);\n          Util.singularValueDecompose2dScale(transf, XY);\n          ctx.lineWidth *= Math.max(XY[0], XY[1]) / fontSize;\n          ctx.stroke(this.#getScaledPath(path, currentTransform, patternStrokeTransform));\n        } else {\n          ctx.lineWidth /= fontSize;\n          ctx.stroke(path);\n        }\n      }\n      ctx.restore();\n    } else {\n      if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n        ctx.fillText(character, x, y);\n        this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y, () => ctx.measureText(character));\n      }\n      if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n        if (this.dependencyTracker) {\n          this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y, () => ctx.measureText(character)).recordDependencies(opIdx, Dependencies.stroke);\n        }\n        ctx.strokeText(character, x, y);\n      }\n    }\n    if (isAddToPathSet) {\n      const paths = this.pendingTextPaths ||= [];\n      paths.push({\n        transform: getCurrentTransform(ctx),\n        x,\n        y,\n        fontSize,\n        path\n      });\n      this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y);\n    }\n  }\n  get isFontSubpixelAAEnabled() {\n    const {\n      context: ctx\n    } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10);\n    ctx.scale(1.5, 1);\n    ctx.fillText(\"I\", 0, 10);\n    const data = ctx.getImageData(0, 0, 10, 10).data;\n    let enabled = false;\n    for (let i = 3; i < data.length; i += 4) {\n      if (data[i] > 0 && data[i] < 255) {\n        enabled = true;\n        break;\n      }\n    }\n    return shadow(this, \"isFontSubpixelAAEnabled\", enabled);\n  }\n  showText(opIdx, glyphs) {\n    if (this.dependencyTracker) {\n      this.dependencyTracker.recordDependencies(opIdx, Dependencies.showText).copyDependenciesFromIncrementalOperation(opIdx, \"sameLineText\").resetBBox(opIdx);\n      if (this.current.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG) {\n        this.dependencyTracker.recordFutureForcedDependency(\"textClip\", opIdx).inheritPendingDependenciesAsFutureForcedDependencies();\n      }\n    }\n    const current = this.current;\n    const font = current.font;\n    if (font.isType3Font) {\n      this.showType3Text(opIdx, glyphs);\n      this.dependencyTracker?.recordOperation(opIdx).recordIncrementalData(\"sameLineText\", opIdx);\n      return undefined;\n    }\n    const fontSize = current.fontSize;\n    if (fontSize === 0) {\n      this.dependencyTracker?.recordOperation(opIdx);\n      return undefined;\n    }\n    const ctx = this.ctx;\n    const fontSizeScale = current.fontSizeScale;\n    const charSpacing = current.charSpacing;\n    const wordSpacing = current.wordSpacing;\n    const fontDirection = current.fontDirection;\n    const textHScale = current.textHScale * fontDirection;\n    const glyphsLength = glyphs.length;\n    const vertical = font.vertical;\n    const spacingDir = vertical ? 1 : -1;\n    const defaultVMetrics = font.defaultVMetrics;\n    const widthAdvanceScale = fontSize * current.fontMatrix[0];\n    const simpleFillText = current.textRenderingMode === TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n    ctx.save();\n    if (current.textMatrix) {\n      ctx.transform(...current.textMatrix);\n    }\n    ctx.translate(current.x, current.y + current.textRise);\n    if (fontDirection > 0) {\n      ctx.scale(textHScale, -1);\n    } else {\n      ctx.scale(textHScale, 1);\n    }\n    let patternFillTransform, patternStrokeTransform;\n    if (current.patternFill) {\n      ctx.save();\n      const pattern = current.fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL);\n      patternFillTransform = getCurrentTransform(ctx);\n      ctx.restore();\n      ctx.fillStyle = pattern;\n    }\n    if (current.patternStroke) {\n      ctx.save();\n      const pattern = current.strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE);\n      patternStrokeTransform = getCurrentTransform(ctx);\n      ctx.restore();\n      ctx.strokeStyle = pattern;\n    }\n    let lineWidth = current.lineWidth;\n    const scale = current.textMatrixScale;\n    if (scale === 0 || lineWidth === 0) {\n      const fillStrokeMode = current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n      if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n        lineWidth = this.getSinglePixelWidth();\n      }\n    } else {\n      lineWidth /= scale;\n    }\n    if (fontSizeScale !== 1.0) {\n      ctx.scale(fontSizeScale, fontSizeScale);\n      lineWidth /= fontSizeScale;\n    }\n    ctx.lineWidth = lineWidth;\n    if (font.isInvalidPDFjsFont) {\n      const chars = [];\n      let width = 0;\n      for (const glyph of glyphs) {\n        chars.push(glyph.unicode);\n        width += glyph.width;\n      }\n      const joinedChars = chars.join(\"\");\n      ctx.fillText(joinedChars, 0, 0);\n      if (this.dependencyTracker !== null) {\n        const measure = ctx.measureText(joinedChars);\n        this.dependencyTracker.recordBBox(opIdx, this.ctx, -measure.actualBoundingBoxLeft, measure.actualBoundingBoxRight, -measure.actualBoundingBoxAscent, measure.actualBoundingBoxDescent).recordOperation(opIdx).recordIncrementalData(\"sameLineText\", opIdx);\n      }\n      current.x += width * widthAdvanceScale * textHScale;\n      ctx.restore();\n      this.compose();\n      return undefined;\n    }\n    let x = 0,\n      i;\n    for (i = 0; i < glyphsLength; ++i) {\n      const glyph = glyphs[i];\n      if (typeof glyph === \"number\") {\n        x += spacingDir * glyph * fontSize / 1000;\n        continue;\n      }\n      let restoreNeeded = false;\n      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n      const character = glyph.fontChar;\n      const accent = glyph.accent;\n      let scaledX, scaledY;\n      let width = glyph.width;\n      if (vertical) {\n        const vmetric = glyph.vmetric || defaultVMetrics;\n        const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\n        const vy = vmetric[2] * widthAdvanceScale;\n        width = vmetric ? -vmetric[0] : width;\n        scaledX = vx / fontSizeScale;\n        scaledY = (x + vy) / fontSizeScale;\n      } else {\n        scaledX = x / fontSizeScale;\n        scaledY = 0;\n      }\n      let measure;\n      if (font.remeasure && width > 0) {\n        measure = ctx.measureText(character);\n        const measuredWidth = measure.width * 1000 / fontSize * fontSizeScale;\n        if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n          const characterScaleX = width / measuredWidth;\n          restoreNeeded = true;\n          ctx.save();\n          ctx.scale(characterScaleX, 1);\n          scaledX /= characterScaleX;\n        } else if (width !== measuredWidth) {\n          scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n        }\n      }\n      if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n        if (simpleFillText && !accent) {\n          ctx.fillText(character, scaledX, scaledY);\n          this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, measure ? {\n            bbox: null\n          } : font, fontSize / fontSizeScale, scaledX, scaledY, () => measure ?? ctx.measureText(character));\n        } else {\n          this.paintChar(opIdx, character, scaledX, scaledY, patternFillTransform, patternStrokeTransform);\n          if (accent) {\n            const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n            const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n            this.paintChar(opIdx, accent.fontChar, scaledAccentX, scaledAccentY, patternFillTransform, patternStrokeTransform);\n          }\n        }\n      }\n      const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;\n      x += charWidth;\n      if (restoreNeeded) {\n        ctx.restore();\n      }\n    }\n    if (vertical) {\n      current.y -= x;\n    } else {\n      current.x += x * textHScale;\n    }\n    ctx.restore();\n    this.compose();\n    this.dependencyTracker?.recordOperation(opIdx).recordIncrementalData(\"sameLineText\", opIdx);\n    return undefined;\n  }\n  showType3Text(opIdx, glyphs) {\n    const ctx = this.ctx;\n    const current = this.current;\n    const font = current.font;\n    const fontSize = current.fontSize;\n    const fontDirection = current.fontDirection;\n    const spacingDir = font.vertical ? 1 : -1;\n    const charSpacing = current.charSpacing;\n    const wordSpacing = current.wordSpacing;\n    const textHScale = current.textHScale * fontDirection;\n    const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;\n    const glyphsLength = glyphs.length;\n    const isTextInvisible = current.textRenderingMode === TextRenderingMode.INVISIBLE;\n    let i, glyph, width, spacingLength;\n    if (isTextInvisible || fontSize === 0) {\n      return;\n    }\n    this._cachedScaleForStroking[0] = -1;\n    this._cachedGetSinglePixelWidth = null;\n    ctx.save();\n    if (current.textMatrix) {\n      ctx.transform(...current.textMatrix);\n    }\n    ctx.translate(current.x, current.y + current.textRise);\n    ctx.scale(textHScale, fontDirection);\n    const dependencyTracker = this.dependencyTracker;\n    this.dependencyTracker = dependencyTracker ? new CanvasNestedDependencyTracker(dependencyTracker, opIdx) : null;\n    for (i = 0; i < glyphsLength; ++i) {\n      glyph = glyphs[i];\n      if (typeof glyph === \"number\") {\n        spacingLength = spacingDir * glyph * fontSize / 1000;\n        this.ctx.translate(spacingLength, 0);\n        current.x += spacingLength * textHScale;\n        continue;\n      }\n      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n      const operatorList = font.charProcOperatorList[glyph.operatorListId];\n      if (!operatorList) {\n        warn(`Type3 character \"${glyph.operatorListId}\" is not available.`);\n      } else if (this.contentVisible) {\n        this.save();\n        ctx.scale(fontSize, fontSize);\n        ctx.transform(...fontMatrix);\n        this.executeOperatorList(operatorList);\n        this.restore();\n      }\n      const p = [glyph.width, 0];\n      Util.applyTransform(p, fontMatrix);\n      width = p[0] * fontSize + spacing;\n      ctx.translate(width, 0);\n      current.x += width * textHScale;\n    }\n    ctx.restore();\n    if (dependencyTracker) {\n      this.dependencyTracker.recordNestedDependencies();\n      this.dependencyTracker = dependencyTracker;\n    }\n  }\n  setCharWidth(opIdx, xWidth, yWidth) {}\n  setCharWidthAndBounds(opIdx, xWidth, yWidth, llx, lly, urx, ury) {\n    const clip = new Path2D();\n    clip.rect(llx, lly, urx - llx, ury - lly);\n    this.ctx.clip(clip);\n    this.dependencyTracker?.recordBBox(opIdx, this.ctx, llx, urx, lly, ury).recordClipBox(opIdx, this.ctx, llx, urx, lly, ury);\n    this.endPath(opIdx);\n  }\n  getColorN_Pattern(opIdx, IR) {\n    let pattern;\n    if (IR[0] === \"TilingPattern\") {\n      const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);\n      const canvasGraphicsFactory = {\n        createCanvasGraphics: ctx => new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n          optionalContentConfig: this.optionalContentConfig,\n          markedContentStack: this.markedContentStack\n        }, undefined, undefined, this.dependencyTracker ? new CanvasNestedDependencyTracker(this.dependencyTracker, opIdx) : null)\n      };\n      pattern = new TilingPattern(IR, this.ctx, canvasGraphicsFactory, baseTransform);\n    } else {\n      pattern = this._getPattern(opIdx, IR[1], IR[2]);\n    }\n    return pattern;\n  }\n  setStrokeColorN(opIdx, ...args) {\n    this.dependencyTracker?.recordSimpleData(\"strokeColor\", opIdx);\n    this.current.strokeColor = this.getColorN_Pattern(opIdx, args);\n    this.current.patternStroke = true;\n  }\n  setFillColorN(opIdx, ...args) {\n    this.dependencyTracker?.recordSimpleData(\"fillColor\", opIdx);\n    this.current.fillColor = this.getColorN_Pattern(opIdx, args);\n    this.current.patternFill = true;\n  }\n  setStrokeRGBColor(opIdx, color) {\n    this.dependencyTracker?.recordSimpleData(\"strokeColor\", opIdx);\n    this.ctx.strokeStyle = this.current.strokeColor = color;\n    this.current.patternStroke = false;\n  }\n  setStrokeTransparent(opIdx) {\n    this.dependencyTracker?.recordSimpleData(\"strokeColor\", opIdx);\n    this.ctx.strokeStyle = this.current.strokeColor = \"transparent\";\n    this.current.patternStroke = false;\n  }\n  setFillRGBColor(opIdx, color) {\n    this.dependencyTracker?.recordSimpleData(\"fillColor\", opIdx);\n    this.ctx.fillStyle = this.current.fillColor = color;\n    this.current.patternFill = false;\n  }\n  setFillTransparent(opIdx) {\n    this.dependencyTracker?.recordSimpleData(\"fillColor\", opIdx);\n    this.ctx.fillStyle = this.current.fillColor = \"transparent\";\n    this.current.patternFill = false;\n  }\n  _getPattern(opIdx, objId, matrix = null) {\n    let pattern;\n    if (this.cachedPatterns.has(objId)) {\n      pattern = this.cachedPatterns.get(objId);\n    } else {\n      pattern = getShadingPattern(this.getObject(opIdx, objId));\n      this.cachedPatterns.set(objId, pattern);\n    }\n    if (matrix) {\n      pattern.matrix = matrix;\n    }\n    return pattern;\n  }\n  shadingFill(opIdx, objId) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const ctx = this.ctx;\n    this.save(opIdx);\n    const pattern = this._getPattern(opIdx, objId);\n    ctx.fillStyle = pattern.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.SHADING);\n    const inv = getCurrentTransformInverse(ctx);\n    if (inv) {\n      const {\n        width,\n        height\n      } = ctx.canvas;\n      const minMax = MIN_MAX_INIT.slice();\n      Util.axialAlignedBoundingBox([0, 0, width, height], inv, minMax);\n      const [x0, y0, x1, y1] = minMax;\n      this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n    } else {\n      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n    }\n    this.dependencyTracker?.resetBBox(opIdx).recordFullPageBBox(opIdx).recordDependencies(opIdx, Dependencies.transform).recordDependencies(opIdx, Dependencies.fill).recordOperation(opIdx);\n    this.compose(this.current.getClippedPathBoundingBox());\n    this.restore(opIdx);\n  }\n  beginInlineImage() {\n    unreachable(\"Should not call beginInlineImage\");\n  }\n  beginImageData() {\n    unreachable(\"Should not call beginImageData\");\n  }\n  paintFormXObjectBegin(opIdx, matrix, bbox) {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.save(opIdx);\n    this.baseTransformStack.push(this.baseTransform);\n    if (matrix) {\n      this.transform(opIdx, ...matrix);\n    }\n    this.baseTransform = getCurrentTransform(this.ctx);\n    if (bbox) {\n      Util.axialAlignedBoundingBox(bbox, this.baseTransform, this.current.minMax);\n      const [x0, y0, x1, y1] = bbox;\n      const clip = new Path2D();\n      clip.rect(x0, y0, x1 - x0, y1 - y0);\n      this.ctx.clip(clip);\n      this.dependencyTracker?.recordClipBox(opIdx, this.ctx, x0, x1, y0, y1);\n      this.endPath(opIdx);\n    }\n  }\n  paintFormXObjectEnd(opIdx) {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.restore(opIdx);\n    this.baseTransform = this.baseTransformStack.pop();\n  }\n  beginGroup(opIdx, group) {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.save(opIdx);\n    if (this.inSMaskMode) {\n      this.endSMaskMode();\n      this.current.activeSMask = null;\n    }\n    const currentCtx = this.ctx;\n    if (!group.isolated) {\n      info(\"TODO: Support non-isolated groups.\");\n    }\n    if (group.knockout) {\n      warn(\"Knockout groups not supported.\");\n    }\n    const currentTransform = getCurrentTransform(currentCtx);\n    if (group.matrix) {\n      currentCtx.transform(...group.matrix);\n    }\n    if (!group.bbox) {\n      throw new Error(\"Bounding box is required.\");\n    }\n    let bounds = MIN_MAX_INIT.slice();\n    Util.axialAlignedBoundingBox(group.bbox, getCurrentTransform(currentCtx), bounds);\n    const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];\n    bounds = Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];\n    const offsetX = Math.floor(bounds[0]);\n    const offsetY = Math.floor(bounds[1]);\n    const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n    const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n    this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);\n    let cacheId = \"groupAt\" + this.groupLevel;\n    if (group.smask) {\n      cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n    }\n    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n    const groupCtx = scratchCanvas.context;\n    groupCtx.translate(-offsetX, -offsetY);\n    groupCtx.transform(...currentTransform);\n    let clip = new Path2D();\n    const [x0, y0, x1, y1] = group.bbox;\n    clip.rect(x0, y0, x1 - x0, y1 - y0);\n    if (group.matrix) {\n      const path = new Path2D();\n      path.addPath(clip, new DOMMatrix(group.matrix));\n      clip = path;\n    }\n    groupCtx.clip(clip);\n    if (group.smask) {\n      this.smaskStack.push({\n        canvas: scratchCanvas.canvas,\n        context: groupCtx,\n        offsetX,\n        offsetY,\n        subtype: group.smask.subtype,\n        backdrop: group.smask.backdrop,\n        transferMap: group.smask.transferMap || null,\n        startTransformInverse: null\n      });\n    }\n    if (!group.smask || this.dependencyTracker) {\n      currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n      currentCtx.translate(offsetX, offsetY);\n      currentCtx.save();\n    }\n    copyCtxState(currentCtx, groupCtx);\n    this.ctx = groupCtx;\n    this.dependencyTracker?.inheritSimpleDataAsFutureForcedDependencies([\"fillAlpha\", \"strokeAlpha\", \"globalCompositeOperation\"]).pushBaseTransform(currentCtx);\n    this.setGState(opIdx, [[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n    this.groupStack.push(currentCtx);\n    this.groupLevel++;\n  }\n  endGroup(opIdx, group) {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.groupLevel--;\n    const groupCtx = this.ctx;\n    const ctx = this.groupStack.pop();\n    this.ctx = ctx;\n    this.ctx.imageSmoothingEnabled = false;\n    this.dependencyTracker?.popBaseTransform();\n    if (group.smask) {\n      this.tempSMask = this.smaskStack.pop();\n      this.restore(opIdx);\n      if (this.dependencyTracker) {\n        this.ctx.restore();\n      }\n    } else {\n      this.ctx.restore();\n      const currentMtx = getCurrentTransform(this.ctx);\n      this.restore(opIdx);\n      this.ctx.save();\n      this.ctx.setTransform(...currentMtx);\n      const dirtyBox = MIN_MAX_INIT.slice();\n      Util.axialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx, dirtyBox);\n      this.ctx.drawImage(groupCtx.canvas, 0, 0);\n      this.ctx.restore();\n      this.compose(dirtyBox);\n    }\n  }\n  beginAnnotation(opIdx, id, rect, transform, matrix, hasOwnCanvas) {\n    this.#restoreInitialState();\n    resetCtxToDefault(this.ctx);\n    this.ctx.save();\n    this.save(opIdx);\n    if (this.baseTransform) {\n      this.ctx.setTransform(...this.baseTransform);\n    }\n    if (rect) {\n      const width = rect[2] - rect[0];\n      const height = rect[3] - rect[1];\n      if (hasOwnCanvas && this.annotationCanvasMap) {\n        transform = transform.slice();\n        transform[4] -= rect[0];\n        transform[5] -= rect[1];\n        rect = rect.slice();\n        rect[0] = rect[1] = 0;\n        rect[2] = width;\n        rect[3] = height;\n        Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx), XY);\n        const {\n          viewportScale\n        } = this;\n        const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);\n        const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);\n        this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);\n        const {\n          canvas,\n          context\n        } = this.annotationCanvas;\n        this.annotationCanvasMap.set(id, canvas);\n        this.annotationCanvas.savedCtx = this.ctx;\n        this.ctx = context;\n        this.ctx.save();\n        this.ctx.setTransform(XY[0], 0, 0, -XY[1], 0, height * XY[1]);\n        resetCtxToDefault(this.ctx);\n      } else {\n        resetCtxToDefault(this.ctx);\n        this.endPath(opIdx);\n        const clip = new Path2D();\n        clip.rect(rect[0], rect[1], width, height);\n        this.ctx.clip(clip);\n      }\n    }\n    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n    this.transform(opIdx, ...transform);\n    this.transform(opIdx, ...matrix);\n  }\n  endAnnotation(opIdx) {\n    if (this.annotationCanvas) {\n      this.ctx.restore();\n      this.#drawFilter();\n      this.ctx = this.annotationCanvas.savedCtx;\n      delete this.annotationCanvas.savedCtx;\n      delete this.annotationCanvas;\n    }\n  }\n  paintImageMaskXObject(opIdx, img) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const count = img.count;\n    img = this.getObject(opIdx, img.data, img);\n    img.count = count;\n    const ctx = this.ctx;\n    const mask = this._createMaskCanvas(opIdx, img);\n    const maskCanvas = mask.canvas;\n    ctx.save();\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);\n    this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, this.ctx, mask.offsetX, mask.offsetX + maskCanvas.width, mask.offsetY, mask.offsetY + maskCanvas.height).recordOperation(opIdx);\n    ctx.restore();\n    this.compose();\n  }\n  paintImageMaskXObjectRepeat(opIdx, img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {\n    if (!this.contentVisible) {\n      return;\n    }\n    img = this.getObject(opIdx, img.data, img);\n    const ctx = this.ctx;\n    ctx.save();\n    const currentTransform = getCurrentTransform(ctx);\n    ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);\n    const mask = this._createMaskCanvas(opIdx, img);\n    ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);\n    this.dependencyTracker?.resetBBox(opIdx);\n    for (let i = 0, ii = positions.length; i < ii; i += 2) {\n      const trans = Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);\n      ctx.drawImage(mask.canvas, trans[4], trans[5]);\n      this.dependencyTracker?.recordBBox(opIdx, this.ctx, trans[4], trans[4] + mask.canvas.width, trans[5], trans[5] + mask.canvas.height);\n    }\n    ctx.restore();\n    this.compose();\n    this.dependencyTracker?.recordOperation(opIdx);\n  }\n  paintImageMaskXObjectGroup(opIdx, images) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const ctx = this.ctx;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    this.dependencyTracker?.resetBBox(opIdx).recordDependencies(opIdx, Dependencies.transformAndFill);\n    for (const image of images) {\n      const {\n        data,\n        width,\n        height,\n        transform\n      } = image;\n      const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n      const maskCtx = maskCanvas.context;\n      maskCtx.save();\n      const img = this.getObject(opIdx, data, image);\n      putBinaryImageMask(maskCtx, img);\n      maskCtx.globalCompositeOperation = \"source-in\";\n      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, getCurrentTransformInverse(ctx), PathType.FILL) : fillColor;\n      maskCtx.fillRect(0, 0, width, height);\n      maskCtx.restore();\n      ctx.save();\n      ctx.transform(...transform);\n      ctx.scale(1, -1);\n      drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n      this.dependencyTracker?.recordBBox(opIdx, ctx, 0, width, 0, height);\n      ctx.restore();\n    }\n    this.compose();\n    this.dependencyTracker?.recordOperation(opIdx);\n  }\n  paintImageXObject(opIdx, objId) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const imgData = this.getObject(opIdx, objId);\n    if (!imgData) {\n      warn(\"Dependent image isn't ready yet\");\n      return;\n    }\n    this.paintInlineImageXObject(opIdx, imgData);\n  }\n  paintImageXObjectRepeat(opIdx, objId, scaleX, scaleY, positions) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const imgData = this.getObject(opIdx, objId);\n    if (!imgData) {\n      warn(\"Dependent image isn't ready yet\");\n      return;\n    }\n    const width = imgData.width;\n    const height = imgData.height;\n    const map = [];\n    for (let i = 0, ii = positions.length; i < ii; i += 2) {\n      map.push({\n        transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],\n        x: 0,\n        y: 0,\n        w: width,\n        h: height\n      });\n    }\n    this.paintInlineImageXObjectGroup(opIdx, imgData, map);\n  }\n  applyTransferMapsToCanvas(ctx) {\n    if (this.current.transferMaps !== \"none\") {\n      ctx.filter = this.current.transferMaps;\n      ctx.drawImage(ctx.canvas, 0, 0);\n      ctx.filter = \"none\";\n    }\n    return ctx.canvas;\n  }\n  applyTransferMapsToBitmap(imgData) {\n    if (this.current.transferMaps === \"none\") {\n      return imgData.bitmap;\n    }\n    const {\n      bitmap,\n      width,\n      height\n    } = imgData;\n    const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n    const tmpCtx = tmpCanvas.context;\n    tmpCtx.filter = this.current.transferMaps;\n    tmpCtx.drawImage(bitmap, 0, 0);\n    tmpCtx.filter = \"none\";\n    return tmpCanvas.canvas;\n  }\n  paintInlineImageXObject(opIdx, imgData) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const width = imgData.width;\n    const height = imgData.height;\n    const ctx = this.ctx;\n    this.save(opIdx);\n    const {\n      filter\n    } = ctx;\n    if (filter !== \"none\" && filter !== \"\") {\n      ctx.filter = \"none\";\n    }\n    ctx.scale(1 / width, -1 / height);\n    let imgToPaint;\n    if (imgData.bitmap) {\n      imgToPaint = this.applyTransferMapsToBitmap(imgData);\n    } else if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n      imgToPaint = imgData;\n    } else {\n      const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n      const tmpCtx = tmpCanvas.context;\n      putBinaryImageData(tmpCtx, imgData);\n      imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n    }\n    const scaled = this._scaleImage(imgToPaint, getCurrentTransformInverse(ctx));\n    ctx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(ctx), imgData.interpolate);\n    this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, ctx, 0, width, -height, 0).recordDependencies(opIdx, Dependencies.imageXObject).recordOperation(opIdx);\n    drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);\n    this.compose();\n    this.restore(opIdx);\n  }\n  paintInlineImageXObjectGroup(opIdx, imgData, map) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const ctx = this.ctx;\n    let imgToPaint;\n    if (imgData.bitmap) {\n      imgToPaint = imgData.bitmap;\n    } else {\n      const w = imgData.width;\n      const h = imgData.height;\n      const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n      const tmpCtx = tmpCanvas.context;\n      putBinaryImageData(tmpCtx, imgData);\n      imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n    }\n    this.dependencyTracker?.resetBBox(opIdx);\n    for (const entry of map) {\n      ctx.save();\n      ctx.transform(...entry.transform);\n      ctx.scale(1, -1);\n      drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n      this.dependencyTracker?.recordBBox(opIdx, ctx, 0, 1, -1, 0);\n      ctx.restore();\n    }\n    this.dependencyTracker?.recordOperation(opIdx);\n    this.compose();\n  }\n  paintSolidColorImageMask(opIdx) {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, this.ctx, 0, 1, 0, 1).recordDependencies(opIdx, Dependencies.fill).recordOperation(opIdx);\n    this.ctx.fillRect(0, 0, 1, 1);\n    this.compose();\n  }\n  markPoint(opIdx, tag) {}\n  markPointProps(opIdx, tag, properties) {}\n  beginMarkedContent(opIdx, tag) {\n    this.dependencyTracker?.beginMarkedContent(opIdx);\n    this.markedContentStack.push({\n      visible: true\n    });\n  }\n  beginMarkedContentProps(opIdx, tag, properties) {\n    this.dependencyTracker?.beginMarkedContent(opIdx);\n    if (tag === \"OC\") {\n      this.markedContentStack.push({\n        visible: this.optionalContentConfig.isVisible(properties)\n      });\n    } else {\n      this.markedContentStack.push({\n        visible: true\n      });\n    }\n    this.contentVisible = this.isContentVisible();\n  }\n  endMarkedContent(opIdx) {\n    this.dependencyTracker?.endMarkedContent(opIdx);\n    this.markedContentStack.pop();\n    this.contentVisible = this.isContentVisible();\n  }\n  beginCompat(opIdx) {}\n  endCompat(opIdx) {}\n  consumePath(opIdx, path, clipBox) {\n    const isEmpty = this.current.isEmptyClip();\n    if (this.pendingClip) {\n      this.current.updateClipFromPath();\n    }\n    if (!this.pendingClip) {\n      this.compose(clipBox);\n    }\n    const ctx = this.ctx;\n    if (this.pendingClip) {\n      if (!isEmpty) {\n        if (this.pendingClip === EO_CLIP) {\n          ctx.clip(path, \"evenodd\");\n        } else {\n          ctx.clip(path);\n        }\n      }\n      this.pendingClip = null;\n      this.dependencyTracker?.bboxToClipBoxDropOperation(opIdx).recordFutureForcedDependency(\"clipPath\", opIdx);\n    } else {\n      this.dependencyTracker?.recordOperation(opIdx);\n    }\n    this.current.startNewPathAndClipBox(this.current.clipBox);\n  }\n  getSinglePixelWidth() {\n    if (!this._cachedGetSinglePixelWidth) {\n      const m = getCurrentTransform(this.ctx);\n      if (m[1] === 0 && m[2] === 0) {\n        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));\n      } else {\n        const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n        const normX = Math.hypot(m[0], m[2]);\n        const normY = Math.hypot(m[1], m[3]);\n        this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;\n      }\n    }\n    return this._cachedGetSinglePixelWidth;\n  }\n  getScaleForStroking() {\n    if (this._cachedScaleForStroking[0] === -1) {\n      const {\n        lineWidth\n      } = this.current;\n      const {\n        a,\n        b,\n        c,\n        d\n      } = this.ctx.getTransform();\n      let scaleX, scaleY;\n      if (b === 0 && c === 0) {\n        const normX = Math.abs(a);\n        const normY = Math.abs(d);\n        if (normX === normY) {\n          if (lineWidth === 0) {\n            scaleX = scaleY = 1 / normX;\n          } else {\n            const scaledLineWidth = normX * lineWidth;\n            scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;\n          }\n        } else if (lineWidth === 0) {\n          scaleX = 1 / normX;\n          scaleY = 1 / normY;\n        } else {\n          const scaledXLineWidth = normX * lineWidth;\n          const scaledYLineWidth = normY * lineWidth;\n          scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;\n          scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;\n        }\n      } else {\n        const absDet = Math.abs(a * d - b * c);\n        const normX = Math.hypot(a, b);\n        const normY = Math.hypot(c, d);\n        if (lineWidth === 0) {\n          scaleX = normY / absDet;\n          scaleY = normX / absDet;\n        } else {\n          const baseArea = lineWidth * absDet;\n          scaleX = normY > baseArea ? normY / baseArea : 1;\n          scaleY = normX > baseArea ? normX / baseArea : 1;\n        }\n      }\n      this._cachedScaleForStroking[0] = scaleX;\n      this._cachedScaleForStroking[1] = scaleY;\n    }\n    return this._cachedScaleForStroking;\n  }\n  rescaleAndStroke(path, saveRestore) {\n    const {\n      ctx,\n      current: {\n        lineWidth\n      }\n    } = this;\n    const [scaleX, scaleY] = this.getScaleForStroking();\n    if (scaleX === scaleY) {\n      ctx.lineWidth = (lineWidth || 1) * scaleX;\n      ctx.stroke(path);\n      return;\n    }\n    const dashes = ctx.getLineDash();\n    if (saveRestore) {\n      ctx.save();\n    }\n    ctx.scale(scaleX, scaleY);\n    SCALE_MATRIX.a = 1 / scaleX;\n    SCALE_MATRIX.d = 1 / scaleY;\n    const newPath = new Path2D();\n    newPath.addPath(path, SCALE_MATRIX);\n    if (dashes.length > 0) {\n      const scale = Math.max(scaleX, scaleY);\n      ctx.setLineDash(dashes.map(x => x / scale));\n      ctx.lineDashOffset /= scale;\n    }\n    ctx.lineWidth = lineWidth || 1;\n    ctx.stroke(newPath);\n    if (saveRestore) {\n      ctx.restore();\n    }\n  }\n  isContentVisible() {\n    for (let i = this.markedContentStack.length - 1; i >= 0; i--) {\n      if (!this.markedContentStack[i].visible) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nfor (const op in OPS) {\n  if (CanvasGraphics.prototype[op] !== undefined) {\n    CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];\n  }\n}\n\n;// ./src/display/worker_options.js\nclass GlobalWorkerOptions {\n  static #port = null;\n  static #src = \"\";\n  static get workerPort() {\n    return this.#port;\n  }\n  static set workerPort(val) {\n    if (!(typeof Worker !== \"undefined\" && val instanceof Worker) && val !== null) {\n      throw new Error(\"Invalid `workerPort` type.\");\n    }\n    this.#port = val;\n  }\n  static get workerSrc() {\n    return this.#src;\n  }\n  static set workerSrc(val) {\n    if (typeof val !== \"string\") {\n      throw new Error(\"Invalid `workerSrc` type.\");\n    }\n    this.#src = val;\n  }\n}\n\n;// ./src/display/metadata.js\nclass Metadata {\n  #map;\n  #data;\n  constructor({\n    parsedData,\n    rawData\n  }) {\n    this.#map = parsedData;\n    this.#data = rawData;\n  }\n  getRaw() {\n    return this.#data;\n  }\n  get(name) {\n    return this.#map.get(name) ?? null;\n  }\n  [Symbol.iterator]() {\n    return this.#map.entries();\n  }\n}\n\n;// ./src/display/optional_content_config.js\n\n\nconst INTERNAL = Symbol(\"INTERNAL\");\nclass OptionalContentGroup {\n  #isDisplay = false;\n  #isPrint = false;\n  #userSet = false;\n  #visible = true;\n  constructor(renderingIntent, {\n    name,\n    intent,\n    usage,\n    rbGroups\n  }) {\n    this.#isDisplay = !!(renderingIntent & RenderingIntentFlag.DISPLAY);\n    this.#isPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);\n    this.name = name;\n    this.intent = intent;\n    this.usage = usage;\n    this.rbGroups = rbGroups;\n  }\n  get visible() {\n    if (this.#userSet) {\n      return this.#visible;\n    }\n    if (!this.#visible) {\n      return false;\n    }\n    const {\n      print,\n      view\n    } = this.usage;\n    if (this.#isDisplay) {\n      return view?.viewState !== \"OFF\";\n    } else if (this.#isPrint) {\n      return print?.printState !== \"OFF\";\n    }\n    return true;\n  }\n  _setVisible(internal, visible, userSet = false) {\n    if (internal !== INTERNAL) {\n      unreachable(\"Internal method `_setVisible` called.\");\n    }\n    this.#userSet = userSet;\n    this.#visible = visible;\n  }\n}\nclass OptionalContentConfig {\n  #cachedGetHash = null;\n  #groups = new Map();\n  #initialHash = null;\n  #order = null;\n  constructor(data, renderingIntent = RenderingIntentFlag.DISPLAY) {\n    this.renderingIntent = renderingIntent;\n    this.name = null;\n    this.creator = null;\n    if (data === null) {\n      return;\n    }\n    this.name = data.name;\n    this.creator = data.creator;\n    this.#order = data.order;\n    for (const group of data.groups) {\n      this.#groups.set(group.id, new OptionalContentGroup(renderingIntent, group));\n    }\n    if (data.baseState === \"OFF\") {\n      for (const group of this.#groups.values()) {\n        group._setVisible(INTERNAL, false);\n      }\n    }\n    for (const on of data.on) {\n      this.#groups.get(on)._setVisible(INTERNAL, true);\n    }\n    for (const off of data.off) {\n      this.#groups.get(off)._setVisible(INTERNAL, false);\n    }\n    this.#initialHash = this.getHash();\n  }\n  #evaluateVisibilityExpression(array) {\n    const length = array.length;\n    if (length < 2) {\n      return true;\n    }\n    const operator = array[0];\n    for (let i = 1; i < length; i++) {\n      const element = array[i];\n      let state;\n      if (Array.isArray(element)) {\n        state = this.#evaluateVisibilityExpression(element);\n      } else if (this.#groups.has(element)) {\n        state = this.#groups.get(element).visible;\n      } else {\n        warn(`Optional content group not found: ${element}`);\n        return true;\n      }\n      switch (operator) {\n        case \"And\":\n          if (!state) {\n            return false;\n          }\n          break;\n        case \"Or\":\n          if (state) {\n            return true;\n          }\n          break;\n        case \"Not\":\n          return !state;\n        default:\n          return true;\n      }\n    }\n    return operator === \"And\";\n  }\n  isVisible(group) {\n    if (this.#groups.size === 0) {\n      return true;\n    }\n    if (!group) {\n      info(\"Optional content group not defined.\");\n      return true;\n    }\n    if (group.type === \"OCG\") {\n      if (!this.#groups.has(group.id)) {\n        warn(`Optional content group not found: ${group.id}`);\n        return true;\n      }\n      return this.#groups.get(group.id).visible;\n    } else if (group.type === \"OCMD\") {\n      if (group.expression) {\n        return this.#evaluateVisibilityExpression(group.expression);\n      }\n      if (!group.policy || group.policy === \"AnyOn\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            warn(`Optional content group not found: ${id}`);\n            return true;\n          }\n          if (this.#groups.get(id).visible) {\n            return true;\n          }\n        }\n        return false;\n      } else if (group.policy === \"AllOn\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            warn(`Optional content group not found: ${id}`);\n            return true;\n          }\n          if (!this.#groups.get(id).visible) {\n            return false;\n          }\n        }\n        return true;\n      } else if (group.policy === \"AnyOff\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            warn(`Optional content group not found: ${id}`);\n            return true;\n          }\n          if (!this.#groups.get(id).visible) {\n            return true;\n          }\n        }\n        return false;\n      } else if (group.policy === \"AllOff\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            warn(`Optional content group not found: ${id}`);\n            return true;\n          }\n          if (this.#groups.get(id).visible) {\n            return false;\n          }\n        }\n        return true;\n      }\n      warn(`Unknown optional content policy ${group.policy}.`);\n      return true;\n    }\n    warn(`Unknown group type ${group.type}.`);\n    return true;\n  }\n  setVisibility(id, visible = true, preserveRB = true) {\n    const group = this.#groups.get(id);\n    if (!group) {\n      warn(`Optional content group not found: ${id}`);\n      return;\n    }\n    if (preserveRB && visible && group.rbGroups.length) {\n      for (const rbGroup of group.rbGroups) {\n        for (const otherId of rbGroup) {\n          if (otherId !== id) {\n            this.#groups.get(otherId)?._setVisible(INTERNAL, false, true);\n          }\n        }\n      }\n    }\n    group._setVisible(INTERNAL, !!visible, true);\n    this.#cachedGetHash = null;\n  }\n  setOCGState({\n    state,\n    preserveRB\n  }) {\n    let operator;\n    for (const elem of state) {\n      switch (elem) {\n        case \"ON\":\n        case \"OFF\":\n        case \"Toggle\":\n          operator = elem;\n          continue;\n      }\n      const group = this.#groups.get(elem);\n      if (!group) {\n        continue;\n      }\n      switch (operator) {\n        case \"ON\":\n          this.setVisibility(elem, true, preserveRB);\n          break;\n        case \"OFF\":\n          this.setVisibility(elem, false, preserveRB);\n          break;\n        case \"Toggle\":\n          this.setVisibility(elem, !group.visible, preserveRB);\n          break;\n      }\n    }\n    this.#cachedGetHash = null;\n  }\n  get hasInitialVisibility() {\n    return this.#initialHash === null || this.getHash() === this.#initialHash;\n  }\n  getOrder() {\n    if (!this.#groups.size) {\n      return null;\n    }\n    if (this.#order) {\n      return this.#order.slice();\n    }\n    return [...this.#groups.keys()];\n  }\n  getGroup(id) {\n    return this.#groups.get(id) || null;\n  }\n  getHash() {\n    if (this.#cachedGetHash !== null) {\n      return this.#cachedGetHash;\n    }\n    const hash = new MurmurHash3_64();\n    for (const [id, group] of this.#groups) {\n      hash.update(`${id}:${group.visible}`);\n    }\n    return this.#cachedGetHash = hash.hexdigest();\n  }\n  [Symbol.iterator]() {\n    return this.#groups.entries();\n  }\n}\n\n;// ./src/display/transport_stream.js\n\n\nclass PDFDataTransportStream {\n  constructor(pdfDataRangeTransport, {\n    disableRange = false,\n    disableStream = false\n  }) {\n    assert(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n    const {\n      length,\n      initialData,\n      progressiveDone,\n      contentDispositionFilename\n    } = pdfDataRangeTransport;\n    this._queuedChunks = [];\n    this._progressiveDone = progressiveDone;\n    this._contentDispositionFilename = contentDispositionFilename;\n    if (initialData?.length > 0) {\n      const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;\n      this._queuedChunks.push(buffer);\n    }\n    this._pdfDataRangeTransport = pdfDataRangeTransport;\n    this._isStreamingSupported = !disableStream;\n    this._isRangeSupported = !disableRange;\n    this._contentLength = length;\n    this._fullRequestReader = null;\n    this._rangeReaders = [];\n    pdfDataRangeTransport.addRangeListener((begin, chunk) => {\n      this._onReceiveData({\n        begin,\n        chunk\n      });\n    });\n    pdfDataRangeTransport.addProgressListener((loaded, total) => {\n      this._onProgress({\n        loaded,\n        total\n      });\n    });\n    pdfDataRangeTransport.addProgressiveReadListener(chunk => {\n      this._onReceiveData({\n        chunk\n      });\n    });\n    pdfDataRangeTransport.addProgressiveDoneListener(() => {\n      this._onProgressiveDone();\n    });\n    pdfDataRangeTransport.transportReady();\n  }\n  _onReceiveData({\n    begin,\n    chunk\n  }) {\n    const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;\n    if (begin === undefined) {\n      if (this._fullRequestReader) {\n        this._fullRequestReader._enqueue(buffer);\n      } else {\n        this._queuedChunks.push(buffer);\n      }\n    } else {\n      const found = this._rangeReaders.some(function (rangeReader) {\n        if (rangeReader._begin !== begin) {\n          return false;\n        }\n        rangeReader._enqueue(buffer);\n        return true;\n      });\n      assert(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n    }\n  }\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n  _onProgress(evt) {\n    if (evt.total === undefined) {\n      this._rangeReaders[0]?.onProgress?.({\n        loaded: evt.loaded\n      });\n    } else {\n      this._fullRequestReader?.onProgress?.({\n        loaded: evt.loaded,\n        total: evt.total\n      });\n    }\n  }\n  _onProgressiveDone() {\n    this._fullRequestReader?.progressiveDone();\n    this._progressiveDone = true;\n  }\n  _removeRangeReader(reader) {\n    const i = this._rangeReaders.indexOf(reader);\n    if (i >= 0) {\n      this._rangeReaders.splice(i, 1);\n    }\n  }\n  getFullReader() {\n    assert(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n    const queuedChunks = this._queuedChunks;\n    this._queuedChunks = null;\n    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);\n  }\n  getRangeReader(begin, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n    const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n    this._pdfDataRangeTransport.requestDataRange(begin, end);\n    this._rangeReaders.push(reader);\n    return reader;\n  }\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n    for (const reader of this._rangeReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n    this._pdfDataRangeTransport.abort();\n  }\n}\nclass PDFDataTransportStreamReader {\n  constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {\n    this._stream = stream;\n    this._done = progressiveDone || false;\n    this._filename = isPdfFile(contentDispositionFilename) ? contentDispositionFilename : null;\n    this._queuedChunks = queuedChunks || [];\n    this._loaded = 0;\n    for (const chunk of this._queuedChunks) {\n      this._loaded += chunk.byteLength;\n    }\n    this._requests = [];\n    this._headersReady = Promise.resolve();\n    stream._fullRequestReader = this;\n    this.onProgress = null;\n  }\n  _enqueue(chunk) {\n    if (this._done) {\n      return;\n    }\n    if (this._requests.length > 0) {\n      const requestCapability = this._requests.shift();\n      requestCapability.resolve({\n        value: chunk,\n        done: false\n      });\n    } else {\n      this._queuedChunks.push(chunk);\n    }\n    this._loaded += chunk.byteLength;\n  }\n  get headersReady() {\n    return this._headersReady;\n  }\n  get filename() {\n    return this._filename;\n  }\n  get isRangeSupported() {\n    return this._stream._isRangeSupported;\n  }\n  get isStreamingSupported() {\n    return this._stream._isStreamingSupported;\n  }\n  get contentLength() {\n    return this._stream._contentLength;\n  }\n  async read() {\n    if (this._queuedChunks.length > 0) {\n      const chunk = this._queuedChunks.shift();\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    const requestCapability = Promise.withResolvers();\n    this._requests.push(requestCapability);\n    return requestCapability.promise;\n  }\n  cancel(reason) {\n    this._done = true;\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n  }\n  progressiveDone() {\n    if (this._done) {\n      return;\n    }\n    this._done = true;\n  }\n}\nclass PDFDataTransportStreamRangeReader {\n  constructor(stream, begin, end) {\n    this._stream = stream;\n    this._begin = begin;\n    this._end = end;\n    this._queuedChunk = null;\n    this._requests = [];\n    this._done = false;\n    this.onProgress = null;\n  }\n  _enqueue(chunk) {\n    if (this._done) {\n      return;\n    }\n    if (this._requests.length === 0) {\n      this._queuedChunk = chunk;\n    } else {\n      const requestsCapability = this._requests.shift();\n      requestsCapability.resolve({\n        value: chunk,\n        done: false\n      });\n      for (const requestCapability of this._requests) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      }\n      this._requests.length = 0;\n    }\n    this._done = true;\n    this._stream._removeRangeReader(this);\n  }\n  get isStreamingSupported() {\n    return false;\n  }\n  async read() {\n    if (this._queuedChunk) {\n      const chunk = this._queuedChunk;\n      this._queuedChunk = null;\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    const requestCapability = Promise.withResolvers();\n    this._requests.push(requestCapability);\n    return requestCapability.promise;\n  }\n  cancel(reason) {\n    this._done = true;\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n    this._stream._removeRangeReader(this);\n  }\n}\n\n;// ./src/display/content_disposition.js\n\nfunction getFilenameFromContentDispositionHeader(contentDisposition) {\n  let needsEncodingFixup = true;\n  let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n  if (tmp) {\n    tmp = tmp[1];\n    let filename = rfc2616unquote(tmp);\n    filename = unescape(filename);\n    filename = rfc5987decode(filename);\n    filename = rfc2047decode(filename);\n    return fixupEncoding(filename);\n  }\n  tmp = rfc2231getparam(contentDisposition);\n  if (tmp) {\n    const filename = rfc2047decode(tmp);\n    return fixupEncoding(filename);\n  }\n  tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n  if (tmp) {\n    tmp = tmp[1];\n    let filename = rfc2616unquote(tmp);\n    filename = rfc2047decode(filename);\n    return fixupEncoding(filename);\n  }\n  function toParamRegExp(attributePattern, flags) {\n    return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\n  }\n  function textdecode(encoding, value) {\n    if (encoding) {\n      if (!/^[\\x00-\\xFF]+$/.test(value)) {\n        return value;\n      }\n      try {\n        const decoder = new TextDecoder(encoding, {\n          fatal: true\n        });\n        const buffer = stringToBytes(value);\n        value = decoder.decode(buffer);\n        needsEncodingFixup = false;\n      } catch {}\n    }\n    return value;\n  }\n  function fixupEncoding(value) {\n    if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n      value = textdecode(\"utf-8\", value);\n      if (needsEncodingFixup) {\n        value = textdecode(\"iso-8859-1\", value);\n      }\n    }\n    return value;\n  }\n  function rfc2231getparam(contentDispositionStr) {\n    const matches = [];\n    let match;\n    const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n    while ((match = iter.exec(contentDispositionStr)) !== null) {\n      let [, n, quot, part] = match;\n      n = parseInt(n, 10);\n      if (n in matches) {\n        if (n === 0) {\n          break;\n        }\n        continue;\n      }\n      matches[n] = [quot, part];\n    }\n    const parts = [];\n    for (let n = 0; n < matches.length; ++n) {\n      if (!(n in matches)) {\n        break;\n      }\n      let [quot, part] = matches[n];\n      part = rfc2616unquote(part);\n      if (quot) {\n        part = unescape(part);\n        if (n === 0) {\n          part = rfc5987decode(part);\n        }\n      }\n      parts.push(part);\n    }\n    return parts.join(\"\");\n  }\n  function rfc2616unquote(value) {\n    if (value.startsWith('\"')) {\n      const parts = value.slice(1).split('\\\\\"');\n      for (let i = 0; i < parts.length; ++i) {\n        const quotindex = parts[i].indexOf('\"');\n        if (quotindex !== -1) {\n          parts[i] = parts[i].slice(0, quotindex);\n          parts.length = i + 1;\n        }\n        parts[i] = parts[i].replaceAll(/\\\\(.)/g, \"$1\");\n      }\n      value = parts.join('\"');\n    }\n    return value;\n  }\n  function rfc5987decode(extvalue) {\n    const encodingend = extvalue.indexOf(\"'\");\n    if (encodingend === -1) {\n      return extvalue;\n    }\n    const encoding = extvalue.slice(0, encodingend);\n    const langvalue = extvalue.slice(encodingend + 1);\n    const value = langvalue.replace(/^[^']*'/, \"\");\n    return textdecode(encoding, value);\n  }\n  function rfc2047decode(value) {\n    if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n      return value;\n    }\n    return value.replaceAll(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function (matches, charset, encoding, text) {\n      if (encoding === \"q\" || encoding === \"Q\") {\n        text = text.replaceAll(\"_\", \" \");\n        text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function (match, hex) {\n          return String.fromCharCode(parseInt(hex, 16));\n        });\n        return textdecode(charset, text);\n      }\n      try {\n        text = atob(text);\n      } catch {}\n      return textdecode(charset, text);\n    });\n  }\n  return \"\";\n}\n\n;// ./src/display/network_utils.js\n\n\n\nfunction createHeaders(isHttp, httpHeaders) {\n  const headers = new Headers();\n  if (!isHttp || !httpHeaders || typeof httpHeaders !== \"object\") {\n    return headers;\n  }\n  for (const key in httpHeaders) {\n    const val = httpHeaders[key];\n    if (val !== undefined) {\n      headers.append(key, val);\n    }\n  }\n  return headers;\n}\nfunction getResponseOrigin(url) {\n  return URL.parse(url)?.origin ?? null;\n}\nfunction validateRangeRequestCapabilities({\n  responseHeaders,\n  isHttp,\n  rangeChunkSize,\n  disableRange\n}) {\n  const returnValues = {\n    allowRangeRequests: false,\n    suggestedLength: undefined\n  };\n  const length = parseInt(responseHeaders.get(\"Content-Length\"), 10);\n  if (!Number.isInteger(length)) {\n    return returnValues;\n  }\n  returnValues.suggestedLength = length;\n  if (length <= 2 * rangeChunkSize) {\n    return returnValues;\n  }\n  if (disableRange || !isHttp) {\n    return returnValues;\n  }\n  if (responseHeaders.get(\"Accept-Ranges\") !== \"bytes\") {\n    return returnValues;\n  }\n  const contentEncoding = responseHeaders.get(\"Content-Encoding\") || \"identity\";\n  if (contentEncoding !== \"identity\") {\n    return returnValues;\n  }\n  returnValues.allowRangeRequests = true;\n  return returnValues;\n}\nfunction extractFilenameFromHeader(responseHeaders) {\n  const contentDisposition = responseHeaders.get(\"Content-Disposition\");\n  if (contentDisposition) {\n    let filename = getFilenameFromContentDispositionHeader(contentDisposition);\n    if (filename.includes(\"%\")) {\n      try {\n        filename = decodeURIComponent(filename);\n      } catch {}\n    }\n    if (isPdfFile(filename)) {\n      return filename;\n    }\n  }\n  return null;\n}\nfunction createResponseError(status, url) {\n  return new ResponseException(`Unexpected server response (${status}) while retrieving PDF \"${url}\".`, status, status === 404 || status === 0 && url.startsWith(\"file:\"));\n}\nfunction validateResponseStatus(status) {\n  return status === 200 || status === 206;\n}\n\n;// ./src/display/fetch_stream.js\n\n\nfunction createFetchOptions(headers, withCredentials, abortController) {\n  return {\n    method: \"GET\",\n    headers,\n    signal: abortController.signal,\n    mode: \"cors\",\n    credentials: withCredentials ? \"include\" : \"same-origin\",\n    redirect: \"follow\"\n  };\n}\nfunction getArrayBuffer(val) {\n  if (val instanceof Uint8Array) {\n    return val.buffer;\n  }\n  if (val instanceof ArrayBuffer) {\n    return val;\n  }\n  warn(`getArrayBuffer - unexpected data format: ${val}`);\n  return new Uint8Array(val).buffer;\n}\nclass PDFFetchStream {\n  _responseOrigin = null;\n  constructor(source) {\n    this.source = source;\n    this.isHttp = /^https?:/i.test(source.url);\n    this.headers = createHeaders(this.isHttp, source.httpHeaders);\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n  getFullReader() {\n    assert(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n    this._fullRequestReader = new PDFFetchStreamReader(this);\n    return this._fullRequestReader;\n  }\n  getRangeReader(begin, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n    const reader = new PDFFetchStreamRangeReader(this, begin, end);\n    this._rangeRequestReaders.push(reader);\n    return reader;\n  }\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n}\nclass PDFFetchStreamReader {\n  constructor(stream) {\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    this._filename = null;\n    const source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._contentLength = source.length;\n    this._headersCapability = Promise.withResolvers();\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n    this._abortController = new AbortController();\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n    const headers = new Headers(stream.headers);\n    const url = source.url;\n    fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then(response => {\n      stream._responseOrigin = getResponseOrigin(response.url);\n      if (!validateResponseStatus(response.status)) {\n        throw createResponseError(response.status, url);\n      }\n      this._reader = response.body.getReader();\n      this._headersCapability.resolve();\n      const responseHeaders = response.headers;\n      const {\n        allowRangeRequests,\n        suggestedLength\n      } = validateRangeRequestCapabilities({\n        responseHeaders,\n        isHttp: stream.isHttp,\n        rangeChunkSize: this._rangeChunkSize,\n        disableRange: this._disableRange\n      });\n      this._isRangeSupported = allowRangeRequests;\n      this._contentLength = suggestedLength || this._contentLength;\n      this._filename = extractFilenameFromHeader(responseHeaders);\n      if (!this._isStreamingSupported && this._isRangeSupported) {\n        this.cancel(new AbortException(\"Streaming is disabled.\"));\n      }\n    }).catch(this._headersCapability.reject);\n    this.onProgress = null;\n  }\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n  get filename() {\n    return this._filename;\n  }\n  get contentLength() {\n    return this._contentLength;\n  }\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  async read() {\n    await this._headersCapability.promise;\n    const {\n      value,\n      done\n    } = await this._reader.read();\n    if (done) {\n      return {\n        value,\n        done\n      };\n    }\n    this._loaded += value.byteLength;\n    this.onProgress?.({\n      loaded: this._loaded,\n      total: this._contentLength\n    });\n    return {\n      value: getArrayBuffer(value),\n      done: false\n    };\n  }\n  cancel(reason) {\n    this._reader?.cancel(reason);\n    this._abortController.abort();\n  }\n}\nclass PDFFetchStreamRangeReader {\n  constructor(stream, begin, end) {\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    const source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._readCapability = Promise.withResolvers();\n    this._isStreamingSupported = !source.disableStream;\n    this._abortController = new AbortController();\n    const headers = new Headers(stream.headers);\n    headers.append(\"Range\", `bytes=${begin}-${end - 1}`);\n    const url = source.url;\n    fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then(response => {\n      const responseOrigin = getResponseOrigin(response.url);\n      if (responseOrigin !== stream._responseOrigin) {\n        throw new Error(`Expected range response-origin \"${responseOrigin}\" to match \"${stream._responseOrigin}\".`);\n      }\n      if (!validateResponseStatus(response.status)) {\n        throw createResponseError(response.status, url);\n      }\n      this._readCapability.resolve();\n      this._reader = response.body.getReader();\n    }).catch(this._readCapability.reject);\n    this.onProgress = null;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  async read() {\n    await this._readCapability.promise;\n    const {\n      value,\n      done\n    } = await this._reader.read();\n    if (done) {\n      return {\n        value,\n        done\n      };\n    }\n    this._loaded += value.byteLength;\n    this.onProgress?.({\n      loaded: this._loaded\n    });\n    return {\n      value: getArrayBuffer(value),\n      done: false\n    };\n  }\n  cancel(reason) {\n    this._reader?.cancel(reason);\n    this._abortController.abort();\n  }\n}\n\n;// ./src/display/network.js\n\n\nconst OK_RESPONSE = 200;\nconst PARTIAL_CONTENT_RESPONSE = 206;\nfunction network_getArrayBuffer(xhr) {\n  const data = xhr.response;\n  if (typeof data !== \"string\") {\n    return data;\n  }\n  return stringToBytes(data).buffer;\n}\nclass NetworkManager {\n  _responseOrigin = null;\n  constructor({\n    url,\n    httpHeaders,\n    withCredentials\n  }) {\n    this.url = url;\n    this.isHttp = /^https?:/i.test(url);\n    this.headers = createHeaders(this.isHttp, httpHeaders);\n    this.withCredentials = withCredentials || false;\n    this.currXhrId = 0;\n    this.pendingRequests = Object.create(null);\n  }\n  request(args) {\n    const xhr = new XMLHttpRequest();\n    const xhrId = this.currXhrId++;\n    const pendingRequest = this.pendingRequests[xhrId] = {\n      xhr\n    };\n    xhr.open(\"GET\", this.url);\n    xhr.withCredentials = this.withCredentials;\n    for (const [key, val] of this.headers) {\n      xhr.setRequestHeader(key, val);\n    }\n    if (this.isHttp && \"begin\" in args && \"end\" in args) {\n      xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\n      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n    } else {\n      pendingRequest.expectedStatus = OK_RESPONSE;\n    }\n    xhr.responseType = \"arraybuffer\";\n    assert(args.onError, \"Expected `onError` callback to be provided.\");\n    xhr.onerror = () => {\n      args.onError(xhr.status);\n    };\n    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n    xhr.onprogress = this.onProgress.bind(this, xhrId);\n    pendingRequest.onHeadersReceived = args.onHeadersReceived;\n    pendingRequest.onDone = args.onDone;\n    pendingRequest.onError = args.onError;\n    pendingRequest.onProgress = args.onProgress;\n    xhr.send(null);\n    return xhrId;\n  }\n  onProgress(xhrId, evt) {\n    const pendingRequest = this.pendingRequests[xhrId];\n    if (!pendingRequest) {\n      return;\n    }\n    pendingRequest.onProgress?.(evt);\n  }\n  onStateChange(xhrId, evt) {\n    const pendingRequest = this.pendingRequests[xhrId];\n    if (!pendingRequest) {\n      return;\n    }\n    const xhr = pendingRequest.xhr;\n    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n      pendingRequest.onHeadersReceived();\n      delete pendingRequest.onHeadersReceived;\n    }\n    if (xhr.readyState !== 4) {\n      return;\n    }\n    if (!(xhrId in this.pendingRequests)) {\n      return;\n    }\n    delete this.pendingRequests[xhrId];\n    if (xhr.status === 0 && this.isHttp) {\n      pendingRequest.onError(xhr.status);\n      return;\n    }\n    const xhrStatus = xhr.status || OK_RESPONSE;\n    const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n      pendingRequest.onError(xhr.status);\n      return;\n    }\n    const chunk = network_getArrayBuffer(xhr);\n    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n      const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n      const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n      if (matches) {\n        pendingRequest.onDone({\n          begin: parseInt(matches[1], 10),\n          chunk\n        });\n      } else {\n        warn(`Missing or invalid \"Content-Range\" header.`);\n        pendingRequest.onError(0);\n      }\n    } else if (chunk) {\n      pendingRequest.onDone({\n        begin: 0,\n        chunk\n      });\n    } else {\n      pendingRequest.onError(xhr.status);\n    }\n  }\n  getRequestXhr(xhrId) {\n    return this.pendingRequests[xhrId].xhr;\n  }\n  isPendingRequest(xhrId) {\n    return xhrId in this.pendingRequests;\n  }\n  abortRequest(xhrId) {\n    const xhr = this.pendingRequests[xhrId].xhr;\n    delete this.pendingRequests[xhrId];\n    xhr.abort();\n  }\n}\nclass PDFNetworkStream {\n  constructor(source) {\n    this._source = source;\n    this._manager = new NetworkManager(source);\n    this._rangeChunkSize = source.rangeChunkSize;\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n  _onRangeRequestReaderClosed(reader) {\n    const i = this._rangeRequestReaders.indexOf(reader);\n    if (i >= 0) {\n      this._rangeRequestReaders.splice(i, 1);\n    }\n  }\n  getFullReader() {\n    assert(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n    return this._fullRequestReader;\n  }\n  getRangeReader(begin, end) {\n    const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n    this._rangeRequestReaders.push(reader);\n    return reader;\n  }\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n}\nclass PDFNetworkStreamFullRequestReader {\n  constructor(manager, source) {\n    this._manager = manager;\n    this._url = source.url;\n    this._fullRequestId = manager.request({\n      onHeadersReceived: this._onHeadersReceived.bind(this),\n      onDone: this._onDone.bind(this),\n      onError: this._onError.bind(this),\n      onProgress: this._onProgress.bind(this)\n    });\n    this._headersCapability = Promise.withResolvers();\n    this._disableRange = source.disableRange || false;\n    this._contentLength = source.length;\n    this._rangeChunkSize = source.rangeChunkSize;\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n    this._isStreamingSupported = false;\n    this._isRangeSupported = false;\n    this._cachedChunks = [];\n    this._requests = [];\n    this._done = false;\n    this._storedError = undefined;\n    this._filename = null;\n    this.onProgress = null;\n  }\n  _onHeadersReceived() {\n    const fullRequestXhrId = this._fullRequestId;\n    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n    this._manager._responseOrigin = getResponseOrigin(fullRequestXhr.responseURL);\n    const rawResponseHeaders = fullRequestXhr.getAllResponseHeaders();\n    const responseHeaders = new Headers(rawResponseHeaders ? rawResponseHeaders.trimStart().replace(/[^\\S ]+$/, \"\").split(/[\\r\\n]+/).map(x => {\n      const [key, ...val] = x.split(\": \");\n      return [key, val.join(\": \")];\n    }) : []);\n    const {\n      allowRangeRequests,\n      suggestedLength\n    } = validateRangeRequestCapabilities({\n      responseHeaders,\n      isHttp: this._manager.isHttp,\n      rangeChunkSize: this._rangeChunkSize,\n      disableRange: this._disableRange\n    });\n    if (allowRangeRequests) {\n      this._isRangeSupported = true;\n    }\n    this._contentLength = suggestedLength || this._contentLength;\n    this._filename = extractFilenameFromHeader(responseHeaders);\n    if (this._isRangeSupported) {\n      this._manager.abortRequest(fullRequestXhrId);\n    }\n    this._headersCapability.resolve();\n  }\n  _onDone(data) {\n    if (data) {\n      if (this._requests.length > 0) {\n        const requestCapability = this._requests.shift();\n        requestCapability.resolve({\n          value: data.chunk,\n          done: false\n        });\n      } else {\n        this._cachedChunks.push(data.chunk);\n      }\n    }\n    this._done = true;\n    if (this._cachedChunks.length > 0) {\n      return;\n    }\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n  }\n  _onError(status) {\n    this._storedError = createResponseError(status, this._url);\n    this._headersCapability.reject(this._storedError);\n    for (const requestCapability of this._requests) {\n      requestCapability.reject(this._storedError);\n    }\n    this._requests.length = 0;\n    this._cachedChunks.length = 0;\n  }\n  _onProgress(evt) {\n    this.onProgress?.({\n      loaded: evt.loaded,\n      total: evt.lengthComputable ? evt.total : this._contentLength\n    });\n  }\n  get filename() {\n    return this._filename;\n  }\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  get contentLength() {\n    return this._contentLength;\n  }\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n  async read() {\n    await this._headersCapability.promise;\n    if (this._storedError) {\n      throw this._storedError;\n    }\n    if (this._cachedChunks.length > 0) {\n      const chunk = this._cachedChunks.shift();\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    const requestCapability = Promise.withResolvers();\n    this._requests.push(requestCapability);\n    return requestCapability.promise;\n  }\n  cancel(reason) {\n    this._done = true;\n    this._headersCapability.reject(reason);\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n    if (this._manager.isPendingRequest(this._fullRequestId)) {\n      this._manager.abortRequest(this._fullRequestId);\n    }\n    this._fullRequestReader = null;\n  }\n}\nclass PDFNetworkStreamRangeRequestReader {\n  constructor(manager, begin, end) {\n    this._manager = manager;\n    this._url = manager.url;\n    this._requestId = manager.request({\n      begin,\n      end,\n      onHeadersReceived: this._onHeadersReceived.bind(this),\n      onDone: this._onDone.bind(this),\n      onError: this._onError.bind(this),\n      onProgress: this._onProgress.bind(this)\n    });\n    this._requests = [];\n    this._queuedChunk = null;\n    this._done = false;\n    this._storedError = undefined;\n    this.onProgress = null;\n    this.onClosed = null;\n  }\n  _onHeadersReceived() {\n    const responseOrigin = getResponseOrigin(this._manager.getRequestXhr(this._requestId)?.responseURL);\n    if (responseOrigin !== this._manager._responseOrigin) {\n      this._storedError = new Error(`Expected range response-origin \"${responseOrigin}\" to match \"${this._manager._responseOrigin}\".`);\n      this._onError(0);\n    }\n  }\n  _close() {\n    this.onClosed?.(this);\n  }\n  _onDone(data) {\n    const chunk = data.chunk;\n    if (this._requests.length > 0) {\n      const requestCapability = this._requests.shift();\n      requestCapability.resolve({\n        value: chunk,\n        done: false\n      });\n    } else {\n      this._queuedChunk = chunk;\n    }\n    this._done = true;\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n    this._close();\n  }\n  _onError(status) {\n    this._storedError ??= createResponseError(status, this._url);\n    for (const requestCapability of this._requests) {\n      requestCapability.reject(this._storedError);\n    }\n    this._requests.length = 0;\n    this._queuedChunk = null;\n  }\n  _onProgress(evt) {\n    if (!this.isStreamingSupported) {\n      this.onProgress?.({\n        loaded: evt.loaded\n      });\n    }\n  }\n  get isStreamingSupported() {\n    return false;\n  }\n  async read() {\n    if (this._storedError) {\n      throw this._storedError;\n    }\n    if (this._queuedChunk !== null) {\n      const chunk = this._queuedChunk;\n      this._queuedChunk = null;\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    const requestCapability = Promise.withResolvers();\n    this._requests.push(requestCapability);\n    return requestCapability.promise;\n  }\n  cancel(reason) {\n    this._done = true;\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n    if (this._manager.isPendingRequest(this._requestId)) {\n      this._manager.abortRequest(this._requestId);\n    }\n    this._close();\n  }\n}\n\n;// ./src/display/node_stream.js\n\n\nconst urlRegex = /^[a-z][a-z0-9\\-+.]+:/i;\nfunction parseUrlOrPath(sourceUrl) {\n  if (urlRegex.test(sourceUrl)) {\n    return new URL(sourceUrl);\n  }\n  const url = process.getBuiltinModule(\"url\");\n  return new URL(url.pathToFileURL(sourceUrl));\n}\nclass PDFNodeStream {\n  constructor(source) {\n    this.source = source;\n    this.url = parseUrlOrPath(source.url);\n    assert(this.url.protocol === \"file:\", \"PDFNodeStream only supports file:// URLs.\");\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n  getFullReader() {\n    assert(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n    this._fullRequestReader = new PDFNodeStreamFsFullReader(this);\n    return this._fullRequestReader;\n  }\n  getRangeReader(start, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n    const rangeReader = new PDFNodeStreamFsRangeReader(this, start, end);\n    this._rangeRequestReaders.push(rangeReader);\n    return rangeReader;\n  }\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n}\nclass PDFNodeStreamFsFullReader {\n  constructor(stream) {\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    const source = stream.source;\n    this._contentLength = source.length;\n    this._loaded = 0;\n    this._filename = null;\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n    this._readableStream = null;\n    this._readCapability = Promise.withResolvers();\n    this._headersCapability = Promise.withResolvers();\n    const fs = process.getBuiltinModule(\"fs\");\n    fs.promises.lstat(this._url).then(stat => {\n      this._contentLength = stat.size;\n      this._setReadableStream(fs.createReadStream(this._url));\n      this._headersCapability.resolve();\n    }, error => {\n      if (error.code === \"ENOENT\") {\n        error = createResponseError(0, this._url.href);\n      }\n      this._storedError = error;\n      this._headersCapability.reject(error);\n    });\n  }\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n  get filename() {\n    return this._filename;\n  }\n  get contentLength() {\n    return this._contentLength;\n  }\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  async read() {\n    await this._readCapability.promise;\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    if (this._storedError) {\n      throw this._storedError;\n    }\n    const chunk = this._readableStream.read();\n    if (chunk === null) {\n      this._readCapability = Promise.withResolvers();\n      return this.read();\n    }\n    this._loaded += chunk.length;\n    this.onProgress?.({\n      loaded: this._loaded,\n      total: this._contentLength\n    });\n    const buffer = new Uint8Array(chunk).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n  cancel(reason) {\n    if (!this._readableStream) {\n      this._error(reason);\n      return;\n    }\n    this._readableStream.destroy(reason);\n  }\n  _error(reason) {\n    this._storedError = reason;\n    this._readCapability.resolve();\n  }\n  _setReadableStream(readableStream) {\n    this._readableStream = readableStream;\n    readableStream.on(\"readable\", () => {\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"end\", () => {\n      readableStream.destroy();\n      this._done = true;\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"error\", reason => {\n      this._error(reason);\n    });\n    if (!this._isStreamingSupported && this._isRangeSupported) {\n      this._error(new AbortException(\"streaming is disabled\"));\n    }\n    if (this._storedError) {\n      this._readableStream.destroy(this._storedError);\n    }\n  }\n}\nclass PDFNodeStreamFsRangeReader {\n  constructor(stream, start, end) {\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    this._loaded = 0;\n    this._readableStream = null;\n    this._readCapability = Promise.withResolvers();\n    const source = stream.source;\n    this._isStreamingSupported = !source.disableStream;\n    const fs = process.getBuiltinModule(\"fs\");\n    this._setReadableStream(fs.createReadStream(this._url, {\n      start,\n      end: end - 1\n    }));\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  async read() {\n    await this._readCapability.promise;\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    if (this._storedError) {\n      throw this._storedError;\n    }\n    const chunk = this._readableStream.read();\n    if (chunk === null) {\n      this._readCapability = Promise.withResolvers();\n      return this.read();\n    }\n    this._loaded += chunk.length;\n    this.onProgress?.({\n      loaded: this._loaded\n    });\n    const buffer = new Uint8Array(chunk).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n  cancel(reason) {\n    if (!this._readableStream) {\n      this._error(reason);\n      return;\n    }\n    this._readableStream.destroy(reason);\n  }\n  _error(reason) {\n    this._storedError = reason;\n    this._readCapability.resolve();\n  }\n  _setReadableStream(readableStream) {\n    this._readableStream = readableStream;\n    readableStream.on(\"readable\", () => {\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"end\", () => {\n      readableStream.destroy();\n      this._done = true;\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"error\", reason => {\n      this._error(reason);\n    });\n    if (this._storedError) {\n      this._readableStream.destroy(this._storedError);\n    }\n  }\n}\n\n;// ./src/display/pdf_objects.js\nconst INITIAL_DATA = Symbol(\"INITIAL_DATA\");\nclass PDFObjects {\n  #objs = Object.create(null);\n  #ensureObj(objId) {\n    return this.#objs[objId] ||= {\n      ...Promise.withResolvers(),\n      data: INITIAL_DATA\n    };\n  }\n  get(objId, callback = null) {\n    if (callback) {\n      const obj = this.#ensureObj(objId);\n      obj.promise.then(() => callback(obj.data));\n      return null;\n    }\n    const obj = this.#objs[objId];\n    if (!obj || obj.data === INITIAL_DATA) {\n      throw new Error(`Requesting object that isn't resolved yet ${objId}.`);\n    }\n    return obj.data;\n  }\n  has(objId) {\n    const obj = this.#objs[objId];\n    return !!obj && obj.data !== INITIAL_DATA;\n  }\n  delete(objId) {\n    const obj = this.#objs[objId];\n    if (!obj || obj.data === INITIAL_DATA) {\n      return false;\n    }\n    delete this.#objs[objId];\n    return true;\n  }\n  resolve(objId, data = null) {\n    const obj = this.#ensureObj(objId);\n    obj.data = data;\n    obj.resolve();\n  }\n  clear() {\n    for (const objId in this.#objs) {\n      const {\n        data\n      } = this.#objs[objId];\n      data?.bitmap?.close();\n    }\n    this.#objs = Object.create(null);\n  }\n  *[Symbol.iterator]() {\n    for (const objId in this.#objs) {\n      const {\n        data\n      } = this.#objs[objId];\n      if (data === INITIAL_DATA) {\n        continue;\n      }\n      yield [objId, data];\n    }\n  }\n}\n\n;// ./src/display/text_layer.js\n\n\nconst MAX_TEXT_DIVS_TO_RENDER = 100000;\nconst DEFAULT_FONT_SIZE = 30;\nclass TextLayer {\n  #capability = Promise.withResolvers();\n  #container = null;\n  #disableProcessItems = false;\n  #fontInspectorEnabled = !!globalThis.FontInspector?.enabled;\n  #lang = null;\n  #layoutTextParams = null;\n  #pageHeight = 0;\n  #pageWidth = 0;\n  #reader = null;\n  #rootContainer = null;\n  #rotation = 0;\n  #scale = 0;\n  #styleCache = Object.create(null);\n  #textContentItemsStr = [];\n  #textContentSource = null;\n  #textDivs = [];\n  #textDivProperties = new WeakMap();\n  #transform = null;\n  static #ascentCache = new Map();\n  static #canvasContexts = new Map();\n  static #canvasCtxFonts = new WeakMap();\n  static #minFontSize = null;\n  static #pendingTextLayers = new Set();\n  constructor({\n    textContentSource,\n    container,\n    viewport\n  }) {\n    if (textContentSource instanceof ReadableStream) {\n      this.#textContentSource = textContentSource;\n    } else if (typeof textContentSource === \"object\") {\n      this.#textContentSource = new ReadableStream({\n        start(controller) {\n          controller.enqueue(textContentSource);\n          controller.close();\n        }\n      });\n    } else {\n      throw new Error('No \"textContentSource\" parameter specified.');\n    }\n    this.#container = this.#rootContainer = container;\n    this.#scale = viewport.scale * OutputScale.pixelRatio;\n    this.#rotation = viewport.rotation;\n    this.#layoutTextParams = {\n      div: null,\n      properties: null,\n      ctx: null\n    };\n    const {\n      pageWidth,\n      pageHeight,\n      pageX,\n      pageY\n    } = viewport.rawDims;\n    this.#transform = [1, 0, 0, -1, -pageX, pageY + pageHeight];\n    this.#pageWidth = pageWidth;\n    this.#pageHeight = pageHeight;\n    TextLayer.#ensureMinFontSizeComputed();\n    setLayerDimensions(container, viewport);\n    this.#capability.promise.finally(() => {\n      TextLayer.#pendingTextLayers.delete(this);\n      this.#layoutTextParams = null;\n      this.#styleCache = null;\n    }).catch(() => {});\n  }\n  static get fontFamilyMap() {\n    const {\n      isWindows,\n      isFirefox\n    } = util_FeatureTest.platform;\n    return shadow(this, \"fontFamilyMap\", new Map([[\"sans-serif\", `${isWindows && isFirefox ? \"Calibri, \" : \"\"}sans-serif`], [\"monospace\", `${isWindows && isFirefox ? \"Lucida Console, \" : \"\"}monospace`]]));\n  }\n  render() {\n    const pump = () => {\n      this.#reader.read().then(({\n        value,\n        done\n      }) => {\n        if (done) {\n          this.#capability.resolve();\n          return;\n        }\n        this.#lang ??= value.lang;\n        Object.assign(this.#styleCache, value.styles);\n        this.#processItems(value.items);\n        pump();\n      }, this.#capability.reject);\n    };\n    this.#reader = this.#textContentSource.getReader();\n    TextLayer.#pendingTextLayers.add(this);\n    pump();\n    return this.#capability.promise;\n  }\n  update({\n    viewport,\n    onBefore = null\n  }) {\n    const scale = viewport.scale * OutputScale.pixelRatio;\n    const rotation = viewport.rotation;\n    if (rotation !== this.#rotation) {\n      onBefore?.();\n      this.#rotation = rotation;\n      setLayerDimensions(this.#rootContainer, {\n        rotation\n      });\n    }\n    if (scale !== this.#scale) {\n      onBefore?.();\n      this.#scale = scale;\n      const params = {\n        div: null,\n        properties: null,\n        ctx: TextLayer.#getCtx(this.#lang)\n      };\n      for (const div of this.#textDivs) {\n        params.properties = this.#textDivProperties.get(div);\n        params.div = div;\n        this.#layout(params);\n      }\n    }\n  }\n  cancel() {\n    const abortEx = new AbortException(\"TextLayer task cancelled.\");\n    this.#reader?.cancel(abortEx).catch(() => {});\n    this.#reader = null;\n    this.#capability.reject(abortEx);\n  }\n  get textDivs() {\n    return this.#textDivs;\n  }\n  get textContentItemsStr() {\n    return this.#textContentItemsStr;\n  }\n  #processItems(items) {\n    if (this.#disableProcessItems) {\n      return;\n    }\n    this.#layoutTextParams.ctx ??= TextLayer.#getCtx(this.#lang);\n    const textDivs = this.#textDivs,\n      textContentItemsStr = this.#textContentItemsStr;\n    for (const item of items) {\n      if (textDivs.length > MAX_TEXT_DIVS_TO_RENDER) {\n        warn(\"Ignoring additional textDivs for performance reasons.\");\n        this.#disableProcessItems = true;\n        return;\n      }\n      if (item.str === undefined) {\n        if (item.type === \"beginMarkedContentProps\" || item.type === \"beginMarkedContent\") {\n          const parent = this.#container;\n          this.#container = document.createElement(\"span\");\n          this.#container.classList.add(\"markedContent\");\n          if (item.id) {\n            this.#container.setAttribute(\"id\", `${item.id}`);\n          }\n          parent.append(this.#container);\n        } else if (item.type === \"endMarkedContent\") {\n          this.#container = this.#container.parentNode;\n        }\n        continue;\n      }\n      textContentItemsStr.push(item.str);\n      this.#appendText(item);\n    }\n  }\n  #appendText(geom) {\n    const textDiv = document.createElement(\"span\");\n    const textDivProperties = {\n      angle: 0,\n      canvasWidth: 0,\n      hasText: geom.str !== \"\",\n      hasEOL: geom.hasEOL,\n      fontSize: 0\n    };\n    this.#textDivs.push(textDiv);\n    const tx = Util.transform(this.#transform, geom.transform);\n    let angle = Math.atan2(tx[1], tx[0]);\n    const style = this.#styleCache[geom.fontName];\n    if (style.vertical) {\n      angle += Math.PI / 2;\n    }\n    let fontFamily = this.#fontInspectorEnabled && style.fontSubstitution || style.fontFamily;\n    fontFamily = TextLayer.fontFamilyMap.get(fontFamily) || fontFamily;\n    const fontHeight = Math.hypot(tx[2], tx[3]);\n    const fontAscent = fontHeight * TextLayer.#getAscent(fontFamily, style, this.#lang);\n    let left, top;\n    if (angle === 0) {\n      left = tx[4];\n      top = tx[5] - fontAscent;\n    } else {\n      left = tx[4] + fontAscent * Math.sin(angle);\n      top = tx[5] - fontAscent * Math.cos(angle);\n    }\n    const scaleFactorStr = \"calc(var(--total-scale-factor) *\";\n    const divStyle = textDiv.style;\n    if (this.#container === this.#rootContainer) {\n      divStyle.left = `${(100 * left / this.#pageWidth).toFixed(2)}%`;\n      divStyle.top = `${(100 * top / this.#pageHeight).toFixed(2)}%`;\n    } else {\n      divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;\n      divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;\n    }\n    divStyle.fontSize = `${scaleFactorStr}${(TextLayer.#minFontSize * fontHeight).toFixed(2)}px)`;\n    divStyle.fontFamily = fontFamily;\n    textDivProperties.fontSize = fontHeight;\n    textDiv.setAttribute(\"role\", \"presentation\");\n    textDiv.textContent = geom.str;\n    textDiv.dir = geom.dir;\n    if (this.#fontInspectorEnabled) {\n      textDiv.dataset.fontName = style.fontSubstitutionLoadedName || geom.fontName;\n    }\n    if (angle !== 0) {\n      textDivProperties.angle = angle * (180 / Math.PI);\n    }\n    let shouldScaleText = false;\n    if (geom.str.length > 1) {\n      shouldScaleText = true;\n    } else if (geom.str !== \" \" && geom.transform[0] !== geom.transform[3]) {\n      const absScaleX = Math.abs(geom.transform[0]),\n        absScaleY = Math.abs(geom.transform[3]);\n      if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n        shouldScaleText = true;\n      }\n    }\n    if (shouldScaleText) {\n      textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;\n    }\n    this.#textDivProperties.set(textDiv, textDivProperties);\n    this.#layoutTextParams.div = textDiv;\n    this.#layoutTextParams.properties = textDivProperties;\n    this.#layout(this.#layoutTextParams);\n    if (textDivProperties.hasText) {\n      this.#container.append(textDiv);\n    }\n    if (textDivProperties.hasEOL) {\n      const br = document.createElement(\"br\");\n      br.setAttribute(\"role\", \"presentation\");\n      this.#container.append(br);\n    }\n  }\n  #layout(params) {\n    const {\n      div,\n      properties,\n      ctx\n    } = params;\n    const {\n      style\n    } = div;\n    let transform = \"\";\n    if (TextLayer.#minFontSize > 1) {\n      transform = `scale(${1 / TextLayer.#minFontSize})`;\n    }\n    if (properties.canvasWidth !== 0 && properties.hasText) {\n      const {\n        fontFamily\n      } = style;\n      const {\n        canvasWidth,\n        fontSize\n      } = properties;\n      TextLayer.#ensureCtxFont(ctx, fontSize * this.#scale, fontFamily);\n      const {\n        width\n      } = ctx.measureText(div.textContent);\n      if (width > 0) {\n        transform = `scaleX(${canvasWidth * this.#scale / width}) ${transform}`;\n      }\n    }\n    if (properties.angle !== 0) {\n      transform = `rotate(${properties.angle}deg) ${transform}`;\n    }\n    if (transform.length > 0) {\n      style.transform = transform;\n    }\n  }\n  static cleanup() {\n    if (this.#pendingTextLayers.size > 0) {\n      return;\n    }\n    this.#ascentCache.clear();\n    for (const {\n      canvas\n    } of this.#canvasContexts.values()) {\n      canvas.remove();\n    }\n    this.#canvasContexts.clear();\n  }\n  static #getCtx(lang = null) {\n    let ctx = this.#canvasContexts.get(lang ||= \"\");\n    if (!ctx) {\n      const canvas = document.createElement(\"canvas\");\n      canvas.className = \"hiddenCanvasElement\";\n      canvas.lang = lang;\n      document.body.append(canvas);\n      ctx = canvas.getContext(\"2d\", {\n        alpha: false,\n        willReadFrequently: true\n      });\n      this.#canvasContexts.set(lang, ctx);\n      this.#canvasCtxFonts.set(ctx, {\n        size: 0,\n        family: \"\"\n      });\n    }\n    return ctx;\n  }\n  static #ensureCtxFont(ctx, size, family) {\n    const cached = this.#canvasCtxFonts.get(ctx);\n    if (size === cached.size && family === cached.family) {\n      return;\n    }\n    ctx.font = `${size}px ${family}`;\n    cached.size = size;\n    cached.family = family;\n  }\n  static #ensureMinFontSizeComputed() {\n    if (this.#minFontSize !== null) {\n      return;\n    }\n    const div = document.createElement(\"div\");\n    div.style.opacity = 0;\n    div.style.lineHeight = 1;\n    div.style.fontSize = \"1px\";\n    div.style.position = \"absolute\";\n    div.textContent = \"X\";\n    document.body.append(div);\n    this.#minFontSize = div.getBoundingClientRect().height;\n    div.remove();\n  }\n  static #getAscent(fontFamily, style, lang) {\n    const cachedAscent = this.#ascentCache.get(fontFamily);\n    if (cachedAscent) {\n      return cachedAscent;\n    }\n    const ctx = this.#getCtx(lang);\n    ctx.canvas.width = ctx.canvas.height = DEFAULT_FONT_SIZE;\n    this.#ensureCtxFont(ctx, DEFAULT_FONT_SIZE, fontFamily);\n    const metrics = ctx.measureText(\"\");\n    const ascent = metrics.fontBoundingBoxAscent;\n    const descent = Math.abs(metrics.fontBoundingBoxDescent);\n    ctx.canvas.width = ctx.canvas.height = 0;\n    let ratio = 0.8;\n    if (ascent) {\n      ratio = ascent / (ascent + descent);\n    } else {\n      if (util_FeatureTest.platform.isFirefox) {\n        warn(\"Enable the `dom.textMetrics.fontBoundingBox.enabled` preference \" + \"in `about:config` to improve TextLayer rendering.\");\n      }\n      if (style.ascent) {\n        ratio = style.ascent;\n      } else if (style.descent) {\n        ratio = 1 + style.descent;\n      }\n    }\n    this.#ascentCache.set(fontFamily, ratio);\n    return ratio;\n  }\n}\n\n;// ./src/display/xfa_text.js\nclass XfaText {\n  static textContent(xfa) {\n    const items = [];\n    const output = {\n      items,\n      styles: Object.create(null)\n    };\n    function walk(node) {\n      if (!node) {\n        return;\n      }\n      let str = null;\n      const name = node.name;\n      if (name === \"#text\") {\n        str = node.value;\n      } else if (!XfaText.shouldBuildText(name)) {\n        return;\n      } else if (node?.attributes?.textContent) {\n        str = node.attributes.textContent;\n      } else if (node.value) {\n        str = node.value;\n      }\n      if (str !== null) {\n        items.push({\n          str\n        });\n      }\n      if (!node.children) {\n        return;\n      }\n      for (const child of node.children) {\n        walk(child);\n      }\n    }\n    walk(xfa);\n    return output;\n  }\n  static shouldBuildText(name) {\n    return !(name === \"textarea\" || name === \"input\" || name === \"option\" || name === \"select\");\n  }\n}\n\n;// ./src/display/api.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst RENDERING_CANCELLED_TIMEOUT = 100;\nfunction getDocument(src = {}) {\n  if (typeof src === \"string\" || src instanceof URL) {\n    src = {\n      url: src\n    };\n  } else if (src instanceof ArrayBuffer || ArrayBuffer.isView(src)) {\n    src = {\n      data: src\n    };\n  }\n  const task = new PDFDocumentLoadingTask();\n  const {\n    docId\n  } = task;\n  const url = src.url ? getUrlProp(src.url) : null;\n  const data = src.data ? getDataProp(src.data) : null;\n  const httpHeaders = src.httpHeaders || null;\n  const withCredentials = src.withCredentials === true;\n  const password = src.password ?? null;\n  const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;\n  const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : 2 ** 16;\n  let worker = src.worker instanceof PDFWorker ? src.worker : null;\n  const verbosity = src.verbosity;\n  const docBaseUrl = typeof src.docBaseUrl === \"string\" && !isDataScheme(src.docBaseUrl) ? src.docBaseUrl : null;\n  const cMapUrl = getFactoryUrlProp(src.cMapUrl);\n  const cMapPacked = src.cMapPacked !== false;\n  const CMapReaderFactory = src.CMapReaderFactory || (isNodeJS ? NodeCMapReaderFactory : DOMCMapReaderFactory);\n  const iccUrl = getFactoryUrlProp(src.iccUrl);\n  const standardFontDataUrl = getFactoryUrlProp(src.standardFontDataUrl);\n  const StandardFontDataFactory = src.StandardFontDataFactory || (isNodeJS ? NodeStandardFontDataFactory : DOMStandardFontDataFactory);\n  const wasmUrl = getFactoryUrlProp(src.wasmUrl);\n  const WasmFactory = src.WasmFactory || (isNodeJS ? NodeWasmFactory : DOMWasmFactory);\n  const ignoreErrors = src.stopAtErrors !== true;\n  const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;\n  const isEvalSupported = src.isEvalSupported !== false;\n  const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === \"boolean\" ? src.isOffscreenCanvasSupported : !isNodeJS;\n  const isImageDecoderSupported = typeof src.isImageDecoderSupported === \"boolean\" ? src.isImageDecoderSupported : !isNodeJS && (util_FeatureTest.platform.isFirefox || !globalThis.chrome);\n  const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;\n  const disableFontFace = typeof src.disableFontFace === \"boolean\" ? src.disableFontFace : isNodeJS;\n  const fontExtraProperties = src.fontExtraProperties === true;\n  const enableXfa = src.enableXfa === true;\n  const ownerDocument = src.ownerDocument || globalThis.document;\n  const disableRange = src.disableRange === true;\n  const disableStream = src.disableStream === true;\n  const disableAutoFetch = src.disableAutoFetch === true;\n  const pdfBug = src.pdfBug === true;\n  const CanvasFactory = src.CanvasFactory || (isNodeJS ? NodeCanvasFactory : DOMCanvasFactory);\n  const FilterFactory = src.FilterFactory || (isNodeJS ? NodeFilterFactory : DOMFilterFactory);\n  const enableHWA = src.enableHWA === true;\n  const useWasm = src.useWasm !== false;\n  const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;\n  const useSystemFonts = typeof src.useSystemFonts === \"boolean\" ? src.useSystemFonts : !isNodeJS && !disableFontFace;\n  const useWorkerFetch = typeof src.useWorkerFetch === \"boolean\" ? src.useWorkerFetch : !!(CMapReaderFactory === DOMCMapReaderFactory && StandardFontDataFactory === DOMStandardFontDataFactory && WasmFactory === DOMWasmFactory && cMapUrl && standardFontDataUrl && wasmUrl && isValidFetchUrl(cMapUrl, document.baseURI) && isValidFetchUrl(standardFontDataUrl, document.baseURI) && isValidFetchUrl(wasmUrl, document.baseURI));\n  const styleElement = null;\n  setVerbosityLevel(verbosity);\n  const transportFactory = {\n    canvasFactory: new CanvasFactory({\n      ownerDocument,\n      enableHWA\n    }),\n    filterFactory: new FilterFactory({\n      docId,\n      ownerDocument\n    }),\n    cMapReaderFactory: useWorkerFetch ? null : new CMapReaderFactory({\n      baseUrl: cMapUrl,\n      isCompressed: cMapPacked\n    }),\n    standardFontDataFactory: useWorkerFetch ? null : new StandardFontDataFactory({\n      baseUrl: standardFontDataUrl\n    }),\n    wasmFactory: useWorkerFetch ? null : new WasmFactory({\n      baseUrl: wasmUrl\n    })\n  };\n  if (!worker) {\n    worker = PDFWorker.create({\n      verbosity,\n      port: GlobalWorkerOptions.workerPort\n    });\n    task._worker = worker;\n  }\n  const docParams = {\n    docId,\n    apiVersion: \"5.4.149\",\n    data,\n    password,\n    disableAutoFetch,\n    rangeChunkSize,\n    length,\n    docBaseUrl,\n    enableXfa,\n    evaluatorOptions: {\n      maxImageSize,\n      disableFontFace,\n      ignoreErrors,\n      isEvalSupported,\n      isOffscreenCanvasSupported,\n      isImageDecoderSupported,\n      canvasMaxAreaInBytes,\n      fontExtraProperties,\n      useSystemFonts,\n      useWasm,\n      useWorkerFetch,\n      cMapUrl,\n      iccUrl,\n      standardFontDataUrl,\n      wasmUrl\n    }\n  };\n  const transportParams = {\n    ownerDocument,\n    pdfBug,\n    styleElement,\n    loadingParams: {\n      disableAutoFetch,\n      enableXfa\n    }\n  };\n  worker.promise.then(function () {\n    if (task.destroyed) {\n      throw new Error(\"Loading aborted\");\n    }\n    if (worker.destroyed) {\n      throw new Error(\"Worker was destroyed\");\n    }\n    const workerIdPromise = worker.messageHandler.sendWithPromise(\"GetDocRequest\", docParams, data ? [data.buffer] : null);\n    let networkStream;\n    if (rangeTransport) {\n      networkStream = new PDFDataTransportStream(rangeTransport, {\n        disableRange,\n        disableStream\n      });\n    } else if (!data) {\n      if (!url) {\n        throw new Error(\"getDocument - no `url` parameter provided.\");\n      }\n      const NetworkStream = isValidFetchUrl(url) ? PDFFetchStream : isNodeJS ? PDFNodeStream : PDFNetworkStream;\n      networkStream = new NetworkStream({\n        url,\n        length,\n        httpHeaders,\n        withCredentials,\n        rangeChunkSize,\n        disableRange,\n        disableStream\n      });\n    }\n    return workerIdPromise.then(workerId => {\n      if (task.destroyed) {\n        throw new Error(\"Loading aborted\");\n      }\n      if (worker.destroyed) {\n        throw new Error(\"Worker was destroyed\");\n      }\n      const messageHandler = new MessageHandler(docId, workerId, worker.port);\n      const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory, enableHWA);\n      task._transport = transport;\n      messageHandler.send(\"Ready\", null);\n    });\n  }).catch(task._capability.reject);\n  return task;\n}\nclass PDFDocumentLoadingTask {\n  static #docId = 0;\n  _capability = Promise.withResolvers();\n  _transport = null;\n  _worker = null;\n  docId = `d${PDFDocumentLoadingTask.#docId++}`;\n  destroyed = false;\n  onPassword = null;\n  onProgress = null;\n  get promise() {\n    return this._capability.promise;\n  }\n  async destroy() {\n    this.destroyed = true;\n    try {\n      if (this._worker?.port) {\n        this._worker._pendingDestroy = true;\n      }\n      await this._transport?.destroy();\n    } catch (ex) {\n      if (this._worker?.port) {\n        delete this._worker._pendingDestroy;\n      }\n      throw ex;\n    }\n    this._transport = null;\n    this._worker?.destroy();\n    this._worker = null;\n  }\n  async getData() {\n    return this._transport.getData();\n  }\n}\nclass PDFDataRangeTransport {\n  #capability = Promise.withResolvers();\n  #progressiveDoneListeners = [];\n  #progressiveReadListeners = [];\n  #progressListeners = [];\n  #rangeListeners = [];\n  constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {\n    this.length = length;\n    this.initialData = initialData;\n    this.progressiveDone = progressiveDone;\n    this.contentDispositionFilename = contentDispositionFilename;\n  }\n  addRangeListener(listener) {\n    this.#rangeListeners.push(listener);\n  }\n  addProgressListener(listener) {\n    this.#progressListeners.push(listener);\n  }\n  addProgressiveReadListener(listener) {\n    this.#progressiveReadListeners.push(listener);\n  }\n  addProgressiveDoneListener(listener) {\n    this.#progressiveDoneListeners.push(listener);\n  }\n  onDataRange(begin, chunk) {\n    for (const listener of this.#rangeListeners) {\n      listener(begin, chunk);\n    }\n  }\n  onDataProgress(loaded, total) {\n    this.#capability.promise.then(() => {\n      for (const listener of this.#progressListeners) {\n        listener(loaded, total);\n      }\n    });\n  }\n  onDataProgressiveRead(chunk) {\n    this.#capability.promise.then(() => {\n      for (const listener of this.#progressiveReadListeners) {\n        listener(chunk);\n      }\n    });\n  }\n  onDataProgressiveDone() {\n    this.#capability.promise.then(() => {\n      for (const listener of this.#progressiveDoneListeners) {\n        listener();\n      }\n    });\n  }\n  transportReady() {\n    this.#capability.resolve();\n  }\n  requestDataRange(begin, end) {\n    unreachable(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n  }\n  abort() {}\n}\nclass PDFDocumentProxy {\n  constructor(pdfInfo, transport) {\n    this._pdfInfo = pdfInfo;\n    this._transport = transport;\n  }\n  get annotationStorage() {\n    return this._transport.annotationStorage;\n  }\n  get canvasFactory() {\n    return this._transport.canvasFactory;\n  }\n  get filterFactory() {\n    return this._transport.filterFactory;\n  }\n  get numPages() {\n    return this._pdfInfo.numPages;\n  }\n  get fingerprints() {\n    return this._pdfInfo.fingerprints;\n  }\n  get isPureXfa() {\n    return shadow(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n  }\n  get allXfaHtml() {\n    return this._transport._htmlForXfa;\n  }\n  getPage(pageNumber) {\n    return this._transport.getPage(pageNumber);\n  }\n  getPageIndex(ref) {\n    return this._transport.getPageIndex(ref);\n  }\n  getDestinations() {\n    return this._transport.getDestinations();\n  }\n  getDestination(id) {\n    return this._transport.getDestination(id);\n  }\n  getPageLabels() {\n    return this._transport.getPageLabels();\n  }\n  getPageLayout() {\n    return this._transport.getPageLayout();\n  }\n  getPageMode() {\n    return this._transport.getPageMode();\n  }\n  getViewerPreferences() {\n    return this._transport.getViewerPreferences();\n  }\n  getOpenAction() {\n    return this._transport.getOpenAction();\n  }\n  getAttachments() {\n    return this._transport.getAttachments();\n  }\n  getAnnotationsByType(types, pageIndexesToSkip) {\n    return this._transport.getAnnotationsByType(types, pageIndexesToSkip);\n  }\n  getJSActions() {\n    return this._transport.getDocJSActions();\n  }\n  getOutline() {\n    return this._transport.getOutline();\n  }\n  getOptionalContentConfig({\n    intent = \"display\"\n  } = {}) {\n    const {\n      renderingIntent\n    } = this._transport.getRenderingIntent(intent);\n    return this._transport.getOptionalContentConfig(renderingIntent);\n  }\n  getPermissions() {\n    return this._transport.getPermissions();\n  }\n  getMetadata() {\n    return this._transport.getMetadata();\n  }\n  getMarkInfo() {\n    return this._transport.getMarkInfo();\n  }\n  getData() {\n    return this._transport.getData();\n  }\n  saveDocument() {\n    return this._transport.saveDocument();\n  }\n  getDownloadInfo() {\n    return this._transport.downloadInfoCapability.promise;\n  }\n  cleanup(keepLoadedFonts = false) {\n    return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);\n  }\n  destroy() {\n    return this.loadingTask.destroy();\n  }\n  cachedPageNumber(ref) {\n    return this._transport.cachedPageNumber(ref);\n  }\n  get loadingParams() {\n    return this._transport.loadingParams;\n  }\n  get loadingTask() {\n    return this._transport.loadingTask;\n  }\n  getFieldObjects() {\n    return this._transport.getFieldObjects();\n  }\n  hasJSActions() {\n    return this._transport.hasJSActions();\n  }\n  getCalculationOrderIds() {\n    return this._transport.getCalculationOrderIds();\n  }\n}\nclass PDFPageProxy {\n  #pendingCleanup = false;\n  constructor(pageIndex, pageInfo, transport, pdfBug = false) {\n    this._pageIndex = pageIndex;\n    this._pageInfo = pageInfo;\n    this._transport = transport;\n    this._stats = pdfBug ? new StatTimer() : null;\n    this._pdfBug = pdfBug;\n    this.commonObjs = transport.commonObjs;\n    this.objs = new PDFObjects();\n    this._intentStates = new Map();\n    this.destroyed = false;\n    this.recordedGroups = null;\n  }\n  get pageNumber() {\n    return this._pageIndex + 1;\n  }\n  get rotate() {\n    return this._pageInfo.rotate;\n  }\n  get ref() {\n    return this._pageInfo.ref;\n  }\n  get userUnit() {\n    return this._pageInfo.userUnit;\n  }\n  get view() {\n    return this._pageInfo.view;\n  }\n  getViewport({\n    scale,\n    rotation = this.rotate,\n    offsetX = 0,\n    offsetY = 0,\n    dontFlip = false\n  } = {}) {\n    return new PageViewport({\n      viewBox: this.view,\n      userUnit: this.userUnit,\n      scale,\n      rotation,\n      offsetX,\n      offsetY,\n      dontFlip\n    });\n  }\n  getAnnotations({\n    intent = \"display\"\n  } = {}) {\n    const {\n      renderingIntent\n    } = this._transport.getRenderingIntent(intent);\n    return this._transport.getAnnotations(this._pageIndex, renderingIntent);\n  }\n  getJSActions() {\n    return this._transport.getPageJSActions(this._pageIndex);\n  }\n  get filterFactory() {\n    return this._transport.filterFactory;\n  }\n  get isPureXfa() {\n    return shadow(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n  }\n  async getXfa() {\n    return this._transport._htmlForXfa?.children[this._pageIndex] || null;\n  }\n  render({\n    canvasContext,\n    canvas = canvasContext.canvas,\n    viewport,\n    intent = \"display\",\n    annotationMode = AnnotationMode.ENABLE,\n    transform = null,\n    background = null,\n    optionalContentConfigPromise = null,\n    annotationCanvasMap = null,\n    pageColors = null,\n    printAnnotationStorage = null,\n    isEditing = false,\n    recordOperations = false,\n    filteredOperationIndexes = null\n  }) {\n    this._stats?.time(\"Overall\");\n    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing);\n    const {\n      renderingIntent,\n      cacheKey\n    } = intentArgs;\n    this.#pendingCleanup = false;\n    optionalContentConfigPromise ||= this._transport.getOptionalContentConfig(renderingIntent);\n    let intentState = this._intentStates.get(cacheKey);\n    if (!intentState) {\n      intentState = Object.create(null);\n      this._intentStates.set(cacheKey, intentState);\n    }\n    if (intentState.streamReaderCancelTimeout) {\n      clearTimeout(intentState.streamReaderCancelTimeout);\n      intentState.streamReaderCancelTimeout = null;\n    }\n    const intentPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);\n    if (!intentState.displayReadyCapability) {\n      intentState.displayReadyCapability = Promise.withResolvers();\n      intentState.operatorList = {\n        fnArray: [],\n        argsArray: [],\n        lastChunk: false,\n        separateAnnots: null\n      };\n      this._stats?.time(\"Page Request\");\n      this._pumpOperatorList(intentArgs);\n    }\n    const shouldRecordOperations = !this.recordedGroups && (recordOperations || this._pdfBug && globalThis.StepperManager?.enabled);\n    const complete = error => {\n      intentState.renderTasks.delete(internalRenderTask);\n      if (shouldRecordOperations) {\n        const recordedGroups = internalRenderTask.gfx?.dependencyTracker.take();\n        if (recordedGroups) {\n          internalRenderTask.stepper?.setOperatorGroups(recordedGroups);\n          if (recordOperations) {\n            this.recordedGroups = recordedGroups;\n          }\n        } else if (recordOperations) {\n          this.recordedGroups = [];\n        }\n      }\n      if (intentPrint) {\n        this.#pendingCleanup = true;\n      }\n      this.#tryCleanup();\n      if (error) {\n        internalRenderTask.capability.reject(error);\n        this._abortOperatorList({\n          intentState,\n          reason: error instanceof Error ? error : new Error(error)\n        });\n      } else {\n        internalRenderTask.capability.resolve();\n      }\n      if (this._stats) {\n        this._stats.timeEnd(\"Rendering\");\n        this._stats.timeEnd(\"Overall\");\n        if (globalThis.Stats?.enabled) {\n          globalThis.Stats.add(this.pageNumber, this._stats);\n        }\n      }\n    };\n    const internalRenderTask = new InternalRenderTask({\n      callback: complete,\n      params: {\n        canvas,\n        canvasContext,\n        dependencyTracker: shouldRecordOperations ? new CanvasDependencyTracker(canvas) : null,\n        viewport,\n        transform,\n        background\n      },\n      objs: this.objs,\n      commonObjs: this.commonObjs,\n      annotationCanvasMap,\n      operatorList: intentState.operatorList,\n      pageIndex: this._pageIndex,\n      canvasFactory: this._transport.canvasFactory,\n      filterFactory: this._transport.filterFactory,\n      useRequestAnimationFrame: !intentPrint,\n      pdfBug: this._pdfBug,\n      pageColors,\n      enableHWA: this._transport.enableHWA,\n      filteredOperationIndexes\n    });\n    (intentState.renderTasks ||= new Set()).add(internalRenderTask);\n    const renderTask = internalRenderTask.task;\n    Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {\n      if (this.destroyed) {\n        complete();\n        return;\n      }\n      this._stats?.time(\"Rendering\");\n      if (!(optionalContentConfig.renderingIntent & renderingIntent)) {\n        throw new Error(\"Must use the same `intent`-argument when calling the `PDFPageProxy.render` \" + \"and `PDFDocumentProxy.getOptionalContentConfig` methods.\");\n      }\n      internalRenderTask.initializeGraphics({\n        transparency,\n        optionalContentConfig\n      });\n      internalRenderTask.operatorListChanged();\n    }).catch(complete);\n    return renderTask;\n  }\n  getOperatorList({\n    intent = \"display\",\n    annotationMode = AnnotationMode.ENABLE,\n    printAnnotationStorage = null,\n    isEditing = false\n  } = {}) {\n    function operatorListChanged() {\n      if (intentState.operatorList.lastChunk) {\n        intentState.opListReadCapability.resolve(intentState.operatorList);\n        intentState.renderTasks.delete(opListTask);\n      }\n    }\n    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing, true);\n    let intentState = this._intentStates.get(intentArgs.cacheKey);\n    if (!intentState) {\n      intentState = Object.create(null);\n      this._intentStates.set(intentArgs.cacheKey, intentState);\n    }\n    let opListTask;\n    if (!intentState.opListReadCapability) {\n      opListTask = Object.create(null);\n      opListTask.operatorListChanged = operatorListChanged;\n      intentState.opListReadCapability = Promise.withResolvers();\n      (intentState.renderTasks ||= new Set()).add(opListTask);\n      intentState.operatorList = {\n        fnArray: [],\n        argsArray: [],\n        lastChunk: false,\n        separateAnnots: null\n      };\n      this._stats?.time(\"Page Request\");\n      this._pumpOperatorList(intentArgs);\n    }\n    return intentState.opListReadCapability.promise;\n  }\n  streamTextContent({\n    includeMarkedContent = false,\n    disableNormalization = false\n  } = {}) {\n    const TEXT_CONTENT_CHUNK_SIZE = 100;\n    return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n      pageIndex: this._pageIndex,\n      includeMarkedContent: includeMarkedContent === true,\n      disableNormalization: disableNormalization === true\n    }, {\n      highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n      size(textContent) {\n        return textContent.items.length;\n      }\n    });\n  }\n  getTextContent(params = {}) {\n    if (this._transport._htmlForXfa) {\n      return this.getXfa().then(xfa => XfaText.textContent(xfa));\n    }\n    const readableStream = this.streamTextContent(params);\n    return new Promise(function (resolve, reject) {\n      function pump() {\n        reader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            resolve(textContent);\n            return;\n          }\n          textContent.lang ??= value.lang;\n          Object.assign(textContent.styles, value.styles);\n          textContent.items.push(...value.items);\n          pump();\n        }, reject);\n      }\n      const reader = readableStream.getReader();\n      const textContent = {\n        items: [],\n        styles: Object.create(null),\n        lang: null\n      };\n      pump();\n    });\n  }\n  getStructTree() {\n    return this._transport.getStructTree(this._pageIndex);\n  }\n  _destroy() {\n    this.destroyed = true;\n    const waitOn = [];\n    for (const intentState of this._intentStates.values()) {\n      this._abortOperatorList({\n        intentState,\n        reason: new Error(\"Page was destroyed.\"),\n        force: true\n      });\n      if (intentState.opListReadCapability) {\n        continue;\n      }\n      for (const internalRenderTask of intentState.renderTasks) {\n        waitOn.push(internalRenderTask.completed);\n        internalRenderTask.cancel();\n      }\n    }\n    this.objs.clear();\n    this.#pendingCleanup = false;\n    return Promise.all(waitOn);\n  }\n  cleanup(resetStats = false) {\n    this.#pendingCleanup = true;\n    const success = this.#tryCleanup();\n    if (resetStats && success) {\n      this._stats &&= new StatTimer();\n    }\n    return success;\n  }\n  #tryCleanup() {\n    if (!this.#pendingCleanup || this.destroyed) {\n      return false;\n    }\n    for (const {\n      renderTasks,\n      operatorList\n    } of this._intentStates.values()) {\n      if (renderTasks.size > 0 || !operatorList.lastChunk) {\n        return false;\n      }\n    }\n    this._intentStates.clear();\n    this.objs.clear();\n    this.#pendingCleanup = false;\n    return true;\n  }\n  _startRenderPage(transparency, cacheKey) {\n    const intentState = this._intentStates.get(cacheKey);\n    if (!intentState) {\n      return;\n    }\n    this._stats?.timeEnd(\"Page Request\");\n    intentState.displayReadyCapability?.resolve(transparency);\n  }\n  _renderPageChunk(operatorListChunk, intentState) {\n    for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {\n      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n    }\n    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n    intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;\n    for (const internalRenderTask of intentState.renderTasks) {\n      internalRenderTask.operatorListChanged();\n    }\n    if (operatorListChunk.lastChunk) {\n      this.#tryCleanup();\n    }\n  }\n  _pumpOperatorList({\n    renderingIntent,\n    cacheKey,\n    annotationStorageSerializable,\n    modifiedIds\n  }) {\n    const {\n      map,\n      transfer\n    } = annotationStorageSerializable;\n    const readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", {\n      pageIndex: this._pageIndex,\n      intent: renderingIntent,\n      cacheKey,\n      annotationStorage: map,\n      modifiedIds\n    }, transfer);\n    const reader = readableStream.getReader();\n    const intentState = this._intentStates.get(cacheKey);\n    intentState.streamReader = reader;\n    const pump = () => {\n      reader.read().then(({\n        value,\n        done\n      }) => {\n        if (done) {\n          intentState.streamReader = null;\n          return;\n        }\n        if (this._transport.destroyed) {\n          return;\n        }\n        this._renderPageChunk(value, intentState);\n        pump();\n      }, reason => {\n        intentState.streamReader = null;\n        if (this._transport.destroyed) {\n          return;\n        }\n        if (intentState.operatorList) {\n          intentState.operatorList.lastChunk = true;\n          for (const internalRenderTask of intentState.renderTasks) {\n            internalRenderTask.operatorListChanged();\n          }\n          this.#tryCleanup();\n        }\n        if (intentState.displayReadyCapability) {\n          intentState.displayReadyCapability.reject(reason);\n        } else if (intentState.opListReadCapability) {\n          intentState.opListReadCapability.reject(reason);\n        } else {\n          throw reason;\n        }\n      });\n    };\n    pump();\n  }\n  _abortOperatorList({\n    intentState,\n    reason,\n    force = false\n  }) {\n    if (!intentState.streamReader) {\n      return;\n    }\n    if (intentState.streamReaderCancelTimeout) {\n      clearTimeout(intentState.streamReaderCancelTimeout);\n      intentState.streamReaderCancelTimeout = null;\n    }\n    if (!force) {\n      if (intentState.renderTasks.size > 0) {\n        return;\n      }\n      if (reason instanceof RenderingCancelledException) {\n        let delay = RENDERING_CANCELLED_TIMEOUT;\n        if (reason.extraDelay > 0 && reason.extraDelay < 1000) {\n          delay += reason.extraDelay;\n        }\n        intentState.streamReaderCancelTimeout = setTimeout(() => {\n          intentState.streamReaderCancelTimeout = null;\n          this._abortOperatorList({\n            intentState,\n            reason,\n            force: true\n          });\n        }, delay);\n        return;\n      }\n    }\n    intentState.streamReader.cancel(new AbortException(reason.message)).catch(() => {});\n    intentState.streamReader = null;\n    if (this._transport.destroyed) {\n      return;\n    }\n    for (const [curCacheKey, curIntentState] of this._intentStates) {\n      if (curIntentState === intentState) {\n        this._intentStates.delete(curCacheKey);\n        break;\n      }\n    }\n    this.cleanup();\n  }\n  get stats() {\n    return this._stats;\n  }\n}\nclass PDFWorker {\n  #capability = Promise.withResolvers();\n  #messageHandler = null;\n  #port = null;\n  #webWorker = null;\n  static #fakeWorkerId = 0;\n  static #isWorkerDisabled = false;\n  static #workerPorts = new WeakMap();\n  static {\n    if (isNodeJS) {\n      this.#isWorkerDisabled = true;\n      GlobalWorkerOptions.workerSrc ||= \"./pdf.worker.mjs\";\n    }\n    this._isSameOrigin = (baseUrl, otherUrl) => {\n      const base = URL.parse(baseUrl);\n      if (!base?.origin || base.origin === \"null\") {\n        return false;\n      }\n      const other = new URL(otherUrl, base);\n      return base.origin === other.origin;\n    };\n    this._createCDNWrapper = url => {\n      const wrapper = `await import(\"${url}\");`;\n      return URL.createObjectURL(new Blob([wrapper], {\n        type: \"text/javascript\"\n      }));\n    };\n    this.fromPort = params => {\n      deprecated(\"`PDFWorker.fromPort` - please use `PDFWorker.create` instead.\");\n      if (!params?.port) {\n        throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n      }\n      return this.create(params);\n    };\n  }\n  constructor({\n    name = null,\n    port = null,\n    verbosity = getVerbosityLevel()\n  } = {}) {\n    this.name = name;\n    this.destroyed = false;\n    this.verbosity = verbosity;\n    if (port) {\n      if (PDFWorker.#workerPorts.has(port)) {\n        throw new Error(\"Cannot use more than one PDFWorker per port.\");\n      }\n      PDFWorker.#workerPorts.set(port, this);\n      this.#initializeFromPort(port);\n    } else {\n      this.#initialize();\n    }\n  }\n  get promise() {\n    return this.#capability.promise;\n  }\n  #resolve() {\n    this.#capability.resolve();\n    this.#messageHandler.send(\"configure\", {\n      verbosity: this.verbosity\n    });\n  }\n  get port() {\n    return this.#port;\n  }\n  get messageHandler() {\n    return this.#messageHandler;\n  }\n  #initializeFromPort(port) {\n    this.#port = port;\n    this.#messageHandler = new MessageHandler(\"main\", \"worker\", port);\n    this.#messageHandler.on(\"ready\", () => {});\n    this.#resolve();\n  }\n  #initialize() {\n    if (PDFWorker.#isWorkerDisabled || PDFWorker.#mainThreadWorkerMessageHandler) {\n      this.#setupFakeWorker();\n      return;\n    }\n    let {\n      workerSrc\n    } = PDFWorker;\n    try {\n      if (!PDFWorker._isSameOrigin(window.location, workerSrc)) {\n        workerSrc = PDFWorker._createCDNWrapper(new URL(workerSrc, window.location).href);\n      }\n      const worker = new Worker(workerSrc, {\n        type: \"module\"\n      });\n      const messageHandler = new MessageHandler(\"main\", \"worker\", worker);\n      const terminateEarly = () => {\n        ac.abort();\n        messageHandler.destroy();\n        worker.terminate();\n        if (this.destroyed) {\n          this.#capability.reject(new Error(\"Worker was destroyed\"));\n        } else {\n          this.#setupFakeWorker();\n        }\n      };\n      const ac = new AbortController();\n      worker.addEventListener(\"error\", () => {\n        if (!this.#webWorker) {\n          terminateEarly();\n        }\n      }, {\n        signal: ac.signal\n      });\n      messageHandler.on(\"test\", data => {\n        ac.abort();\n        if (this.destroyed || !data) {\n          terminateEarly();\n          return;\n        }\n        this.#messageHandler = messageHandler;\n        this.#port = worker;\n        this.#webWorker = worker;\n        this.#resolve();\n      });\n      messageHandler.on(\"ready\", data => {\n        ac.abort();\n        if (this.destroyed) {\n          terminateEarly();\n          return;\n        }\n        try {\n          sendTest();\n        } catch {\n          this.#setupFakeWorker();\n        }\n      });\n      const sendTest = () => {\n        const testObj = new Uint8Array();\n        messageHandler.send(\"test\", testObj, [testObj.buffer]);\n      };\n      sendTest();\n      return;\n    } catch {\n      info(\"The worker has been disabled.\");\n    }\n    this.#setupFakeWorker();\n  }\n  #setupFakeWorker() {\n    if (!PDFWorker.#isWorkerDisabled) {\n      warn(\"Setting up fake worker.\");\n      PDFWorker.#isWorkerDisabled = true;\n    }\n    PDFWorker._setupFakeWorkerGlobal.then(WorkerMessageHandler => {\n      if (this.destroyed) {\n        this.#capability.reject(new Error(\"Worker was destroyed\"));\n        return;\n      }\n      const port = new LoopbackPort();\n      this.#port = port;\n      const id = `fake${PDFWorker.#fakeWorkerId++}`;\n      const workerHandler = new MessageHandler(id + \"_worker\", id, port);\n      WorkerMessageHandler.setup(workerHandler, port);\n      this.#messageHandler = new MessageHandler(id, id + \"_worker\", port);\n      this.#resolve();\n    }).catch(reason => {\n      this.#capability.reject(new Error(`Setting up fake worker failed: \"${reason.message}\".`));\n    });\n  }\n  destroy() {\n    this.destroyed = true;\n    this.#webWorker?.terminate();\n    this.#webWorker = null;\n    PDFWorker.#workerPorts.delete(this.#port);\n    this.#port = null;\n    this.#messageHandler?.destroy();\n    this.#messageHandler = null;\n  }\n  static create(params) {\n    const cachedPort = this.#workerPorts.get(params?.port);\n    if (cachedPort) {\n      if (cachedPort._pendingDestroy) {\n        throw new Error(\"PDFWorker.create - the worker is being destroyed.\\n\" + \"Please remember to await `PDFDocumentLoadingTask.destroy()`-calls.\");\n      }\n      return cachedPort;\n    }\n    return new PDFWorker(params);\n  }\n  static get workerSrc() {\n    if (GlobalWorkerOptions.workerSrc) {\n      return GlobalWorkerOptions.workerSrc;\n    }\n    throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n  }\n  static get #mainThreadWorkerMessageHandler() {\n    try {\n      return globalThis.pdfjsWorker?.WorkerMessageHandler || null;\n    } catch {\n      return null;\n    }\n  }\n  static get _setupFakeWorkerGlobal() {\n    const loader = async () => {\n      if (this.#mainThreadWorkerMessageHandler) {\n        return this.#mainThreadWorkerMessageHandler;\n      }\n      const worker = await import(\n      /*webpackIgnore: true*/\n      /*@vite-ignore*/\n      this.workerSrc);\n      return worker.WorkerMessageHandler;\n    };\n    return shadow(this, \"_setupFakeWorkerGlobal\", loader());\n  }\n}\nclass WorkerTransport {\n  #methodPromises = new Map();\n  #pageCache = new Map();\n  #pagePromises = new Map();\n  #pageRefCache = new Map();\n  #passwordCapability = null;\n  constructor(messageHandler, loadingTask, networkStream, params, factory, enableHWA) {\n    this.messageHandler = messageHandler;\n    this.loadingTask = loadingTask;\n    this.commonObjs = new PDFObjects();\n    this.fontLoader = new FontLoader({\n      ownerDocument: params.ownerDocument,\n      styleElement: params.styleElement\n    });\n    this.loadingParams = params.loadingParams;\n    this._params = params;\n    this.canvasFactory = factory.canvasFactory;\n    this.filterFactory = factory.filterFactory;\n    this.cMapReaderFactory = factory.cMapReaderFactory;\n    this.standardFontDataFactory = factory.standardFontDataFactory;\n    this.wasmFactory = factory.wasmFactory;\n    this.destroyed = false;\n    this.destroyCapability = null;\n    this._networkStream = networkStream;\n    this._fullReader = null;\n    this._lastProgress = null;\n    this.downloadInfoCapability = Promise.withResolvers();\n    this.enableHWA = enableHWA;\n    this.setupMessageHandler();\n  }\n  #cacheSimpleMethod(name, data = null) {\n    const cachedPromise = this.#methodPromises.get(name);\n    if (cachedPromise) {\n      return cachedPromise;\n    }\n    const promise = this.messageHandler.sendWithPromise(name, data);\n    this.#methodPromises.set(name, promise);\n    return promise;\n  }\n  get annotationStorage() {\n    return shadow(this, \"annotationStorage\", new AnnotationStorage());\n  }\n  getRenderingIntent(intent, annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false, isOpList = false) {\n    let renderingIntent = RenderingIntentFlag.DISPLAY;\n    let annotationStorageSerializable = SerializableEmpty;\n    switch (intent) {\n      case \"any\":\n        renderingIntent = RenderingIntentFlag.ANY;\n        break;\n      case \"display\":\n        break;\n      case \"print\":\n        renderingIntent = RenderingIntentFlag.PRINT;\n        break;\n      default:\n        warn(`getRenderingIntent - invalid intent: ${intent}`);\n    }\n    const annotationStorage = renderingIntent & RenderingIntentFlag.PRINT && printAnnotationStorage instanceof PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;\n    switch (annotationMode) {\n      case AnnotationMode.DISABLE:\n        renderingIntent += RenderingIntentFlag.ANNOTATIONS_DISABLE;\n        break;\n      case AnnotationMode.ENABLE:\n        break;\n      case AnnotationMode.ENABLE_FORMS:\n        renderingIntent += RenderingIntentFlag.ANNOTATIONS_FORMS;\n        break;\n      case AnnotationMode.ENABLE_STORAGE:\n        renderingIntent += RenderingIntentFlag.ANNOTATIONS_STORAGE;\n        annotationStorageSerializable = annotationStorage.serializable;\n        break;\n      default:\n        warn(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);\n    }\n    if (isEditing) {\n      renderingIntent += RenderingIntentFlag.IS_EDITING;\n    }\n    if (isOpList) {\n      renderingIntent += RenderingIntentFlag.OPLIST;\n    }\n    const {\n      ids: modifiedIds,\n      hash: modifiedIdsHash\n    } = annotationStorage.modifiedIds;\n    const cacheKeyBuf = [renderingIntent, annotationStorageSerializable.hash, modifiedIdsHash];\n    return {\n      renderingIntent,\n      cacheKey: cacheKeyBuf.join(\"_\"),\n      annotationStorageSerializable,\n      modifiedIds\n    };\n  }\n  destroy() {\n    if (this.destroyCapability) {\n      return this.destroyCapability.promise;\n    }\n    this.destroyed = true;\n    this.destroyCapability = Promise.withResolvers();\n    this.#passwordCapability?.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n    const waitOn = [];\n    for (const page of this.#pageCache.values()) {\n      waitOn.push(page._destroy());\n    }\n    this.#pageCache.clear();\n    this.#pagePromises.clear();\n    this.#pageRefCache.clear();\n    if (this.hasOwnProperty(\"annotationStorage\")) {\n      this.annotationStorage.resetModified();\n    }\n    const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n    waitOn.push(terminated);\n    Promise.all(waitOn).then(() => {\n      this.commonObjs.clear();\n      this.fontLoader.clear();\n      this.#methodPromises.clear();\n      this.filterFactory.destroy();\n      TextLayer.cleanup();\n      this._networkStream?.cancelAllRequests(new AbortException(\"Worker was terminated.\"));\n      this.messageHandler?.destroy();\n      this.messageHandler = null;\n      this.destroyCapability.resolve();\n    }, this.destroyCapability.reject);\n    return this.destroyCapability.promise;\n  }\n  setupMessageHandler() {\n    const {\n      messageHandler,\n      loadingTask\n    } = this;\n    messageHandler.on(\"GetReader\", (data, sink) => {\n      assert(this._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n      this._fullReader = this._networkStream.getFullReader();\n      this._fullReader.onProgress = evt => {\n        this._lastProgress = {\n          loaded: evt.loaded,\n          total: evt.total\n        };\n      };\n      sink.onPull = () => {\n        this._fullReader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            sink.close();\n            return;\n          }\n          assert(value instanceof ArrayBuffer, \"GetReader - expected an ArrayBuffer.\");\n          sink.enqueue(new Uint8Array(value), 1, [value]);\n        }).catch(reason => {\n          sink.error(reason);\n        });\n      };\n      sink.onCancel = reason => {\n        this._fullReader.cancel(reason);\n        sink.ready.catch(readyReason => {\n          if (this.destroyed) {\n            return;\n          }\n          throw readyReason;\n        });\n      };\n    });\n    messageHandler.on(\"ReaderHeadersReady\", async data => {\n      await this._fullReader.headersReady;\n      const {\n        isStreamingSupported,\n        isRangeSupported,\n        contentLength\n      } = this._fullReader;\n      if (!isStreamingSupported || !isRangeSupported) {\n        if (this._lastProgress) {\n          loadingTask.onProgress?.(this._lastProgress);\n        }\n        this._fullReader.onProgress = evt => {\n          loadingTask.onProgress?.({\n            loaded: evt.loaded,\n            total: evt.total\n          });\n        };\n      }\n      return {\n        isStreamingSupported,\n        isRangeSupported,\n        contentLength\n      };\n    });\n    messageHandler.on(\"GetRangeReader\", (data, sink) => {\n      assert(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n      const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\n      if (!rangeReader) {\n        sink.close();\n        return;\n      }\n      sink.onPull = () => {\n        rangeReader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            sink.close();\n            return;\n          }\n          assert(value instanceof ArrayBuffer, \"GetRangeReader - expected an ArrayBuffer.\");\n          sink.enqueue(new Uint8Array(value), 1, [value]);\n        }).catch(reason => {\n          sink.error(reason);\n        });\n      };\n      sink.onCancel = reason => {\n        rangeReader.cancel(reason);\n        sink.ready.catch(readyReason => {\n          if (this.destroyed) {\n            return;\n          }\n          throw readyReason;\n        });\n      };\n    });\n    messageHandler.on(\"GetDoc\", ({\n      pdfInfo\n    }) => {\n      this._numPages = pdfInfo.numPages;\n      this._htmlForXfa = pdfInfo.htmlForXfa;\n      delete pdfInfo.htmlForXfa;\n      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\n    });\n    messageHandler.on(\"DocException\", ex => {\n      loadingTask._capability.reject(wrapReason(ex));\n    });\n    messageHandler.on(\"PasswordRequest\", ex => {\n      this.#passwordCapability = Promise.withResolvers();\n      try {\n        if (!loadingTask.onPassword) {\n          throw wrapReason(ex);\n        }\n        const updatePassword = password => {\n          if (password instanceof Error) {\n            this.#passwordCapability.reject(password);\n          } else {\n            this.#passwordCapability.resolve({\n              password\n            });\n          }\n        };\n        loadingTask.onPassword(updatePassword, ex.code);\n      } catch (err) {\n        this.#passwordCapability.reject(err);\n      }\n      return this.#passwordCapability.promise;\n    });\n    messageHandler.on(\"DataLoaded\", data => {\n      loadingTask.onProgress?.({\n        loaded: data.length,\n        total: data.length\n      });\n      this.downloadInfoCapability.resolve(data);\n    });\n    messageHandler.on(\"StartRenderPage\", data => {\n      if (this.destroyed) {\n        return;\n      }\n      const page = this.#pageCache.get(data.pageIndex);\n      page._startRenderPage(data.transparency, data.cacheKey);\n    });\n    messageHandler.on(\"commonobj\", ([id, type, exportedData]) => {\n      if (this.destroyed) {\n        return null;\n      }\n      if (this.commonObjs.has(id)) {\n        return null;\n      }\n      switch (type) {\n        case \"Font\":\n          if (\"error\" in exportedData) {\n            const exportedError = exportedData.error;\n            warn(`Error during font loading: ${exportedError}`);\n            this.commonObjs.resolve(id, exportedError);\n            break;\n          }\n          const inspectFont = this._params.pdfBug && globalThis.FontInspector?.enabled ? (font, url) => globalThis.FontInspector.fontAdded(font, url) : null;\n          const font = new FontFaceObject(exportedData, inspectFont);\n          this.fontLoader.bind(font).catch(() => messageHandler.sendWithPromise(\"FontFallback\", {\n            id\n          })).finally(() => {\n            if (!font.fontExtraProperties && font.data) {\n              font.data = null;\n            }\n            this.commonObjs.resolve(id, font);\n          });\n          break;\n        case \"CopyLocalImage\":\n          const {\n            imageRef\n          } = exportedData;\n          assert(imageRef, \"The imageRef must be defined.\");\n          for (const pageProxy of this.#pageCache.values()) {\n            for (const [, data] of pageProxy.objs) {\n              if (data?.ref !== imageRef) {\n                continue;\n              }\n              if (!data.dataLen) {\n                return null;\n              }\n              this.commonObjs.resolve(id, structuredClone(data));\n              return data.dataLen;\n            }\n          }\n          break;\n        case \"FontPath\":\n        case \"Image\":\n        case \"Pattern\":\n          this.commonObjs.resolve(id, exportedData);\n          break;\n        default:\n          throw new Error(`Got unknown common object type ${type}`);\n      }\n      return null;\n    });\n    messageHandler.on(\"obj\", ([id, pageIndex, type, imageData]) => {\n      if (this.destroyed) {\n        return;\n      }\n      const pageProxy = this.#pageCache.get(pageIndex);\n      if (pageProxy.objs.has(id)) {\n        return;\n      }\n      if (pageProxy._intentStates.size === 0) {\n        imageData?.bitmap?.close();\n        return;\n      }\n      switch (type) {\n        case \"Image\":\n        case \"Pattern\":\n          pageProxy.objs.resolve(id, imageData);\n          break;\n        default:\n          throw new Error(`Got unknown object type ${type}`);\n      }\n    });\n    messageHandler.on(\"DocProgress\", data => {\n      if (this.destroyed) {\n        return;\n      }\n      loadingTask.onProgress?.({\n        loaded: data.loaded,\n        total: data.total\n      });\n    });\n    messageHandler.on(\"FetchBinaryData\", async data => {\n      if (this.destroyed) {\n        throw new Error(\"Worker was destroyed.\");\n      }\n      const factory = this[data.type];\n      if (!factory) {\n        throw new Error(`${data.type} not initialized, see the \\`useWorkerFetch\\` parameter.`);\n      }\n      return factory.fetch(data);\n    });\n  }\n  getData() {\n    return this.messageHandler.sendWithPromise(\"GetData\", null);\n  }\n  saveDocument() {\n    if (this.annotationStorage.size <= 0) {\n      warn(\"saveDocument called while `annotationStorage` is empty, \" + \"please use the getData-method instead.\");\n    }\n    const {\n      map,\n      transfer\n    } = this.annotationStorage.serializable;\n    return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n      isPureXfa: !!this._htmlForXfa,\n      numPages: this._numPages,\n      annotationStorage: map,\n      filename: this._fullReader?.filename ?? null\n    }, transfer).finally(() => {\n      this.annotationStorage.resetModified();\n    });\n  }\n  getPage(pageNumber) {\n    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n      return Promise.reject(new Error(\"Invalid page request.\"));\n    }\n    const pageIndex = pageNumber - 1,\n      cachedPromise = this.#pagePromises.get(pageIndex);\n    if (cachedPromise) {\n      return cachedPromise;\n    }\n    const promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n      pageIndex\n    }).then(pageInfo => {\n      if (this.destroyed) {\n        throw new Error(\"Transport destroyed\");\n      }\n      if (pageInfo.refStr) {\n        this.#pageRefCache.set(pageInfo.refStr, pageNumber);\n      }\n      const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);\n      this.#pageCache.set(pageIndex, page);\n      return page;\n    });\n    this.#pagePromises.set(pageIndex, promise);\n    return promise;\n  }\n  getPageIndex(ref) {\n    if (!isRefProxy(ref)) {\n      return Promise.reject(new Error(\"Invalid pageIndex request.\"));\n    }\n    return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n      num: ref.num,\n      gen: ref.gen\n    });\n  }\n  getAnnotations(pageIndex, intent) {\n    return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n      pageIndex,\n      intent\n    });\n  }\n  getFieldObjects() {\n    return this.#cacheSimpleMethod(\"GetFieldObjects\");\n  }\n  hasJSActions() {\n    return this.#cacheSimpleMethod(\"HasJSActions\");\n  }\n  getCalculationOrderIds() {\n    return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n  }\n  getDestinations() {\n    return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n  }\n  getDestination(id) {\n    if (typeof id !== \"string\") {\n      return Promise.reject(new Error(\"Invalid destination request.\"));\n    }\n    return this.messageHandler.sendWithPromise(\"GetDestination\", {\n      id\n    });\n  }\n  getPageLabels() {\n    return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n  }\n  getPageLayout() {\n    return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n  }\n  getPageMode() {\n    return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n  }\n  getViewerPreferences() {\n    return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n  }\n  getOpenAction() {\n    return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n  }\n  getAttachments() {\n    return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n  }\n  getAnnotationsByType(types, pageIndexesToSkip) {\n    return this.messageHandler.sendWithPromise(\"GetAnnotationsByType\", {\n      types,\n      pageIndexesToSkip\n    });\n  }\n  getDocJSActions() {\n    return this.#cacheSimpleMethod(\"GetDocJSActions\");\n  }\n  getPageJSActions(pageIndex) {\n    return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n      pageIndex\n    });\n  }\n  getStructTree(pageIndex) {\n    return this.messageHandler.sendWithPromise(\"GetStructTree\", {\n      pageIndex\n    });\n  }\n  getOutline() {\n    return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n  }\n  getOptionalContentConfig(renderingIntent) {\n    return this.#cacheSimpleMethod(\"GetOptionalContentConfig\").then(data => new OptionalContentConfig(data, renderingIntent));\n  }\n  getPermissions() {\n    return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n  }\n  getMetadata() {\n    const name = \"GetMetadata\",\n      cachedPromise = this.#methodPromises.get(name);\n    if (cachedPromise) {\n      return cachedPromise;\n    }\n    const promise = this.messageHandler.sendWithPromise(name, null).then(results => ({\n      info: results[0],\n      metadata: results[1] ? new Metadata(results[1]) : null,\n      contentDispositionFilename: this._fullReader?.filename ?? null,\n      contentLength: this._fullReader?.contentLength ?? null\n    }));\n    this.#methodPromises.set(name, promise);\n    return promise;\n  }\n  getMarkInfo() {\n    return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n  }\n  async startCleanup(keepLoadedFonts = false) {\n    if (this.destroyed) {\n      return;\n    }\n    await this.messageHandler.sendWithPromise(\"Cleanup\", null);\n    for (const page of this.#pageCache.values()) {\n      const cleanupSuccessful = page.cleanup();\n      if (!cleanupSuccessful) {\n        throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);\n      }\n    }\n    this.commonObjs.clear();\n    if (!keepLoadedFonts) {\n      this.fontLoader.clear();\n    }\n    this.#methodPromises.clear();\n    this.filterFactory.destroy(true);\n    TextLayer.cleanup();\n  }\n  cachedPageNumber(ref) {\n    if (!isRefProxy(ref)) {\n      return null;\n    }\n    const refStr = ref.gen === 0 ? `${ref.num}R` : `${ref.num}R${ref.gen}`;\n    return this.#pageRefCache.get(refStr) ?? null;\n  }\n}\nclass RenderTask {\n  #internalRenderTask = null;\n  onContinue = null;\n  onError = null;\n  constructor(internalRenderTask) {\n    this.#internalRenderTask = internalRenderTask;\n  }\n  get promise() {\n    return this.#internalRenderTask.capability.promise;\n  }\n  cancel(extraDelay = 0) {\n    this.#internalRenderTask.cancel(null, extraDelay);\n  }\n  get separateAnnots() {\n    const {\n      separateAnnots\n    } = this.#internalRenderTask.operatorList;\n    if (!separateAnnots) {\n      return false;\n    }\n    const {\n      annotationCanvasMap\n    } = this.#internalRenderTask;\n    return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;\n  }\n}\nclass InternalRenderTask {\n  #rAF = null;\n  static #canvasInUse = new WeakSet();\n  constructor({\n    callback,\n    params,\n    objs,\n    commonObjs,\n    annotationCanvasMap,\n    operatorList,\n    pageIndex,\n    canvasFactory,\n    filterFactory,\n    useRequestAnimationFrame = false,\n    pdfBug = false,\n    pageColors = null,\n    enableHWA = false,\n    filteredOperationIndexes = null\n  }) {\n    this.callback = callback;\n    this.params = params;\n    this.objs = objs;\n    this.commonObjs = commonObjs;\n    this.annotationCanvasMap = annotationCanvasMap;\n    this.operatorListIdx = null;\n    this.operatorList = operatorList;\n    this._pageIndex = pageIndex;\n    this.canvasFactory = canvasFactory;\n    this.filterFactory = filterFactory;\n    this._pdfBug = pdfBug;\n    this.pageColors = pageColors;\n    this.running = false;\n    this.graphicsReadyCallback = null;\n    this.graphicsReady = false;\n    this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== \"undefined\";\n    this.cancelled = false;\n    this.capability = Promise.withResolvers();\n    this.task = new RenderTask(this);\n    this._cancelBound = this.cancel.bind(this);\n    this._continueBound = this._continue.bind(this);\n    this._scheduleNextBound = this._scheduleNext.bind(this);\n    this._nextBound = this._next.bind(this);\n    this._canvas = params.canvas;\n    this._canvasContext = params.canvas ? null : params.canvasContext;\n    this._enableHWA = enableHWA;\n    this._dependencyTracker = params.dependencyTracker;\n    this._filteredOperationIndexes = filteredOperationIndexes;\n  }\n  get completed() {\n    return this.capability.promise.catch(function () {});\n  }\n  initializeGraphics({\n    transparency = false,\n    optionalContentConfig\n  }) {\n    if (this.cancelled) {\n      return;\n    }\n    if (this._canvas) {\n      if (InternalRenderTask.#canvasInUse.has(this._canvas)) {\n        throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n      }\n      InternalRenderTask.#canvasInUse.add(this._canvas);\n    }\n    if (this._pdfBug && globalThis.StepperManager?.enabled) {\n      this.stepper = globalThis.StepperManager.create(this._pageIndex);\n      this.stepper.init(this.operatorList);\n      this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n    }\n    const {\n      viewport,\n      transform,\n      background,\n      dependencyTracker\n    } = this.params;\n    const canvasContext = this._canvasContext || this._canvas.getContext(\"2d\", {\n      alpha: false,\n      willReadFrequently: !this._enableHWA\n    });\n    this.gfx = new CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n      optionalContentConfig\n    }, this.annotationCanvasMap, this.pageColors, dependencyTracker);\n    this.gfx.beginDrawing({\n      transform,\n      viewport,\n      transparency,\n      background\n    });\n    this.operatorListIdx = 0;\n    this.graphicsReady = true;\n    this.graphicsReadyCallback?.();\n  }\n  cancel(error = null, extraDelay = 0) {\n    this.running = false;\n    this.cancelled = true;\n    this.gfx?.endDrawing();\n    if (this.#rAF) {\n      window.cancelAnimationFrame(this.#rAF);\n      this.#rAF = null;\n    }\n    InternalRenderTask.#canvasInUse.delete(this._canvas);\n    error ||= new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay);\n    this.callback(error);\n    this.task.onError?.(error);\n  }\n  operatorListChanged() {\n    if (!this.graphicsReady) {\n      this.graphicsReadyCallback ||= this._continueBound;\n      return;\n    }\n    this.stepper?.updateOperatorList(this.operatorList);\n    if (this.running) {\n      return;\n    }\n    this._continue();\n  }\n  _continue() {\n    this.running = true;\n    if (this.cancelled) {\n      return;\n    }\n    if (this.task.onContinue) {\n      this.task.onContinue(this._scheduleNextBound);\n    } else {\n      this._scheduleNext();\n    }\n  }\n  _scheduleNext() {\n    if (this._useRequestAnimationFrame) {\n      this.#rAF = window.requestAnimationFrame(() => {\n        this.#rAF = null;\n        this._nextBound().catch(this._cancelBound);\n      });\n    } else {\n      Promise.resolve().then(this._nextBound).catch(this._cancelBound);\n    }\n  }\n  async _next() {\n    if (this.cancelled) {\n      return;\n    }\n    this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper, this._filteredOperationIndexes);\n    if (this.operatorListIdx === this.operatorList.argsArray.length) {\n      this.running = false;\n      if (this.operatorList.lastChunk) {\n        this.gfx.endDrawing();\n        InternalRenderTask.#canvasInUse.delete(this._canvas);\n        this.callback();\n      }\n    }\n  }\n}\nconst version = \"5.4.149\";\nconst build = \"9e2e9e209\";\n\n;// ./src/display/editor/color_picker.js\n\n\n\nclass ColorPicker {\n  #button = null;\n  #buttonSwatch = null;\n  #defaultColor;\n  #dropdown = null;\n  #dropdownWasFromKeyboard = false;\n  #isMainColorPicker = false;\n  #editor = null;\n  #eventBus;\n  #openDropdownAC = null;\n  #uiManager = null;\n  static #l10nColor = null;\n  static get _keyboardManager() {\n    return shadow(this, \"_keyboardManager\", new KeyboardManager([[[\"Escape\", \"mac+Escape\"], ColorPicker.prototype._hideDropdownFromKeyboard], [[\" \", \"mac+ \"], ColorPicker.prototype._colorSelectFromKeyboard], [[\"ArrowDown\", \"ArrowRight\", \"mac+ArrowDown\", \"mac+ArrowRight\"], ColorPicker.prototype._moveToNext], [[\"ArrowUp\", \"ArrowLeft\", \"mac+ArrowUp\", \"mac+ArrowLeft\"], ColorPicker.prototype._moveToPrevious], [[\"Home\", \"mac+Home\"], ColorPicker.prototype._moveToBeginning], [[\"End\", \"mac+End\"], ColorPicker.prototype._moveToEnd]]));\n  }\n  constructor({\n    editor = null,\n    uiManager = null\n  }) {\n    if (editor) {\n      this.#isMainColorPicker = false;\n      this.#editor = editor;\n    } else {\n      this.#isMainColorPicker = true;\n    }\n    this.#uiManager = editor?._uiManager || uiManager;\n    this.#eventBus = this.#uiManager._eventBus;\n    this.#defaultColor = editor?.color?.toUpperCase() || this.#uiManager?.highlightColors.values().next().value || \"#FFFF98\";\n    ColorPicker.#l10nColor ||= Object.freeze({\n      blue: \"pdfjs-editor-colorpicker-blue\",\n      green: \"pdfjs-editor-colorpicker-green\",\n      pink: \"pdfjs-editor-colorpicker-pink\",\n      red: \"pdfjs-editor-colorpicker-red\",\n      yellow: \"pdfjs-editor-colorpicker-yellow\"\n    });\n  }\n  renderButton() {\n    const button = this.#button = document.createElement(\"button\");\n    button.className = \"colorPicker\";\n    button.tabIndex = \"0\";\n    button.setAttribute(\"data-l10n-id\", \"pdfjs-editor-colorpicker-button\");\n    button.ariaHasPopup = \"true\";\n    if (this.#editor) {\n      button.ariaControls = `${this.#editor.id}_colorpicker_dropdown`;\n    }\n    const signal = this.#uiManager._signal;\n    button.addEventListener(\"click\", this.#openDropdown.bind(this), {\n      signal\n    });\n    button.addEventListener(\"keydown\", this.#keyDown.bind(this), {\n      signal\n    });\n    const swatch = this.#buttonSwatch = document.createElement(\"span\");\n    swatch.className = \"swatch\";\n    swatch.ariaHidden = \"true\";\n    swatch.style.backgroundColor = this.#defaultColor;\n    button.append(swatch);\n    return button;\n  }\n  renderMainDropdown() {\n    const dropdown = this.#dropdown = this.#getDropdownRoot();\n    dropdown.ariaOrientation = \"horizontal\";\n    dropdown.ariaLabelledBy = \"highlightColorPickerLabel\";\n    return dropdown;\n  }\n  #getDropdownRoot() {\n    const div = document.createElement(\"div\");\n    const signal = this.#uiManager._signal;\n    div.addEventListener(\"contextmenu\", noContextMenu, {\n      signal\n    });\n    div.className = \"dropdown\";\n    div.role = \"listbox\";\n    div.ariaMultiSelectable = \"false\";\n    div.ariaOrientation = \"vertical\";\n    div.setAttribute(\"data-l10n-id\", \"pdfjs-editor-colorpicker-dropdown\");\n    if (this.#editor) {\n      div.id = `${this.#editor.id}_colorpicker_dropdown`;\n    }\n    for (const [name, color] of this.#uiManager.highlightColors) {\n      const button = document.createElement(\"button\");\n      button.tabIndex = \"0\";\n      button.role = \"option\";\n      button.setAttribute(\"data-color\", color);\n      button.title = name;\n      button.setAttribute(\"data-l10n-id\", ColorPicker.#l10nColor[name]);\n      const swatch = document.createElement(\"span\");\n      button.append(swatch);\n      swatch.className = \"swatch\";\n      swatch.style.backgroundColor = color;\n      button.ariaSelected = color === this.#defaultColor;\n      button.addEventListener(\"click\", this.#colorSelect.bind(this, color), {\n        signal\n      });\n      div.append(button);\n    }\n    div.addEventListener(\"keydown\", this.#keyDown.bind(this), {\n      signal\n    });\n    return div;\n  }\n  #colorSelect(color, event) {\n    event.stopPropagation();\n    this.#eventBus.dispatch(\"switchannotationeditorparams\", {\n      source: this,\n      type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n      value: color\n    });\n    this.updateColor(color);\n  }\n  _colorSelectFromKeyboard(event) {\n    if (event.target === this.#button) {\n      this.#openDropdown(event);\n      return;\n    }\n    const color = event.target.getAttribute(\"data-color\");\n    if (!color) {\n      return;\n    }\n    this.#colorSelect(color, event);\n  }\n  _moveToNext(event) {\n    if (!this.#isDropdownVisible) {\n      this.#openDropdown(event);\n      return;\n    }\n    if (event.target === this.#button) {\n      this.#dropdown.firstChild?.focus();\n      return;\n    }\n    event.target.nextSibling?.focus();\n  }\n  _moveToPrevious(event) {\n    if (event.target === this.#dropdown?.firstChild || event.target === this.#button) {\n      if (this.#isDropdownVisible) {\n        this._hideDropdownFromKeyboard();\n      }\n      return;\n    }\n    if (!this.#isDropdownVisible) {\n      this.#openDropdown(event);\n    }\n    event.target.previousSibling?.focus();\n  }\n  _moveToBeginning(event) {\n    if (!this.#isDropdownVisible) {\n      this.#openDropdown(event);\n      return;\n    }\n    this.#dropdown.firstChild?.focus();\n  }\n  _moveToEnd(event) {\n    if (!this.#isDropdownVisible) {\n      this.#openDropdown(event);\n      return;\n    }\n    this.#dropdown.lastChild?.focus();\n  }\n  #keyDown(event) {\n    ColorPicker._keyboardManager.exec(this, event);\n  }\n  #openDropdown(event) {\n    if (this.#isDropdownVisible) {\n      this.hideDropdown();\n      return;\n    }\n    this.#dropdownWasFromKeyboard = event.detail === 0;\n    if (!this.#openDropdownAC) {\n      this.#openDropdownAC = new AbortController();\n      window.addEventListener(\"pointerdown\", this.#pointerDown.bind(this), {\n        signal: this.#uiManager.combinedSignal(this.#openDropdownAC)\n      });\n    }\n    this.#button.ariaExpanded = \"true\";\n    if (this.#dropdown) {\n      this.#dropdown.classList.remove(\"hidden\");\n      return;\n    }\n    const root = this.#dropdown = this.#getDropdownRoot();\n    this.#button.append(root);\n  }\n  #pointerDown(event) {\n    if (this.#dropdown?.contains(event.target)) {\n      return;\n    }\n    this.hideDropdown();\n  }\n  hideDropdown() {\n    this.#dropdown?.classList.add(\"hidden\");\n    this.#button.ariaExpanded = \"false\";\n    this.#openDropdownAC?.abort();\n    this.#openDropdownAC = null;\n  }\n  get #isDropdownVisible() {\n    return this.#dropdown && !this.#dropdown.classList.contains(\"hidden\");\n  }\n  _hideDropdownFromKeyboard() {\n    if (this.#isMainColorPicker) {\n      return;\n    }\n    if (!this.#isDropdownVisible) {\n      this.#editor?.unselect();\n      return;\n    }\n    this.hideDropdown();\n    this.#button.focus({\n      preventScroll: true,\n      focusVisible: this.#dropdownWasFromKeyboard\n    });\n  }\n  updateColor(color) {\n    if (this.#buttonSwatch) {\n      this.#buttonSwatch.style.backgroundColor = color;\n    }\n    if (!this.#dropdown) {\n      return;\n    }\n    const i = this.#uiManager.highlightColors.values();\n    for (const child of this.#dropdown.children) {\n      child.ariaSelected = i.next().value === color.toUpperCase();\n    }\n  }\n  destroy() {\n    this.#button?.remove();\n    this.#button = null;\n    this.#buttonSwatch = null;\n    this.#dropdown?.remove();\n    this.#dropdown = null;\n  }\n}\nclass BasicColorPicker {\n  #input = null;\n  #editor = null;\n  #uiManager = null;\n  static #l10nColor = null;\n  constructor(editor) {\n    this.#editor = editor;\n    this.#uiManager = editor._uiManager;\n    BasicColorPicker.#l10nColor ||= Object.freeze({\n      freetext: \"pdfjs-editor-color-picker-free-text-input\",\n      ink: \"pdfjs-editor-color-picker-ink-input\"\n    });\n  }\n  renderButton() {\n    if (this.#input) {\n      return this.#input;\n    }\n    const {\n      editorType,\n      colorType,\n      colorValue\n    } = this.#editor;\n    const input = this.#input = document.createElement(\"input\");\n    input.type = \"color\";\n    input.value = colorValue || \"#000000\";\n    input.className = \"basicColorPicker\";\n    input.tabIndex = 0;\n    input.setAttribute(\"data-l10n-id\", BasicColorPicker.#l10nColor[editorType]);\n    input.addEventListener(\"input\", () => {\n      this.#uiManager.updateParams(colorType, input.value);\n    }, {\n      signal: this.#uiManager._signal\n    });\n    return input;\n  }\n  update(value) {\n    if (!this.#input) {\n      return;\n    }\n    this.#input.value = value;\n  }\n  destroy() {\n    this.#input?.remove();\n    this.#input = null;\n  }\n  hideDropdown() {}\n}\n\n;// ./src/shared/scripting_utils.js\nfunction makeColorComp(n) {\n  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\n}\nfunction scaleAndClamp(x) {\n  return Math.max(0, Math.min(255, 255 * x));\n}\nclass ColorConverters {\n  static CMYK_G([c, y, m, k]) {\n    return [\"G\", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];\n  }\n  static G_CMYK([g]) {\n    return [\"CMYK\", 0, 0, 0, 1 - g];\n  }\n  static G_RGB([g]) {\n    return [\"RGB\", g, g, g];\n  }\n  static G_rgb([g]) {\n    g = scaleAndClamp(g);\n    return [g, g, g];\n  }\n  static G_HTML([g]) {\n    const G = makeColorComp(g);\n    return `#${G}${G}${G}`;\n  }\n  static RGB_G([r, g, b]) {\n    return [\"G\", 0.3 * r + 0.59 * g + 0.11 * b];\n  }\n  static RGB_rgb(color) {\n    return color.map(scaleAndClamp);\n  }\n  static RGB_HTML(color) {\n    return `#${color.map(makeColorComp).join(\"\")}`;\n  }\n  static T_HTML() {\n    return \"#00000000\";\n  }\n  static T_rgb() {\n    return [null];\n  }\n  static CMYK_RGB([c, y, m, k]) {\n    return [\"RGB\", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];\n  }\n  static CMYK_rgb([c, y, m, k]) {\n    return [scaleAndClamp(1 - Math.min(1, c + k)), scaleAndClamp(1 - Math.min(1, m + k)), scaleAndClamp(1 - Math.min(1, y + k))];\n  }\n  static CMYK_HTML(components) {\n    const rgb = this.CMYK_RGB(components).slice(1);\n    return this.RGB_HTML(rgb);\n  }\n  static RGB_CMYK([r, g, b]) {\n    const c = 1 - r;\n    const m = 1 - g;\n    const y = 1 - b;\n    const k = Math.min(c, m, y);\n    return [\"CMYK\", c, m, y, k];\n  }\n}\nconst DateFormats = (/* unused pure expression or super */ null && (0));\nconst TimeFormats = (/* unused pure expression or super */ null && (0));\n\n;// ./src/display/svg_factory.js\n\n\nclass BaseSVGFactory {\n  create(width, height, skipDimensions = false) {\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid SVG dimensions\");\n    }\n    const svg = this._createSVG(\"svg:svg\");\n    svg.setAttribute(\"version\", \"1.1\");\n    if (!skipDimensions) {\n      svg.setAttribute(\"width\", `${width}px`);\n      svg.setAttribute(\"height\", `${height}px`);\n    }\n    svg.setAttribute(\"preserveAspectRatio\", \"none\");\n    svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n    return svg;\n  }\n  createElement(type) {\n    if (typeof type !== \"string\") {\n      throw new Error(\"Invalid SVG element type\");\n    }\n    return this._createSVG(type);\n  }\n  _createSVG(type) {\n    unreachable(\"Abstract method `_createSVG` called.\");\n  }\n}\nclass DOMSVGFactory extends BaseSVGFactory {\n  _createSVG(type) {\n    return document.createElementNS(SVG_NS, type);\n  }\n}\n\n;// ./src/display/xfa_layer.js\n\nclass XfaLayer {\n  static setupStorage(html, id, element, storage, intent) {\n    const storedData = storage.getValue(id, {\n      value: null\n    });\n    switch (element.name) {\n      case \"textarea\":\n        if (storedData.value !== null) {\n          html.textContent = storedData.value;\n        }\n        if (intent === \"print\") {\n          break;\n        }\n        html.addEventListener(\"input\", event => {\n          storage.setValue(id, {\n            value: event.target.value\n          });\n        });\n        break;\n      case \"input\":\n        if (element.attributes.type === \"radio\" || element.attributes.type === \"checkbox\") {\n          if (storedData.value === element.attributes.xfaOn) {\n            html.setAttribute(\"checked\", true);\n          } else if (storedData.value === element.attributes.xfaOff) {\n            html.removeAttribute(\"checked\");\n          }\n          if (intent === \"print\") {\n            break;\n          }\n          html.addEventListener(\"change\", event => {\n            storage.setValue(id, {\n              value: event.target.checked ? event.target.getAttribute(\"xfaOn\") : event.target.getAttribute(\"xfaOff\")\n            });\n          });\n        } else {\n          if (storedData.value !== null) {\n            html.setAttribute(\"value\", storedData.value);\n          }\n          if (intent === \"print\") {\n            break;\n          }\n          html.addEventListener(\"input\", event => {\n            storage.setValue(id, {\n              value: event.target.value\n            });\n          });\n        }\n        break;\n      case \"select\":\n        if (storedData.value !== null) {\n          html.setAttribute(\"value\", storedData.value);\n          for (const option of element.children) {\n            if (option.attributes.value === storedData.value) {\n              option.attributes.selected = true;\n            } else if (option.attributes.hasOwnProperty(\"selected\")) {\n              delete option.attributes.selected;\n            }\n          }\n        }\n        html.addEventListener(\"input\", event => {\n          const options = event.target.options;\n          const value = options.selectedIndex === -1 ? \"\" : options[options.selectedIndex].value;\n          storage.setValue(id, {\n            value\n          });\n        });\n        break;\n    }\n  }\n  static setAttributes({\n    html,\n    element,\n    storage = null,\n    intent,\n    linkService\n  }) {\n    const {\n      attributes\n    } = element;\n    const isHTMLAnchorElement = html instanceof HTMLAnchorElement;\n    if (attributes.type === \"radio\") {\n      attributes.name = `${attributes.name}-${intent}`;\n    }\n    for (const [key, value] of Object.entries(attributes)) {\n      if (value === null || value === undefined) {\n        continue;\n      }\n      switch (key) {\n        case \"class\":\n          if (value.length) {\n            html.setAttribute(key, value.join(\" \"));\n          }\n          break;\n        case \"dataId\":\n          break;\n        case \"id\":\n          html.setAttribute(\"data-element-id\", value);\n          break;\n        case \"style\":\n          Object.assign(html.style, value);\n          break;\n        case \"textContent\":\n          html.textContent = value;\n          break;\n        default:\n          if (!isHTMLAnchorElement || key !== \"href\" && key !== \"newWindow\") {\n            html.setAttribute(key, value);\n          }\n      }\n    }\n    if (isHTMLAnchorElement) {\n      linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);\n    }\n    if (storage && attributes.dataId) {\n      this.setupStorage(html, attributes.dataId, element, storage);\n    }\n  }\n  static render(parameters) {\n    const storage = parameters.annotationStorage;\n    const linkService = parameters.linkService;\n    const root = parameters.xfaHtml;\n    const intent = parameters.intent || \"display\";\n    const rootHtml = document.createElement(root.name);\n    if (root.attributes) {\n      this.setAttributes({\n        html: rootHtml,\n        element: root,\n        intent,\n        linkService\n      });\n    }\n    const isNotForRichText = intent !== \"richText\";\n    const rootDiv = parameters.div;\n    rootDiv.append(rootHtml);\n    if (parameters.viewport) {\n      const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n      rootDiv.style.transform = transform;\n    }\n    if (isNotForRichText) {\n      rootDiv.setAttribute(\"class\", \"xfaLayer xfaFont\");\n    }\n    const textDivs = [];\n    if (root.children.length === 0) {\n      if (root.value) {\n        const node = document.createTextNode(root.value);\n        rootHtml.append(node);\n        if (isNotForRichText && XfaText.shouldBuildText(root.name)) {\n          textDivs.push(node);\n        }\n      }\n      return {\n        textDivs\n      };\n    }\n    const stack = [[root, -1, rootHtml]];\n    while (stack.length > 0) {\n      const [parent, i, html] = stack.at(-1);\n      if (i + 1 === parent.children.length) {\n        stack.pop();\n        continue;\n      }\n      const child = parent.children[++stack.at(-1)[1]];\n      if (child === null) {\n        continue;\n      }\n      const {\n        name\n      } = child;\n      if (name === \"#text\") {\n        const node = document.createTextNode(child.value);\n        textDivs.push(node);\n        html.append(node);\n        continue;\n      }\n      const childHtml = child?.attributes?.xmlns ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);\n      html.append(childHtml);\n      if (child.attributes) {\n        this.setAttributes({\n          html: childHtml,\n          element: child,\n          storage,\n          intent,\n          linkService\n        });\n      }\n      if (child.children?.length > 0) {\n        stack.push([child, -1, childHtml]);\n      } else if (child.value) {\n        const node = document.createTextNode(child.value);\n        if (isNotForRichText && XfaText.shouldBuildText(name)) {\n          textDivs.push(node);\n        }\n        childHtml.append(node);\n      }\n    }\n    for (const el of rootDiv.querySelectorAll(\".xfaNonInteractive input, .xfaNonInteractive textarea\")) {\n      el.setAttribute(\"readOnly\", true);\n    }\n    return {\n      textDivs\n    };\n  }\n  static update(parameters) {\n    const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n    parameters.div.style.transform = transform;\n    parameters.div.hidden = false;\n  }\n}\n\n;// ./src/display/annotation_layer.js\n\n\n\n\n\n\nconst annotation_layer_DEFAULT_FONT_SIZE = 9;\nconst GetElementsByNameSet = new WeakSet();\nconst TIMEZONE_OFFSET = new Date().getTimezoneOffset() * 60 * 1000;\nclass AnnotationElementFactory {\n  static create(parameters) {\n    const subtype = parameters.data.annotationType;\n    switch (subtype) {\n      case AnnotationType.LINK:\n        return new LinkAnnotationElement(parameters);\n      case AnnotationType.TEXT:\n        return new TextAnnotationElement(parameters);\n      case AnnotationType.WIDGET:\n        const fieldType = parameters.data.fieldType;\n        switch (fieldType) {\n          case \"Tx\":\n            return new TextWidgetAnnotationElement(parameters);\n          case \"Btn\":\n            if (parameters.data.radioButton) {\n              return new RadioButtonWidgetAnnotationElement(parameters);\n            } else if (parameters.data.checkBox) {\n              return new CheckboxWidgetAnnotationElement(parameters);\n            }\n            return new PushButtonWidgetAnnotationElement(parameters);\n          case \"Ch\":\n            return new ChoiceWidgetAnnotationElement(parameters);\n          case \"Sig\":\n            return new SignatureWidgetAnnotationElement(parameters);\n        }\n        return new WidgetAnnotationElement(parameters);\n      case AnnotationType.POPUP:\n        return new PopupAnnotationElement(parameters);\n      case AnnotationType.FREETEXT:\n        return new FreeTextAnnotationElement(parameters);\n      case AnnotationType.LINE:\n        return new LineAnnotationElement(parameters);\n      case AnnotationType.SQUARE:\n        return new SquareAnnotationElement(parameters);\n      case AnnotationType.CIRCLE:\n        return new CircleAnnotationElement(parameters);\n      case AnnotationType.POLYLINE:\n        return new PolylineAnnotationElement(parameters);\n      case AnnotationType.CARET:\n        return new CaretAnnotationElement(parameters);\n      case AnnotationType.INK:\n        return new InkAnnotationElement(parameters);\n      case AnnotationType.POLYGON:\n        return new PolygonAnnotationElement(parameters);\n      case AnnotationType.HIGHLIGHT:\n        return new HighlightAnnotationElement(parameters);\n      case AnnotationType.UNDERLINE:\n        return new UnderlineAnnotationElement(parameters);\n      case AnnotationType.SQUIGGLY:\n        return new SquigglyAnnotationElement(parameters);\n      case AnnotationType.STRIKEOUT:\n        return new StrikeOutAnnotationElement(parameters);\n      case AnnotationType.STAMP:\n        return new StampAnnotationElement(parameters);\n      case AnnotationType.FILEATTACHMENT:\n        return new FileAttachmentAnnotationElement(parameters);\n      default:\n        return new AnnotationElement(parameters);\n    }\n  }\n}\nclass AnnotationElement {\n  #updates = null;\n  #hasBorder = false;\n  #popupElement = null;\n  constructor(parameters, {\n    isRenderable = false,\n    ignoreBorder = false,\n    createQuadrilaterals = false\n  } = {}) {\n    this.isRenderable = isRenderable;\n    this.data = parameters.data;\n    this.layer = parameters.layer;\n    this.linkService = parameters.linkService;\n    this.downloadManager = parameters.downloadManager;\n    this.imageResourcesPath = parameters.imageResourcesPath;\n    this.renderForms = parameters.renderForms;\n    this.svgFactory = parameters.svgFactory;\n    this.annotationStorage = parameters.annotationStorage;\n    this.enableComment = parameters.enableComment;\n    this.enableScripting = parameters.enableScripting;\n    this.hasJSActions = parameters.hasJSActions;\n    this._fieldObjects = parameters.fieldObjects;\n    this.parent = parameters.parent;\n    if (isRenderable) {\n      this.container = this._createContainer(ignoreBorder);\n    }\n    if (createQuadrilaterals) {\n      this._createQuadrilaterals();\n    }\n  }\n  static _hasPopupData({\n    contentsObj,\n    richText\n  }) {\n    return !!(contentsObj?.str || richText?.str);\n  }\n  get _isEditable() {\n    return this.data.isEditable;\n  }\n  get hasPopupData() {\n    return AnnotationElement._hasPopupData(this.data);\n  }\n  get hasCommentButton() {\n    return this.enableComment && this._isEditable && this.hasPopupElement;\n  }\n  get commentButtonPosition() {\n    const {\n      quadPoints,\n      rect\n    } = this.data;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    if (quadPoints?.length >= 8) {\n      for (let i = 0; i < quadPoints.length; i += 8) {\n        if (quadPoints[i + 1] > maxY) {\n          maxY = quadPoints[i + 1];\n          maxX = quadPoints[i + 2];\n        } else if (quadPoints[i + 1] === maxY) {\n          maxX = Math.max(maxX, quadPoints[i + 2]);\n        }\n      }\n      return [maxX, maxY];\n    }\n    if (rect) {\n      return [rect[2], rect[3]];\n    }\n    return null;\n  }\n  get commentButtonColor() {\n    if (!this.data.color) {\n      return null;\n    }\n    const [r, g, b] = this.data.color;\n    const opacity = this.data.opacity ?? 1;\n    const oppositeOpacity = 255 * (1 - opacity);\n    return this.#changeLightness(Math.min(r + oppositeOpacity, 255), Math.min(g + oppositeOpacity, 255), Math.min(b + oppositeOpacity, 255));\n  }\n  #changeLightness(r, g, b) {\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const l = (max + min) / 2;\n    const newL = ((1 + Math.sqrt(l)) / 2 * 100).toFixed(2);\n    if (max === min) {\n      return `hsl(0, 0%, ${newL}%)`;\n    }\n    const d = max - min;\n    let h;\n    if (max === r) {\n      h = (g - b) / d + (g < b ? 6 : 0);\n    } else if (max === g) {\n      h = (b - r) / d + 2;\n    } else {\n      h = (r - g) / d + 4;\n    }\n    h = (h * 60).toFixed(2);\n    const s = (d / (1 - Math.abs(2 * l - 1)) * 100).toFixed(2);\n    return `hsl(${h}, ${s}%, ${newL}%)`;\n  }\n  _normalizePoint(point) {\n    const {\n      page: {\n        view\n      },\n      viewport: {\n        rawDims: {\n          pageWidth,\n          pageHeight,\n          pageX,\n          pageY\n        }\n      }\n    } = this.parent;\n    point[1] = view[3] - point[1] + view[1];\n    point[0] = 100 * (point[0] - pageX) / pageWidth;\n    point[1] = 100 * (point[1] - pageY) / pageHeight;\n    return point;\n  }\n  updateEdited(params) {\n    if (!this.container) {\n      return;\n    }\n    if (params.rect) {\n      this.#updates ||= {\n        rect: this.data.rect.slice(0)\n      };\n    }\n    const {\n      rect,\n      popup: newPopup\n    } = params;\n    if (rect) {\n      this.#setRectEdited(rect);\n    }\n    let popup = this.#popupElement?.popup || this.popup;\n    if (!popup && newPopup?.text) {\n      this._createPopup(newPopup);\n      popup = this.#popupElement.popup;\n    }\n    if (!popup) {\n      return;\n    }\n    popup.updateEdited(params);\n    if (newPopup?.deleted) {\n      popup.remove();\n      this.#popupElement = null;\n      this.popup = null;\n    }\n  }\n  resetEdited() {\n    if (!this.#updates) {\n      return;\n    }\n    this.#setRectEdited(this.#updates.rect);\n    this.#popupElement?.popup.resetEdited();\n    this.#updates = null;\n  }\n  #setRectEdited(rect) {\n    const {\n      container: {\n        style\n      },\n      data: {\n        rect: currentRect,\n        rotation\n      },\n      parent: {\n        viewport: {\n          rawDims: {\n            pageWidth,\n            pageHeight,\n            pageX,\n            pageY\n          }\n        }\n      }\n    } = this;\n    currentRect?.splice(0, 4, ...rect);\n    style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n    style.top = `${100 * (pageHeight - rect[3] + pageY) / pageHeight}%`;\n    if (rotation === 0) {\n      style.width = `${100 * (rect[2] - rect[0]) / pageWidth}%`;\n      style.height = `${100 * (rect[3] - rect[1]) / pageHeight}%`;\n    } else {\n      this.setRotation(rotation);\n    }\n  }\n  _createContainer(ignoreBorder) {\n    const {\n      data,\n      parent: {\n        page,\n        viewport\n      }\n    } = this;\n    const container = document.createElement(\"section\");\n    container.setAttribute(\"data-annotation-id\", data.id);\n    if (!(this instanceof WidgetAnnotationElement) && !(this instanceof LinkAnnotationElement)) {\n      container.tabIndex = 0;\n    }\n    const {\n      style\n    } = container;\n    style.zIndex = this.parent.zIndex;\n    this.parent.zIndex += 2;\n    if (data.alternativeText) {\n      container.title = data.alternativeText;\n    }\n    if (data.noRotate) {\n      container.classList.add(\"norotate\");\n    }\n    if (!data.rect || this instanceof PopupAnnotationElement) {\n      const {\n        rotation\n      } = data;\n      if (!data.hasOwnCanvas && rotation !== 0) {\n        this.setRotation(rotation, container);\n      }\n      return container;\n    }\n    const {\n      width,\n      height\n    } = this;\n    if (!ignoreBorder && data.borderStyle.width > 0) {\n      style.borderWidth = `${data.borderStyle.width}px`;\n      const horizontalRadius = data.borderStyle.horizontalCornerRadius;\n      const verticalRadius = data.borderStyle.verticalCornerRadius;\n      if (horizontalRadius > 0 || verticalRadius > 0) {\n        const radius = `calc(${horizontalRadius}px * var(--total-scale-factor)) / calc(${verticalRadius}px * var(--total-scale-factor))`;\n        style.borderRadius = radius;\n      } else if (this instanceof RadioButtonWidgetAnnotationElement) {\n        const radius = `calc(${width}px * var(--total-scale-factor)) / calc(${height}px * var(--total-scale-factor))`;\n        style.borderRadius = radius;\n      }\n      switch (data.borderStyle.style) {\n        case AnnotationBorderStyleType.SOLID:\n          style.borderStyle = \"solid\";\n          break;\n        case AnnotationBorderStyleType.DASHED:\n          style.borderStyle = \"dashed\";\n          break;\n        case AnnotationBorderStyleType.BEVELED:\n          warn(\"Unimplemented border style: beveled\");\n          break;\n        case AnnotationBorderStyleType.INSET:\n          warn(\"Unimplemented border style: inset\");\n          break;\n        case AnnotationBorderStyleType.UNDERLINE:\n          style.borderBottomStyle = \"solid\";\n          break;\n        default:\n          break;\n      }\n      const borderColor = data.borderColor || null;\n      if (borderColor) {\n        this.#hasBorder = true;\n        style.borderColor = Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);\n      } else {\n        style.borderWidth = 0;\n      }\n    }\n    const rect = Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);\n    const {\n      pageWidth,\n      pageHeight,\n      pageX,\n      pageY\n    } = viewport.rawDims;\n    style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n    style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;\n    const {\n      rotation\n    } = data;\n    if (data.hasOwnCanvas || rotation === 0) {\n      style.width = `${100 * width / pageWidth}%`;\n      style.height = `${100 * height / pageHeight}%`;\n    } else {\n      this.setRotation(rotation, container);\n    }\n    return container;\n  }\n  setRotation(angle, container = this.container) {\n    if (!this.data.rect) {\n      return;\n    }\n    const {\n      pageWidth,\n      pageHeight\n    } = this.parent.viewport.rawDims;\n    let {\n      width,\n      height\n    } = this;\n    if (angle % 180 !== 0) {\n      [width, height] = [height, width];\n    }\n    container.style.width = `${100 * width / pageWidth}%`;\n    container.style.height = `${100 * height / pageHeight}%`;\n    container.setAttribute(\"data-main-rotation\", (360 - angle) % 360);\n  }\n  get _commonActions() {\n    const setColor = (jsName, styleName, event) => {\n      const color = event.detail[jsName];\n      const colorType = color[0];\n      const colorArray = color.slice(1);\n      event.target.style[styleName] = ColorConverters[`${colorType}_HTML`](colorArray);\n      this.annotationStorage.setValue(this.data.id, {\n        [styleName]: ColorConverters[`${colorType}_rgb`](colorArray)\n      });\n    };\n    return shadow(this, \"_commonActions\", {\n      display: event => {\n        const {\n          display\n        } = event.detail;\n        const hidden = display % 2 === 1;\n        this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n        this.annotationStorage.setValue(this.data.id, {\n          noView: hidden,\n          noPrint: display === 1 || display === 2\n        });\n      },\n      print: event => {\n        this.annotationStorage.setValue(this.data.id, {\n          noPrint: !event.detail.print\n        });\n      },\n      hidden: event => {\n        const {\n          hidden\n        } = event.detail;\n        this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n        this.annotationStorage.setValue(this.data.id, {\n          noPrint: hidden,\n          noView: hidden\n        });\n      },\n      focus: event => {\n        setTimeout(() => event.target.focus({\n          preventScroll: false\n        }), 0);\n      },\n      userName: event => {\n        event.target.title = event.detail.userName;\n      },\n      readonly: event => {\n        event.target.disabled = event.detail.readonly;\n      },\n      required: event => {\n        this._setRequired(event.target, event.detail.required);\n      },\n      bgColor: event => {\n        setColor(\"bgColor\", \"backgroundColor\", event);\n      },\n      fillColor: event => {\n        setColor(\"fillColor\", \"backgroundColor\", event);\n      },\n      fgColor: event => {\n        setColor(\"fgColor\", \"color\", event);\n      },\n      textColor: event => {\n        setColor(\"textColor\", \"color\", event);\n      },\n      borderColor: event => {\n        setColor(\"borderColor\", \"borderColor\", event);\n      },\n      strokeColor: event => {\n        setColor(\"strokeColor\", \"borderColor\", event);\n      },\n      rotation: event => {\n        const angle = event.detail.rotation;\n        this.setRotation(angle);\n        this.annotationStorage.setValue(this.data.id, {\n          rotation: angle\n        });\n      }\n    });\n  }\n  _dispatchEventFromSandbox(actions, jsEvent) {\n    const commonActions = this._commonActions;\n    for (const name of Object.keys(jsEvent.detail)) {\n      const action = actions[name] || commonActions[name];\n      action?.(jsEvent);\n    }\n  }\n  _setDefaultPropertiesFromJS(element) {\n    if (!this.enableScripting) {\n      return;\n    }\n    const storedData = this.annotationStorage.getRawValue(this.data.id);\n    if (!storedData) {\n      return;\n    }\n    const commonActions = this._commonActions;\n    for (const [actionName, detail] of Object.entries(storedData)) {\n      const action = commonActions[actionName];\n      if (action) {\n        const eventProxy = {\n          detail: {\n            [actionName]: detail\n          },\n          target: element\n        };\n        action(eventProxy);\n        delete storedData[actionName];\n      }\n    }\n  }\n  _createQuadrilaterals() {\n    if (!this.container) {\n      return;\n    }\n    const {\n      quadPoints\n    } = this.data;\n    if (!quadPoints) {\n      return;\n    }\n    const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect.map(x => Math.fround(x));\n    if (quadPoints.length === 8) {\n      const [trX, trY, blX, blY] = quadPoints.subarray(2, 6);\n      if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {\n        return;\n      }\n    }\n    const {\n      style\n    } = this.container;\n    let svgBuffer;\n    if (this.#hasBorder) {\n      const {\n        borderColor,\n        borderWidth\n      } = style;\n      style.borderWidth = 0;\n      svgBuffer = [\"url('data:image/svg+xml;utf8,\", `<svg xmlns=\"http://www.w3.org/2000/svg\"`, ` preserveAspectRatio=\"none\" viewBox=\"0 0 1 1\">`, `<g fill=\"transparent\" stroke=\"${borderColor}\" stroke-width=\"${borderWidth}\">`];\n      this.container.classList.add(\"hasBorder\");\n    }\n    const width = rectTrX - rectBlX;\n    const height = rectTrY - rectBlY;\n    const {\n      svgFactory\n    } = this;\n    const svg = svgFactory.createElement(\"svg\");\n    svg.classList.add(\"quadrilateralsContainer\");\n    svg.setAttribute(\"width\", 0);\n    svg.setAttribute(\"height\", 0);\n    svg.role = \"none\";\n    const defs = svgFactory.createElement(\"defs\");\n    svg.append(defs);\n    const clipPath = svgFactory.createElement(\"clipPath\");\n    const id = `clippath_${this.data.id}`;\n    clipPath.setAttribute(\"id\", id);\n    clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n    defs.append(clipPath);\n    for (let i = 2, ii = quadPoints.length; i < ii; i += 8) {\n      const trX = quadPoints[i];\n      const trY = quadPoints[i + 1];\n      const blX = quadPoints[i + 2];\n      const blY = quadPoints[i + 3];\n      const rect = svgFactory.createElement(\"rect\");\n      const x = (blX - rectBlX) / width;\n      const y = (rectTrY - trY) / height;\n      const rectWidth = (trX - blX) / width;\n      const rectHeight = (trY - blY) / height;\n      rect.setAttribute(\"x\", x);\n      rect.setAttribute(\"y\", y);\n      rect.setAttribute(\"width\", rectWidth);\n      rect.setAttribute(\"height\", rectHeight);\n      clipPath.append(rect);\n      svgBuffer?.push(`<rect vector-effect=\"non-scaling-stroke\" x=\"${x}\" y=\"${y}\" width=\"${rectWidth}\" height=\"${rectHeight}\"/>`);\n    }\n    if (this.#hasBorder) {\n      svgBuffer.push(`</g></svg>')`);\n      style.backgroundImage = svgBuffer.join(\"\");\n    }\n    this.container.append(svg);\n    this.container.style.clipPath = `url(#${id})`;\n  }\n  _createPopup(popupData = null) {\n    const {\n      data\n    } = this;\n    let contentsObj, modificationDate;\n    if (popupData) {\n      contentsObj = {\n        str: popupData.text\n      };\n      modificationDate = popupData.date;\n    } else {\n      contentsObj = data.contentsObj;\n      modificationDate = data.modificationDate;\n    }\n    const popup = this.#popupElement = new PopupAnnotationElement({\n      data: {\n        color: data.color,\n        titleObj: data.titleObj,\n        modificationDate,\n        contentsObj,\n        richText: data.richText,\n        parentRect: data.rect,\n        borderStyle: 0,\n        id: `popup_${data.id}`,\n        rotation: data.rotation,\n        noRotate: true\n      },\n      linkService: this.linkService,\n      parent: this.parent,\n      elements: [this]\n    });\n    this.parent.div.append(popup.render());\n  }\n  get hasPopupElement() {\n    return !!(this.#popupElement || this.popup || this.data.popupRef);\n  }\n  render() {\n    unreachable(\"Abstract method `AnnotationElement.render` called\");\n  }\n  _getElementsByName(name, skipId = null) {\n    const fields = [];\n    if (this._fieldObjects) {\n      const fieldObj = this._fieldObjects[name];\n      if (fieldObj) {\n        for (const {\n          page,\n          id,\n          exportValues\n        } of fieldObj) {\n          if (page === -1) {\n            continue;\n          }\n          if (id === skipId) {\n            continue;\n          }\n          const exportValue = typeof exportValues === \"string\" ? exportValues : null;\n          const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n          if (domElement && !GetElementsByNameSet.has(domElement)) {\n            warn(`_getElementsByName - element not allowed: ${id}`);\n            continue;\n          }\n          fields.push({\n            id,\n            exportValue,\n            domElement\n          });\n        }\n      }\n      return fields;\n    }\n    for (const domElement of document.getElementsByName(name)) {\n      const {\n        exportValue\n      } = domElement;\n      const id = domElement.getAttribute(\"data-element-id\");\n      if (id === skipId) {\n        continue;\n      }\n      if (!GetElementsByNameSet.has(domElement)) {\n        continue;\n      }\n      fields.push({\n        id,\n        exportValue,\n        domElement\n      });\n    }\n    return fields;\n  }\n  show() {\n    if (this.container) {\n      this.container.hidden = false;\n    }\n    this.popup?.maybeShow();\n  }\n  hide() {\n    if (this.container) {\n      this.container.hidden = true;\n    }\n    this.popup?.forceHide();\n  }\n  getElementsToTriggerPopup() {\n    return this.container;\n  }\n  addHighlightArea() {\n    const triggers = this.getElementsToTriggerPopup();\n    if (Array.isArray(triggers)) {\n      for (const element of triggers) {\n        element.classList.add(\"highlightArea\");\n      }\n    } else {\n      triggers.classList.add(\"highlightArea\");\n    }\n  }\n  _editOnDoubleClick() {\n    if (!this._isEditable) {\n      return;\n    }\n    const {\n      annotationEditorType: mode,\n      data: {\n        id: editId\n      }\n    } = this;\n    this.container.addEventListener(\"dblclick\", () => {\n      this.linkService.eventBus?.dispatch(\"switchannotationeditormode\", {\n        source: this,\n        mode,\n        editId,\n        mustEnterInEditMode: true\n      });\n    });\n  }\n  get width() {\n    return this.data.rect[2] - this.data.rect[0];\n  }\n  get height() {\n    return this.data.rect[3] - this.data.rect[1];\n  }\n}\nclass LinkAnnotationElement extends AnnotationElement {\n  constructor(parameters, options = null) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: !!options?.ignoreBorder,\n      createQuadrilaterals: true\n    });\n    this.isTooltipOnly = parameters.data.isTooltipOnly;\n  }\n  render() {\n    const {\n      data,\n      linkService\n    } = this;\n    const link = document.createElement(\"a\");\n    link.setAttribute(\"data-element-id\", data.id);\n    let isBound = false;\n    if (data.url) {\n      linkService.addLinkAttributes(link, data.url, data.newWindow);\n      isBound = true;\n    } else if (data.action) {\n      this._bindNamedAction(link, data.action, data.overlaidText);\n      isBound = true;\n    } else if (data.attachment) {\n      this.#bindAttachment(link, data.attachment, data.overlaidText, data.attachmentDest);\n      isBound = true;\n    } else if (data.setOCGState) {\n      this.#bindSetOCGState(link, data.setOCGState, data.overlaidText);\n      isBound = true;\n    } else if (data.dest) {\n      this._bindLink(link, data.dest, data.overlaidText);\n      isBound = true;\n    } else {\n      if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n        this._bindJSAction(link, data);\n        isBound = true;\n      }\n      if (data.resetForm) {\n        this._bindResetFormAction(link, data.resetForm);\n        isBound = true;\n      } else if (this.isTooltipOnly && !isBound) {\n        this._bindLink(link, \"\");\n        isBound = true;\n      }\n    }\n    this.container.classList.add(\"linkAnnotation\");\n    if (isBound) {\n      this.container.append(link);\n    }\n    return this.container;\n  }\n  #setInternalLink() {\n    this.container.setAttribute(\"data-internal-link\", \"\");\n  }\n  _bindLink(link, destination, overlaidText = \"\") {\n    link.href = this.linkService.getDestinationHash(destination);\n    link.onclick = () => {\n      if (destination) {\n        this.linkService.goToDestination(destination);\n      }\n      return false;\n    };\n    if (destination || destination === \"\") {\n      this.#setInternalLink();\n    }\n    if (overlaidText) {\n      link.title = overlaidText;\n    }\n  }\n  _bindNamedAction(link, action, overlaidText = \"\") {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    link.onclick = () => {\n      this.linkService.executeNamedAction(action);\n      return false;\n    };\n    if (overlaidText) {\n      link.title = overlaidText;\n    }\n    this.#setInternalLink();\n  }\n  #bindAttachment(link, attachment, overlaidText = \"\", dest = null) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    if (attachment.description) {\n      link.title = attachment.description;\n    } else if (overlaidText) {\n      link.title = overlaidText;\n    }\n    link.onclick = () => {\n      this.downloadManager?.openOrDownloadData(attachment.content, attachment.filename, dest);\n      return false;\n    };\n    this.#setInternalLink();\n  }\n  #bindSetOCGState(link, action, overlaidText = \"\") {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    link.onclick = () => {\n      this.linkService.executeSetOCGState(action);\n      return false;\n    };\n    if (overlaidText) {\n      link.title = overlaidText;\n    }\n    this.#setInternalLink();\n  }\n  _bindJSAction(link, data) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    const map = new Map([[\"Action\", \"onclick\"], [\"Mouse Up\", \"onmouseup\"], [\"Mouse Down\", \"onmousedown\"]]);\n    for (const name of Object.keys(data.actions)) {\n      const jsName = map.get(name);\n      if (!jsName) {\n        continue;\n      }\n      link[jsName] = () => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: data.id,\n            name\n          }\n        });\n        return false;\n      };\n    }\n    if (data.overlaidText) {\n      link.title = data.overlaidText;\n    }\n    if (!link.onclick) {\n      link.onclick = () => false;\n    }\n    this.#setInternalLink();\n  }\n  _bindResetFormAction(link, resetForm) {\n    const otherClickAction = link.onclick;\n    if (!otherClickAction) {\n      link.href = this.linkService.getAnchorUrl(\"\");\n    }\n    this.#setInternalLink();\n    if (!this._fieldObjects) {\n      warn(`_bindResetFormAction - \"resetForm\" action not supported, ` + \"ensure that the `fieldObjects` parameter is provided.\");\n      if (!otherClickAction) {\n        link.onclick = () => false;\n      }\n      return;\n    }\n    link.onclick = () => {\n      otherClickAction?.();\n      const {\n        fields: resetFormFields,\n        refs: resetFormRefs,\n        include\n      } = resetForm;\n      const allFields = [];\n      if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {\n        const fieldIds = new Set(resetFormRefs);\n        for (const fieldName of resetFormFields) {\n          const fields = this._fieldObjects[fieldName] || [];\n          for (const {\n            id\n          } of fields) {\n            fieldIds.add(id);\n          }\n        }\n        for (const fields of Object.values(this._fieldObjects)) {\n          for (const field of fields) {\n            if (fieldIds.has(field.id) === include) {\n              allFields.push(field);\n            }\n          }\n        }\n      } else {\n        for (const fields of Object.values(this._fieldObjects)) {\n          allFields.push(...fields);\n        }\n      }\n      const storage = this.annotationStorage;\n      const allIds = [];\n      for (const field of allFields) {\n        const {\n          id\n        } = field;\n        allIds.push(id);\n        switch (field.type) {\n          case \"text\":\n            {\n              const value = field.defaultValue || \"\";\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n          case \"checkbox\":\n          case \"radiobutton\":\n            {\n              const value = field.defaultValue === field.exportValues;\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n          case \"combobox\":\n          case \"listbox\":\n            {\n              const value = field.defaultValue || \"\";\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n          default:\n            continue;\n        }\n        const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n        if (!domElement) {\n          continue;\n        } else if (!GetElementsByNameSet.has(domElement)) {\n          warn(`_bindResetFormAction - element not allowed: ${id}`);\n          continue;\n        }\n        domElement.dispatchEvent(new Event(\"resetform\"));\n      }\n      if (this.enableScripting) {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: \"app\",\n            ids: allIds,\n            name: \"ResetForm\"\n          }\n        });\n      }\n      return false;\n    };\n  }\n}\nclass TextAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"textAnnotation\");\n    const image = document.createElement(\"img\");\n    image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n    image.setAttribute(\"data-l10n-id\", \"pdfjs-text-annotation-type\");\n    image.setAttribute(\"data-l10n-args\", JSON.stringify({\n      type: this.data.name\n    }));\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this.container.append(image);\n    return this.container;\n  }\n}\nclass WidgetAnnotationElement extends AnnotationElement {\n  render() {\n    return this.container;\n  }\n  showElementAndHideCanvas(element) {\n    if (this.data.hasOwnCanvas) {\n      if (element.previousSibling?.nodeName === \"CANVAS\") {\n        element.previousSibling.hidden = true;\n      }\n      element.hidden = false;\n    }\n  }\n  _getKeyModifier(event) {\n    return util_FeatureTest.platform.isMac ? event.metaKey : event.ctrlKey;\n  }\n  _setEventListener(element, elementData, baseName, eventName, valueGetter) {\n    if (baseName.includes(\"mouse\")) {\n      element.addEventListener(baseName, event => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: this.data.id,\n            name: eventName,\n            value: valueGetter(event),\n            shift: event.shiftKey,\n            modifier: this._getKeyModifier(event)\n          }\n        });\n      });\n    } else {\n      element.addEventListener(baseName, event => {\n        if (baseName === \"blur\") {\n          if (!elementData.focused || !event.relatedTarget) {\n            return;\n          }\n          elementData.focused = false;\n        } else if (baseName === \"focus\") {\n          if (elementData.focused) {\n            return;\n          }\n          elementData.focused = true;\n        }\n        if (!valueGetter) {\n          return;\n        }\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: this.data.id,\n            name: eventName,\n            value: valueGetter(event)\n          }\n        });\n      });\n    }\n  }\n  _setEventListeners(element, elementData, names, getter) {\n    for (const [baseName, eventName] of names) {\n      if (eventName === \"Action\" || this.data.actions?.[eventName]) {\n        if (eventName === \"Focus\" || eventName === \"Blur\") {\n          elementData ||= {\n            focused: false\n          };\n        }\n        this._setEventListener(element, elementData, baseName, eventName, getter);\n        if (eventName === \"Focus\" && !this.data.actions?.Blur) {\n          this._setEventListener(element, elementData, \"blur\", \"Blur\", null);\n        } else if (eventName === \"Blur\" && !this.data.actions?.Focus) {\n          this._setEventListener(element, elementData, \"focus\", \"Focus\", null);\n        }\n      }\n    }\n  }\n  _setBackgroundColor(element) {\n    const color = this.data.backgroundColor || null;\n    element.style.backgroundColor = color === null ? \"transparent\" : Util.makeHexColor(color[0], color[1], color[2]);\n  }\n  _setTextStyle(element) {\n    const TEXT_ALIGNMENT = [\"left\", \"center\", \"right\"];\n    const {\n      fontColor\n    } = this.data.defaultAppearanceData;\n    const fontSize = this.data.defaultAppearanceData.fontSize || annotation_layer_DEFAULT_FONT_SIZE;\n    const style = element.style;\n    let computedFontSize;\n    const BORDER_SIZE = 2;\n    const roundToOneDecimal = x => Math.round(10 * x) / 10;\n    if (this.data.multiLine) {\n      const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n      const numberOfLines = Math.round(height / (LINE_FACTOR * fontSize)) || 1;\n      const lineHeight = height / numberOfLines;\n      computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / LINE_FACTOR));\n    } else {\n      const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n      computedFontSize = Math.min(fontSize, roundToOneDecimal(height / LINE_FACTOR));\n    }\n    style.fontSize = `calc(${computedFontSize}px * var(--total-scale-factor))`;\n    style.color = Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n    if (this.data.textAlignment !== null) {\n      style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n    }\n  }\n  _setRequired(element, isRequired) {\n    if (isRequired) {\n      element.setAttribute(\"required\", true);\n    } else {\n      element.removeAttribute(\"required\");\n    }\n    element.setAttribute(\"aria-required\", isRequired);\n  }\n}\nclass TextWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    const isRenderable = parameters.renderForms || parameters.data.hasOwnCanvas || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n    super(parameters, {\n      isRenderable\n    });\n  }\n  setPropertyOnSiblings(base, key, value, keyInStorage) {\n    const storage = this.annotationStorage;\n    for (const element of this._getElementsByName(base.name, base.id)) {\n      if (element.domElement) {\n        element.domElement[key] = value;\n      }\n      storage.setValue(element.id, {\n        [keyInStorage]: value\n      });\n    }\n  }\n  render() {\n    const storage = this.annotationStorage;\n    const id = this.data.id;\n    this.container.classList.add(\"textWidgetAnnotation\");\n    let element = null;\n    if (this.renderForms) {\n      const storedData = storage.getValue(id, {\n        value: this.data.fieldValue\n      });\n      let textContent = storedData.value || \"\";\n      const maxLen = storage.getValue(id, {\n        charLimit: this.data.maxLen\n      }).charLimit;\n      if (maxLen && textContent.length > maxLen) {\n        textContent = textContent.slice(0, maxLen);\n      }\n      let fieldFormattedValues = storedData.formattedValue || this.data.textContent?.join(\"\\n\") || null;\n      if (fieldFormattedValues && this.data.comb) {\n        fieldFormattedValues = fieldFormattedValues.replaceAll(/\\s+/g, \"\");\n      }\n      const elementData = {\n        userValue: textContent,\n        formattedValue: fieldFormattedValues,\n        lastCommittedValue: null,\n        commitKey: 1,\n        focused: false\n      };\n      if (this.data.multiLine) {\n        element = document.createElement(\"textarea\");\n        element.textContent = fieldFormattedValues ?? textContent;\n        if (this.data.doNotScroll) {\n          element.style.overflowY = \"hidden\";\n        }\n      } else {\n        element = document.createElement(\"input\");\n        element.type = this.data.password ? \"password\" : \"text\";\n        element.setAttribute(\"value\", fieldFormattedValues ?? textContent);\n        if (this.data.doNotScroll) {\n          element.style.overflowX = \"hidden\";\n        }\n      }\n      if (this.data.hasOwnCanvas) {\n        element.hidden = true;\n      }\n      GetElementsByNameSet.add(element);\n      element.setAttribute(\"data-element-id\", id);\n      element.disabled = this.data.readOnly;\n      element.name = this.data.fieldName;\n      element.tabIndex = 0;\n      const {\n        datetimeFormat,\n        datetimeType,\n        timeStep\n      } = this.data;\n      const hasDateOrTime = !!datetimeType && this.enableScripting;\n      if (datetimeFormat) {\n        element.title = datetimeFormat;\n      }\n      this._setRequired(element, this.data.required);\n      if (maxLen) {\n        element.maxLength = maxLen;\n      }\n      element.addEventListener(\"input\", event => {\n        storage.setValue(id, {\n          value: event.target.value\n        });\n        this.setPropertyOnSiblings(element, \"value\", event.target.value, \"value\");\n        elementData.formattedValue = null;\n      });\n      element.addEventListener(\"resetform\", event => {\n        const defaultValue = this.data.defaultFieldValue ?? \"\";\n        element.value = elementData.userValue = defaultValue;\n        elementData.formattedValue = null;\n      });\n      let blurListener = event => {\n        const {\n          formattedValue\n        } = elementData;\n        if (formattedValue !== null && formattedValue !== undefined) {\n          event.target.value = formattedValue;\n        }\n        event.target.scrollLeft = 0;\n      };\n      if (this.enableScripting && this.hasJSActions) {\n        element.addEventListener(\"focus\", event => {\n          if (elementData.focused) {\n            return;\n          }\n          const {\n            target\n          } = event;\n          if (hasDateOrTime) {\n            target.type = datetimeType;\n            if (timeStep) {\n              target.step = timeStep;\n            }\n          }\n          if (elementData.userValue) {\n            const value = elementData.userValue;\n            if (hasDateOrTime) {\n              if (datetimeType === \"time\") {\n                const date = new Date(value);\n                const parts = [date.getHours(), date.getMinutes(), date.getSeconds()];\n                target.value = parts.map(v => v.toString().padStart(2, \"0\")).join(\":\");\n              } else {\n                target.value = new Date(value - TIMEZONE_OFFSET).toISOString().split(datetimeType === \"date\" ? \"T\" : \".\", 1)[0];\n              }\n            } else {\n              target.value = value;\n            }\n          }\n          elementData.lastCommittedValue = target.value;\n          elementData.commitKey = 1;\n          if (!this.data.actions?.Focus) {\n            elementData.focused = true;\n          }\n        });\n        element.addEventListener(\"updatefromsandbox\", jsEvent => {\n          this.showElementAndHideCanvas(jsEvent.target);\n          const actions = {\n            value(event) {\n              elementData.userValue = event.detail.value ?? \"\";\n              if (!hasDateOrTime) {\n                storage.setValue(id, {\n                  value: elementData.userValue.toString()\n                });\n              }\n              event.target.value = elementData.userValue;\n            },\n            formattedValue(event) {\n              const {\n                formattedValue\n              } = event.detail;\n              elementData.formattedValue = formattedValue;\n              if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {\n                event.target.value = formattedValue;\n              }\n              const data = {\n                formattedValue\n              };\n              if (hasDateOrTime) {\n                data.value = formattedValue;\n              }\n              storage.setValue(id, data);\n            },\n            selRange(event) {\n              event.target.setSelectionRange(...event.detail.selRange);\n            },\n            charLimit: event => {\n              const {\n                charLimit\n              } = event.detail;\n              const {\n                target\n              } = event;\n              if (charLimit === 0) {\n                target.removeAttribute(\"maxLength\");\n                return;\n              }\n              target.setAttribute(\"maxLength\", charLimit);\n              let value = elementData.userValue;\n              if (!value || value.length <= charLimit) {\n                return;\n              }\n              value = value.slice(0, charLimit);\n              target.value = elementData.userValue = value;\n              storage.setValue(id, {\n                value\n              });\n              this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                source: this,\n                detail: {\n                  id,\n                  name: \"Keystroke\",\n                  value,\n                  willCommit: true,\n                  commitKey: 1,\n                  selStart: target.selectionStart,\n                  selEnd: target.selectionEnd\n                }\n              });\n            }\n          };\n          this._dispatchEventFromSandbox(actions, jsEvent);\n        });\n        element.addEventListener(\"keydown\", event => {\n          elementData.commitKey = 1;\n          let commitKey = -1;\n          if (event.key === \"Escape\") {\n            commitKey = 0;\n          } else if (event.key === \"Enter\" && !this.data.multiLine) {\n            commitKey = 2;\n          } else if (event.key === \"Tab\") {\n            elementData.commitKey = 3;\n          }\n          if (commitKey === -1) {\n            return;\n          }\n          const {\n            value\n          } = event.target;\n          if (elementData.lastCommittedValue === value) {\n            return;\n          }\n          elementData.lastCommittedValue = value;\n          elementData.userValue = value;\n          this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n            source: this,\n            detail: {\n              id,\n              name: \"Keystroke\",\n              value,\n              willCommit: true,\n              commitKey,\n              selStart: event.target.selectionStart,\n              selEnd: event.target.selectionEnd\n            }\n          });\n        });\n        const _blurListener = blurListener;\n        blurListener = null;\n        element.addEventListener(\"blur\", event => {\n          if (!elementData.focused || !event.relatedTarget) {\n            return;\n          }\n          if (!this.data.actions?.Blur) {\n            elementData.focused = false;\n          }\n          const {\n            target\n          } = event;\n          let {\n            value\n          } = target;\n          if (hasDateOrTime) {\n            if (value && datetimeType === \"time\") {\n              const parts = value.split(\":\").map(v => parseInt(v, 10));\n              value = new Date(2000, 0, 1, parts[0], parts[1], parts[2] || 0).valueOf();\n              target.step = \"\";\n            } else {\n              value = new Date(value).valueOf();\n            }\n            target.type = \"text\";\n          }\n          elementData.userValue = value;\n          if (elementData.lastCommittedValue !== value) {\n            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n              source: this,\n              detail: {\n                id,\n                name: \"Keystroke\",\n                value,\n                willCommit: true,\n                commitKey: elementData.commitKey,\n                selStart: event.target.selectionStart,\n                selEnd: event.target.selectionEnd\n              }\n            });\n          }\n          _blurListener(event);\n        });\n        if (this.data.actions?.Keystroke) {\n          element.addEventListener(\"beforeinput\", event => {\n            elementData.lastCommittedValue = null;\n            const {\n              data,\n              target\n            } = event;\n            const {\n              value,\n              selectionStart,\n              selectionEnd\n            } = target;\n            let selStart = selectionStart,\n              selEnd = selectionEnd;\n            switch (event.inputType) {\n              case \"deleteWordBackward\":\n                {\n                  const match = value.substring(0, selectionStart).match(/\\w*[^\\w]*$/);\n                  if (match) {\n                    selStart -= match[0].length;\n                  }\n                  break;\n                }\n              case \"deleteWordForward\":\n                {\n                  const match = value.substring(selectionStart).match(/^[^\\w]*\\w*/);\n                  if (match) {\n                    selEnd += match[0].length;\n                  }\n                  break;\n                }\n              case \"deleteContentBackward\":\n                if (selectionStart === selectionEnd) {\n                  selStart -= 1;\n                }\n                break;\n              case \"deleteContentForward\":\n                if (selectionStart === selectionEnd) {\n                  selEnd += 1;\n                }\n                break;\n            }\n            event.preventDefault();\n            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n              source: this,\n              detail: {\n                id,\n                name: \"Keystroke\",\n                value,\n                change: data || \"\",\n                willCommit: false,\n                selStart,\n                selEnd\n              }\n            });\n          });\n        }\n        this._setEventListeners(element, elementData, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.value);\n      }\n      if (blurListener) {\n        element.addEventListener(\"blur\", blurListener);\n      }\n      if (this.data.comb) {\n        const fieldWidth = this.data.rect[2] - this.data.rect[0];\n        const combWidth = fieldWidth / maxLen;\n        element.classList.add(\"comb\");\n        element.style.letterSpacing = `calc(${combWidth}px * var(--total-scale-factor) - 1ch)`;\n      }\n    } else {\n      element = document.createElement(\"div\");\n      element.textContent = this.data.fieldValue;\n      element.style.verticalAlign = \"middle\";\n      element.style.display = \"table-cell\";\n      if (this.data.hasOwnCanvas) {\n        element.hidden = true;\n      }\n    }\n    this._setTextStyle(element);\n    this._setBackgroundColor(element);\n    this._setDefaultPropertiesFromJS(element);\n    this.container.append(element);\n    return this.container;\n  }\n}\nclass SignatureWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: !!parameters.data.hasOwnCanvas\n    });\n  }\n}\nclass CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n  render() {\n    const storage = this.annotationStorage;\n    const data = this.data;\n    const id = data.id;\n    let value = storage.getValue(id, {\n      value: data.exportValue === data.fieldValue\n    }).value;\n    if (typeof value === \"string\") {\n      value = value !== \"Off\";\n      storage.setValue(id, {\n        value\n      });\n    }\n    this.container.classList.add(\"buttonWidgetAnnotation\", \"checkBox\");\n    const element = document.createElement(\"input\");\n    GetElementsByNameSet.add(element);\n    element.setAttribute(\"data-element-id\", id);\n    element.disabled = data.readOnly;\n    this._setRequired(element, this.data.required);\n    element.type = \"checkbox\";\n    element.name = data.fieldName;\n    if (value) {\n      element.setAttribute(\"checked\", true);\n    }\n    element.setAttribute(\"exportValue\", data.exportValue);\n    element.tabIndex = 0;\n    element.addEventListener(\"change\", event => {\n      const {\n        name,\n        checked\n      } = event.target;\n      for (const checkbox of this._getElementsByName(name, id)) {\n        const curChecked = checked && checkbox.exportValue === data.exportValue;\n        if (checkbox.domElement) {\n          checkbox.domElement.checked = curChecked;\n        }\n        storage.setValue(checkbox.id, {\n          value: curChecked\n        });\n      }\n      storage.setValue(id, {\n        value: checked\n      });\n    });\n    element.addEventListener(\"resetform\", event => {\n      const defaultValue = data.defaultFieldValue || \"Off\";\n      event.target.checked = defaultValue === data.exportValue;\n    });\n    if (this.enableScripting && this.hasJSActions) {\n      element.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value(event) {\n            event.target.checked = event.detail.value !== \"Off\";\n            storage.setValue(id, {\n              value: event.target.checked\n            });\n          }\n        };\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n      this._setEventListeners(element, null, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\n    }\n    this._setBackgroundColor(element);\n    this._setDefaultPropertiesFromJS(element);\n    this.container.append(element);\n    return this.container;\n  }\n}\nclass RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n  render() {\n    this.container.classList.add(\"buttonWidgetAnnotation\", \"radioButton\");\n    const storage = this.annotationStorage;\n    const data = this.data;\n    const id = data.id;\n    let value = storage.getValue(id, {\n      value: data.fieldValue === data.buttonValue\n    }).value;\n    if (typeof value === \"string\") {\n      value = value !== data.buttonValue;\n      storage.setValue(id, {\n        value\n      });\n    }\n    if (value) {\n      for (const radio of this._getElementsByName(data.fieldName, id)) {\n        storage.setValue(radio.id, {\n          value: false\n        });\n      }\n    }\n    const element = document.createElement(\"input\");\n    GetElementsByNameSet.add(element);\n    element.setAttribute(\"data-element-id\", id);\n    element.disabled = data.readOnly;\n    this._setRequired(element, this.data.required);\n    element.type = \"radio\";\n    element.name = data.fieldName;\n    if (value) {\n      element.setAttribute(\"checked\", true);\n    }\n    element.tabIndex = 0;\n    element.addEventListener(\"change\", event => {\n      const {\n        name,\n        checked\n      } = event.target;\n      for (const radio of this._getElementsByName(name, id)) {\n        storage.setValue(radio.id, {\n          value: false\n        });\n      }\n      storage.setValue(id, {\n        value: checked\n      });\n    });\n    element.addEventListener(\"resetform\", event => {\n      const defaultValue = data.defaultFieldValue;\n      event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;\n    });\n    if (this.enableScripting && this.hasJSActions) {\n      const pdfButtonValue = data.buttonValue;\n      element.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value: event => {\n            const checked = pdfButtonValue === event.detail.value;\n            for (const radio of this._getElementsByName(event.target.name)) {\n              const curChecked = checked && radio.id === id;\n              if (radio.domElement) {\n                radio.domElement.checked = curChecked;\n              }\n              storage.setValue(radio.id, {\n                value: curChecked\n              });\n            }\n          }\n        };\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n      this._setEventListeners(element, null, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\n    }\n    this._setBackgroundColor(element);\n    this._setDefaultPropertiesFromJS(element);\n    this.container.append(element);\n    return this.container;\n  }\n}\nclass PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      ignoreBorder: parameters.data.hasAppearance\n    });\n  }\n  render() {\n    const container = super.render();\n    container.classList.add(\"buttonWidgetAnnotation\", \"pushButton\");\n    const linkElement = container.lastChild;\n    if (this.enableScripting && this.hasJSActions && linkElement) {\n      this._setDefaultPropertiesFromJS(linkElement);\n      linkElement.addEventListener(\"updatefromsandbox\", jsEvent => {\n        this._dispatchEventFromSandbox({}, jsEvent);\n      });\n    }\n    return container;\n  }\n}\nclass ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n  render() {\n    this.container.classList.add(\"choiceWidgetAnnotation\");\n    const storage = this.annotationStorage;\n    const id = this.data.id;\n    const storedData = storage.getValue(id, {\n      value: this.data.fieldValue\n    });\n    const selectElement = document.createElement(\"select\");\n    GetElementsByNameSet.add(selectElement);\n    selectElement.setAttribute(\"data-element-id\", id);\n    selectElement.disabled = this.data.readOnly;\n    this._setRequired(selectElement, this.data.required);\n    selectElement.name = this.data.fieldName;\n    selectElement.tabIndex = 0;\n    let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;\n    if (!this.data.combo) {\n      selectElement.size = this.data.options.length;\n      if (this.data.multiSelect) {\n        selectElement.multiple = true;\n      }\n    }\n    selectElement.addEventListener(\"resetform\", event => {\n      const defaultValue = this.data.defaultFieldValue;\n      for (const option of selectElement.options) {\n        option.selected = option.value === defaultValue;\n      }\n    });\n    for (const option of this.data.options) {\n      const optionElement = document.createElement(\"option\");\n      optionElement.textContent = option.displayValue;\n      optionElement.value = option.exportValue;\n      if (storedData.value.includes(option.exportValue)) {\n        optionElement.setAttribute(\"selected\", true);\n        addAnEmptyEntry = false;\n      }\n      selectElement.append(optionElement);\n    }\n    let removeEmptyEntry = null;\n    if (addAnEmptyEntry) {\n      const noneOptionElement = document.createElement(\"option\");\n      noneOptionElement.value = \" \";\n      noneOptionElement.setAttribute(\"hidden\", true);\n      noneOptionElement.setAttribute(\"selected\", true);\n      selectElement.prepend(noneOptionElement);\n      removeEmptyEntry = () => {\n        noneOptionElement.remove();\n        selectElement.removeEventListener(\"input\", removeEmptyEntry);\n        removeEmptyEntry = null;\n      };\n      selectElement.addEventListener(\"input\", removeEmptyEntry);\n    }\n    const getValue = isExport => {\n      const name = isExport ? \"value\" : \"textContent\";\n      const {\n        options,\n        multiple\n      } = selectElement;\n      if (!multiple) {\n        return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];\n      }\n      return Array.prototype.filter.call(options, option => option.selected).map(option => option[name]);\n    };\n    let selectedValues = getValue(false);\n    const getItems = event => {\n      const options = event.target.options;\n      return Array.prototype.map.call(options, option => ({\n        displayValue: option.textContent,\n        exportValue: option.value\n      }));\n    };\n    if (this.enableScripting && this.hasJSActions) {\n      selectElement.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value(event) {\n            removeEmptyEntry?.();\n            const value = event.detail.value;\n            const values = new Set(Array.isArray(value) ? value : [value]);\n            for (const option of selectElement.options) {\n              option.selected = values.has(option.value);\n            }\n            storage.setValue(id, {\n              value: getValue(true)\n            });\n            selectedValues = getValue(false);\n          },\n          multipleSelection(event) {\n            selectElement.multiple = true;\n          },\n          remove(event) {\n            const options = selectElement.options;\n            const index = event.detail.remove;\n            options[index].selected = false;\n            selectElement.remove(index);\n            if (options.length > 0) {\n              const i = Array.prototype.findIndex.call(options, option => option.selected);\n              if (i === -1) {\n                options[0].selected = true;\n              }\n            }\n            storage.setValue(id, {\n              value: getValue(true),\n              items: getItems(event)\n            });\n            selectedValues = getValue(false);\n          },\n          clear(event) {\n            while (selectElement.length !== 0) {\n              selectElement.remove(0);\n            }\n            storage.setValue(id, {\n              value: null,\n              items: []\n            });\n            selectedValues = getValue(false);\n          },\n          insert(event) {\n            const {\n              index,\n              displayValue,\n              exportValue\n            } = event.detail.insert;\n            const selectChild = selectElement.children[index];\n            const optionElement = document.createElement(\"option\");\n            optionElement.textContent = displayValue;\n            optionElement.value = exportValue;\n            if (selectChild) {\n              selectChild.before(optionElement);\n            } else {\n              selectElement.append(optionElement);\n            }\n            storage.setValue(id, {\n              value: getValue(true),\n              items: getItems(event)\n            });\n            selectedValues = getValue(false);\n          },\n          items(event) {\n            const {\n              items\n            } = event.detail;\n            while (selectElement.length !== 0) {\n              selectElement.remove(0);\n            }\n            for (const item of items) {\n              const {\n                displayValue,\n                exportValue\n              } = item;\n              const optionElement = document.createElement(\"option\");\n              optionElement.textContent = displayValue;\n              optionElement.value = exportValue;\n              selectElement.append(optionElement);\n            }\n            if (selectElement.options.length > 0) {\n              selectElement.options[0].selected = true;\n            }\n            storage.setValue(id, {\n              value: getValue(true),\n              items: getItems(event)\n            });\n            selectedValues = getValue(false);\n          },\n          indices(event) {\n            const indices = new Set(event.detail.indices);\n            for (const option of event.target.options) {\n              option.selected = indices.has(option.index);\n            }\n            storage.setValue(id, {\n              value: getValue(true)\n            });\n            selectedValues = getValue(false);\n          },\n          editable(event) {\n            event.target.disabled = !event.detail.editable;\n          }\n        };\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n      selectElement.addEventListener(\"input\", event => {\n        const exportValue = getValue(true);\n        const change = getValue(false);\n        storage.setValue(id, {\n          value: exportValue\n        });\n        event.preventDefault();\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id,\n            name: \"Keystroke\",\n            value: selectedValues,\n            change,\n            changeEx: exportValue,\n            willCommit: false,\n            commitKey: 1,\n            keyDown: false\n          }\n        });\n      });\n      this._setEventListeners(selectElement, null, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"], [\"input\", \"Action\"], [\"input\", \"Validate\"]], event => event.target.value);\n    } else {\n      selectElement.addEventListener(\"input\", function (event) {\n        storage.setValue(id, {\n          value: getValue(true)\n        });\n      });\n    }\n    if (this.data.combo) {\n      this._setTextStyle(selectElement);\n    } else {}\n    this._setBackgroundColor(selectElement);\n    this._setDefaultPropertiesFromJS(selectElement);\n    this.container.append(selectElement);\n    return this.container;\n  }\n}\nclass PopupAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const {\n      data,\n      elements\n    } = parameters;\n    super(parameters, {\n      isRenderable: AnnotationElement._hasPopupData(data)\n    });\n    this.elements = elements;\n    this.popup = null;\n  }\n  render() {\n    const {\n      container\n    } = this;\n    container.classList.add(\"popupAnnotation\");\n    container.role = \"comment\";\n    const popup = this.popup = new PopupElement({\n      container: this.container,\n      color: this.data.color,\n      titleObj: this.data.titleObj,\n      modificationDate: this.data.modificationDate || this.data.creationDate,\n      contentsObj: this.data.contentsObj,\n      richText: this.data.richText,\n      rect: this.data.rect,\n      parentRect: this.data.parentRect || null,\n      parent: this.parent,\n      elements: this.elements,\n      open: this.data.open,\n      eventBus: this.linkService.eventBus\n    });\n    const elementIds = [];\n    for (const element of this.elements) {\n      element.popup = popup;\n      element.container.ariaHasPopup = \"dialog\";\n      elementIds.push(element.data.id);\n      element.addHighlightArea();\n    }\n    this.container.setAttribute(\"aria-controls\", elementIds.map(id => `${AnnotationPrefix}${id}`).join(\",\"));\n    return this.container;\n  }\n}\nclass PopupElement {\n  #boundKeyDown = this.#keyDown.bind(this);\n  #boundHide = this.#hide.bind(this);\n  #boundShow = this.#show.bind(this);\n  #boundToggle = this.#toggle.bind(this);\n  #color = null;\n  #container = null;\n  #contentsObj = null;\n  #dateObj = null;\n  #elements = null;\n  #eventBus = null;\n  #parent = null;\n  #parentRect = null;\n  #pinned = false;\n  #popup = null;\n  #popupAbortController = null;\n  #position = null;\n  #commentButton = null;\n  #commentButtonPosition = null;\n  #commentButtonColor = null;\n  #rect = null;\n  #richText = null;\n  #titleObj = null;\n  #updates = null;\n  #wasVisible = false;\n  constructor({\n    container,\n    color,\n    elements,\n    titleObj,\n    modificationDate,\n    contentsObj,\n    richText,\n    parent,\n    rect,\n    parentRect,\n    open,\n    eventBus = null\n  }) {\n    this.#container = container;\n    this.#titleObj = titleObj;\n    this.#contentsObj = contentsObj;\n    this.#richText = richText;\n    this.#parent = parent;\n    this.#color = color;\n    this.#rect = rect;\n    this.#parentRect = parentRect;\n    this.#elements = elements;\n    this.#eventBus = eventBus;\n    this.#dateObj = PDFDateString.toDateObject(modificationDate);\n    this.trigger = elements.flatMap(e => e.getElementsToTriggerPopup());\n    this.#addEventListeners();\n    this.#container.hidden = true;\n    if (open) {\n      this.#toggle();\n    }\n  }\n  #addEventListeners() {\n    if (this.#popupAbortController) {\n      return;\n    }\n    this.#popupAbortController = new AbortController();\n    const {\n      signal\n    } = this.#popupAbortController;\n    for (const element of this.trigger) {\n      element.addEventListener(\"click\", this.#boundToggle, {\n        signal\n      });\n      element.addEventListener(\"mouseenter\", this.#boundShow, {\n        signal\n      });\n      element.addEventListener(\"mouseleave\", this.#boundHide, {\n        signal\n      });\n      element.classList.add(\"popupTriggerArea\");\n    }\n    for (const element of this.#elements) {\n      element.container?.addEventListener(\"keydown\", this.#boundKeyDown, {\n        signal\n      });\n    }\n    this.#renderCommentButton();\n  }\n  #setCommentButtonPosition() {\n    const element = this.#elements.find(e => e.hasCommentButton);\n    if (!element) {\n      return;\n    }\n    this.#commentButtonPosition = element._normalizePoint(element.commentButtonPosition);\n    this.#commentButtonColor = element.commentButtonColor;\n  }\n  #renderCommentButton() {\n    if (this.#commentButton) {\n      return;\n    }\n    if (!this.#commentButtonPosition) {\n      this.#setCommentButtonPosition();\n    }\n    if (!this.#commentButtonPosition) {\n      return;\n    }\n    const button = this.#commentButton = document.createElement(\"button\");\n    button.className = \"annotationCommentButton\";\n    const parentContainer = this.#elements[0].container;\n    button.style.zIndex = parentContainer.style.zIndex + 1;\n    button.tabIndex = 0;\n    const {\n      signal\n    } = this.#popupAbortController;\n    button.addEventListener(\"hover\", this.#boundToggle, {\n      signal\n    });\n    button.addEventListener(\"keydown\", this.#boundKeyDown, {\n      signal\n    });\n    button.addEventListener(\"click\", () => {\n      const [{\n        data: {\n          id: editId\n        },\n        annotationEditorType: mode\n      }] = this.#elements;\n      this.#eventBus?.dispatch(\"switchannotationeditormode\", {\n        source: this,\n        editId,\n        mode,\n        editComment: true\n      });\n    }, {\n      signal\n    });\n    const {\n      style\n    } = button;\n    style.left = `calc(${this.#commentButtonPosition[0]}%)`;\n    style.top = `calc(${this.#commentButtonPosition[1]}% - var(--comment-button-dim))`;\n    if (this.#commentButtonColor) {\n      style.backgroundColor = this.#commentButtonColor;\n    }\n    parentContainer.after(button);\n  }\n  render() {\n    if (this.#popup) {\n      return;\n    }\n    const popup = this.#popup = document.createElement(\"div\");\n    popup.className = \"popup\";\n    if (this.#color) {\n      const baseColor = popup.style.outlineColor = Util.makeHexColor(...this.#color);\n      popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;\n    }\n    const header = document.createElement(\"span\");\n    header.className = \"header\";\n    if (this.#titleObj?.str) {\n      const title = document.createElement(\"span\");\n      title.className = \"title\";\n      header.append(title);\n      ({\n        dir: title.dir,\n        str: title.textContent\n      } = this.#titleObj);\n    }\n    popup.append(header);\n    if (this.#dateObj) {\n      const modificationDate = document.createElement(\"time\");\n      modificationDate.className = \"popupDate\";\n      modificationDate.setAttribute(\"data-l10n-id\", \"pdfjs-annotation-date-time-string\");\n      modificationDate.setAttribute(\"data-l10n-args\", JSON.stringify({\n        dateObj: this.#dateObj.valueOf()\n      }));\n      modificationDate.dateTime = this.#dateObj.toISOString();\n      header.append(modificationDate);\n    }\n    const html = this.#html;\n    if (html) {\n      XfaLayer.render({\n        xfaHtml: html,\n        intent: \"richText\",\n        div: popup\n      });\n      popup.lastChild.classList.add(\"richText\", \"popupContent\");\n    } else {\n      const contents = this._formatContents(this.#contentsObj);\n      popup.append(contents);\n    }\n    this.#container.append(popup);\n  }\n  get #html() {\n    const richText = this.#richText;\n    const contentsObj = this.#contentsObj;\n    if (richText?.str && (!contentsObj?.str || contentsObj.str === richText.str)) {\n      return this.#richText.html || null;\n    }\n    return null;\n  }\n  get #fontSize() {\n    return this.#html?.attributes?.style?.fontSize || 0;\n  }\n  get #fontColor() {\n    return this.#html?.attributes?.style?.color || null;\n  }\n  #makePopupContent(text) {\n    const popupLines = [];\n    const popupContent = {\n      str: text,\n      html: {\n        name: \"div\",\n        attributes: {\n          dir: \"auto\"\n        },\n        children: [{\n          name: \"p\",\n          children: popupLines\n        }]\n      }\n    };\n    const lineAttributes = {\n      style: {\n        color: this.#fontColor,\n        fontSize: this.#fontSize ? `calc(${this.#fontSize}px * var(--total-scale-factor))` : \"\"\n      }\n    };\n    for (const line of text.split(\"\\n\")) {\n      popupLines.push({\n        name: \"span\",\n        value: line,\n        attributes: lineAttributes\n      });\n    }\n    return popupContent;\n  }\n  _formatContents({\n    str,\n    dir\n  }) {\n    const p = document.createElement(\"p\");\n    p.classList.add(\"popupContent\");\n    p.dir = dir;\n    const lines = str.split(/(?:\\r\\n?|\\n)/);\n    for (let i = 0, ii = lines.length; i < ii; ++i) {\n      const line = lines[i];\n      p.append(document.createTextNode(line));\n      if (i < ii - 1) {\n        p.append(document.createElement(\"br\"));\n      }\n    }\n    return p;\n  }\n  #keyDown(event) {\n    if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {\n      return;\n    }\n    if (event.key === \"Enter\" || event.key === \"Escape\" && this.#pinned) {\n      this.#toggle();\n    }\n  }\n  updateEdited({\n    rect,\n    popup,\n    deleted\n  }) {\n    if (deleted || popup?.deleted) {\n      this.remove();\n      return;\n    }\n    this.#addEventListeners();\n    this.#updates ||= {\n      contentsObj: this.#contentsObj,\n      richText: this.#richText\n    };\n    if (rect) {\n      this.#position = null;\n    }\n    if (popup) {\n      this.#richText = this.#makePopupContent(popup.text);\n      this.#dateObj = PDFDateString.toDateObject(popup.date);\n      this.#contentsObj = null;\n    }\n    this.#popup?.remove();\n    this.#popup = null;\n  }\n  resetEdited() {\n    if (!this.#updates) {\n      return;\n    }\n    ({\n      contentsObj: this.#contentsObj,\n      richText: this.#richText\n    } = this.#updates);\n    this.#updates = null;\n    this.#popup?.remove();\n    this.#popup = null;\n    this.#position = null;\n  }\n  remove() {\n    this.#popupAbortController?.abort();\n    this.#popupAbortController = null;\n    this.#popup?.remove();\n    this.#popup = null;\n    this.#wasVisible = false;\n    this.#pinned = false;\n    for (const element of this.trigger) {\n      element.classList.remove(\"popupTriggerArea\");\n    }\n  }\n  #setPosition() {\n    if (this.#position !== null) {\n      return;\n    }\n    const {\n      page: {\n        view\n      },\n      viewport: {\n        rawDims: {\n          pageWidth,\n          pageHeight,\n          pageX,\n          pageY\n        }\n      }\n    } = this.#parent;\n    let useParentRect = !!this.#parentRect;\n    let rect = useParentRect ? this.#parentRect : this.#rect;\n    for (const element of this.#elements) {\n      if (!rect || Util.intersect(element.data.rect, rect) !== null) {\n        rect = element.data.rect;\n        useParentRect = true;\n        break;\n      }\n    }\n    const normalizedRect = Util.normalizeRect([rect[0], view[3] - rect[1] + view[1], rect[2], view[3] - rect[3] + view[1]]);\n    const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;\n    const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;\n    const popupLeft = normalizedRect[0] + parentWidth;\n    const popupTop = normalizedRect[1];\n    this.#position = [100 * (popupLeft - pageX) / pageWidth, 100 * (popupTop - pageY) / pageHeight];\n    const {\n      style\n    } = this.#container;\n    style.left = `${this.#position[0]}%`;\n    style.top = `${this.#position[1]}%`;\n  }\n  #toggle() {\n    this.#pinned = !this.#pinned;\n    if (this.#pinned) {\n      this.#show();\n      this.#container.addEventListener(\"click\", this.#boundToggle);\n      this.#container.addEventListener(\"keydown\", this.#boundKeyDown);\n    } else {\n      this.#hide();\n      this.#container.removeEventListener(\"click\", this.#boundToggle);\n      this.#container.removeEventListener(\"keydown\", this.#boundKeyDown);\n    }\n  }\n  #show() {\n    if (!this.#popup) {\n      this.render();\n    }\n    if (!this.isVisible) {\n      this.#setPosition();\n      this.#container.hidden = false;\n      this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1000;\n    } else if (this.#pinned) {\n      this.#container.classList.add(\"focused\");\n    }\n  }\n  #hide() {\n    this.#container.classList.remove(\"focused\");\n    if (this.#pinned || !this.isVisible) {\n      return;\n    }\n    this.#container.hidden = true;\n    this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1000;\n  }\n  forceHide() {\n    this.#wasVisible = this.isVisible;\n    if (!this.#wasVisible) {\n      return;\n    }\n    this.#container.hidden = true;\n  }\n  maybeShow() {\n    this.#addEventListeners();\n    if (!this.#wasVisible) {\n      return;\n    }\n    if (!this.#popup) {\n      this.#show();\n    }\n    this.#wasVisible = false;\n    this.#container.hidden = false;\n  }\n  get isVisible() {\n    return this.#container.hidden === false;\n  }\n}\nclass FreeTextAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n    this.textContent = parameters.data.textContent;\n    this.textPosition = parameters.data.textPosition;\n    this.annotationEditorType = AnnotationEditorType.FREETEXT;\n  }\n  render() {\n    this.container.classList.add(\"freeTextAnnotation\");\n    if (this.textContent) {\n      const content = document.createElement(\"div\");\n      content.classList.add(\"annotationTextContent\");\n      content.setAttribute(\"role\", \"comment\");\n      for (const line of this.textContent) {\n        const lineSpan = document.createElement(\"span\");\n        lineSpan.textContent = line;\n        content.append(lineSpan);\n      }\n      this.container.append(content);\n    }\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this._editOnDoubleClick();\n    return this.container;\n  }\n}\nclass LineAnnotationElement extends AnnotationElement {\n  #line = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"lineAnnotation\");\n    const {\n      data,\n      width,\n      height\n    } = this;\n    const svg = this.svgFactory.create(width, height, true);\n    const line = this.#line = this.svgFactory.createElement(\"svg:line\");\n    line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n    line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n    line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n    line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n    line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n    line.setAttribute(\"stroke\", \"transparent\");\n    line.setAttribute(\"fill\", \"transparent\");\n    svg.append(line);\n    this.container.append(svg);\n    if (!data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    return this.container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#line;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n}\nclass SquareAnnotationElement extends AnnotationElement {\n  #square = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"squareAnnotation\");\n    const {\n      data,\n      width,\n      height\n    } = this;\n    const svg = this.svgFactory.create(width, height, true);\n    const borderWidth = data.borderStyle.width;\n    const square = this.#square = this.svgFactory.createElement(\"svg:rect\");\n    square.setAttribute(\"x\", borderWidth / 2);\n    square.setAttribute(\"y\", borderWidth / 2);\n    square.setAttribute(\"width\", width - borderWidth);\n    square.setAttribute(\"height\", height - borderWidth);\n    square.setAttribute(\"stroke-width\", borderWidth || 1);\n    square.setAttribute(\"stroke\", \"transparent\");\n    square.setAttribute(\"fill\", \"transparent\");\n    svg.append(square);\n    this.container.append(svg);\n    if (!data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    return this.container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#square;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n}\nclass CircleAnnotationElement extends AnnotationElement {\n  #circle = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"circleAnnotation\");\n    const {\n      data,\n      width,\n      height\n    } = this;\n    const svg = this.svgFactory.create(width, height, true);\n    const borderWidth = data.borderStyle.width;\n    const circle = this.#circle = this.svgFactory.createElement(\"svg:ellipse\");\n    circle.setAttribute(\"cx\", width / 2);\n    circle.setAttribute(\"cy\", height / 2);\n    circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n    circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n    circle.setAttribute(\"stroke-width\", borderWidth || 1);\n    circle.setAttribute(\"stroke\", \"transparent\");\n    circle.setAttribute(\"fill\", \"transparent\");\n    svg.append(circle);\n    this.container.append(svg);\n    if (!data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    return this.container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#circle;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n}\nclass PolylineAnnotationElement extends AnnotationElement {\n  #polyline = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n    this.containerClassName = \"polylineAnnotation\";\n    this.svgElementName = \"svg:polyline\";\n  }\n  render() {\n    this.container.classList.add(this.containerClassName);\n    const {\n      data: {\n        rect,\n        vertices,\n        borderStyle,\n        popupRef\n      },\n      width,\n      height\n    } = this;\n    if (!vertices) {\n      return this.container;\n    }\n    const svg = this.svgFactory.create(width, height, true);\n    let points = [];\n    for (let i = 0, ii = vertices.length; i < ii; i += 2) {\n      const x = vertices[i] - rect[0];\n      const y = rect[3] - vertices[i + 1];\n      points.push(`${x},${y}`);\n    }\n    points = points.join(\" \");\n    const polyline = this.#polyline = this.svgFactory.createElement(this.svgElementName);\n    polyline.setAttribute(\"points\", points);\n    polyline.setAttribute(\"stroke-width\", borderStyle.width || 1);\n    polyline.setAttribute(\"stroke\", \"transparent\");\n    polyline.setAttribute(\"fill\", \"transparent\");\n    svg.append(polyline);\n    this.container.append(svg);\n    if (!popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    return this.container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#polyline;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n}\nclass PolygonAnnotationElement extends PolylineAnnotationElement {\n  constructor(parameters) {\n    super(parameters);\n    this.containerClassName = \"polygonAnnotation\";\n    this.svgElementName = \"svg:polygon\";\n  }\n}\nclass CaretAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"caretAnnotation\");\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    return this.container;\n  }\n}\nclass InkAnnotationElement extends AnnotationElement {\n  #polylinesGroupElement = null;\n  #polylines = [];\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n    this.containerClassName = \"inkAnnotation\";\n    this.svgElementName = \"svg:polyline\";\n    this.annotationEditorType = this.data.it === \"InkHighlight\" ? AnnotationEditorType.HIGHLIGHT : AnnotationEditorType.INK;\n  }\n  #getTransform(rotation, rect) {\n    switch (rotation) {\n      case 90:\n        return {\n          transform: `rotate(90) translate(${-rect[0]},${rect[1]}) scale(1,-1)`,\n          width: rect[3] - rect[1],\n          height: rect[2] - rect[0]\n        };\n      case 180:\n        return {\n          transform: `rotate(180) translate(${-rect[2]},${rect[1]}) scale(1,-1)`,\n          width: rect[2] - rect[0],\n          height: rect[3] - rect[1]\n        };\n      case 270:\n        return {\n          transform: `rotate(270) translate(${-rect[2]},${rect[3]}) scale(1,-1)`,\n          width: rect[3] - rect[1],\n          height: rect[2] - rect[0]\n        };\n      default:\n        return {\n          transform: `translate(${-rect[0]},${rect[3]}) scale(1,-1)`,\n          width: rect[2] - rect[0],\n          height: rect[3] - rect[1]\n        };\n    }\n  }\n  render() {\n    this.container.classList.add(this.containerClassName);\n    const {\n      data: {\n        rect,\n        rotation,\n        inkLists,\n        borderStyle,\n        popupRef\n      }\n    } = this;\n    const {\n      transform,\n      width,\n      height\n    } = this.#getTransform(rotation, rect);\n    const svg = this.svgFactory.create(width, height, true);\n    const g = this.#polylinesGroupElement = this.svgFactory.createElement(\"svg:g\");\n    svg.append(g);\n    g.setAttribute(\"stroke-width\", borderStyle.width || 1);\n    g.setAttribute(\"stroke-linecap\", \"round\");\n    g.setAttribute(\"stroke-linejoin\", \"round\");\n    g.setAttribute(\"stroke-miterlimit\", 10);\n    g.setAttribute(\"stroke\", \"transparent\");\n    g.setAttribute(\"fill\", \"transparent\");\n    g.setAttribute(\"transform\", transform);\n    for (let i = 0, ii = inkLists.length; i < ii; i++) {\n      const polyline = this.svgFactory.createElement(this.svgElementName);\n      this.#polylines.push(polyline);\n      polyline.setAttribute(\"points\", inkLists[i].join(\",\"));\n      g.append(polyline);\n    }\n    if (!popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this.container.append(svg);\n    this._editOnDoubleClick();\n    return this.container;\n  }\n  updateEdited(params) {\n    super.updateEdited(params);\n    const {\n      thickness,\n      points,\n      rect\n    } = params;\n    const g = this.#polylinesGroupElement;\n    if (thickness >= 0) {\n      g.setAttribute(\"stroke-width\", thickness || 1);\n    }\n    if (points) {\n      for (let i = 0, ii = this.#polylines.length; i < ii; i++) {\n        this.#polylines[i].setAttribute(\"points\", points[i].join(\",\"));\n      }\n    }\n    if (rect) {\n      const {\n        transform,\n        width,\n        height\n      } = this.#getTransform(this.data.rotation, rect);\n      const root = g.parentElement;\n      root.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n      g.setAttribute(\"transform\", transform);\n    }\n  }\n  getElementsToTriggerPopup() {\n    return this.#polylines;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n  get commentButtonPosition() {\n    const {\n      inkLists,\n      rect\n    } = this.data;\n    if (inkLists?.length >= 1) {\n      let maxX = -Infinity;\n      let maxY = -Infinity;\n      for (const inkList of inkLists) {\n        for (let i = 0, ii = inkList.length; i < ii; i += 2) {\n          if (inkList[i + 1] > maxY) {\n            maxY = inkList[i + 1];\n            maxX = inkList[i];\n          } else if (inkList[i + 1] === maxY) {\n            maxX = Math.max(maxX, inkList[i]);\n          }\n        }\n      }\n      if (maxX !== Infinity) {\n        return [maxX, maxY];\n      }\n    }\n    if (rect) {\n      return [rect[2], rect[3]];\n    }\n    return null;\n  }\n}\nclass HighlightAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n    this.annotationEditorType = AnnotationEditorType.HIGHLIGHT;\n  }\n  render() {\n    const {\n      data: {\n        overlaidText,\n        popupRef\n      }\n    } = this;\n    if (!popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this.container.classList.add(\"highlightAnnotation\");\n    this._editOnDoubleClick();\n    if (overlaidText) {\n      const mark = document.createElement(\"mark\");\n      mark.classList.add(\"overlaidText\");\n      mark.textContent = overlaidText;\n      this.container.append(mark);\n    }\n    return this.container;\n  }\n}\nclass UnderlineAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n  render() {\n    const {\n      data: {\n        overlaidText,\n        popupRef\n      }\n    } = this;\n    if (!popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this.container.classList.add(\"underlineAnnotation\");\n    if (overlaidText) {\n      const underline = document.createElement(\"u\");\n      underline.classList.add(\"overlaidText\");\n      underline.textContent = overlaidText;\n      this.container.append(underline);\n    }\n    return this.container;\n  }\n}\nclass SquigglyAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n  render() {\n    const {\n      data: {\n        overlaidText,\n        popupRef\n      }\n    } = this;\n    if (!popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this.container.classList.add(\"squigglyAnnotation\");\n    if (overlaidText) {\n      const underline = document.createElement(\"u\");\n      underline.classList.add(\"overlaidText\");\n      underline.textContent = overlaidText;\n      this.container.append(underline);\n    }\n    return this.container;\n  }\n}\nclass StrikeOutAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n  render() {\n    const {\n      data: {\n        overlaidText,\n        popupRef\n      }\n    } = this;\n    if (!popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this.container.classList.add(\"strikeoutAnnotation\");\n    if (overlaidText) {\n      const strikeout = document.createElement(\"s\");\n      strikeout.classList.add(\"overlaidText\");\n      strikeout.textContent = overlaidText;\n      this.container.append(strikeout);\n    }\n    return this.container;\n  }\n}\nclass StampAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n    this.annotationEditorType = AnnotationEditorType.STAMP;\n  }\n  render() {\n    this.container.classList.add(\"stampAnnotation\");\n    this.container.setAttribute(\"role\", \"img\");\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this._editOnDoubleClick();\n    return this.container;\n  }\n}\nclass FileAttachmentAnnotationElement extends AnnotationElement {\n  #trigger = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true\n    });\n    const {\n      file\n    } = this.data;\n    this.filename = file.filename;\n    this.content = file.content;\n    this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", {\n      source: this,\n      ...file\n    });\n  }\n  render() {\n    this.container.classList.add(\"fileAttachmentAnnotation\");\n    const {\n      container,\n      data\n    } = this;\n    let trigger;\n    if (data.hasAppearance || data.fillAlpha === 0) {\n      trigger = document.createElement(\"div\");\n    } else {\n      trigger = document.createElement(\"img\");\n      trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? \"paperclip\" : \"pushpin\"}.svg`;\n      if (data.fillAlpha && data.fillAlpha < 1) {\n        trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;\n      }\n    }\n    trigger.addEventListener(\"dblclick\", this.#download.bind(this));\n    this.#trigger = trigger;\n    const {\n      isMac\n    } = util_FeatureTest.platform;\n    container.addEventListener(\"keydown\", evt => {\n      if (evt.key === \"Enter\" && (isMac ? evt.metaKey : evt.ctrlKey)) {\n        this.#download();\n      }\n    });\n    if (!data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    } else {\n      trigger.classList.add(\"popupTriggerArea\");\n    }\n    container.append(trigger);\n    return container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#trigger;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n  #download() {\n    this.downloadManager?.openOrDownloadData(this.content, this.filename);\n  }\n}\nclass AnnotationLayer {\n  #accessibilityManager = null;\n  #annotationCanvasMap = null;\n  #editableAnnotations = new Map();\n  #structTreeLayer = null;\n  constructor({\n    div,\n    accessibilityManager,\n    annotationCanvasMap,\n    annotationEditorUIManager,\n    page,\n    viewport,\n    structTreeLayer\n  }) {\n    this.div = div;\n    this.#accessibilityManager = accessibilityManager;\n    this.#annotationCanvasMap = annotationCanvasMap;\n    this.#structTreeLayer = structTreeLayer || null;\n    this.page = page;\n    this.viewport = viewport;\n    this.zIndex = 0;\n    this._annotationEditorUIManager = annotationEditorUIManager;\n  }\n  hasEditableAnnotations() {\n    return this.#editableAnnotations.size > 0;\n  }\n  async #appendElement(element, id, popupElements) {\n    const contentElement = element.firstChild || element;\n    const annotationId = contentElement.id = `${AnnotationPrefix}${id}`;\n    const ariaAttributes = await this.#structTreeLayer?.getAriaAttributes(annotationId);\n    if (ariaAttributes) {\n      for (const [key, value] of ariaAttributes) {\n        contentElement.setAttribute(key, value);\n      }\n    }\n    if (popupElements) {\n      popupElements.at(-1).container.after(element);\n    } else {\n      this.div.append(element);\n      this.#accessibilityManager?.moveElementInDOM(this.div, element, contentElement, false);\n    }\n  }\n  async render(params) {\n    const {\n      annotations\n    } = params;\n    const layer = this.div;\n    setLayerDimensions(layer, this.viewport);\n    const popupToElements = new Map();\n    const elementParams = {\n      data: null,\n      layer,\n      linkService: params.linkService,\n      downloadManager: params.downloadManager,\n      imageResourcesPath: params.imageResourcesPath || \"\",\n      renderForms: params.renderForms !== false,\n      svgFactory: new DOMSVGFactory(),\n      annotationStorage: params.annotationStorage || new AnnotationStorage(),\n      enableComment: params.enableComment === true,\n      enableScripting: params.enableScripting === true,\n      hasJSActions: params.hasJSActions,\n      fieldObjects: params.fieldObjects,\n      parent: this,\n      elements: null\n    };\n    for (const data of annotations) {\n      if (data.noHTML) {\n        continue;\n      }\n      const isPopupAnnotation = data.annotationType === AnnotationType.POPUP;\n      if (!isPopupAnnotation) {\n        if (data.rect[2] === data.rect[0] || data.rect[3] === data.rect[1]) {\n          continue;\n        }\n      } else {\n        const elements = popupToElements.get(data.id);\n        if (!elements) {\n          continue;\n        }\n        elementParams.elements = elements;\n      }\n      elementParams.data = data;\n      const element = AnnotationElementFactory.create(elementParams);\n      if (!element.isRenderable) {\n        continue;\n      }\n      if (!isPopupAnnotation && data.popupRef) {\n        const elements = popupToElements.get(data.popupRef);\n        if (!elements) {\n          popupToElements.set(data.popupRef, [element]);\n        } else {\n          elements.push(element);\n        }\n      }\n      const rendered = element.render();\n      if (data.hidden) {\n        rendered.style.visibility = \"hidden\";\n      }\n      await this.#appendElement(rendered, data.id, elementParams.elements);\n      if (element._isEditable) {\n        this.#editableAnnotations.set(element.data.id, element);\n        this._annotationEditorUIManager?.renderAnnotationElement(element);\n      }\n    }\n    this.#setAnnotationCanvasMap();\n  }\n  async addLinkAnnotations(annotations, linkService) {\n    const elementParams = {\n      data: null,\n      layer: this.div,\n      linkService,\n      svgFactory: new DOMSVGFactory(),\n      parent: this\n    };\n    for (const data of annotations) {\n      data.borderStyle ||= AnnotationLayer._defaultBorderStyle;\n      elementParams.data = data;\n      const element = AnnotationElementFactory.create(elementParams);\n      if (!element.isRenderable) {\n        continue;\n      }\n      const rendered = element.render();\n      await this.#appendElement(rendered, data.id, null);\n    }\n  }\n  update({\n    viewport\n  }) {\n    const layer = this.div;\n    this.viewport = viewport;\n    setLayerDimensions(layer, {\n      rotation: viewport.rotation\n    });\n    this.#setAnnotationCanvasMap();\n    layer.hidden = false;\n  }\n  #setAnnotationCanvasMap() {\n    if (!this.#annotationCanvasMap) {\n      return;\n    }\n    const layer = this.div;\n    for (const [id, canvas] of this.#annotationCanvasMap) {\n      const element = layer.querySelector(`[data-annotation-id=\"${id}\"]`);\n      if (!element) {\n        continue;\n      }\n      canvas.className = \"annotationContent\";\n      const {\n        firstChild\n      } = element;\n      if (!firstChild) {\n        element.append(canvas);\n      } else if (firstChild.nodeName === \"CANVAS\") {\n        firstChild.replaceWith(canvas);\n      } else if (!firstChild.classList.contains(\"annotationContent\")) {\n        firstChild.before(canvas);\n      } else {\n        firstChild.after(canvas);\n      }\n      const editableAnnotation = this.#editableAnnotations.get(id);\n      if (!editableAnnotation) {\n        continue;\n      }\n      if (editableAnnotation._hasNoCanvas) {\n        this._annotationEditorUIManager?.setMissingCanvas(id, element.id, canvas);\n        editableAnnotation._hasNoCanvas = false;\n      } else {\n        editableAnnotation.canvas = canvas;\n      }\n    }\n    this.#annotationCanvasMap.clear();\n  }\n  getEditableAnnotations() {\n    return Array.from(this.#editableAnnotations.values());\n  }\n  getEditableAnnotation(id) {\n    return this.#editableAnnotations.get(id);\n  }\n  static get _defaultBorderStyle() {\n    return shadow(this, \"_defaultBorderStyle\", Object.freeze({\n      width: 1,\n      rawWidth: 1,\n      style: AnnotationBorderStyleType.SOLID,\n      dashArray: [3],\n      horizontalCornerRadius: 0,\n      verticalCornerRadius: 0\n    }));\n  }\n}\n\n;// ./src/display/editor/freetext.js\n\n\n\n\n\nconst EOL_PATTERN = /\\r\\n?|\\n/g;\nclass FreeTextEditor extends AnnotationEditor {\n  #color;\n  #content = \"\";\n  #editorDivId = `${this.id}-editor`;\n  #editModeAC = null;\n  #fontSize;\n  _colorPicker = null;\n  static _freeTextDefaultContent = \"\";\n  static _internalPadding = 0;\n  static _defaultColor = null;\n  static _defaultFontSize = 10;\n  static get _keyboardManager() {\n    const proto = FreeTextEditor.prototype;\n    const arrowChecker = self => self.isEmpty();\n    const small = AnnotationEditorUIManager.TRANSLATE_SMALL;\n    const big = AnnotationEditorUIManager.TRANSLATE_BIG;\n    return shadow(this, \"_keyboardManager\", new KeyboardManager([[[\"ctrl+s\", \"mac+meta+s\", \"ctrl+p\", \"mac+meta+p\"], proto.commitOrRemove, {\n      bubbles: true\n    }], [[\"ctrl+Enter\", \"mac+meta+Enter\", \"Escape\", \"mac+Escape\"], proto.commitOrRemove], [[\"ArrowLeft\", \"mac+ArrowLeft\"], proto._translateEmpty, {\n      args: [-small, 0],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowLeft\", \"mac+shift+ArrowLeft\"], proto._translateEmpty, {\n      args: [-big, 0],\n      checker: arrowChecker\n    }], [[\"ArrowRight\", \"mac+ArrowRight\"], proto._translateEmpty, {\n      args: [small, 0],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowRight\", \"mac+shift+ArrowRight\"], proto._translateEmpty, {\n      args: [big, 0],\n      checker: arrowChecker\n    }], [[\"ArrowUp\", \"mac+ArrowUp\"], proto._translateEmpty, {\n      args: [0, -small],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowUp\", \"mac+shift+ArrowUp\"], proto._translateEmpty, {\n      args: [0, -big],\n      checker: arrowChecker\n    }], [[\"ArrowDown\", \"mac+ArrowDown\"], proto._translateEmpty, {\n      args: [0, small],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowDown\", \"mac+shift+ArrowDown\"], proto._translateEmpty, {\n      args: [0, big],\n      checker: arrowChecker\n    }]]));\n  }\n  static _type = \"freetext\";\n  static _editorType = AnnotationEditorType.FREETEXT;\n  constructor(params) {\n    super({\n      ...params,\n      name: \"freeTextEditor\"\n    });\n    this.#color = params.color || FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor;\n    this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;\n    if (!this.annotationElementId) {\n      this._uiManager.a11yAlert(\"pdfjs-editor-freetext-added-alert\");\n    }\n  }\n  static initialize(l10n, uiManager) {\n    AnnotationEditor.initialize(l10n, uiManager);\n    const style = getComputedStyle(document.documentElement);\n    this._internalPadding = parseFloat(style.getPropertyValue(\"--freetext-padding\"));\n  }\n  static updateDefaultParams(type, value) {\n    switch (type) {\n      case AnnotationEditorParamsType.FREETEXT_SIZE:\n        FreeTextEditor._defaultFontSize = value;\n        break;\n      case AnnotationEditorParamsType.FREETEXT_COLOR:\n        FreeTextEditor._defaultColor = value;\n        break;\n    }\n  }\n  updateParams(type, value) {\n    switch (type) {\n      case AnnotationEditorParamsType.FREETEXT_SIZE:\n        this.#updateFontSize(value);\n        break;\n      case AnnotationEditorParamsType.FREETEXT_COLOR:\n        this.#updateColor(value);\n        break;\n    }\n  }\n  static get defaultPropertiesToUpdate() {\n    return [[AnnotationEditorParamsType.FREETEXT_SIZE, FreeTextEditor._defaultFontSize], [AnnotationEditorParamsType.FREETEXT_COLOR, FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor]];\n  }\n  get propertiesToUpdate() {\n    return [[AnnotationEditorParamsType.FREETEXT_SIZE, this.#fontSize], [AnnotationEditorParamsType.FREETEXT_COLOR, this.#color]];\n  }\n  get toolbarButtons() {\n    this._colorPicker ||= new BasicColorPicker(this);\n    return [[\"colorPicker\", this._colorPicker]];\n  }\n  get colorType() {\n    return AnnotationEditorParamsType.FREETEXT_COLOR;\n  }\n  get colorValue() {\n    return this.#color;\n  }\n  #updateFontSize(fontSize) {\n    const setFontsize = size => {\n      this.editorDiv.style.fontSize = `calc(${size}px * var(--total-scale-factor))`;\n      this.translate(0, -(size - this.#fontSize) * this.parentScale);\n      this.#fontSize = size;\n      this.#setEditorDimensions();\n    };\n    const savedFontsize = this.#fontSize;\n    this.addCommands({\n      cmd: setFontsize.bind(this, fontSize),\n      undo: setFontsize.bind(this, savedFontsize),\n      post: this._uiManager.updateUI.bind(this._uiManager, this),\n      mustExec: true,\n      type: AnnotationEditorParamsType.FREETEXT_SIZE,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n  #updateColor(color) {\n    const setColor = col => {\n      this.#color = this.editorDiv.style.color = col;\n      this._colorPicker?.update(col);\n    };\n    const savedColor = this.#color;\n    this.addCommands({\n      cmd: setColor.bind(this, color),\n      undo: setColor.bind(this, savedColor),\n      post: this._uiManager.updateUI.bind(this._uiManager, this),\n      mustExec: true,\n      type: AnnotationEditorParamsType.FREETEXT_COLOR,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n  _translateEmpty(x, y) {\n    this._uiManager.translateSelectedEditors(x, y, true);\n  }\n  getInitialTranslation() {\n    const scale = this.parentScale;\n    return [-FreeTextEditor._internalPadding * scale, -(FreeTextEditor._internalPadding + this.#fontSize) * scale];\n  }\n  rebuild() {\n    if (!this.parent) {\n      return;\n    }\n    super.rebuild();\n    if (this.div === null) {\n      return;\n    }\n    if (!this.isAttachedToDOM) {\n      this.parent.add(this);\n    }\n  }\n  enableEditMode() {\n    if (!super.enableEditMode()) {\n      return false;\n    }\n    this.overlayDiv.classList.remove(\"enabled\");\n    this.editorDiv.contentEditable = true;\n    this._isDraggable = false;\n    this.div.removeAttribute(\"aria-activedescendant\");\n    this.#editModeAC = new AbortController();\n    const signal = this._uiManager.combinedSignal(this.#editModeAC);\n    this.editorDiv.addEventListener(\"keydown\", this.editorDivKeydown.bind(this), {\n      signal\n    });\n    this.editorDiv.addEventListener(\"focus\", this.editorDivFocus.bind(this), {\n      signal\n    });\n    this.editorDiv.addEventListener(\"blur\", this.editorDivBlur.bind(this), {\n      signal\n    });\n    this.editorDiv.addEventListener(\"input\", this.editorDivInput.bind(this), {\n      signal\n    });\n    this.editorDiv.addEventListener(\"paste\", this.editorDivPaste.bind(this), {\n      signal\n    });\n    return true;\n  }\n  disableEditMode() {\n    if (!super.disableEditMode()) {\n      return false;\n    }\n    this.overlayDiv.classList.add(\"enabled\");\n    this.editorDiv.contentEditable = false;\n    this.div.setAttribute(\"aria-activedescendant\", this.#editorDivId);\n    this._isDraggable = true;\n    this.#editModeAC?.abort();\n    this.#editModeAC = null;\n    this.div.focus({\n      preventScroll: true\n    });\n    this.isEditing = false;\n    this.parent.div.classList.add(\"freetextEditing\");\n    return true;\n  }\n  focusin(event) {\n    if (!this._focusEventsAllowed) {\n      return;\n    }\n    super.focusin(event);\n    if (event.target !== this.editorDiv) {\n      this.editorDiv.focus();\n    }\n  }\n  onceAdded(focus) {\n    if (this.width) {\n      return;\n    }\n    this.enableEditMode();\n    if (focus) {\n      this.editorDiv.focus();\n    }\n    if (this._initialOptions?.isCentered) {\n      this.center();\n    }\n    this._initialOptions = null;\n  }\n  isEmpty() {\n    return !this.editorDiv || this.editorDiv.innerText.trim() === \"\";\n  }\n  remove() {\n    this.isEditing = false;\n    if (this.parent) {\n      this.parent.setEditingState(true);\n      this.parent.div.classList.add(\"freetextEditing\");\n    }\n    super.remove();\n  }\n  #extractText() {\n    const buffer = [];\n    this.editorDiv.normalize();\n    let prevChild = null;\n    for (const child of this.editorDiv.childNodes) {\n      if (prevChild?.nodeType === Node.TEXT_NODE && child.nodeName === \"BR\") {\n        continue;\n      }\n      buffer.push(FreeTextEditor.#getNodeContent(child));\n      prevChild = child;\n    }\n    return buffer.join(\"\\n\");\n  }\n  #setEditorDimensions() {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    let rect;\n    if (this.isAttachedToDOM) {\n      rect = this.div.getBoundingClientRect();\n    } else {\n      const {\n        currentLayer,\n        div\n      } = this;\n      const savedDisplay = div.style.display;\n      const savedVisibility = div.classList.contains(\"hidden\");\n      div.classList.remove(\"hidden\");\n      div.style.display = \"hidden\";\n      currentLayer.div.append(this.div);\n      rect = div.getBoundingClientRect();\n      div.remove();\n      div.style.display = savedDisplay;\n      div.classList.toggle(\"hidden\", savedVisibility);\n    }\n    if (this.rotation % 180 === this.parentRotation % 180) {\n      this.width = rect.width / parentWidth;\n      this.height = rect.height / parentHeight;\n    } else {\n      this.width = rect.height / parentWidth;\n      this.height = rect.width / parentHeight;\n    }\n    this.fixAndSetPosition();\n  }\n  commit() {\n    if (!this.isInEditMode()) {\n      return;\n    }\n    super.commit();\n    this.disableEditMode();\n    const savedText = this.#content;\n    const newText = this.#content = this.#extractText().trimEnd();\n    if (savedText === newText) {\n      return;\n    }\n    const setText = text => {\n      this.#content = text;\n      if (!text) {\n        this.remove();\n        return;\n      }\n      this.#setContent();\n      this._uiManager.rebuild(this);\n      this.#setEditorDimensions();\n    };\n    this.addCommands({\n      cmd: () => {\n        setText(newText);\n      },\n      undo: () => {\n        setText(savedText);\n      },\n      mustExec: false\n    });\n    this.#setEditorDimensions();\n  }\n  shouldGetKeyboardEvents() {\n    return this.isInEditMode();\n  }\n  enterInEditMode() {\n    this.enableEditMode();\n    this.editorDiv.focus();\n  }\n  keydown(event) {\n    if (event.target === this.div && event.key === \"Enter\") {\n      this.enterInEditMode();\n      event.preventDefault();\n    }\n  }\n  editorDivKeydown(event) {\n    FreeTextEditor._keyboardManager.exec(this, event);\n  }\n  editorDivFocus(event) {\n    this.isEditing = true;\n  }\n  editorDivBlur(event) {\n    this.isEditing = false;\n  }\n  editorDivInput(event) {\n    this.parent.div.classList.toggle(\"freetextEditing\", this.isEmpty());\n  }\n  disableEditing() {\n    this.editorDiv.setAttribute(\"role\", \"comment\");\n    this.editorDiv.removeAttribute(\"aria-multiline\");\n  }\n  enableEditing() {\n    this.editorDiv.setAttribute(\"role\", \"textbox\");\n    this.editorDiv.setAttribute(\"aria-multiline\", true);\n  }\n  get canChangeContent() {\n    return true;\n  }\n  render() {\n    if (this.div) {\n      return this.div;\n    }\n    let baseX, baseY;\n    if (this._isCopy || this.annotationElementId) {\n      baseX = this.x;\n      baseY = this.y;\n    }\n    super.render();\n    this.editorDiv = document.createElement(\"div\");\n    this.editorDiv.className = \"internal\";\n    this.editorDiv.setAttribute(\"id\", this.#editorDivId);\n    this.editorDiv.setAttribute(\"data-l10n-id\", \"pdfjs-free-text2\");\n    this.editorDiv.setAttribute(\"data-l10n-attrs\", \"default-content\");\n    this.enableEditing();\n    this.editorDiv.contentEditable = true;\n    const {\n      style\n    } = this.editorDiv;\n    style.fontSize = `calc(${this.#fontSize}px * var(--total-scale-factor))`;\n    style.color = this.#color;\n    this.div.append(this.editorDiv);\n    this.overlayDiv = document.createElement(\"div\");\n    this.overlayDiv.classList.add(\"overlay\", \"enabled\");\n    this.div.append(this.overlayDiv);\n    if (this._isCopy || this.annotationElementId) {\n      const [parentWidth, parentHeight] = this.parentDimensions;\n      if (this.annotationElementId) {\n        const {\n          position\n        } = this._initialData;\n        let [tx, ty] = this.getInitialTranslation();\n        [tx, ty] = this.pageTranslationToScreen(tx, ty);\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const [pageX, pageY] = this.pageTranslation;\n        let posX, posY;\n        switch (this.rotation) {\n          case 0:\n            posX = baseX + (position[0] - pageX) / pageWidth;\n            posY = baseY + this.height - (position[1] - pageY) / pageHeight;\n            break;\n          case 90:\n            posX = baseX + (position[0] - pageX) / pageWidth;\n            posY = baseY - (position[1] - pageY) / pageHeight;\n            [tx, ty] = [ty, -tx];\n            break;\n          case 180:\n            posX = baseX - this.width + (position[0] - pageX) / pageWidth;\n            posY = baseY - (position[1] - pageY) / pageHeight;\n            [tx, ty] = [-tx, -ty];\n            break;\n          case 270:\n            posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;\n            posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;\n            [tx, ty] = [-ty, tx];\n            break;\n        }\n        this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);\n      } else {\n        this._moveAfterPaste(baseX, baseY);\n      }\n      this.#setContent();\n      this._isDraggable = true;\n      this.editorDiv.contentEditable = false;\n    } else {\n      this._isDraggable = false;\n      this.editorDiv.contentEditable = true;\n    }\n    return this.div;\n  }\n  static #getNodeContent(node) {\n    return (node.nodeType === Node.TEXT_NODE ? node.nodeValue : node.innerText).replaceAll(EOL_PATTERN, \"\");\n  }\n  editorDivPaste(event) {\n    const clipboardData = event.clipboardData || window.clipboardData;\n    const {\n      types\n    } = clipboardData;\n    if (types.length === 1 && types[0] === \"text/plain\") {\n      return;\n    }\n    event.preventDefault();\n    const paste = FreeTextEditor.#deserializeContent(clipboardData.getData(\"text\") || \"\").replaceAll(EOL_PATTERN, \"\\n\");\n    if (!paste) {\n      return;\n    }\n    const selection = window.getSelection();\n    if (!selection.rangeCount) {\n      return;\n    }\n    this.editorDiv.normalize();\n    selection.deleteFromDocument();\n    const range = selection.getRangeAt(0);\n    if (!paste.includes(\"\\n\")) {\n      range.insertNode(document.createTextNode(paste));\n      this.editorDiv.normalize();\n      selection.collapseToStart();\n      return;\n    }\n    const {\n      startContainer,\n      startOffset\n    } = range;\n    const bufferBefore = [];\n    const bufferAfter = [];\n    if (startContainer.nodeType === Node.TEXT_NODE) {\n      const parent = startContainer.parentElement;\n      bufferAfter.push(startContainer.nodeValue.slice(startOffset).replaceAll(EOL_PATTERN, \"\"));\n      if (parent !== this.editorDiv) {\n        let buffer = bufferBefore;\n        for (const child of this.editorDiv.childNodes) {\n          if (child === parent) {\n            buffer = bufferAfter;\n            continue;\n          }\n          buffer.push(FreeTextEditor.#getNodeContent(child));\n        }\n      }\n      bufferBefore.push(startContainer.nodeValue.slice(0, startOffset).replaceAll(EOL_PATTERN, \"\"));\n    } else if (startContainer === this.editorDiv) {\n      let buffer = bufferBefore;\n      let i = 0;\n      for (const child of this.editorDiv.childNodes) {\n        if (i++ === startOffset) {\n          buffer = bufferAfter;\n        }\n        buffer.push(FreeTextEditor.#getNodeContent(child));\n      }\n    }\n    this.#content = `${bufferBefore.join(\"\\n\")}${paste}${bufferAfter.join(\"\\n\")}`;\n    this.#setContent();\n    const newRange = new Range();\n    let beforeLength = Math.sumPrecise(bufferBefore.map(line => line.length));\n    for (const {\n      firstChild\n    } of this.editorDiv.childNodes) {\n      if (firstChild.nodeType === Node.TEXT_NODE) {\n        const length = firstChild.nodeValue.length;\n        if (beforeLength <= length) {\n          newRange.setStart(firstChild, beforeLength);\n          newRange.setEnd(firstChild, beforeLength);\n          break;\n        }\n        beforeLength -= length;\n      }\n    }\n    selection.removeAllRanges();\n    selection.addRange(newRange);\n  }\n  #setContent() {\n    this.editorDiv.replaceChildren();\n    if (!this.#content) {\n      return;\n    }\n    for (const line of this.#content.split(\"\\n\")) {\n      const div = document.createElement(\"div\");\n      div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n      this.editorDiv.append(div);\n    }\n  }\n  #serializeContent() {\n    return this.#content.replaceAll(\"\\xa0\", \" \");\n  }\n  static #deserializeContent(content) {\n    return content.replaceAll(\" \", \"\\xa0\");\n  }\n  get contentDiv() {\n    return this.editorDiv;\n  }\n  getPDFRect() {\n    const padding = FreeTextEditor._internalPadding * this.parentScale;\n    return this.getRect(padding, padding);\n  }\n  static async deserialize(data, parent, uiManager) {\n    let initialData = null;\n    if (data instanceof FreeTextAnnotationElement) {\n      const {\n        data: {\n          defaultAppearanceData: {\n            fontSize,\n            fontColor\n          },\n          rect,\n          rotation,\n          id,\n          popupRef,\n          contentsObj\n        },\n        textContent,\n        textPosition,\n        parent: {\n          page: {\n            pageNumber\n          }\n        }\n      } = data;\n      if (!textContent || textContent.length === 0) {\n        return null;\n      }\n      initialData = data = {\n        annotationType: AnnotationEditorType.FREETEXT,\n        color: Array.from(fontColor),\n        fontSize,\n        value: textContent.join(\"\\n\"),\n        position: textPosition,\n        pageIndex: pageNumber - 1,\n        rect: rect.slice(0),\n        rotation,\n        annotationElementId: id,\n        id,\n        deleted: false,\n        popupRef,\n        comment: contentsObj?.str || null\n      };\n    }\n    const editor = await super.deserialize(data, parent, uiManager);\n    editor.#fontSize = data.fontSize;\n    editor.#color = Util.makeHexColor(...data.color);\n    editor.#content = FreeTextEditor.#deserializeContent(data.value);\n    editor._initialData = initialData;\n    if (data.comment) {\n      editor.setCommentData(data.comment);\n    }\n    return editor;\n  }\n  serialize(isForCopying = false) {\n    if (this.isEmpty()) {\n      return null;\n    }\n    if (this.deleted) {\n      return this.serializeDeleted();\n    }\n    const rect = this.getPDFRect();\n    const color = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.#color);\n    const serialized = {\n      annotationType: AnnotationEditorType.FREETEXT,\n      color,\n      fontSize: this.#fontSize,\n      value: this.#serializeContent(),\n      pageIndex: this.pageIndex,\n      rect,\n      rotation: this.rotation,\n      structTreeParentId: this._structTreeParentId\n    };\n    this.addComment(serialized);\n    if (isForCopying) {\n      serialized.isCopy = true;\n      return serialized;\n    }\n    if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n      return null;\n    }\n    serialized.id = this.annotationElementId;\n    return serialized;\n  }\n  #hasElementChanged(serialized) {\n    const {\n      value,\n      fontSize,\n      color,\n      pageIndex\n    } = this._initialData;\n    return this.hasEditedComment || this._hasBeenMoved || serialized.value !== value || serialized.fontSize !== fontSize || serialized.color.some((c, i) => c !== color[i]) || serialized.pageIndex !== pageIndex;\n  }\n  renderAnnotationElement(annotation) {\n    const content = super.renderAnnotationElement(annotation);\n    if (!content) {\n      return null;\n    }\n    const {\n      style\n    } = content;\n    style.fontSize = `calc(${this.#fontSize}px * var(--total-scale-factor))`;\n    style.color = this.#color;\n    content.replaceChildren();\n    for (const line of this.#content.split(\"\\n\")) {\n      const div = document.createElement(\"div\");\n      div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n      content.append(div);\n    }\n    const params = {\n      rect: this.getPDFRect()\n    };\n    params.popup = this.hasEditedComment ? this.comment : {\n      text: this.#content\n    };\n    annotation.updateEdited(params);\n    return content;\n  }\n  resetAnnotationElement(annotation) {\n    super.resetAnnotationElement(annotation);\n    annotation.resetEdited();\n  }\n}\n\n;// ./src/display/editor/drawers/outline.js\n\nclass Outline {\n  static PRECISION = 1e-4;\n  toSVGPath() {\n    unreachable(\"Abstract method `toSVGPath` must be implemented.\");\n  }\n  get box() {\n    unreachable(\"Abstract getter `box` must be implemented.\");\n  }\n  serialize(_bbox, _rotation) {\n    unreachable(\"Abstract method `serialize` must be implemented.\");\n  }\n  static _rescale(src, tx, ty, sx, sy, dest) {\n    dest ||= new Float32Array(src.length);\n    for (let i = 0, ii = src.length; i < ii; i += 2) {\n      dest[i] = tx + src[i] * sx;\n      dest[i + 1] = ty + src[i + 1] * sy;\n    }\n    return dest;\n  }\n  static _rescaleAndSwap(src, tx, ty, sx, sy, dest) {\n    dest ||= new Float32Array(src.length);\n    for (let i = 0, ii = src.length; i < ii; i += 2) {\n      dest[i] = tx + src[i + 1] * sx;\n      dest[i + 1] = ty + src[i] * sy;\n    }\n    return dest;\n  }\n  static _translate(src, tx, ty, dest) {\n    dest ||= new Float32Array(src.length);\n    for (let i = 0, ii = src.length; i < ii; i += 2) {\n      dest[i] = tx + src[i];\n      dest[i + 1] = ty + src[i + 1];\n    }\n    return dest;\n  }\n  static svgRound(x) {\n    return Math.round(x * 10000);\n  }\n  static _normalizePoint(x, y, parentWidth, parentHeight, rotation) {\n    switch (rotation) {\n      case 90:\n        return [1 - y / parentWidth, x / parentHeight];\n      case 180:\n        return [1 - x / parentWidth, 1 - y / parentHeight];\n      case 270:\n        return [y / parentWidth, 1 - x / parentHeight];\n      default:\n        return [x / parentWidth, y / parentHeight];\n    }\n  }\n  static _normalizePagePoint(x, y, rotation) {\n    switch (rotation) {\n      case 90:\n        return [1 - y, x];\n      case 180:\n        return [1 - x, 1 - y];\n      case 270:\n        return [y, 1 - x];\n      default:\n        return [x, y];\n    }\n  }\n  static createBezierPoints(x1, y1, x2, y2, x3, y3) {\n    return [(x1 + 5 * x2) / 6, (y1 + 5 * y2) / 6, (5 * x2 + x3) / 6, (5 * y2 + y3) / 6, (x2 + x3) / 2, (y2 + y3) / 2];\n  }\n}\n\n;// ./src/display/editor/drawers/freedraw.js\n\n\nclass FreeDrawOutliner {\n  #box;\n  #bottom = [];\n  #innerMargin;\n  #isLTR;\n  #top = [];\n  #last = new Float32Array(18);\n  #lastX;\n  #lastY;\n  #min;\n  #min_dist;\n  #scaleFactor;\n  #thickness;\n  #points = [];\n  static #MIN_DIST = 8;\n  static #MIN_DIFF = 2;\n  static #MIN = FreeDrawOutliner.#MIN_DIST + FreeDrawOutliner.#MIN_DIFF;\n  constructor({\n    x,\n    y\n  }, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n    this.#box = box;\n    this.#thickness = thickness * scaleFactor;\n    this.#isLTR = isLTR;\n    this.#last.set([NaN, NaN, NaN, NaN, x, y], 6);\n    this.#innerMargin = innerMargin;\n    this.#min_dist = FreeDrawOutliner.#MIN_DIST * scaleFactor;\n    this.#min = FreeDrawOutliner.#MIN * scaleFactor;\n    this.#scaleFactor = scaleFactor;\n    this.#points.push(x, y);\n  }\n  isEmpty() {\n    return isNaN(this.#last[8]);\n  }\n  #getLastCoords() {\n    const lastTop = this.#last.subarray(4, 6);\n    const lastBottom = this.#last.subarray(16, 18);\n    const [x, y, width, height] = this.#box;\n    return [(this.#lastX + (lastTop[0] - lastBottom[0]) / 2 - x) / width, (this.#lastY + (lastTop[1] - lastBottom[1]) / 2 - y) / height, (this.#lastX + (lastBottom[0] - lastTop[0]) / 2 - x) / width, (this.#lastY + (lastBottom[1] - lastTop[1]) / 2 - y) / height];\n  }\n  add({\n    x,\n    y\n  }) {\n    this.#lastX = x;\n    this.#lastY = y;\n    const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n    let [x1, y1, x2, y2] = this.#last.subarray(8, 12);\n    const diffX = x - x2;\n    const diffY = y - y2;\n    const d = Math.hypot(diffX, diffY);\n    if (d < this.#min) {\n      return false;\n    }\n    const diffD = d - this.#min_dist;\n    const K = diffD / d;\n    const shiftX = K * diffX;\n    const shiftY = K * diffY;\n    let x0 = x1;\n    let y0 = y1;\n    x1 = x2;\n    y1 = y2;\n    x2 += shiftX;\n    y2 += shiftY;\n    this.#points?.push(x, y);\n    const nX = -shiftY / diffD;\n    const nY = shiftX / diffD;\n    const thX = nX * this.#thickness;\n    const thY = nY * this.#thickness;\n    this.#last.set(this.#last.subarray(2, 8), 0);\n    this.#last.set([x2 + thX, y2 + thY], 4);\n    this.#last.set(this.#last.subarray(14, 18), 12);\n    this.#last.set([x2 - thX, y2 - thY], 16);\n    if (isNaN(this.#last[6])) {\n      if (this.#top.length === 0) {\n        this.#last.set([x1 + thX, y1 + thY], 2);\n        this.#top.push(NaN, NaN, NaN, NaN, (x1 + thX - layerX) / layerWidth, (y1 + thY - layerY) / layerHeight);\n        this.#last.set([x1 - thX, y1 - thY], 14);\n        this.#bottom.push(NaN, NaN, NaN, NaN, (x1 - thX - layerX) / layerWidth, (y1 - thY - layerY) / layerHeight);\n      }\n      this.#last.set([x0, y0, x1, y1, x2, y2], 6);\n      return !this.isEmpty();\n    }\n    this.#last.set([x0, y0, x1, y1, x2, y2], 6);\n    const angle = Math.abs(Math.atan2(y0 - y1, x0 - x1) - Math.atan2(shiftY, shiftX));\n    if (angle < Math.PI / 2) {\n      [x1, y1, x2, y2] = this.#last.subarray(2, 6);\n      this.#top.push(NaN, NaN, NaN, NaN, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n      [x1, y1, x0, y0] = this.#last.subarray(14, 18);\n      this.#bottom.push(NaN, NaN, NaN, NaN, ((x0 + x1) / 2 - layerX) / layerWidth, ((y0 + y1) / 2 - layerY) / layerHeight);\n      return true;\n    }\n    [x0, y0, x1, y1, x2, y2] = this.#last.subarray(0, 6);\n    this.#top.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n    [x2, y2, x1, y1, x0, y0] = this.#last.subarray(12, 18);\n    this.#bottom.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n    return true;\n  }\n  toSVGPath() {\n    if (this.isEmpty()) {\n      return \"\";\n    }\n    const top = this.#top;\n    const bottom = this.#bottom;\n    if (isNaN(this.#last[6]) && !this.isEmpty()) {\n      return this.#toSVGPathTwoPoints();\n    }\n    const buffer = [];\n    buffer.push(`M${top[4]} ${top[5]}`);\n    for (let i = 6; i < top.length; i += 6) {\n      if (isNaN(top[i])) {\n        buffer.push(`L${top[i + 4]} ${top[i + 5]}`);\n      } else {\n        buffer.push(`C${top[i]} ${top[i + 1]} ${top[i + 2]} ${top[i + 3]} ${top[i + 4]} ${top[i + 5]}`);\n      }\n    }\n    this.#toSVGPathEnd(buffer);\n    for (let i = bottom.length - 6; i >= 6; i -= 6) {\n      if (isNaN(bottom[i])) {\n        buffer.push(`L${bottom[i + 4]} ${bottom[i + 5]}`);\n      } else {\n        buffer.push(`C${bottom[i]} ${bottom[i + 1]} ${bottom[i + 2]} ${bottom[i + 3]} ${bottom[i + 4]} ${bottom[i + 5]}`);\n      }\n    }\n    this.#toSVGPathStart(buffer);\n    return buffer.join(\" \");\n  }\n  #toSVGPathTwoPoints() {\n    const [x, y, width, height] = this.#box;\n    const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n    return `M${(this.#last[2] - x) / width} ${(this.#last[3] - y) / height} L${(this.#last[4] - x) / width} ${(this.#last[5] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(this.#last[16] - x) / width} ${(this.#last[17] - y) / height} L${(this.#last[14] - x) / width} ${(this.#last[15] - y) / height} Z`;\n  }\n  #toSVGPathStart(buffer) {\n    const bottom = this.#bottom;\n    buffer.push(`L${bottom[4]} ${bottom[5]} Z`);\n  }\n  #toSVGPathEnd(buffer) {\n    const [x, y, width, height] = this.#box;\n    const lastTop = this.#last.subarray(4, 6);\n    const lastBottom = this.#last.subarray(16, 18);\n    const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n    buffer.push(`L${(lastTop[0] - x) / width} ${(lastTop[1] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(lastBottom[0] - x) / width} ${(lastBottom[1] - y) / height}`);\n  }\n  newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {\n    return new FreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR);\n  }\n  getOutlines() {\n    const top = this.#top;\n    const bottom = this.#bottom;\n    const last = this.#last;\n    const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n    const points = new Float32Array((this.#points?.length ?? 0) + 2);\n    for (let i = 0, ii = points.length - 2; i < ii; i += 2) {\n      points[i] = (this.#points[i] - layerX) / layerWidth;\n      points[i + 1] = (this.#points[i + 1] - layerY) / layerHeight;\n    }\n    points[points.length - 2] = (this.#lastX - layerX) / layerWidth;\n    points[points.length - 1] = (this.#lastY - layerY) / layerHeight;\n    if (isNaN(last[6]) && !this.isEmpty()) {\n      return this.#getOutlineTwoPoints(points);\n    }\n    const outline = new Float32Array(this.#top.length + 24 + this.#bottom.length);\n    let N = top.length;\n    for (let i = 0; i < N; i += 2) {\n      if (isNaN(top[i])) {\n        outline[i] = outline[i + 1] = NaN;\n        continue;\n      }\n      outline[i] = top[i];\n      outline[i + 1] = top[i + 1];\n    }\n    N = this.#getOutlineEnd(outline, N);\n    for (let i = bottom.length - 6; i >= 6; i -= 6) {\n      for (let j = 0; j < 6; j += 2) {\n        if (isNaN(bottom[i + j])) {\n          outline[N] = outline[N + 1] = NaN;\n          N += 2;\n          continue;\n        }\n        outline[N] = bottom[i + j];\n        outline[N + 1] = bottom[i + j + 1];\n        N += 2;\n      }\n    }\n    this.#getOutlineStart(outline, N);\n    return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);\n  }\n  #getOutlineTwoPoints(points) {\n    const last = this.#last;\n    const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n    const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n    const outline = new Float32Array(36);\n    outline.set([NaN, NaN, NaN, NaN, (last[2] - layerX) / layerWidth, (last[3] - layerY) / layerHeight, NaN, NaN, NaN, NaN, (last[4] - layerX) / layerWidth, (last[5] - layerY) / layerHeight, NaN, NaN, NaN, NaN, lastTopX, lastTopY, NaN, NaN, NaN, NaN, lastBottomX, lastBottomY, NaN, NaN, NaN, NaN, (last[16] - layerX) / layerWidth, (last[17] - layerY) / layerHeight, NaN, NaN, NaN, NaN, (last[14] - layerX) / layerWidth, (last[15] - layerY) / layerHeight], 0);\n    return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);\n  }\n  #getOutlineStart(outline, pos) {\n    const bottom = this.#bottom;\n    outline.set([NaN, NaN, NaN, NaN, bottom[4], bottom[5]], pos);\n    return pos += 6;\n  }\n  #getOutlineEnd(outline, pos) {\n    const lastTop = this.#last.subarray(4, 6);\n    const lastBottom = this.#last.subarray(16, 18);\n    const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n    const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n    outline.set([NaN, NaN, NaN, NaN, (lastTop[0] - layerX) / layerWidth, (lastTop[1] - layerY) / layerHeight, NaN, NaN, NaN, NaN, lastTopX, lastTopY, NaN, NaN, NaN, NaN, lastBottomX, lastBottomY, NaN, NaN, NaN, NaN, (lastBottom[0] - layerX) / layerWidth, (lastBottom[1] - layerY) / layerHeight], pos);\n    return pos += 24;\n  }\n}\nclass FreeDrawOutline extends Outline {\n  #box;\n  #bbox = new Float32Array(4);\n  #innerMargin;\n  #isLTR;\n  #points;\n  #scaleFactor;\n  #outline;\n  constructor(outline, points, box, scaleFactor, innerMargin, isLTR) {\n    super();\n    this.#outline = outline;\n    this.#points = points;\n    this.#box = box;\n    this.#scaleFactor = scaleFactor;\n    this.#innerMargin = innerMargin;\n    this.#isLTR = isLTR;\n    this.lastPoint = [NaN, NaN];\n    this.#computeMinMax(isLTR);\n    const [x, y, width, height] = this.#bbox;\n    for (let i = 0, ii = outline.length; i < ii; i += 2) {\n      outline[i] = (outline[i] - x) / width;\n      outline[i + 1] = (outline[i + 1] - y) / height;\n    }\n    for (let i = 0, ii = points.length; i < ii; i += 2) {\n      points[i] = (points[i] - x) / width;\n      points[i + 1] = (points[i + 1] - y) / height;\n    }\n  }\n  toSVGPath() {\n    const buffer = [`M${this.#outline[4]} ${this.#outline[5]}`];\n    for (let i = 6, ii = this.#outline.length; i < ii; i += 6) {\n      if (isNaN(this.#outline[i])) {\n        buffer.push(`L${this.#outline[i + 4]} ${this.#outline[i + 5]}`);\n        continue;\n      }\n      buffer.push(`C${this.#outline[i]} ${this.#outline[i + 1]} ${this.#outline[i + 2]} ${this.#outline[i + 3]} ${this.#outline[i + 4]} ${this.#outline[i + 5]}`);\n    }\n    buffer.push(\"Z\");\n    return buffer.join(\" \");\n  }\n  serialize([blX, blY, trX, trY], rotation) {\n    const width = trX - blX;\n    const height = trY - blY;\n    let outline;\n    let points;\n    switch (rotation) {\n      case 0:\n        outline = Outline._rescale(this.#outline, blX, trY, width, -height);\n        points = Outline._rescale(this.#points, blX, trY, width, -height);\n        break;\n      case 90:\n        outline = Outline._rescaleAndSwap(this.#outline, blX, blY, width, height);\n        points = Outline._rescaleAndSwap(this.#points, blX, blY, width, height);\n        break;\n      case 180:\n        outline = Outline._rescale(this.#outline, trX, blY, -width, height);\n        points = Outline._rescale(this.#points, trX, blY, -width, height);\n        break;\n      case 270:\n        outline = Outline._rescaleAndSwap(this.#outline, trX, trY, -width, -height);\n        points = Outline._rescaleAndSwap(this.#points, trX, trY, -width, -height);\n        break;\n    }\n    return {\n      outline: Array.from(outline),\n      points: [Array.from(points)]\n    };\n  }\n  #computeMinMax(isLTR) {\n    const outline = this.#outline;\n    let lastX = outline[4];\n    let lastY = outline[5];\n    const minMax = [lastX, lastY, lastX, lastY];\n    let lastPointX = lastX;\n    let lastPointY = lastY;\n    const ltrCallback = isLTR ? Math.max : Math.min;\n    for (let i = 6, ii = outline.length; i < ii; i += 6) {\n      const x = outline[i + 4],\n        y = outline[i + 5];\n      if (isNaN(outline[i])) {\n        Util.pointBoundingBox(x, y, minMax);\n        if (lastPointY < y) {\n          lastPointX = x;\n          lastPointY = y;\n        } else if (lastPointY === y) {\n          lastPointX = ltrCallback(lastPointX, x);\n        }\n      } else {\n        const bbox = [Infinity, Infinity, -Infinity, -Infinity];\n        Util.bezierBoundingBox(lastX, lastY, ...outline.slice(i, i + 6), bbox);\n        Util.rectBoundingBox(...bbox, minMax);\n        if (lastPointY < bbox[3]) {\n          lastPointX = bbox[2];\n          lastPointY = bbox[3];\n        } else if (lastPointY === bbox[3]) {\n          lastPointX = ltrCallback(lastPointX, bbox[2]);\n        }\n      }\n      lastX = x;\n      lastY = y;\n    }\n    const bbox = this.#bbox;\n    bbox[0] = minMax[0] - this.#innerMargin;\n    bbox[1] = minMax[1] - this.#innerMargin;\n    bbox[2] = minMax[2] - minMax[0] + 2 * this.#innerMargin;\n    bbox[3] = minMax[3] - minMax[1] + 2 * this.#innerMargin;\n    this.lastPoint = [lastPointX, lastPointY];\n  }\n  get box() {\n    return this.#bbox;\n  }\n  newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n    return new FreeDrawOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);\n  }\n  getNewOutline(thickness, innerMargin) {\n    const [x, y, width, height] = this.#bbox;\n    const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n    const sx = width * layerWidth;\n    const sy = height * layerHeight;\n    const tx = x * layerWidth + layerX;\n    const ty = y * layerHeight + layerY;\n    const outliner = this.newOutliner({\n      x: this.#points[0] * sx + tx,\n      y: this.#points[1] * sy + ty\n    }, this.#box, this.#scaleFactor, thickness, this.#isLTR, innerMargin ?? this.#innerMargin);\n    for (let i = 2; i < this.#points.length; i += 2) {\n      outliner.add({\n        x: this.#points[i] * sx + tx,\n        y: this.#points[i + 1] * sy + ty\n      });\n    }\n    return outliner.getOutlines();\n  }\n}\n\n;// ./src/display/editor/drawers/highlight.js\n\n\n\nclass HighlightOutliner {\n  #box;\n  #lastPoint;\n  #verticalEdges = [];\n  #intervals = [];\n  constructor(boxes, borderWidth = 0, innerMargin = 0, isLTR = true) {\n    const minMax = [Infinity, Infinity, -Infinity, -Infinity];\n    const NUMBER_OF_DIGITS = 4;\n    const EPSILON = 10 ** -NUMBER_OF_DIGITS;\n    for (const {\n      x,\n      y,\n      width,\n      height\n    } of boxes) {\n      const x1 = Math.floor((x - borderWidth) / EPSILON) * EPSILON;\n      const x2 = Math.ceil((x + width + borderWidth) / EPSILON) * EPSILON;\n      const y1 = Math.floor((y - borderWidth) / EPSILON) * EPSILON;\n      const y2 = Math.ceil((y + height + borderWidth) / EPSILON) * EPSILON;\n      const left = [x1, y1, y2, true];\n      const right = [x2, y1, y2, false];\n      this.#verticalEdges.push(left, right);\n      Util.rectBoundingBox(x1, y1, x2, y2, minMax);\n    }\n    const bboxWidth = minMax[2] - minMax[0] + 2 * innerMargin;\n    const bboxHeight = minMax[3] - minMax[1] + 2 * innerMargin;\n    const shiftedMinX = minMax[0] - innerMargin;\n    const shiftedMinY = minMax[1] - innerMargin;\n    const lastEdge = this.#verticalEdges.at(isLTR ? -1 : -2);\n    const lastPoint = [lastEdge[0], lastEdge[2]];\n    for (const edge of this.#verticalEdges) {\n      const [x, y1, y2] = edge;\n      edge[0] = (x - shiftedMinX) / bboxWidth;\n      edge[1] = (y1 - shiftedMinY) / bboxHeight;\n      edge[2] = (y2 - shiftedMinY) / bboxHeight;\n    }\n    this.#box = new Float32Array([shiftedMinX, shiftedMinY, bboxWidth, bboxHeight]);\n    this.#lastPoint = lastPoint;\n  }\n  getOutlines() {\n    this.#verticalEdges.sort((a, b) => a[0] - b[0] || a[1] - b[1] || a[2] - b[2]);\n    const outlineVerticalEdges = [];\n    for (const edge of this.#verticalEdges) {\n      if (edge[3]) {\n        outlineVerticalEdges.push(...this.#breakEdge(edge));\n        this.#insert(edge);\n      } else {\n        this.#remove(edge);\n        outlineVerticalEdges.push(...this.#breakEdge(edge));\n      }\n    }\n    return this.#getOutlines(outlineVerticalEdges);\n  }\n  #getOutlines(outlineVerticalEdges) {\n    const edges = [];\n    const allEdges = new Set();\n    for (const edge of outlineVerticalEdges) {\n      const [x, y1, y2] = edge;\n      edges.push([x, y1, edge], [x, y2, edge]);\n    }\n    edges.sort((a, b) => a[1] - b[1] || a[0] - b[0]);\n    for (let i = 0, ii = edges.length; i < ii; i += 2) {\n      const edge1 = edges[i][2];\n      const edge2 = edges[i + 1][2];\n      edge1.push(edge2);\n      edge2.push(edge1);\n      allEdges.add(edge1);\n      allEdges.add(edge2);\n    }\n    const outlines = [];\n    let outline;\n    while (allEdges.size > 0) {\n      const edge = allEdges.values().next().value;\n      let [x, y1, y2, edge1, edge2] = edge;\n      allEdges.delete(edge);\n      let lastPointX = x;\n      let lastPointY = y1;\n      outline = [x, y2];\n      outlines.push(outline);\n      while (true) {\n        let e;\n        if (allEdges.has(edge1)) {\n          e = edge1;\n        } else if (allEdges.has(edge2)) {\n          e = edge2;\n        } else {\n          break;\n        }\n        allEdges.delete(e);\n        [x, y1, y2, edge1, edge2] = e;\n        if (lastPointX !== x) {\n          outline.push(lastPointX, lastPointY, x, lastPointY === y1 ? y1 : y2);\n          lastPointX = x;\n        }\n        lastPointY = lastPointY === y1 ? y2 : y1;\n      }\n      outline.push(lastPointX, lastPointY);\n    }\n    return new HighlightOutline(outlines, this.#box, this.#lastPoint);\n  }\n  #binarySearch(y) {\n    const array = this.#intervals;\n    let start = 0;\n    let end = array.length - 1;\n    while (start <= end) {\n      const middle = start + end >> 1;\n      const y1 = array[middle][0];\n      if (y1 === y) {\n        return middle;\n      }\n      if (y1 < y) {\n        start = middle + 1;\n      } else {\n        end = middle - 1;\n      }\n    }\n    return end + 1;\n  }\n  #insert([, y1, y2]) {\n    const index = this.#binarySearch(y1);\n    this.#intervals.splice(index, 0, [y1, y2]);\n  }\n  #remove([, y1, y2]) {\n    const index = this.#binarySearch(y1);\n    for (let i = index; i < this.#intervals.length; i++) {\n      const [start, end] = this.#intervals[i];\n      if (start !== y1) {\n        break;\n      }\n      if (start === y1 && end === y2) {\n        this.#intervals.splice(i, 1);\n        return;\n      }\n    }\n    for (let i = index - 1; i >= 0; i--) {\n      const [start, end] = this.#intervals[i];\n      if (start !== y1) {\n        break;\n      }\n      if (start === y1 && end === y2) {\n        this.#intervals.splice(i, 1);\n        return;\n      }\n    }\n  }\n  #breakEdge(edge) {\n    const [x, y1, y2] = edge;\n    const results = [[x, y1, y2]];\n    const index = this.#binarySearch(y2);\n    for (let i = 0; i < index; i++) {\n      const [start, end] = this.#intervals[i];\n      for (let j = 0, jj = results.length; j < jj; j++) {\n        const [, y3, y4] = results[j];\n        if (end <= y3 || y4 <= start) {\n          continue;\n        }\n        if (y3 >= start) {\n          if (y4 > end) {\n            results[j][1] = end;\n          } else {\n            if (jj === 1) {\n              return [];\n            }\n            results.splice(j, 1);\n            j--;\n            jj--;\n          }\n          continue;\n        }\n        results[j][2] = start;\n        if (y4 > end) {\n          results.push([x, end, y4]);\n        }\n      }\n    }\n    return results;\n  }\n}\nclass HighlightOutline extends Outline {\n  #box;\n  #outlines;\n  constructor(outlines, box, lastPoint) {\n    super();\n    this.#outlines = outlines;\n    this.#box = box;\n    this.lastPoint = lastPoint;\n  }\n  toSVGPath() {\n    const buffer = [];\n    for (const polygon of this.#outlines) {\n      let [prevX, prevY] = polygon;\n      buffer.push(`M${prevX} ${prevY}`);\n      for (let i = 2; i < polygon.length; i += 2) {\n        const x = polygon[i];\n        const y = polygon[i + 1];\n        if (x === prevX) {\n          buffer.push(`V${y}`);\n          prevY = y;\n        } else if (y === prevY) {\n          buffer.push(`H${x}`);\n          prevX = x;\n        }\n      }\n      buffer.push(\"Z\");\n    }\n    return buffer.join(\" \");\n  }\n  serialize([blX, blY, trX, trY], _rotation) {\n    const outlines = [];\n    const width = trX - blX;\n    const height = trY - blY;\n    for (const outline of this.#outlines) {\n      const points = new Array(outline.length);\n      for (let i = 0; i < outline.length; i += 2) {\n        points[i] = blX + outline[i] * width;\n        points[i + 1] = trY - outline[i + 1] * height;\n      }\n      outlines.push(points);\n    }\n    return outlines;\n  }\n  get box() {\n    return this.#box;\n  }\n  get classNamesForOutlining() {\n    return [\"highlightOutline\"];\n  }\n}\nclass FreeHighlightOutliner extends FreeDrawOutliner {\n  newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {\n    return new FreeHighlightOutline(outline, points, box, scaleFactor, innerMargin, isLTR);\n  }\n}\nclass FreeHighlightOutline extends FreeDrawOutline {\n  newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n    return new FreeHighlightOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);\n  }\n}\n\n;// ./src/display/editor/highlight.js\n\n\n\n\n\n\n\nclass HighlightEditor extends AnnotationEditor {\n  #anchorNode = null;\n  #anchorOffset = 0;\n  #boxes;\n  #clipPathId = null;\n  #colorPicker = null;\n  #focusOutlines = null;\n  #focusNode = null;\n  #focusOffset = 0;\n  #highlightDiv = null;\n  #highlightOutlines = null;\n  #id = null;\n  #isFreeHighlight = false;\n  #lastPoint = null;\n  #opacity;\n  #outlineId = null;\n  #text = \"\";\n  #thickness;\n  #methodOfCreation = \"\";\n  static _defaultColor = null;\n  static _defaultOpacity = 1;\n  static _defaultThickness = 12;\n  static _type = \"highlight\";\n  static _editorType = AnnotationEditorType.HIGHLIGHT;\n  static _freeHighlightId = -1;\n  static _freeHighlight = null;\n  static _freeHighlightClipId = \"\";\n  static get _keyboardManager() {\n    const proto = HighlightEditor.prototype;\n    return shadow(this, \"_keyboardManager\", new KeyboardManager([[[\"ArrowLeft\", \"mac+ArrowLeft\"], proto._moveCaret, {\n      args: [0]\n    }], [[\"ArrowRight\", \"mac+ArrowRight\"], proto._moveCaret, {\n      args: [1]\n    }], [[\"ArrowUp\", \"mac+ArrowUp\"], proto._moveCaret, {\n      args: [2]\n    }], [[\"ArrowDown\", \"mac+ArrowDown\"], proto._moveCaret, {\n      args: [3]\n    }]]));\n  }\n  constructor(params) {\n    super({\n      ...params,\n      name: \"highlightEditor\"\n    });\n    this.color = params.color || HighlightEditor._defaultColor;\n    this.#thickness = params.thickness || HighlightEditor._defaultThickness;\n    this.#opacity = params.opacity || HighlightEditor._defaultOpacity;\n    this.#boxes = params.boxes || null;\n    this.#methodOfCreation = params.methodOfCreation || \"\";\n    this.#text = params.text || \"\";\n    this._isDraggable = false;\n    this.defaultL10nId = \"pdfjs-editor-highlight-editor\";\n    if (params.highlightId > -1) {\n      this.#isFreeHighlight = true;\n      this.#createFreeOutlines(params);\n      this.#addToDrawLayer();\n    } else if (this.#boxes) {\n      this.#anchorNode = params.anchorNode;\n      this.#anchorOffset = params.anchorOffset;\n      this.#focusNode = params.focusNode;\n      this.#focusOffset = params.focusOffset;\n      this.#createOutlines();\n      this.#addToDrawLayer();\n      this.rotate(this.rotation);\n    }\n    if (!this.annotationElementId) {\n      this._uiManager.a11yAlert(\"pdfjs-editor-highlight-added-alert\");\n    }\n  }\n  get telemetryInitialData() {\n    return {\n      action: \"added\",\n      type: this.#isFreeHighlight ? \"free_highlight\" : \"highlight\",\n      color: this._uiManager.getNonHCMColorName(this.color),\n      thickness: this.#thickness,\n      methodOfCreation: this.#methodOfCreation\n    };\n  }\n  get telemetryFinalData() {\n    return {\n      type: \"highlight\",\n      color: this._uiManager.getNonHCMColorName(this.color)\n    };\n  }\n  get commentColor() {\n    return this.color;\n  }\n  static computeTelemetryFinalData(data) {\n    return {\n      numberOfColors: data.get(\"color\").size\n    };\n  }\n  #createOutlines() {\n    const outliner = new HighlightOutliner(this.#boxes, 0.001);\n    this.#highlightOutlines = outliner.getOutlines();\n    [this.x, this.y, this.width, this.height] = this.#highlightOutlines.box;\n    const outlinerForOutline = new HighlightOutliner(this.#boxes, 0.0025, 0.001, this._uiManager.direction === \"ltr\");\n    this.#focusOutlines = outlinerForOutline.getOutlines();\n    const {\n      lastPoint\n    } = this.#focusOutlines;\n    this.#lastPoint = [(lastPoint[0] - this.x) / this.width, (lastPoint[1] - this.y) / this.height];\n  }\n  #createFreeOutlines({\n    highlightOutlines,\n    highlightId,\n    clipPathId\n  }) {\n    this.#highlightOutlines = highlightOutlines;\n    const extraThickness = 1.5;\n    this.#focusOutlines = highlightOutlines.getNewOutline(this.#thickness / 2 + extraThickness, 0.0025);\n    if (highlightId >= 0) {\n      this.#id = highlightId;\n      this.#clipPathId = clipPathId;\n      this.parent.drawLayer.finalizeDraw(highlightId, {\n        bbox: highlightOutlines.box,\n        path: {\n          d: highlightOutlines.toSVGPath()\n        }\n      });\n      this.#outlineId = this.parent.drawLayer.drawOutline({\n        rootClass: {\n          highlightOutline: true,\n          free: true\n        },\n        bbox: this.#focusOutlines.box,\n        path: {\n          d: this.#focusOutlines.toSVGPath()\n        }\n      }, true);\n    } else if (this.parent) {\n      const angle = this.parent.viewport.rotation;\n      this.parent.drawLayer.updateProperties(this.#id, {\n        bbox: HighlightEditor.#rotateBbox(this.#highlightOutlines.box, (angle - this.rotation + 360) % 360),\n        path: {\n          d: highlightOutlines.toSVGPath()\n        }\n      });\n      this.parent.drawLayer.updateProperties(this.#outlineId, {\n        bbox: HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),\n        path: {\n          d: this.#focusOutlines.toSVGPath()\n        }\n      });\n    }\n    const [x, y, width, height] = highlightOutlines.box;\n    switch (this.rotation) {\n      case 0:\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        break;\n      case 90:\n        {\n          const [pageWidth, pageHeight] = this.parentDimensions;\n          this.x = y;\n          this.y = 1 - x;\n          this.width = width * pageHeight / pageWidth;\n          this.height = height * pageWidth / pageHeight;\n          break;\n        }\n      case 180:\n        this.x = 1 - x;\n        this.y = 1 - y;\n        this.width = width;\n        this.height = height;\n        break;\n      case 270:\n        {\n          const [pageWidth, pageHeight] = this.parentDimensions;\n          this.x = 1 - y;\n          this.y = x;\n          this.width = width * pageHeight / pageWidth;\n          this.height = height * pageWidth / pageHeight;\n          break;\n        }\n    }\n    const {\n      lastPoint\n    } = this.#focusOutlines;\n    this.#lastPoint = [(lastPoint[0] - x) / width, (lastPoint[1] - y) / height];\n  }\n  static initialize(l10n, uiManager) {\n    AnnotationEditor.initialize(l10n, uiManager);\n    HighlightEditor._defaultColor ||= uiManager.highlightColors?.values().next().value || \"#fff066\";\n  }\n  static updateDefaultParams(type, value) {\n    switch (type) {\n      case AnnotationEditorParamsType.HIGHLIGHT_COLOR:\n        HighlightEditor._defaultColor = value;\n        break;\n      case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:\n        HighlightEditor._defaultThickness = value;\n        break;\n    }\n  }\n  translateInPage(x, y) {}\n  get toolbarPosition() {\n    return this.#lastPoint;\n  }\n  updateParams(type, value) {\n    switch (type) {\n      case AnnotationEditorParamsType.HIGHLIGHT_COLOR:\n        this.#updateColor(value);\n        break;\n      case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:\n        this.#updateThickness(value);\n        break;\n    }\n  }\n  static get defaultPropertiesToUpdate() {\n    return [[AnnotationEditorParamsType.HIGHLIGHT_COLOR, HighlightEditor._defaultColor], [AnnotationEditorParamsType.HIGHLIGHT_THICKNESS, HighlightEditor._defaultThickness]];\n  }\n  get propertiesToUpdate() {\n    return [[AnnotationEditorParamsType.HIGHLIGHT_COLOR, this.color || HighlightEditor._defaultColor], [AnnotationEditorParamsType.HIGHLIGHT_THICKNESS, this.#thickness || HighlightEditor._defaultThickness], [AnnotationEditorParamsType.HIGHLIGHT_FREE, this.#isFreeHighlight]];\n  }\n  #updateColor(color) {\n    const setColorAndOpacity = (col, opa) => {\n      this.color = col;\n      this.#opacity = opa;\n      this.parent?.drawLayer.updateProperties(this.#id, {\n        root: {\n          fill: col,\n          \"fill-opacity\": opa\n        }\n      });\n      this.#colorPicker?.updateColor(col);\n    };\n    const savedColor = this.color;\n    const savedOpacity = this.#opacity;\n    this.addCommands({\n      cmd: setColorAndOpacity.bind(this, color, HighlightEditor._defaultOpacity),\n      undo: setColorAndOpacity.bind(this, savedColor, savedOpacity),\n      post: this._uiManager.updateUI.bind(this._uiManager, this),\n      mustExec: true,\n      type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n    this._reportTelemetry({\n      action: \"color_changed\",\n      color: this._uiManager.getNonHCMColorName(color)\n    }, true);\n  }\n  #updateThickness(thickness) {\n    const savedThickness = this.#thickness;\n    const setThickness = th => {\n      this.#thickness = th;\n      this.#changeThickness(th);\n    };\n    this.addCommands({\n      cmd: setThickness.bind(this, thickness),\n      undo: setThickness.bind(this, savedThickness),\n      post: this._uiManager.updateUI.bind(this._uiManager, this),\n      mustExec: true,\n      type: AnnotationEditorParamsType.INK_THICKNESS,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n    this._reportTelemetry({\n      action: \"thickness_changed\",\n      thickness\n    }, true);\n  }\n  get toolbarButtons() {\n    if (this._uiManager.highlightColors) {\n      const colorPicker = this.#colorPicker = new ColorPicker({\n        editor: this\n      });\n      return [[\"colorPicker\", colorPicker]];\n    }\n    return super.toolbarButtons;\n  }\n  disableEditing() {\n    super.disableEditing();\n    this.div.classList.toggle(\"disabled\", true);\n  }\n  enableEditing() {\n    super.enableEditing();\n    this.div.classList.toggle(\"disabled\", false);\n  }\n  fixAndSetPosition() {\n    return super.fixAndSetPosition(this.#getRotation());\n  }\n  getBaseTranslation() {\n    return [0, 0];\n  }\n  getRect(tx, ty) {\n    return super.getRect(tx, ty, this.#getRotation());\n  }\n  onceAdded(focus) {\n    if (!this.annotationElementId) {\n      this.parent.addUndoableEditor(this);\n    }\n    if (focus) {\n      this.div.focus();\n    }\n  }\n  remove() {\n    this.#cleanDrawLayer();\n    this._reportTelemetry({\n      action: \"deleted\"\n    });\n    super.remove();\n  }\n  rebuild() {\n    if (!this.parent) {\n      return;\n    }\n    super.rebuild();\n    if (this.div === null) {\n      return;\n    }\n    this.#addToDrawLayer();\n    if (!this.isAttachedToDOM) {\n      this.parent.add(this);\n    }\n  }\n  setParent(parent) {\n    let mustBeSelected = false;\n    if (this.parent && !parent) {\n      this.#cleanDrawLayer();\n    } else if (parent) {\n      this.#addToDrawLayer(parent);\n      mustBeSelected = !this.parent && this.div?.classList.contains(\"selectedEditor\");\n    }\n    super.setParent(parent);\n    this.show(this._isVisible);\n    if (mustBeSelected) {\n      this.select();\n    }\n  }\n  #changeThickness(thickness) {\n    if (!this.#isFreeHighlight) {\n      return;\n    }\n    this.#createFreeOutlines({\n      highlightOutlines: this.#highlightOutlines.getNewOutline(thickness / 2)\n    });\n    this.fixAndSetPosition();\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.setDims(this.width * parentWidth, this.height * parentHeight);\n  }\n  #cleanDrawLayer() {\n    if (this.#id === null || !this.parent) {\n      return;\n    }\n    this.parent.drawLayer.remove(this.#id);\n    this.#id = null;\n    this.parent.drawLayer.remove(this.#outlineId);\n    this.#outlineId = null;\n  }\n  #addToDrawLayer(parent = this.parent) {\n    if (this.#id !== null) {\n      return;\n    }\n    ({\n      id: this.#id,\n      clipPathId: this.#clipPathId\n    } = parent.drawLayer.draw({\n      bbox: this.#highlightOutlines.box,\n      root: {\n        viewBox: \"0 0 1 1\",\n        fill: this.color,\n        \"fill-opacity\": this.#opacity\n      },\n      rootClass: {\n        highlight: true,\n        free: this.#isFreeHighlight\n      },\n      path: {\n        d: this.#highlightOutlines.toSVGPath()\n      }\n    }, false, true));\n    this.#outlineId = parent.drawLayer.drawOutline({\n      rootClass: {\n        highlightOutline: true,\n        free: this.#isFreeHighlight\n      },\n      bbox: this.#focusOutlines.box,\n      path: {\n        d: this.#focusOutlines.toSVGPath()\n      }\n    }, this.#isFreeHighlight);\n    if (this.#highlightDiv) {\n      this.#highlightDiv.style.clipPath = this.#clipPathId;\n    }\n  }\n  static #rotateBbox([x, y, width, height], angle) {\n    switch (angle) {\n      case 90:\n        return [1 - y - height, x, height, width];\n      case 180:\n        return [1 - x - width, 1 - y - height, width, height];\n      case 270:\n        return [y, 1 - x - width, height, width];\n    }\n    return [x, y, width, height];\n  }\n  rotate(angle) {\n    const {\n      drawLayer\n    } = this.parent;\n    let box;\n    if (this.#isFreeHighlight) {\n      angle = (angle - this.rotation + 360) % 360;\n      box = HighlightEditor.#rotateBbox(this.#highlightOutlines.box, angle);\n    } else {\n      box = HighlightEditor.#rotateBbox([this.x, this.y, this.width, this.height], angle);\n    }\n    drawLayer.updateProperties(this.#id, {\n      bbox: box,\n      root: {\n        \"data-main-rotation\": angle\n      }\n    });\n    drawLayer.updateProperties(this.#outlineId, {\n      bbox: HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),\n      root: {\n        \"data-main-rotation\": angle\n      }\n    });\n  }\n  render() {\n    if (this.div) {\n      return this.div;\n    }\n    const div = super.render();\n    if (this.#text) {\n      div.setAttribute(\"aria-label\", this.#text);\n      div.setAttribute(\"role\", \"mark\");\n    }\n    if (this.#isFreeHighlight) {\n      div.classList.add(\"free\");\n    } else {\n      this.div.addEventListener(\"keydown\", this.#keydown.bind(this), {\n        signal: this._uiManager._signal\n      });\n    }\n    const highlightDiv = this.#highlightDiv = document.createElement(\"div\");\n    div.append(highlightDiv);\n    highlightDiv.setAttribute(\"aria-hidden\", \"true\");\n    highlightDiv.className = \"internal\";\n    highlightDiv.style.clipPath = this.#clipPathId;\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.setDims(this.width * parentWidth, this.height * parentHeight);\n    bindEvents(this, this.#highlightDiv, [\"pointerover\", \"pointerleave\"]);\n    this.enableEditing();\n    return div;\n  }\n  pointerover() {\n    if (!this.isSelected) {\n      this.parent?.drawLayer.updateProperties(this.#outlineId, {\n        rootClass: {\n          hovered: true\n        }\n      });\n    }\n  }\n  pointerleave() {\n    if (!this.isSelected) {\n      this.parent?.drawLayer.updateProperties(this.#outlineId, {\n        rootClass: {\n          hovered: false\n        }\n      });\n    }\n  }\n  #keydown(event) {\n    HighlightEditor._keyboardManager.exec(this, event);\n  }\n  _moveCaret(direction) {\n    this.parent.unselect(this);\n    switch (direction) {\n      case 0:\n      case 2:\n        this.#setCaret(true);\n        break;\n      case 1:\n      case 3:\n        this.#setCaret(false);\n        break;\n    }\n  }\n  #setCaret(start) {\n    if (!this.#anchorNode) {\n      return;\n    }\n    const selection = window.getSelection();\n    if (start) {\n      selection.setPosition(this.#anchorNode, this.#anchorOffset);\n    } else {\n      selection.setPosition(this.#focusNode, this.#focusOffset);\n    }\n  }\n  select() {\n    super.select();\n    if (!this.#outlineId) {\n      return;\n    }\n    this.parent?.drawLayer.updateProperties(this.#outlineId, {\n      rootClass: {\n        hovered: false,\n        selected: true\n      }\n    });\n  }\n  unselect() {\n    super.unselect();\n    if (!this.#outlineId) {\n      return;\n    }\n    this.parent?.drawLayer.updateProperties(this.#outlineId, {\n      rootClass: {\n        selected: false\n      }\n    });\n    if (!this.#isFreeHighlight) {\n      this.#setCaret(false);\n    }\n  }\n  get _mustFixPosition() {\n    return !this.#isFreeHighlight;\n  }\n  show(visible = this._isVisible) {\n    super.show(visible);\n    if (this.parent) {\n      this.parent.drawLayer.updateProperties(this.#id, {\n        rootClass: {\n          hidden: !visible\n        }\n      });\n      this.parent.drawLayer.updateProperties(this.#outlineId, {\n        rootClass: {\n          hidden: !visible\n        }\n      });\n    }\n  }\n  #getRotation() {\n    return this.#isFreeHighlight ? this.rotation : 0;\n  }\n  #serializeBoxes() {\n    if (this.#isFreeHighlight) {\n      return null;\n    }\n    const [pageWidth, pageHeight] = this.pageDimensions;\n    const [pageX, pageY] = this.pageTranslation;\n    const boxes = this.#boxes;\n    const quadPoints = new Float32Array(boxes.length * 8);\n    let i = 0;\n    for (const {\n      x,\n      y,\n      width,\n      height\n    } of boxes) {\n      const sx = x * pageWidth + pageX;\n      const sy = (1 - y) * pageHeight + pageY;\n      quadPoints[i] = quadPoints[i + 4] = sx;\n      quadPoints[i + 1] = quadPoints[i + 3] = sy;\n      quadPoints[i + 2] = quadPoints[i + 6] = sx + width * pageWidth;\n      quadPoints[i + 5] = quadPoints[i + 7] = sy - height * pageHeight;\n      i += 8;\n    }\n    return quadPoints;\n  }\n  #serializeOutlines(rect) {\n    return this.#highlightOutlines.serialize(rect, this.#getRotation());\n  }\n  static startHighlighting(parent, isLTR, {\n    target: textLayer,\n    x,\n    y\n  }) {\n    const {\n      x: layerX,\n      y: layerY,\n      width: parentWidth,\n      height: parentHeight\n    } = textLayer.getBoundingClientRect();\n    const ac = new AbortController();\n    const signal = parent.combinedSignal(ac);\n    const pointerUpCallback = e => {\n      ac.abort();\n      this.#endHighlight(parent, e);\n    };\n    window.addEventListener(\"blur\", pointerUpCallback, {\n      signal\n    });\n    window.addEventListener(\"pointerup\", pointerUpCallback, {\n      signal\n    });\n    window.addEventListener(\"pointerdown\", stopEvent, {\n      capture: true,\n      passive: false,\n      signal\n    });\n    window.addEventListener(\"contextmenu\", noContextMenu, {\n      signal\n    });\n    textLayer.addEventListener(\"pointermove\", this.#highlightMove.bind(this, parent), {\n      signal\n    });\n    this._freeHighlight = new FreeHighlightOutliner({\n      x,\n      y\n    }, [layerX, layerY, parentWidth, parentHeight], parent.scale, this._defaultThickness / 2, isLTR, 0.001);\n    ({\n      id: this._freeHighlightId,\n      clipPathId: this._freeHighlightClipId\n    } = parent.drawLayer.draw({\n      bbox: [0, 0, 1, 1],\n      root: {\n        viewBox: \"0 0 1 1\",\n        fill: this._defaultColor,\n        \"fill-opacity\": this._defaultOpacity\n      },\n      rootClass: {\n        highlight: true,\n        free: true\n      },\n      path: {\n        d: this._freeHighlight.toSVGPath()\n      }\n    }, true, true));\n  }\n  static #highlightMove(parent, event) {\n    if (this._freeHighlight.add(event)) {\n      parent.drawLayer.updateProperties(this._freeHighlightId, {\n        path: {\n          d: this._freeHighlight.toSVGPath()\n        }\n      });\n    }\n  }\n  static #endHighlight(parent, event) {\n    if (!this._freeHighlight.isEmpty()) {\n      parent.createAndAddNewEditor(event, false, {\n        highlightId: this._freeHighlightId,\n        highlightOutlines: this._freeHighlight.getOutlines(),\n        clipPathId: this._freeHighlightClipId,\n        methodOfCreation: \"main_toolbar\"\n      });\n    } else {\n      parent.drawLayer.remove(this._freeHighlightId);\n    }\n    this._freeHighlightId = -1;\n    this._freeHighlight = null;\n    this._freeHighlightClipId = \"\";\n  }\n  static async deserialize(data, parent, uiManager) {\n    let initialData = null;\n    if (data instanceof HighlightAnnotationElement) {\n      const {\n        data: {\n          quadPoints,\n          rect,\n          rotation,\n          id,\n          color,\n          opacity,\n          popupRef,\n          contentsObj\n        },\n        parent: {\n          page: {\n            pageNumber\n          }\n        }\n      } = data;\n      initialData = data = {\n        annotationType: AnnotationEditorType.HIGHLIGHT,\n        color: Array.from(color),\n        opacity,\n        quadPoints,\n        boxes: null,\n        pageIndex: pageNumber - 1,\n        rect: rect.slice(0),\n        rotation,\n        annotationElementId: id,\n        id,\n        deleted: false,\n        popupRef,\n        comment: contentsObj?.str || null\n      };\n    } else if (data instanceof InkAnnotationElement) {\n      const {\n        data: {\n          inkLists,\n          rect,\n          rotation,\n          id,\n          color,\n          borderStyle: {\n            rawWidth: thickness\n          },\n          popupRef,\n          contentsObj\n        },\n        parent: {\n          page: {\n            pageNumber\n          }\n        }\n      } = data;\n      initialData = data = {\n        annotationType: AnnotationEditorType.HIGHLIGHT,\n        color: Array.from(color),\n        thickness,\n        inkLists,\n        boxes: null,\n        pageIndex: pageNumber - 1,\n        rect: rect.slice(0),\n        rotation,\n        annotationElementId: id,\n        id,\n        deleted: false,\n        popupRef,\n        comment: contentsObj?.str || null\n      };\n    }\n    const {\n      color,\n      quadPoints,\n      inkLists,\n      opacity\n    } = data;\n    const editor = await super.deserialize(data, parent, uiManager);\n    editor.color = Util.makeHexColor(...color);\n    editor.#opacity = opacity || 1;\n    if (inkLists) {\n      editor.#thickness = data.thickness;\n    }\n    editor._initialData = initialData;\n    if (data.comment) {\n      editor.setCommentData(data.comment);\n    }\n    const [pageWidth, pageHeight] = editor.pageDimensions;\n    const [pageX, pageY] = editor.pageTranslation;\n    if (quadPoints) {\n      const boxes = editor.#boxes = [];\n      for (let i = 0; i < quadPoints.length; i += 8) {\n        boxes.push({\n          x: (quadPoints[i] - pageX) / pageWidth,\n          y: 1 - (quadPoints[i + 1] - pageY) / pageHeight,\n          width: (quadPoints[i + 2] - quadPoints[i]) / pageWidth,\n          height: (quadPoints[i + 1] - quadPoints[i + 5]) / pageHeight\n        });\n      }\n      editor.#createOutlines();\n      editor.#addToDrawLayer();\n      editor.rotate(editor.rotation);\n    } else if (inkLists) {\n      editor.#isFreeHighlight = true;\n      const points = inkLists[0];\n      const point = {\n        x: points[0] - pageX,\n        y: pageHeight - (points[1] - pageY)\n      };\n      const outliner = new FreeHighlightOutliner(point, [0, 0, pageWidth, pageHeight], 1, editor.#thickness / 2, true, 0.001);\n      for (let i = 0, ii = points.length; i < ii; i += 2) {\n        point.x = points[i] - pageX;\n        point.y = pageHeight - (points[i + 1] - pageY);\n        outliner.add(point);\n      }\n      const {\n        id,\n        clipPathId\n      } = parent.drawLayer.draw({\n        bbox: [0, 0, 1, 1],\n        root: {\n          viewBox: \"0 0 1 1\",\n          fill: editor.color,\n          \"fill-opacity\": editor._defaultOpacity\n        },\n        rootClass: {\n          highlight: true,\n          free: true\n        },\n        path: {\n          d: outliner.toSVGPath()\n        }\n      }, true, true);\n      editor.#createFreeOutlines({\n        highlightOutlines: outliner.getOutlines(),\n        highlightId: id,\n        clipPathId\n      });\n      editor.#addToDrawLayer();\n      editor.rotate(editor.parentRotation);\n    }\n    return editor;\n  }\n  serialize(isForCopying = false) {\n    if (this.isEmpty() || isForCopying) {\n      return null;\n    }\n    if (this.deleted) {\n      return this.serializeDeleted();\n    }\n    const rect = this.getPDFRect();\n    const color = AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color));\n    const serialized = {\n      annotationType: AnnotationEditorType.HIGHLIGHT,\n      color,\n      opacity: this.#opacity,\n      thickness: this.#thickness,\n      quadPoints: this.#serializeBoxes(),\n      outlines: this.#serializeOutlines(rect),\n      pageIndex: this.pageIndex,\n      rect,\n      rotation: this.#getRotation(),\n      structTreeParentId: this._structTreeParentId\n    };\n    this.addComment(serialized);\n    if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n      return null;\n    }\n    serialized.id = this.annotationElementId;\n    return serialized;\n  }\n  #hasElementChanged(serialized) {\n    const {\n      color\n    } = this._initialData;\n    return this.hasEditedComment || serialized.color.some((c, i) => c !== color[i]);\n  }\n  renderAnnotationElement(annotation) {\n    if (this.deleted) {\n      annotation.hide();\n      return null;\n    }\n    const params = {\n      rect: this.getPDFRect()\n    };\n    if (this.hasEditedComment) {\n      params.popup = this.comment;\n    }\n    annotation.updateEdited(params);\n    return null;\n  }\n  static canCreateNewEmptyEditor() {\n    return false;\n  }\n}\n\n;// ./src/display/editor/draw.js\n\n\n\nclass DrawingOptions {\n  #svgProperties = Object.create(null);\n  updateProperty(name, value) {\n    this[name] = value;\n    this.updateSVGProperty(name, value);\n  }\n  updateProperties(properties) {\n    if (!properties) {\n      return;\n    }\n    for (const [name, value] of Object.entries(properties)) {\n      if (!name.startsWith(\"_\")) {\n        this.updateProperty(name, value);\n      }\n    }\n  }\n  updateSVGProperty(name, value) {\n    this.#svgProperties[name] = value;\n  }\n  toSVGProperties() {\n    const root = this.#svgProperties;\n    this.#svgProperties = Object.create(null);\n    return {\n      root\n    };\n  }\n  reset() {\n    this.#svgProperties = Object.create(null);\n  }\n  updateAll(options = this) {\n    this.updateProperties(options);\n  }\n  clone() {\n    unreachable(\"Not implemented\");\n  }\n}\nclass DrawingEditor extends AnnotationEditor {\n  #drawOutlines = null;\n  #mustBeCommitted;\n  _colorPicker = null;\n  _drawId = null;\n  static _currentDrawId = -1;\n  static _currentParent = null;\n  static #currentDraw = null;\n  static #currentDrawingAC = null;\n  static #currentDrawingOptions = null;\n  static #currentPointerId = NaN;\n  static #currentPointerType = null;\n  static #currentPointerIds = null;\n  static #currentMoveTimestamp = NaN;\n  static _INNER_MARGIN = 3;\n  constructor(params) {\n    super(params);\n    this.#mustBeCommitted = params.mustBeCommitted || false;\n    this._addOutlines(params);\n  }\n  _addOutlines(params) {\n    if (params.drawOutlines) {\n      this.#createDrawOutlines(params);\n      this.#addToDrawLayer();\n    }\n  }\n  #createDrawOutlines({\n    drawOutlines,\n    drawId,\n    drawingOptions\n  }) {\n    this.#drawOutlines = drawOutlines;\n    this._drawingOptions ||= drawingOptions;\n    if (!this.annotationElementId) {\n      this._uiManager.a11yAlert(`pdfjs-editor-${this.editorType}-added-alert`);\n    }\n    if (drawId >= 0) {\n      this._drawId = drawId;\n      this.parent.drawLayer.finalizeDraw(drawId, drawOutlines.defaultProperties);\n    } else {\n      this._drawId = this.#createDrawing(drawOutlines, this.parent);\n    }\n    this.#updateBbox(drawOutlines.box);\n  }\n  #createDrawing(drawOutlines, parent) {\n    const {\n      id\n    } = parent.drawLayer.draw(DrawingEditor._mergeSVGProperties(this._drawingOptions.toSVGProperties(), drawOutlines.defaultSVGProperties), false, false);\n    return id;\n  }\n  static _mergeSVGProperties(p1, p2) {\n    const p1Keys = new Set(Object.keys(p1));\n    for (const [key, value] of Object.entries(p2)) {\n      if (p1Keys.has(key)) {\n        Object.assign(p1[key], value);\n      } else {\n        p1[key] = value;\n      }\n    }\n    return p1;\n  }\n  static getDefaultDrawingOptions(_options) {\n    unreachable(\"Not implemented\");\n  }\n  static get typesMap() {\n    unreachable(\"Not implemented\");\n  }\n  static get isDrawer() {\n    return true;\n  }\n  static get supportMultipleDrawings() {\n    return false;\n  }\n  static updateDefaultParams(type, value) {\n    const propertyName = this.typesMap.get(type);\n    if (propertyName) {\n      this._defaultDrawingOptions.updateProperty(propertyName, value);\n    }\n    if (this._currentParent) {\n      DrawingEditor.#currentDraw.updateProperty(propertyName, value);\n      this._currentParent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());\n    }\n  }\n  updateParams(type, value) {\n    const propertyName = this.constructor.typesMap.get(type);\n    if (propertyName) {\n      this._updateProperty(type, propertyName, value);\n    }\n  }\n  static get defaultPropertiesToUpdate() {\n    const properties = [];\n    const options = this._defaultDrawingOptions;\n    for (const [type, name] of this.typesMap) {\n      properties.push([type, options[name]]);\n    }\n    return properties;\n  }\n  get propertiesToUpdate() {\n    const properties = [];\n    const {\n      _drawingOptions\n    } = this;\n    for (const [type, name] of this.constructor.typesMap) {\n      properties.push([type, _drawingOptions[name]]);\n    }\n    return properties;\n  }\n  _updateProperty(type, name, value) {\n    const options = this._drawingOptions;\n    const savedValue = options[name];\n    const setter = val => {\n      options.updateProperty(name, val);\n      const bbox = this.#drawOutlines.updateProperty(name, val);\n      if (bbox) {\n        this.#updateBbox(bbox);\n      }\n      this.parent?.drawLayer.updateProperties(this._drawId, options.toSVGProperties());\n      if (type === this.colorType) {\n        this._colorPicker?.update(val);\n      }\n    };\n    this.addCommands({\n      cmd: setter.bind(this, value),\n      undo: setter.bind(this, savedValue),\n      post: this._uiManager.updateUI.bind(this._uiManager, this),\n      mustExec: true,\n      type,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n  _onResizing() {\n    this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizingSVGProperties(this.#convertToDrawSpace()), {\n      bbox: this.#rotateBox()\n    }));\n  }\n  _onResized() {\n    this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizedSVGProperties(this.#convertToDrawSpace()), {\n      bbox: this.#rotateBox()\n    }));\n  }\n  _onTranslating(_x, _y) {\n    this.parent?.drawLayer.updateProperties(this._drawId, {\n      bbox: this.#rotateBox()\n    });\n  }\n  _onTranslated() {\n    this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathTranslatedSVGProperties(this.#convertToDrawSpace(), this.parentDimensions), {\n      bbox: this.#rotateBox()\n    }));\n  }\n  _onStartDragging() {\n    this.parent?.drawLayer.updateProperties(this._drawId, {\n      rootClass: {\n        moving: true\n      }\n    });\n  }\n  _onStopDragging() {\n    this.parent?.drawLayer.updateProperties(this._drawId, {\n      rootClass: {\n        moving: false\n      }\n    });\n  }\n  commit() {\n    super.commit();\n    this.disableEditMode();\n    this.disableEditing();\n  }\n  disableEditing() {\n    super.disableEditing();\n    this.div.classList.toggle(\"disabled\", true);\n  }\n  enableEditing() {\n    super.enableEditing();\n    this.div.classList.toggle(\"disabled\", false);\n  }\n  getBaseTranslation() {\n    return [0, 0];\n  }\n  get isResizable() {\n    return true;\n  }\n  onceAdded(focus) {\n    if (!this.annotationElementId) {\n      this.parent.addUndoableEditor(this);\n    }\n    this._isDraggable = true;\n    if (this.#mustBeCommitted) {\n      this.#mustBeCommitted = false;\n      this.commit();\n      this.parent.setSelected(this);\n      if (focus && this.isOnScreen) {\n        this.div.focus();\n      }\n    }\n  }\n  remove() {\n    this.#cleanDrawLayer();\n    super.remove();\n  }\n  rebuild() {\n    if (!this.parent) {\n      return;\n    }\n    super.rebuild();\n    if (this.div === null) {\n      return;\n    }\n    this.#addToDrawLayer();\n    this.#updateBbox(this.#drawOutlines.box);\n    if (!this.isAttachedToDOM) {\n      this.parent.add(this);\n    }\n  }\n  setParent(parent) {\n    let mustBeSelected = false;\n    if (this.parent && !parent) {\n      this._uiManager.removeShouldRescale(this);\n      this.#cleanDrawLayer();\n    } else if (parent) {\n      this._uiManager.addShouldRescale(this);\n      this.#addToDrawLayer(parent);\n      mustBeSelected = !this.parent && this.div?.classList.contains(\"selectedEditor\");\n    }\n    super.setParent(parent);\n    if (mustBeSelected) {\n      this.select();\n    }\n  }\n  #cleanDrawLayer() {\n    if (this._drawId === null || !this.parent) {\n      return;\n    }\n    this.parent.drawLayer.remove(this._drawId);\n    this._drawId = null;\n    this._drawingOptions.reset();\n  }\n  #addToDrawLayer(parent = this.parent) {\n    if (this._drawId !== null && this.parent === parent) {\n      return;\n    }\n    if (this._drawId !== null) {\n      this.parent.drawLayer.updateParent(this._drawId, parent.drawLayer);\n      return;\n    }\n    this._drawingOptions.updateAll();\n    this._drawId = this.#createDrawing(this.#drawOutlines, parent);\n  }\n  #convertToParentSpace([x, y, width, height]) {\n    const {\n      parentDimensions: [pW, pH],\n      rotation\n    } = this;\n    switch (rotation) {\n      case 90:\n        return [y, 1 - x, width * (pH / pW), height * (pW / pH)];\n      case 180:\n        return [1 - x, 1 - y, width, height];\n      case 270:\n        return [1 - y, x, width * (pH / pW), height * (pW / pH)];\n      default:\n        return [x, y, width, height];\n    }\n  }\n  #convertToDrawSpace() {\n    const {\n      x,\n      y,\n      width,\n      height,\n      parentDimensions: [pW, pH],\n      rotation\n    } = this;\n    switch (rotation) {\n      case 90:\n        return [1 - y, x, width * (pW / pH), height * (pH / pW)];\n      case 180:\n        return [1 - x, 1 - y, width, height];\n      case 270:\n        return [y, 1 - x, width * (pW / pH), height * (pH / pW)];\n      default:\n        return [x, y, width, height];\n    }\n  }\n  #updateBbox(bbox) {\n    [this.x, this.y, this.width, this.height] = this.#convertToParentSpace(bbox);\n    if (this.div) {\n      this.fixAndSetPosition();\n      const [parentWidth, parentHeight] = this.parentDimensions;\n      this.setDims(this.width * parentWidth, this.height * parentHeight);\n    }\n    this._onResized();\n  }\n  #rotateBox() {\n    const {\n      x,\n      y,\n      width,\n      height,\n      rotation,\n      parentRotation,\n      parentDimensions: [pW, pH]\n    } = this;\n    switch ((rotation * 4 + parentRotation) / 90) {\n      case 1:\n        return [1 - y - height, x, height, width];\n      case 2:\n        return [1 - x - width, 1 - y - height, width, height];\n      case 3:\n        return [y, 1 - x - width, height, width];\n      case 4:\n        return [x, y - width * (pW / pH), height * (pH / pW), width * (pW / pH)];\n      case 5:\n        return [1 - y, x, width * (pW / pH), height * (pH / pW)];\n      case 6:\n        return [1 - x - height * (pH / pW), 1 - y, height * (pH / pW), width * (pW / pH)];\n      case 7:\n        return [y - width * (pW / pH), 1 - x - height * (pH / pW), width * (pW / pH), height * (pH / pW)];\n      case 8:\n        return [x - width, y - height, width, height];\n      case 9:\n        return [1 - y, x - width, height, width];\n      case 10:\n        return [1 - x, 1 - y, width, height];\n      case 11:\n        return [y - height, 1 - x, height, width];\n      case 12:\n        return [x - height * (pH / pW), y, height * (pH / pW), width * (pW / pH)];\n      case 13:\n        return [1 - y - width * (pW / pH), x - height * (pH / pW), width * (pW / pH), height * (pH / pW)];\n      case 14:\n        return [1 - x, 1 - y - width * (pW / pH), height * (pH / pW), width * (pW / pH)];\n      case 15:\n        return [y, 1 - x, width * (pW / pH), height * (pH / pW)];\n      default:\n        return [x, y, width, height];\n    }\n  }\n  rotate() {\n    if (!this.parent) {\n      return;\n    }\n    this.parent.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties({\n      bbox: this.#rotateBox()\n    }, this.#drawOutlines.updateRotation((this.parentRotation - this.rotation + 360) % 360)));\n  }\n  onScaleChanging() {\n    if (!this.parent) {\n      return;\n    }\n    this.#updateBbox(this.#drawOutlines.updateParentDimensions(this.parentDimensions, this.parent.scale));\n  }\n  static onScaleChangingWhenDrawing() {}\n  render() {\n    if (this.div) {\n      return this.div;\n    }\n    let baseX, baseY;\n    if (this._isCopy) {\n      baseX = this.x;\n      baseY = this.y;\n    }\n    const div = super.render();\n    div.classList.add(\"draw\");\n    const drawDiv = document.createElement(\"div\");\n    div.append(drawDiv);\n    drawDiv.setAttribute(\"aria-hidden\", \"true\");\n    drawDiv.className = \"internal\";\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.setDims(this.width * parentWidth, this.height * parentHeight);\n    this._uiManager.addShouldRescale(this);\n    this.disableEditing();\n    if (this._isCopy) {\n      this._moveAfterPaste(baseX, baseY);\n    }\n    return div;\n  }\n  static createDrawerInstance(_x, _y, _parentWidth, _parentHeight, _rotation) {\n    unreachable(\"Not implemented\");\n  }\n  static startDrawing(parent, uiManager, _isLTR, event) {\n    const {\n      target,\n      offsetX: x,\n      offsetY: y,\n      pointerId,\n      pointerType\n    } = event;\n    if (DrawingEditor.#currentPointerType && DrawingEditor.#currentPointerType !== pointerType) {\n      return;\n    }\n    const {\n      viewport: {\n        rotation\n      }\n    } = parent;\n    const {\n      width: parentWidth,\n      height: parentHeight\n    } = target.getBoundingClientRect();\n    const ac = DrawingEditor.#currentDrawingAC = new AbortController();\n    const signal = parent.combinedSignal(ac);\n    DrawingEditor.#currentPointerId ||= pointerId;\n    DrawingEditor.#currentPointerType ??= pointerType;\n    window.addEventListener(\"pointerup\", e => {\n      if (DrawingEditor.#currentPointerId === e.pointerId) {\n        this._endDraw(e);\n      } else {\n        DrawingEditor.#currentPointerIds?.delete(e.pointerId);\n      }\n    }, {\n      signal\n    });\n    window.addEventListener(\"pointercancel\", e => {\n      if (DrawingEditor.#currentPointerId === e.pointerId) {\n        this._currentParent.endDrawingSession();\n      } else {\n        DrawingEditor.#currentPointerIds?.delete(e.pointerId);\n      }\n    }, {\n      signal\n    });\n    window.addEventListener(\"pointerdown\", e => {\n      if (DrawingEditor.#currentPointerType !== e.pointerType) {\n        return;\n      }\n      (DrawingEditor.#currentPointerIds ||= new Set()).add(e.pointerId);\n      if (DrawingEditor.#currentDraw.isCancellable()) {\n        DrawingEditor.#currentDraw.removeLastElement();\n        if (DrawingEditor.#currentDraw.isEmpty()) {\n          this._currentParent.endDrawingSession(true);\n        } else {\n          this._endDraw(null);\n        }\n      }\n    }, {\n      capture: true,\n      passive: false,\n      signal\n    });\n    window.addEventListener(\"contextmenu\", noContextMenu, {\n      signal\n    });\n    target.addEventListener(\"pointermove\", this._drawMove.bind(this), {\n      signal\n    });\n    target.addEventListener(\"touchmove\", e => {\n      if (e.timeStamp === DrawingEditor.#currentMoveTimestamp) {\n        stopEvent(e);\n      }\n    }, {\n      signal\n    });\n    parent.toggleDrawing();\n    uiManager._editorUndoBar?.hide();\n    if (DrawingEditor.#currentDraw) {\n      parent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.startNew(x, y, parentWidth, parentHeight, rotation));\n      return;\n    }\n    uiManager.updateUIForDefaultProperties(this);\n    DrawingEditor.#currentDraw = this.createDrawerInstance(x, y, parentWidth, parentHeight, rotation);\n    DrawingEditor.#currentDrawingOptions = this.getDefaultDrawingOptions();\n    this._currentParent = parent;\n    ({\n      id: this._currentDrawId\n    } = parent.drawLayer.draw(this._mergeSVGProperties(DrawingEditor.#currentDrawingOptions.toSVGProperties(), DrawingEditor.#currentDraw.defaultSVGProperties), true, false));\n  }\n  static _drawMove(event) {\n    DrawingEditor.#currentMoveTimestamp = -1;\n    if (!DrawingEditor.#currentDraw) {\n      return;\n    }\n    const {\n      offsetX,\n      offsetY,\n      pointerId\n    } = event;\n    if (DrawingEditor.#currentPointerId !== pointerId) {\n      return;\n    }\n    if (DrawingEditor.#currentPointerIds?.size >= 1) {\n      this._endDraw(event);\n      return;\n    }\n    this._currentParent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.add(offsetX, offsetY));\n    DrawingEditor.#currentMoveTimestamp = event.timeStamp;\n    stopEvent(event);\n  }\n  static _cleanup(all) {\n    if (all) {\n      this._currentDrawId = -1;\n      this._currentParent = null;\n      DrawingEditor.#currentDraw = null;\n      DrawingEditor.#currentDrawingOptions = null;\n      DrawingEditor.#currentPointerType = null;\n      DrawingEditor.#currentMoveTimestamp = NaN;\n    }\n    if (DrawingEditor.#currentDrawingAC) {\n      DrawingEditor.#currentDrawingAC.abort();\n      DrawingEditor.#currentDrawingAC = null;\n      DrawingEditor.#currentPointerId = NaN;\n      DrawingEditor.#currentPointerIds = null;\n    }\n  }\n  static _endDraw(event) {\n    const parent = this._currentParent;\n    if (!parent) {\n      return;\n    }\n    parent.toggleDrawing(true);\n    this._cleanup(false);\n    if (event?.target === parent.div) {\n      parent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.end(event.offsetX, event.offsetY));\n    }\n    if (this.supportMultipleDrawings) {\n      const draw = DrawingEditor.#currentDraw;\n      const drawId = this._currentDrawId;\n      const lastElement = draw.getLastElement();\n      parent.addCommands({\n        cmd: () => {\n          parent.drawLayer.updateProperties(drawId, draw.setLastElement(lastElement));\n        },\n        undo: () => {\n          parent.drawLayer.updateProperties(drawId, draw.removeLastElement());\n        },\n        mustExec: false,\n        type: AnnotationEditorParamsType.DRAW_STEP\n      });\n      return;\n    }\n    this.endDrawing(false);\n  }\n  static endDrawing(isAborted) {\n    const parent = this._currentParent;\n    if (!parent) {\n      return null;\n    }\n    parent.toggleDrawing(true);\n    parent.cleanUndoStack(AnnotationEditorParamsType.DRAW_STEP);\n    if (!DrawingEditor.#currentDraw.isEmpty()) {\n      const {\n        pageDimensions: [pageWidth, pageHeight],\n        scale\n      } = parent;\n      const editor = parent.createAndAddNewEditor({\n        offsetX: 0,\n        offsetY: 0\n      }, false, {\n        drawId: this._currentDrawId,\n        drawOutlines: DrawingEditor.#currentDraw.getOutlines(pageWidth * scale, pageHeight * scale, scale, this._INNER_MARGIN),\n        drawingOptions: DrawingEditor.#currentDrawingOptions,\n        mustBeCommitted: !isAborted\n      });\n      this._cleanup(true);\n      return editor;\n    }\n    parent.drawLayer.remove(this._currentDrawId);\n    this._cleanup(true);\n    return null;\n  }\n  createDrawingOptions(_data) {}\n  static deserializeDraw(_pageX, _pageY, _pageWidth, _pageHeight, _innerWidth, _data) {\n    unreachable(\"Not implemented\");\n  }\n  static async deserialize(data, parent, uiManager) {\n    const {\n      rawDims: {\n        pageWidth,\n        pageHeight,\n        pageX,\n        pageY\n      }\n    } = parent.viewport;\n    const drawOutlines = this.deserializeDraw(pageX, pageY, pageWidth, pageHeight, this._INNER_MARGIN, data);\n    const editor = await super.deserialize(data, parent, uiManager);\n    editor.createDrawingOptions(data);\n    editor.#createDrawOutlines({\n      drawOutlines\n    });\n    editor.#addToDrawLayer();\n    editor.onScaleChanging();\n    editor.rotate();\n    return editor;\n  }\n  serializeDraw(isForCopying) {\n    const [pageX, pageY] = this.pageTranslation;\n    const [pageWidth, pageHeight] = this.pageDimensions;\n    return this.#drawOutlines.serialize([pageX, pageY, pageWidth, pageHeight], isForCopying);\n  }\n  renderAnnotationElement(annotation) {\n    annotation.updateEdited({\n      rect: this.getPDFRect()\n    });\n    return null;\n  }\n  static canCreateNewEmptyEditor() {\n    return false;\n  }\n}\n\n;// ./src/display/editor/drawers/inkdraw.js\n\n\nclass InkDrawOutliner {\n  #last = new Float64Array(6);\n  #line;\n  #lines;\n  #rotation;\n  #thickness;\n  #points;\n  #lastSVGPath = \"\";\n  #lastIndex = 0;\n  #outlines = new InkDrawOutline();\n  #parentWidth;\n  #parentHeight;\n  constructor(x, y, parentWidth, parentHeight, rotation, thickness) {\n    this.#parentWidth = parentWidth;\n    this.#parentHeight = parentHeight;\n    this.#rotation = rotation;\n    this.#thickness = thickness;\n    [x, y] = this.#normalizePoint(x, y);\n    const line = this.#line = [NaN, NaN, NaN, NaN, x, y];\n    this.#points = [x, y];\n    this.#lines = [{\n      line,\n      points: this.#points\n    }];\n    this.#last.set(line, 0);\n  }\n  updateProperty(name, value) {\n    if (name === \"stroke-width\") {\n      this.#thickness = value;\n    }\n  }\n  #normalizePoint(x, y) {\n    return Outline._normalizePoint(x, y, this.#parentWidth, this.#parentHeight, this.#rotation);\n  }\n  isEmpty() {\n    return !this.#lines || this.#lines.length === 0;\n  }\n  isCancellable() {\n    return this.#points.length <= 10;\n  }\n  add(x, y) {\n    [x, y] = this.#normalizePoint(x, y);\n    const [x1, y1, x2, y2] = this.#last.subarray(2, 6);\n    const diffX = x - x2;\n    const diffY = y - y2;\n    const d = Math.hypot(this.#parentWidth * diffX, this.#parentHeight * diffY);\n    if (d <= 2) {\n      return null;\n    }\n    this.#points.push(x, y);\n    if (isNaN(x1)) {\n      this.#last.set([x2, y2, x, y], 2);\n      this.#line.push(NaN, NaN, NaN, NaN, x, y);\n      return {\n        path: {\n          d: this.toSVGPath()\n        }\n      };\n    }\n    if (isNaN(this.#last[0])) {\n      this.#line.splice(6, 6);\n    }\n    this.#last.set([x1, y1, x2, y2, x, y], 0);\n    this.#line.push(...Outline.createBezierPoints(x1, y1, x2, y2, x, y));\n    return {\n      path: {\n        d: this.toSVGPath()\n      }\n    };\n  }\n  end(x, y) {\n    const change = this.add(x, y);\n    if (change) {\n      return change;\n    }\n    if (this.#points.length === 2) {\n      return {\n        path: {\n          d: this.toSVGPath()\n        }\n      };\n    }\n    return null;\n  }\n  startNew(x, y, parentWidth, parentHeight, rotation) {\n    this.#parentWidth = parentWidth;\n    this.#parentHeight = parentHeight;\n    this.#rotation = rotation;\n    [x, y] = this.#normalizePoint(x, y);\n    const line = this.#line = [NaN, NaN, NaN, NaN, x, y];\n    this.#points = [x, y];\n    const last = this.#lines.at(-1);\n    if (last) {\n      last.line = new Float32Array(last.line);\n      last.points = new Float32Array(last.points);\n    }\n    this.#lines.push({\n      line,\n      points: this.#points\n    });\n    this.#last.set(line, 0);\n    this.#lastIndex = 0;\n    this.toSVGPath();\n    return null;\n  }\n  getLastElement() {\n    return this.#lines.at(-1);\n  }\n  setLastElement(element) {\n    if (!this.#lines) {\n      return this.#outlines.setLastElement(element);\n    }\n    this.#lines.push(element);\n    this.#line = element.line;\n    this.#points = element.points;\n    this.#lastIndex = 0;\n    return {\n      path: {\n        d: this.toSVGPath()\n      }\n    };\n  }\n  removeLastElement() {\n    if (!this.#lines) {\n      return this.#outlines.removeLastElement();\n    }\n    this.#lines.pop();\n    this.#lastSVGPath = \"\";\n    for (let i = 0, ii = this.#lines.length; i < ii; i++) {\n      const {\n        line,\n        points\n      } = this.#lines[i];\n      this.#line = line;\n      this.#points = points;\n      this.#lastIndex = 0;\n      this.toSVGPath();\n    }\n    return {\n      path: {\n        d: this.#lastSVGPath\n      }\n    };\n  }\n  toSVGPath() {\n    const firstX = Outline.svgRound(this.#line[4]);\n    const firstY = Outline.svgRound(this.#line[5]);\n    if (this.#points.length === 2) {\n      this.#lastSVGPath = `${this.#lastSVGPath} M ${firstX} ${firstY} Z`;\n      return this.#lastSVGPath;\n    }\n    if (this.#points.length <= 6) {\n      const i = this.#lastSVGPath.lastIndexOf(\"M\");\n      this.#lastSVGPath = `${this.#lastSVGPath.slice(0, i)} M ${firstX} ${firstY}`;\n      this.#lastIndex = 6;\n    }\n    if (this.#points.length === 4) {\n      const secondX = Outline.svgRound(this.#line[10]);\n      const secondY = Outline.svgRound(this.#line[11]);\n      this.#lastSVGPath = `${this.#lastSVGPath} L ${secondX} ${secondY}`;\n      this.#lastIndex = 12;\n      return this.#lastSVGPath;\n    }\n    const buffer = [];\n    if (this.#lastIndex === 0) {\n      buffer.push(`M ${firstX} ${firstY}`);\n      this.#lastIndex = 6;\n    }\n    for (let i = this.#lastIndex, ii = this.#line.length; i < ii; i += 6) {\n      const [c1x, c1y, c2x, c2y, x, y] = this.#line.slice(i, i + 6).map(Outline.svgRound);\n      buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);\n    }\n    this.#lastSVGPath += buffer.join(\" \");\n    this.#lastIndex = this.#line.length;\n    return this.#lastSVGPath;\n  }\n  getOutlines(parentWidth, parentHeight, scale, innerMargin) {\n    const last = this.#lines.at(-1);\n    last.line = new Float32Array(last.line);\n    last.points = new Float32Array(last.points);\n    this.#outlines.build(this.#lines, parentWidth, parentHeight, scale, this.#rotation, this.#thickness, innerMargin);\n    this.#last = null;\n    this.#line = null;\n    this.#lines = null;\n    this.#lastSVGPath = null;\n    return this.#outlines;\n  }\n  get defaultSVGProperties() {\n    return {\n      root: {\n        viewBox: \"0 0 10000 10000\"\n      },\n      rootClass: {\n        draw: true\n      },\n      bbox: [0, 0, 1, 1]\n    };\n  }\n}\nclass InkDrawOutline extends Outline {\n  #bbox;\n  #currentRotation = 0;\n  #innerMargin;\n  #lines;\n  #parentWidth;\n  #parentHeight;\n  #parentScale;\n  #rotation;\n  #thickness;\n  build(lines, parentWidth, parentHeight, parentScale, rotation, thickness, innerMargin) {\n    this.#parentWidth = parentWidth;\n    this.#parentHeight = parentHeight;\n    this.#parentScale = parentScale;\n    this.#rotation = rotation;\n    this.#thickness = thickness;\n    this.#innerMargin = innerMargin ?? 0;\n    this.#lines = lines;\n    this.#computeBbox();\n  }\n  get thickness() {\n    return this.#thickness;\n  }\n  setLastElement(element) {\n    this.#lines.push(element);\n    return {\n      path: {\n        d: this.toSVGPath()\n      }\n    };\n  }\n  removeLastElement() {\n    this.#lines.pop();\n    return {\n      path: {\n        d: this.toSVGPath()\n      }\n    };\n  }\n  toSVGPath() {\n    const buffer = [];\n    for (const {\n      line\n    } of this.#lines) {\n      buffer.push(`M${Outline.svgRound(line[4])} ${Outline.svgRound(line[5])}`);\n      if (line.length === 6) {\n        buffer.push(\"Z\");\n        continue;\n      }\n      if (line.length === 12 && isNaN(line[6])) {\n        buffer.push(`L${Outline.svgRound(line[10])} ${Outline.svgRound(line[11])}`);\n        continue;\n      }\n      for (let i = 6, ii = line.length; i < ii; i += 6) {\n        const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6).map(Outline.svgRound);\n        buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);\n      }\n    }\n    return buffer.join(\"\");\n  }\n  serialize([pageX, pageY, pageWidth, pageHeight], isForCopying) {\n    const serializedLines = [];\n    const serializedPoints = [];\n    const [x, y, width, height] = this.#getBBoxWithNoMargin();\n    let tx, ty, sx, sy, x1, y1, x2, y2, rescaleFn;\n    switch (this.#rotation) {\n      case 0:\n        rescaleFn = Outline._rescale;\n        tx = pageX;\n        ty = pageY + pageHeight;\n        sx = pageWidth;\n        sy = -pageHeight;\n        x1 = pageX + x * pageWidth;\n        y1 = pageY + (1 - y - height) * pageHeight;\n        x2 = pageX + (x + width) * pageWidth;\n        y2 = pageY + (1 - y) * pageHeight;\n        break;\n      case 90:\n        rescaleFn = Outline._rescaleAndSwap;\n        tx = pageX;\n        ty = pageY;\n        sx = pageWidth;\n        sy = pageHeight;\n        x1 = pageX + y * pageWidth;\n        y1 = pageY + x * pageHeight;\n        x2 = pageX + (y + height) * pageWidth;\n        y2 = pageY + (x + width) * pageHeight;\n        break;\n      case 180:\n        rescaleFn = Outline._rescale;\n        tx = pageX + pageWidth;\n        ty = pageY;\n        sx = -pageWidth;\n        sy = pageHeight;\n        x1 = pageX + (1 - x - width) * pageWidth;\n        y1 = pageY + y * pageHeight;\n        x2 = pageX + (1 - x) * pageWidth;\n        y2 = pageY + (y + height) * pageHeight;\n        break;\n      case 270:\n        rescaleFn = Outline._rescaleAndSwap;\n        tx = pageX + pageWidth;\n        ty = pageY + pageHeight;\n        sx = -pageWidth;\n        sy = -pageHeight;\n        x1 = pageX + (1 - y - height) * pageWidth;\n        y1 = pageY + (1 - x - width) * pageHeight;\n        x2 = pageX + (1 - y) * pageWidth;\n        y2 = pageY + (1 - x) * pageHeight;\n        break;\n    }\n    for (const {\n      line,\n      points\n    } of this.#lines) {\n      serializedLines.push(rescaleFn(line, tx, ty, sx, sy, isForCopying ? new Array(line.length) : null));\n      serializedPoints.push(rescaleFn(points, tx, ty, sx, sy, isForCopying ? new Array(points.length) : null));\n    }\n    return {\n      lines: serializedLines,\n      points: serializedPoints,\n      rect: [x1, y1, x2, y2]\n    };\n  }\n  static deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, {\n    paths: {\n      lines,\n      points\n    },\n    rotation,\n    thickness\n  }) {\n    const newLines = [];\n    let tx, ty, sx, sy, rescaleFn;\n    switch (rotation) {\n      case 0:\n        rescaleFn = Outline._rescale;\n        tx = -pageX / pageWidth;\n        ty = pageY / pageHeight + 1;\n        sx = 1 / pageWidth;\n        sy = -1 / pageHeight;\n        break;\n      case 90:\n        rescaleFn = Outline._rescaleAndSwap;\n        tx = -pageY / pageHeight;\n        ty = -pageX / pageWidth;\n        sx = 1 / pageHeight;\n        sy = 1 / pageWidth;\n        break;\n      case 180:\n        rescaleFn = Outline._rescale;\n        tx = pageX / pageWidth + 1;\n        ty = -pageY / pageHeight;\n        sx = -1 / pageWidth;\n        sy = 1 / pageHeight;\n        break;\n      case 270:\n        rescaleFn = Outline._rescaleAndSwap;\n        tx = pageY / pageHeight + 1;\n        ty = pageX / pageWidth + 1;\n        sx = -1 / pageHeight;\n        sy = -1 / pageWidth;\n        break;\n    }\n    if (!lines) {\n      lines = [];\n      for (const point of points) {\n        const len = point.length;\n        if (len === 2) {\n          lines.push(new Float32Array([NaN, NaN, NaN, NaN, point[0], point[1]]));\n          continue;\n        }\n        if (len === 4) {\n          lines.push(new Float32Array([NaN, NaN, NaN, NaN, point[0], point[1], NaN, NaN, NaN, NaN, point[2], point[3]]));\n          continue;\n        }\n        const line = new Float32Array(3 * (len - 2));\n        lines.push(line);\n        let [x1, y1, x2, y2] = point.subarray(0, 4);\n        line.set([NaN, NaN, NaN, NaN, x1, y1], 0);\n        for (let i = 4; i < len; i += 2) {\n          const x = point[i];\n          const y = point[i + 1];\n          line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);\n          [x1, y1, x2, y2] = [x2, y2, x, y];\n        }\n      }\n    }\n    for (let i = 0, ii = lines.length; i < ii; i++) {\n      newLines.push({\n        line: rescaleFn(lines[i].map(x => x ?? NaN), tx, ty, sx, sy),\n        points: rescaleFn(points[i].map(x => x ?? NaN), tx, ty, sx, sy)\n      });\n    }\n    const outlines = new this.prototype.constructor();\n    outlines.build(newLines, pageWidth, pageHeight, 1, rotation, thickness, innerMargin);\n    return outlines;\n  }\n  #getMarginComponents(thickness = this.#thickness) {\n    const margin = this.#innerMargin + thickness / 2 * this.#parentScale;\n    return this.#rotation % 180 === 0 ? [margin / this.#parentWidth, margin / this.#parentHeight] : [margin / this.#parentHeight, margin / this.#parentWidth];\n  }\n  #getBBoxWithNoMargin() {\n    const [x, y, width, height] = this.#bbox;\n    const [marginX, marginY] = this.#getMarginComponents(0);\n    return [x + marginX, y + marginY, width - 2 * marginX, height - 2 * marginY];\n  }\n  #computeBbox() {\n    const bbox = this.#bbox = new Float32Array([Infinity, Infinity, -Infinity, -Infinity]);\n    for (const {\n      line\n    } of this.#lines) {\n      if (line.length <= 12) {\n        for (let i = 4, ii = line.length; i < ii; i += 6) {\n          Util.pointBoundingBox(line[i], line[i + 1], bbox);\n        }\n        continue;\n      }\n      let lastX = line[4],\n        lastY = line[5];\n      for (let i = 6, ii = line.length; i < ii; i += 6) {\n        const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6);\n        Util.bezierBoundingBox(lastX, lastY, c1x, c1y, c2x, c2y, x, y, bbox);\n        lastX = x;\n        lastY = y;\n      }\n    }\n    const [marginX, marginY] = this.#getMarginComponents();\n    bbox[0] = MathClamp(bbox[0] - marginX, 0, 1);\n    bbox[1] = MathClamp(bbox[1] - marginY, 0, 1);\n    bbox[2] = MathClamp(bbox[2] + marginX, 0, 1);\n    bbox[3] = MathClamp(bbox[3] + marginY, 0, 1);\n    bbox[2] -= bbox[0];\n    bbox[3] -= bbox[1];\n  }\n  get box() {\n    return this.#bbox;\n  }\n  updateProperty(name, value) {\n    if (name === \"stroke-width\") {\n      return this.#updateThickness(value);\n    }\n    return null;\n  }\n  #updateThickness(thickness) {\n    const [oldMarginX, oldMarginY] = this.#getMarginComponents();\n    this.#thickness = thickness;\n    const [newMarginX, newMarginY] = this.#getMarginComponents();\n    const [diffMarginX, diffMarginY] = [newMarginX - oldMarginX, newMarginY - oldMarginY];\n    const bbox = this.#bbox;\n    bbox[0] -= diffMarginX;\n    bbox[1] -= diffMarginY;\n    bbox[2] += 2 * diffMarginX;\n    bbox[3] += 2 * diffMarginY;\n    return bbox;\n  }\n  updateParentDimensions([width, height], scale) {\n    const [oldMarginX, oldMarginY] = this.#getMarginComponents();\n    this.#parentWidth = width;\n    this.#parentHeight = height;\n    this.#parentScale = scale;\n    const [newMarginX, newMarginY] = this.#getMarginComponents();\n    const diffMarginX = newMarginX - oldMarginX;\n    const diffMarginY = newMarginY - oldMarginY;\n    const bbox = this.#bbox;\n    bbox[0] -= diffMarginX;\n    bbox[1] -= diffMarginY;\n    bbox[2] += 2 * diffMarginX;\n    bbox[3] += 2 * diffMarginY;\n    return bbox;\n  }\n  updateRotation(rotation) {\n    this.#currentRotation = rotation;\n    return {\n      path: {\n        transform: this.rotationTransform\n      }\n    };\n  }\n  get viewBox() {\n    return this.#bbox.map(Outline.svgRound).join(\" \");\n  }\n  get defaultProperties() {\n    const [x, y] = this.#bbox;\n    return {\n      root: {\n        viewBox: this.viewBox\n      },\n      path: {\n        \"transform-origin\": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`\n      }\n    };\n  }\n  get rotationTransform() {\n    const [,, width, height] = this.#bbox;\n    let a = 0,\n      b = 0,\n      c = 0,\n      d = 0,\n      e = 0,\n      f = 0;\n    switch (this.#currentRotation) {\n      case 90:\n        b = height / width;\n        c = -width / height;\n        e = width;\n        break;\n      case 180:\n        a = -1;\n        d = -1;\n        e = width;\n        f = height;\n        break;\n      case 270:\n        b = -height / width;\n        c = width / height;\n        f = height;\n        break;\n      default:\n        return \"\";\n    }\n    return `matrix(${a} ${b} ${c} ${d} ${Outline.svgRound(e)} ${Outline.svgRound(f)})`;\n  }\n  getPathResizingSVGProperties([newX, newY, newWidth, newHeight]) {\n    const [marginX, marginY] = this.#getMarginComponents();\n    const [x, y, width, height] = this.#bbox;\n    if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {\n      const tx = newX + newWidth / 2 - (x + width / 2);\n      const ty = newY + newHeight / 2 - (y + height / 2);\n      return {\n        path: {\n          \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n          transform: `${this.rotationTransform} translate(${tx} ${ty})`\n        }\n      };\n    }\n    const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);\n    const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);\n    const s2x = width / newWidth;\n    const s2y = height / newHeight;\n    return {\n      path: {\n        \"transform-origin\": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`,\n        transform: `${this.rotationTransform} scale(${s2x} ${s2y}) ` + `translate(${Outline.svgRound(marginX)} ${Outline.svgRound(marginY)}) scale(${s1x} ${s1y}) ` + `translate(${Outline.svgRound(-marginX)} ${Outline.svgRound(-marginY)})`\n      }\n    };\n  }\n  getPathResizedSVGProperties([newX, newY, newWidth, newHeight]) {\n    const [marginX, marginY] = this.#getMarginComponents();\n    const bbox = this.#bbox;\n    const [x, y, width, height] = bbox;\n    bbox[0] = newX;\n    bbox[1] = newY;\n    bbox[2] = newWidth;\n    bbox[3] = newHeight;\n    if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {\n      const tx = newX + newWidth / 2 - (x + width / 2);\n      const ty = newY + newHeight / 2 - (y + height / 2);\n      for (const {\n        line,\n        points\n      } of this.#lines) {\n        Outline._translate(line, tx, ty, line);\n        Outline._translate(points, tx, ty, points);\n      }\n      return {\n        root: {\n          viewBox: this.viewBox\n        },\n        path: {\n          \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n          transform: this.rotationTransform || null,\n          d: this.toSVGPath()\n        }\n      };\n    }\n    const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);\n    const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);\n    const tx = -s1x * (x + marginX) + newX + marginX;\n    const ty = -s1y * (y + marginY) + newY + marginY;\n    if (s1x !== 1 || s1y !== 1 || tx !== 0 || ty !== 0) {\n      for (const {\n        line,\n        points\n      } of this.#lines) {\n        Outline._rescale(line, tx, ty, s1x, s1y, line);\n        Outline._rescale(points, tx, ty, s1x, s1y, points);\n      }\n    }\n    return {\n      root: {\n        viewBox: this.viewBox\n      },\n      path: {\n        \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n        transform: this.rotationTransform || null,\n        d: this.toSVGPath()\n      }\n    };\n  }\n  getPathTranslatedSVGProperties([newX, newY], parentDimensions) {\n    const [newParentWidth, newParentHeight] = parentDimensions;\n    const bbox = this.#bbox;\n    const tx = newX - bbox[0];\n    const ty = newY - bbox[1];\n    if (this.#parentWidth === newParentWidth && this.#parentHeight === newParentHeight) {\n      for (const {\n        line,\n        points\n      } of this.#lines) {\n        Outline._translate(line, tx, ty, line);\n        Outline._translate(points, tx, ty, points);\n      }\n    } else {\n      const sx = this.#parentWidth / newParentWidth;\n      const sy = this.#parentHeight / newParentHeight;\n      this.#parentWidth = newParentWidth;\n      this.#parentHeight = newParentHeight;\n      for (const {\n        line,\n        points\n      } of this.#lines) {\n        Outline._rescale(line, tx, ty, sx, sy, line);\n        Outline._rescale(points, tx, ty, sx, sy, points);\n      }\n      bbox[2] *= sx;\n      bbox[3] *= sy;\n    }\n    bbox[0] = newX;\n    bbox[1] = newY;\n    return {\n      root: {\n        viewBox: this.viewBox\n      },\n      path: {\n        d: this.toSVGPath(),\n        \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`\n      }\n    };\n  }\n  get defaultSVGProperties() {\n    const bbox = this.#bbox;\n    return {\n      root: {\n        viewBox: this.viewBox\n      },\n      rootClass: {\n        draw: true\n      },\n      path: {\n        d: this.toSVGPath(),\n        \"transform-origin\": `${Outline.svgRound(bbox[0])} ${Outline.svgRound(bbox[1])}`,\n        transform: this.rotationTransform || null\n      },\n      bbox\n    };\n  }\n}\n\n;// ./src/display/editor/ink.js\n\n\n\n\n\n\nclass InkDrawingOptions extends DrawingOptions {\n  constructor(viewerParameters) {\n    super();\n    this._viewParameters = viewerParameters;\n    super.updateProperties({\n      fill: \"none\",\n      stroke: AnnotationEditor._defaultLineColor,\n      \"stroke-opacity\": 1,\n      \"stroke-width\": 1,\n      \"stroke-linecap\": \"round\",\n      \"stroke-linejoin\": \"round\",\n      \"stroke-miterlimit\": 10\n    });\n  }\n  updateSVGProperty(name, value) {\n    if (name === \"stroke-width\") {\n      value ??= this[\"stroke-width\"];\n      value *= this._viewParameters.realScale;\n    }\n    super.updateSVGProperty(name, value);\n  }\n  clone() {\n    const clone = new InkDrawingOptions(this._viewParameters);\n    clone.updateAll(this);\n    return clone;\n  }\n}\nclass InkEditor extends DrawingEditor {\n  static _type = \"ink\";\n  static _editorType = AnnotationEditorType.INK;\n  static _defaultDrawingOptions = null;\n  constructor(params) {\n    super({\n      ...params,\n      name: \"inkEditor\"\n    });\n    this._willKeepAspectRatio = true;\n    this.defaultL10nId = \"pdfjs-editor-ink-editor\";\n  }\n  static initialize(l10n, uiManager) {\n    AnnotationEditor.initialize(l10n, uiManager);\n    this._defaultDrawingOptions = new InkDrawingOptions(uiManager.viewParameters);\n  }\n  static getDefaultDrawingOptions(options) {\n    const clone = this._defaultDrawingOptions.clone();\n    clone.updateProperties(options);\n    return clone;\n  }\n  static get supportMultipleDrawings() {\n    return true;\n  }\n  static get typesMap() {\n    return shadow(this, \"typesMap\", new Map([[AnnotationEditorParamsType.INK_THICKNESS, \"stroke-width\"], [AnnotationEditorParamsType.INK_COLOR, \"stroke\"], [AnnotationEditorParamsType.INK_OPACITY, \"stroke-opacity\"]]));\n  }\n  static createDrawerInstance(x, y, parentWidth, parentHeight, rotation) {\n    return new InkDrawOutliner(x, y, parentWidth, parentHeight, rotation, this._defaultDrawingOptions[\"stroke-width\"]);\n  }\n  static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {\n    return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);\n  }\n  static async deserialize(data, parent, uiManager) {\n    let initialData = null;\n    if (data instanceof InkAnnotationElement) {\n      const {\n        data: {\n          inkLists,\n          rect,\n          rotation,\n          id,\n          color,\n          opacity,\n          borderStyle: {\n            rawWidth: thickness\n          },\n          popupRef,\n          contentsObj\n        },\n        parent: {\n          page: {\n            pageNumber\n          }\n        }\n      } = data;\n      initialData = data = {\n        annotationType: AnnotationEditorType.INK,\n        color: Array.from(color),\n        thickness,\n        opacity,\n        paths: {\n          points: inkLists\n        },\n        boxes: null,\n        pageIndex: pageNumber - 1,\n        rect: rect.slice(0),\n        rotation,\n        annotationElementId: id,\n        id,\n        deleted: false,\n        popupRef,\n        comment: contentsObj?.str || null\n      };\n    }\n    const editor = await super.deserialize(data, parent, uiManager);\n    editor._initialData = initialData;\n    if (data.comment) {\n      editor.setCommentData(data.comment);\n    }\n    return editor;\n  }\n  get toolbarButtons() {\n    this._colorPicker ||= new BasicColorPicker(this);\n    return [[\"colorPicker\", this._colorPicker]];\n  }\n  get colorType() {\n    return AnnotationEditorParamsType.INK_COLOR;\n  }\n  get colorValue() {\n    return this._drawingOptions.stroke;\n  }\n  onScaleChanging() {\n    if (!this.parent) {\n      return;\n    }\n    super.onScaleChanging();\n    const {\n      _drawId,\n      _drawingOptions,\n      parent\n    } = this;\n    _drawingOptions.updateSVGProperty(\"stroke-width\");\n    parent.drawLayer.updateProperties(_drawId, _drawingOptions.toSVGProperties());\n  }\n  static onScaleChangingWhenDrawing() {\n    const parent = this._currentParent;\n    if (!parent) {\n      return;\n    }\n    super.onScaleChangingWhenDrawing();\n    this._defaultDrawingOptions.updateSVGProperty(\"stroke-width\");\n    parent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());\n  }\n  createDrawingOptions({\n    color,\n    thickness,\n    opacity\n  }) {\n    this._drawingOptions = InkEditor.getDefaultDrawingOptions({\n      stroke: Util.makeHexColor(...color),\n      \"stroke-width\": thickness,\n      \"stroke-opacity\": opacity\n    });\n  }\n  serialize(isForCopying = false) {\n    if (this.isEmpty()) {\n      return null;\n    }\n    if (this.deleted) {\n      return this.serializeDeleted();\n    }\n    const {\n      lines,\n      points,\n      rect\n    } = this.serializeDraw(isForCopying);\n    const {\n      _drawingOptions: {\n        stroke,\n        \"stroke-opacity\": opacity,\n        \"stroke-width\": thickness\n      }\n    } = this;\n    const serialized = {\n      annotationType: AnnotationEditorType.INK,\n      color: AnnotationEditor._colorManager.convert(stroke),\n      opacity,\n      thickness,\n      paths: {\n        lines,\n        points\n      },\n      pageIndex: this.pageIndex,\n      rect,\n      rotation: this.rotation,\n      structTreeParentId: this._structTreeParentId\n    };\n    this.addComment(serialized);\n    if (isForCopying) {\n      serialized.isCopy = true;\n      return serialized;\n    }\n    if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n      return null;\n    }\n    serialized.id = this.annotationElementId;\n    return serialized;\n  }\n  #hasElementChanged(serialized) {\n    const {\n      color,\n      thickness,\n      opacity,\n      pageIndex\n    } = this._initialData;\n    return this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized || serialized.color.some((c, i) => c !== color[i]) || serialized.thickness !== thickness || serialized.opacity !== opacity || serialized.pageIndex !== pageIndex;\n  }\n  renderAnnotationElement(annotation) {\n    if (this.deleted) {\n      annotation.hide();\n      return null;\n    }\n    const {\n      points,\n      rect\n    } = this.serializeDraw(false);\n    const params = {\n      rect,\n      thickness: this._drawingOptions[\"stroke-width\"],\n      points\n    };\n    if (this.hasEditedComment) {\n      params.popup = this.comment;\n    }\n    annotation.updateEdited(params);\n    return null;\n  }\n}\n\n;// ./src/display/editor/drawers/contour.js\n\nclass ContourDrawOutline extends InkDrawOutline {\n  toSVGPath() {\n    let path = super.toSVGPath();\n    if (!path.endsWith(\"Z\")) {\n      path += \"Z\";\n    }\n    return path;\n  }\n}\n\n;// ./src/display/editor/drawers/signaturedraw.js\n\n\n\n\nconst BASE_HEADER_LENGTH = 8;\nconst POINTS_PROPERTIES_NUMBER = 3;\nclass SignatureExtractor {\n  static #PARAMETERS = {\n    maxDim: 512,\n    sigmaSFactor: 0.02,\n    sigmaR: 25,\n    kernelSize: 16\n  };\n  static #neighborIndexToId(i0, j0, i, j) {\n    i -= i0;\n    j -= j0;\n    if (i === 0) {\n      return j > 0 ? 0 : 4;\n    }\n    if (i === 1) {\n      return j + 6;\n    }\n    return 2 - j;\n  }\n  static #neighborIdToIndex = new Int32Array([0, 1, -1, 1, -1, 0, -1, -1, 0, -1, 1, -1, 1, 0, 1, 1]);\n  static #clockwiseNonZero(buf, width, i0, j0, i, j, offset) {\n    const id = this.#neighborIndexToId(i0, j0, i, j);\n    for (let k = 0; k < 8; k++) {\n      const kk = (-k + id - offset + 16) % 8;\n      const shiftI = this.#neighborIdToIndex[2 * kk];\n      const shiftJ = this.#neighborIdToIndex[2 * kk + 1];\n      if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {\n        return kk;\n      }\n    }\n    return -1;\n  }\n  static #counterClockwiseNonZero(buf, width, i0, j0, i, j, offset) {\n    const id = this.#neighborIndexToId(i0, j0, i, j);\n    for (let k = 0; k < 8; k++) {\n      const kk = (k + id + offset + 16) % 8;\n      const shiftI = this.#neighborIdToIndex[2 * kk];\n      const shiftJ = this.#neighborIdToIndex[2 * kk + 1];\n      if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {\n        return kk;\n      }\n    }\n    return -1;\n  }\n  static #findContours(buf, width, height, threshold) {\n    const N = buf.length;\n    const types = new Int32Array(N);\n    for (let i = 0; i < N; i++) {\n      types[i] = buf[i] <= threshold ? 1 : 0;\n    }\n    for (let i = 1; i < height - 1; i++) {\n      types[i * width] = types[i * width + width - 1] = 0;\n    }\n    for (let i = 0; i < width; i++) {\n      types[i] = types[width * height - 1 - i] = 0;\n    }\n    let nbd = 1;\n    let lnbd;\n    const contours = [];\n    for (let i = 1; i < height - 1; i++) {\n      lnbd = 1;\n      for (let j = 1; j < width - 1; j++) {\n        const ij = i * width + j;\n        const pix = types[ij];\n        if (pix === 0) {\n          continue;\n        }\n        let i2 = i;\n        let j2 = j;\n        if (pix === 1 && types[ij - 1] === 0) {\n          nbd += 1;\n          j2 -= 1;\n        } else if (pix >= 1 && types[ij + 1] === 0) {\n          nbd += 1;\n          j2 += 1;\n          if (pix > 1) {\n            lnbd = pix;\n          }\n        } else {\n          if (pix !== 1) {\n            lnbd = Math.abs(pix);\n          }\n          continue;\n        }\n        const points = [j, i];\n        const isHole = j2 === j + 1;\n        const contour = {\n          isHole,\n          points,\n          id: nbd,\n          parent: 0\n        };\n        contours.push(contour);\n        let contour0;\n        for (const c of contours) {\n          if (c.id === lnbd) {\n            contour0 = c;\n            break;\n          }\n        }\n        if (!contour0) {\n          contour.parent = isHole ? lnbd : 0;\n        } else if (contour0.isHole) {\n          contour.parent = isHole ? contour0.parent : lnbd;\n        } else {\n          contour.parent = isHole ? lnbd : contour0.parent;\n        }\n        const k = this.#clockwiseNonZero(types, width, i, j, i2, j2, 0);\n        if (k === -1) {\n          types[ij] = -nbd;\n          if (types[ij] !== 1) {\n            lnbd = Math.abs(types[ij]);\n          }\n          continue;\n        }\n        let shiftI = this.#neighborIdToIndex[2 * k];\n        let shiftJ = this.#neighborIdToIndex[2 * k + 1];\n        const i1 = i + shiftI;\n        const j1 = j + shiftJ;\n        i2 = i1;\n        j2 = j1;\n        let i3 = i;\n        let j3 = j;\n        while (true) {\n          const kk = this.#counterClockwiseNonZero(types, width, i3, j3, i2, j2, 1);\n          shiftI = this.#neighborIdToIndex[2 * kk];\n          shiftJ = this.#neighborIdToIndex[2 * kk + 1];\n          const i4 = i3 + shiftI;\n          const j4 = j3 + shiftJ;\n          points.push(j4, i4);\n          const ij3 = i3 * width + j3;\n          if (types[ij3 + 1] === 0) {\n            types[ij3] = -nbd;\n          } else if (types[ij3] === 1) {\n            types[ij3] = nbd;\n          }\n          if (i4 === i && j4 === j && i3 === i1 && j3 === j1) {\n            if (types[ij] !== 1) {\n              lnbd = Math.abs(types[ij]);\n            }\n            break;\n          } else {\n            i2 = i3;\n            j2 = j3;\n            i3 = i4;\n            j3 = j4;\n          }\n        }\n      }\n    }\n    return contours;\n  }\n  static #douglasPeuckerHelper(points, start, end, output) {\n    if (end - start <= 4) {\n      for (let i = start; i < end - 2; i += 2) {\n        output.push(points[i], points[i + 1]);\n      }\n      return;\n    }\n    const ax = points[start];\n    const ay = points[start + 1];\n    const abx = points[end - 4] - ax;\n    const aby = points[end - 3] - ay;\n    const dist = Math.hypot(abx, aby);\n    const nabx = abx / dist;\n    const naby = aby / dist;\n    const aa = nabx * ay - naby * ax;\n    const m = aby / abx;\n    const invS = 1 / dist;\n    const phi = Math.atan(m);\n    const cosPhi = Math.cos(phi);\n    const sinPhi = Math.sin(phi);\n    const tmax = invS * (Math.abs(cosPhi) + Math.abs(sinPhi));\n    const poly = invS * (1 - tmax + tmax ** 2);\n    const partialPhi = Math.max(Math.atan(Math.abs(sinPhi + cosPhi) * poly), Math.atan(Math.abs(sinPhi - cosPhi) * poly));\n    let dmax = 0;\n    let index = start;\n    for (let i = start + 2; i < end - 2; i += 2) {\n      const d = Math.abs(aa - nabx * points[i + 1] + naby * points[i]);\n      if (d > dmax) {\n        index = i;\n        dmax = d;\n      }\n    }\n    if (dmax > (dist * partialPhi) ** 2) {\n      this.#douglasPeuckerHelper(points, start, index + 2, output);\n      this.#douglasPeuckerHelper(points, index, end, output);\n    } else {\n      output.push(ax, ay);\n    }\n  }\n  static #douglasPeucker(points) {\n    const output = [];\n    const len = points.length;\n    this.#douglasPeuckerHelper(points, 0, len, output);\n    output.push(points[len - 2], points[len - 1]);\n    return output.length <= 4 ? null : output;\n  }\n  static #bilateralFilter(buf, width, height, sigmaS, sigmaR, kernelSize) {\n    const kernel = new Float32Array(kernelSize ** 2);\n    const sigmaS2 = -2 * sigmaS ** 2;\n    const halfSize = kernelSize >> 1;\n    for (let i = 0; i < kernelSize; i++) {\n      const x = (i - halfSize) ** 2;\n      for (let j = 0; j < kernelSize; j++) {\n        kernel[i * kernelSize + j] = Math.exp((x + (j - halfSize) ** 2) / sigmaS2);\n      }\n    }\n    const rangeValues = new Float32Array(256);\n    const sigmaR2 = -2 * sigmaR ** 2;\n    for (let i = 0; i < 256; i++) {\n      rangeValues[i] = Math.exp(i ** 2 / sigmaR2);\n    }\n    const N = buf.length;\n    const out = new Uint8Array(N);\n    const histogram = new Uint32Array(256);\n    for (let i = 0; i < height; i++) {\n      for (let j = 0; j < width; j++) {\n        const ij = i * width + j;\n        const center = buf[ij];\n        let sum = 0;\n        let norm = 0;\n        for (let k = 0; k < kernelSize; k++) {\n          const y = i + k - halfSize;\n          if (y < 0 || y >= height) {\n            continue;\n          }\n          for (let l = 0; l < kernelSize; l++) {\n            const x = j + l - halfSize;\n            if (x < 0 || x >= width) {\n              continue;\n            }\n            const neighbour = buf[y * width + x];\n            const w = kernel[k * kernelSize + l] * rangeValues[Math.abs(neighbour - center)];\n            sum += neighbour * w;\n            norm += w;\n          }\n        }\n        const pix = out[ij] = Math.round(sum / norm);\n        histogram[pix]++;\n      }\n    }\n    return [out, histogram];\n  }\n  static #getHistogram(buf) {\n    const histogram = new Uint32Array(256);\n    for (const g of buf) {\n      histogram[g]++;\n    }\n    return histogram;\n  }\n  static #toUint8(buf) {\n    const N = buf.length;\n    const out = new Uint8ClampedArray(N >> 2);\n    let max = -Infinity;\n    let min = Infinity;\n    for (let i = 0, ii = out.length; i < ii; i++) {\n      const pix = out[i] = buf[i << 2];\n      max = Math.max(max, pix);\n      min = Math.min(min, pix);\n    }\n    const ratio = 255 / (max - min);\n    for (let i = 0, ii = out.length; i < ii; i++) {\n      out[i] = (out[i] - min) * ratio;\n    }\n    return out;\n  }\n  static #guessThreshold(histogram) {\n    let i;\n    let M = -Infinity;\n    let L = -Infinity;\n    const min = histogram.findIndex(v => v !== 0);\n    let pos = min;\n    let spos = min;\n    for (i = min; i < 256; i++) {\n      const v = histogram[i];\n      if (v > M) {\n        if (i - pos > L) {\n          L = i - pos;\n          spos = i - 1;\n        }\n        M = v;\n        pos = i;\n      }\n    }\n    for (i = spos - 1; i >= 0; i--) {\n      if (histogram[i] > histogram[i + 1]) {\n        break;\n      }\n    }\n    return i;\n  }\n  static #getGrayPixels(bitmap) {\n    const originalBitmap = bitmap;\n    const {\n      width,\n      height\n    } = bitmap;\n    const {\n      maxDim\n    } = this.#PARAMETERS;\n    let newWidth = width;\n    let newHeight = height;\n    if (width > maxDim || height > maxDim) {\n      let prevWidth = width;\n      let prevHeight = height;\n      let steps = Math.log2(Math.max(width, height) / maxDim);\n      const isteps = Math.floor(steps);\n      steps = steps === isteps ? isteps - 1 : isteps;\n      for (let i = 0; i < steps; i++) {\n        newWidth = Math.ceil(prevWidth / 2);\n        newHeight = Math.ceil(prevHeight / 2);\n        const offscreen = new OffscreenCanvas(newWidth, newHeight);\n        const ctx = offscreen.getContext(\"2d\");\n        ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);\n        prevWidth = newWidth;\n        prevHeight = newHeight;\n        if (bitmap !== originalBitmap) {\n          bitmap.close();\n        }\n        bitmap = offscreen.transferToImageBitmap();\n      }\n      const ratio = Math.min(maxDim / newWidth, maxDim / newHeight);\n      newWidth = Math.round(newWidth * ratio);\n      newHeight = Math.round(newHeight * ratio);\n    }\n    const offscreen = new OffscreenCanvas(newWidth, newHeight);\n    const ctx = offscreen.getContext(\"2d\", {\n      willReadFrequently: true\n    });\n    ctx.fillStyle = \"white\";\n    ctx.fillRect(0, 0, newWidth, newHeight);\n    ctx.filter = \"grayscale(1)\";\n    ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, newWidth, newHeight);\n    const grayImage = ctx.getImageData(0, 0, newWidth, newHeight).data;\n    const uint8Buf = this.#toUint8(grayImage);\n    return [uint8Buf, newWidth, newHeight];\n  }\n  static extractContoursFromText(text, {\n    fontFamily,\n    fontStyle,\n    fontWeight\n  }, pageWidth, pageHeight, rotation, innerMargin) {\n    let canvas = new OffscreenCanvas(1, 1);\n    let ctx = canvas.getContext(\"2d\", {\n      alpha: false\n    });\n    const fontSize = 200;\n    const font = ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;\n    const {\n      actualBoundingBoxLeft,\n      actualBoundingBoxRight,\n      actualBoundingBoxAscent,\n      actualBoundingBoxDescent,\n      fontBoundingBoxAscent,\n      fontBoundingBoxDescent,\n      width\n    } = ctx.measureText(text);\n    const SCALE = 1.5;\n    const canvasWidth = Math.ceil(Math.max(Math.abs(actualBoundingBoxLeft) + Math.abs(actualBoundingBoxRight) || 0, width) * SCALE);\n    const canvasHeight = Math.ceil(Math.max(Math.abs(actualBoundingBoxAscent) + Math.abs(actualBoundingBoxDescent) || fontSize, Math.abs(fontBoundingBoxAscent) + Math.abs(fontBoundingBoxDescent) || fontSize) * SCALE);\n    canvas = new OffscreenCanvas(canvasWidth, canvasHeight);\n    ctx = canvas.getContext(\"2d\", {\n      alpha: true,\n      willReadFrequently: true\n    });\n    ctx.font = font;\n    ctx.filter = \"grayscale(1)\";\n    ctx.fillStyle = \"white\";\n    ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n    ctx.fillStyle = \"black\";\n    ctx.fillText(text, canvasWidth * (SCALE - 1) / 2, canvasHeight * (3 - SCALE) / 2);\n    const uint8Buf = this.#toUint8(ctx.getImageData(0, 0, canvasWidth, canvasHeight).data);\n    const histogram = this.#getHistogram(uint8Buf);\n    const threshold = this.#guessThreshold(histogram);\n    const contourList = this.#findContours(uint8Buf, canvasWidth, canvasHeight, threshold);\n    return this.processDrawnLines({\n      lines: {\n        curves: contourList,\n        width: canvasWidth,\n        height: canvasHeight\n      },\n      pageWidth,\n      pageHeight,\n      rotation,\n      innerMargin,\n      mustSmooth: true,\n      areContours: true\n    });\n  }\n  static process(bitmap, pageWidth, pageHeight, rotation, innerMargin) {\n    const [uint8Buf, width, height] = this.#getGrayPixels(bitmap);\n    const [buffer, histogram] = this.#bilateralFilter(uint8Buf, width, height, Math.hypot(width, height) * this.#PARAMETERS.sigmaSFactor, this.#PARAMETERS.sigmaR, this.#PARAMETERS.kernelSize);\n    const threshold = this.#guessThreshold(histogram);\n    const contourList = this.#findContours(buffer, width, height, threshold);\n    return this.processDrawnLines({\n      lines: {\n        curves: contourList,\n        width,\n        height\n      },\n      pageWidth,\n      pageHeight,\n      rotation,\n      innerMargin,\n      mustSmooth: true,\n      areContours: true\n    });\n  }\n  static processDrawnLines({\n    lines,\n    pageWidth,\n    pageHeight,\n    rotation,\n    innerMargin,\n    mustSmooth,\n    areContours\n  }) {\n    if (rotation % 180 !== 0) {\n      [pageWidth, pageHeight] = [pageHeight, pageWidth];\n    }\n    const {\n      curves,\n      width,\n      height\n    } = lines;\n    const thickness = lines.thickness ?? 0;\n    const linesAndPoints = [];\n    const ratio = Math.min(pageWidth / width, pageHeight / height);\n    const xScale = ratio / pageWidth;\n    const yScale = ratio / pageHeight;\n    const newCurves = [];\n    for (const {\n      points\n    } of curves) {\n      const reducedPoints = mustSmooth ? this.#douglasPeucker(points) : points;\n      if (!reducedPoints) {\n        continue;\n      }\n      newCurves.push(reducedPoints);\n      const len = reducedPoints.length;\n      const newPoints = new Float32Array(len);\n      const line = new Float32Array(3 * (len === 2 ? 2 : len - 2));\n      linesAndPoints.push({\n        line,\n        points: newPoints\n      });\n      if (len === 2) {\n        newPoints[0] = reducedPoints[0] * xScale;\n        newPoints[1] = reducedPoints[1] * yScale;\n        line.set([NaN, NaN, NaN, NaN, newPoints[0], newPoints[1]], 0);\n        continue;\n      }\n      let [x1, y1, x2, y2] = reducedPoints;\n      x1 *= xScale;\n      y1 *= yScale;\n      x2 *= xScale;\n      y2 *= yScale;\n      newPoints.set([x1, y1, x2, y2], 0);\n      line.set([NaN, NaN, NaN, NaN, x1, y1], 0);\n      for (let i = 4; i < len; i += 2) {\n        const x = newPoints[i] = reducedPoints[i] * xScale;\n        const y = newPoints[i + 1] = reducedPoints[i + 1] * yScale;\n        line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);\n        [x1, y1, x2, y2] = [x2, y2, x, y];\n      }\n    }\n    if (linesAndPoints.length === 0) {\n      return null;\n    }\n    const outline = areContours ? new ContourDrawOutline() : new InkDrawOutline();\n    outline.build(linesAndPoints, pageWidth, pageHeight, 1, rotation, areContours ? 0 : thickness, innerMargin);\n    return {\n      outline,\n      newCurves,\n      areContours,\n      thickness,\n      width,\n      height\n    };\n  }\n  static async compressSignature({\n    outlines,\n    areContours,\n    thickness,\n    width,\n    height\n  }) {\n    let minDiff = Infinity;\n    let maxDiff = -Infinity;\n    let outlinesLength = 0;\n    for (const points of outlines) {\n      outlinesLength += points.length;\n      for (let i = 2, ii = points.length; i < ii; i++) {\n        const dx = points[i] - points[i - 2];\n        minDiff = Math.min(minDiff, dx);\n        maxDiff = Math.max(maxDiff, dx);\n      }\n    }\n    let bufferType;\n    if (minDiff >= -128 && maxDiff <= 127) {\n      bufferType = Int8Array;\n    } else if (minDiff >= -32768 && maxDiff <= 32767) {\n      bufferType = Int16Array;\n    } else {\n      bufferType = Int32Array;\n    }\n    const len = outlines.length;\n    const headerLength = BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * len;\n    const header = new Uint32Array(headerLength);\n    let offset = 0;\n    header[offset++] = headerLength * Uint32Array.BYTES_PER_ELEMENT + (outlinesLength - 2 * len) * bufferType.BYTES_PER_ELEMENT;\n    header[offset++] = 0;\n    header[offset++] = width;\n    header[offset++] = height;\n    header[offset++] = areContours ? 0 : 1;\n    header[offset++] = Math.max(0, Math.floor(thickness ?? 0));\n    header[offset++] = len;\n    header[offset++] = bufferType.BYTES_PER_ELEMENT;\n    for (const points of outlines) {\n      header[offset++] = points.length - 2;\n      header[offset++] = points[0];\n      header[offset++] = points[1];\n    }\n    const cs = new CompressionStream(\"deflate-raw\");\n    const writer = cs.writable.getWriter();\n    await writer.ready;\n    writer.write(header);\n    const BufferCtor = bufferType.prototype.constructor;\n    for (const points of outlines) {\n      const diffs = new BufferCtor(points.length - 2);\n      for (let i = 2, ii = points.length; i < ii; i++) {\n        diffs[i - 2] = points[i] - points[i - 2];\n      }\n      writer.write(diffs);\n    }\n    writer.close();\n    const buf = await new Response(cs.readable).arrayBuffer();\n    const bytes = new Uint8Array(buf);\n    return toBase64Util(bytes);\n  }\n  static async decompressSignature(signatureData) {\n    try {\n      const bytes = fromBase64Util(signatureData);\n      const {\n        readable,\n        writable\n      } = new DecompressionStream(\"deflate-raw\");\n      const writer = writable.getWriter();\n      await writer.ready;\n      writer.write(bytes).then(async () => {\n        await writer.ready;\n        await writer.close();\n      }).catch(() => {});\n      let data = null;\n      let offset = 0;\n      for await (const chunk of readable) {\n        data ||= new Uint8Array(new Uint32Array(chunk.buffer, 0, 4)[0]);\n        data.set(chunk, offset);\n        offset += chunk.length;\n      }\n      const header = new Uint32Array(data.buffer, 0, data.length >> 2);\n      const version = header[1];\n      if (version !== 0) {\n        throw new Error(`Invalid version: ${version}`);\n      }\n      const width = header[2];\n      const height = header[3];\n      const areContours = header[4] === 0;\n      const thickness = header[5];\n      const numberOfDrawings = header[6];\n      const bufferType = header[7];\n      const outlines = [];\n      const diffsOffset = (BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * numberOfDrawings) * Uint32Array.BYTES_PER_ELEMENT;\n      let diffs;\n      switch (bufferType) {\n        case Int8Array.BYTES_PER_ELEMENT:\n          diffs = new Int8Array(data.buffer, diffsOffset);\n          break;\n        case Int16Array.BYTES_PER_ELEMENT:\n          diffs = new Int16Array(data.buffer, diffsOffset);\n          break;\n        case Int32Array.BYTES_PER_ELEMENT:\n          diffs = new Int32Array(data.buffer, diffsOffset);\n          break;\n      }\n      offset = 0;\n      for (let i = 0; i < numberOfDrawings; i++) {\n        const len = header[POINTS_PROPERTIES_NUMBER * i + BASE_HEADER_LENGTH];\n        const points = new Float32Array(len + 2);\n        outlines.push(points);\n        for (let j = 0; j < POINTS_PROPERTIES_NUMBER - 1; j++) {\n          points[j] = header[POINTS_PROPERTIES_NUMBER * i + BASE_HEADER_LENGTH + j + 1];\n        }\n        for (let j = 0; j < len; j++) {\n          points[j + 2] = points[j] + diffs[offset++];\n        }\n      }\n      return {\n        areContours,\n        thickness,\n        outlines,\n        width,\n        height\n      };\n    } catch (e) {\n      warn(`decompressSignature: ${e}`);\n      return null;\n    }\n  }\n}\n\n;// ./src/display/editor/signature.js\n\n\n\n\n\n\n\nclass SignatureOptions extends DrawingOptions {\n  constructor() {\n    super();\n    super.updateProperties({\n      fill: AnnotationEditor._defaultLineColor,\n      \"stroke-width\": 0\n    });\n  }\n  clone() {\n    const clone = new SignatureOptions();\n    clone.updateAll(this);\n    return clone;\n  }\n}\nclass DrawnSignatureOptions extends InkDrawingOptions {\n  constructor(viewerParameters) {\n    super(viewerParameters);\n    super.updateProperties({\n      stroke: AnnotationEditor._defaultLineColor,\n      \"stroke-width\": 1\n    });\n  }\n  clone() {\n    const clone = new DrawnSignatureOptions(this._viewParameters);\n    clone.updateAll(this);\n    return clone;\n  }\n}\nclass SignatureEditor extends DrawingEditor {\n  #isExtracted = false;\n  #description = null;\n  #signatureData = null;\n  #signatureUUID = null;\n  static _type = \"signature\";\n  static _editorType = AnnotationEditorType.SIGNATURE;\n  static _defaultDrawingOptions = null;\n  constructor(params) {\n    super({\n      ...params,\n      mustBeCommitted: true,\n      name: \"signatureEditor\"\n    });\n    this._willKeepAspectRatio = true;\n    this.#signatureData = params.signatureData || null;\n    this.#description = null;\n    this.defaultL10nId = \"pdfjs-editor-signature-editor1\";\n  }\n  static initialize(l10n, uiManager) {\n    AnnotationEditor.initialize(l10n, uiManager);\n    this._defaultDrawingOptions = new SignatureOptions();\n    this._defaultDrawnSignatureOptions = new DrawnSignatureOptions(uiManager.viewParameters);\n  }\n  static getDefaultDrawingOptions(options) {\n    const clone = this._defaultDrawingOptions.clone();\n    clone.updateProperties(options);\n    return clone;\n  }\n  static get supportMultipleDrawings() {\n    return false;\n  }\n  static get typesMap() {\n    return shadow(this, \"typesMap\", new Map());\n  }\n  static get isDrawer() {\n    return false;\n  }\n  get telemetryFinalData() {\n    return {\n      type: \"signature\",\n      hasDescription: !!this.#description\n    };\n  }\n  static computeTelemetryFinalData(data) {\n    const hasDescriptionStats = data.get(\"hasDescription\");\n    return {\n      hasAltText: hasDescriptionStats.get(true) ?? 0,\n      hasNoAltText: hasDescriptionStats.get(false) ?? 0\n    };\n  }\n  get isResizable() {\n    return true;\n  }\n  onScaleChanging() {\n    if (this._drawId === null) {\n      return;\n    }\n    super.onScaleChanging();\n  }\n  render() {\n    if (this.div) {\n      return this.div;\n    }\n    let baseX, baseY;\n    const {\n      _isCopy\n    } = this;\n    if (_isCopy) {\n      this._isCopy = false;\n      baseX = this.x;\n      baseY = this.y;\n    }\n    super.render();\n    if (this._drawId === null) {\n      if (this.#signatureData) {\n        const {\n          lines,\n          mustSmooth,\n          areContours,\n          description,\n          uuid,\n          heightInPage\n        } = this.#signatureData;\n        const {\n          rawDims: {\n            pageWidth,\n            pageHeight\n          },\n          rotation\n        } = this.parent.viewport;\n        const outline = SignatureExtractor.processDrawnLines({\n          lines,\n          pageWidth,\n          pageHeight,\n          rotation,\n          innerMargin: SignatureEditor._INNER_MARGIN,\n          mustSmooth,\n          areContours\n        });\n        this.addSignature(outline, heightInPage, description, uuid);\n      } else {\n        this.div.setAttribute(\"data-l10n-args\", JSON.stringify({\n          description: \"\"\n        }));\n        this.div.hidden = true;\n        this._uiManager.getSignature(this);\n      }\n    } else {\n      this.div.setAttribute(\"data-l10n-args\", JSON.stringify({\n        description: this.#description || \"\"\n      }));\n    }\n    if (_isCopy) {\n      this._isCopy = true;\n      this._moveAfterPaste(baseX, baseY);\n    }\n    return this.div;\n  }\n  setUuid(uuid) {\n    this.#signatureUUID = uuid;\n    this.addEditToolbar();\n  }\n  getUuid() {\n    return this.#signatureUUID;\n  }\n  get description() {\n    return this.#description;\n  }\n  set description(description) {\n    this.#description = description;\n    if (!this.div) {\n      return;\n    }\n    this.div.setAttribute(\"data-l10n-args\", JSON.stringify({\n      description\n    }));\n    super.addEditToolbar().then(toolbar => {\n      toolbar?.updateEditSignatureButton(description);\n    });\n  }\n  getSignaturePreview() {\n    const {\n      newCurves,\n      areContours,\n      thickness,\n      width,\n      height\n    } = this.#signatureData;\n    const maxDim = Math.max(width, height);\n    const outlineData = SignatureExtractor.processDrawnLines({\n      lines: {\n        curves: newCurves.map(points => ({\n          points\n        })),\n        thickness,\n        width,\n        height\n      },\n      pageWidth: maxDim,\n      pageHeight: maxDim,\n      rotation: 0,\n      innerMargin: 0,\n      mustSmooth: false,\n      areContours\n    });\n    return {\n      areContours,\n      outline: outlineData.outline\n    };\n  }\n  get toolbarButtons() {\n    if (this._uiManager.signatureManager) {\n      return [[\"editSignature\", this._uiManager.signatureManager]];\n    }\n    return super.toolbarButtons;\n  }\n  addSignature(data, heightInPage, description, uuid) {\n    const {\n      x: savedX,\n      y: savedY\n    } = this;\n    const {\n      outline\n    } = this.#signatureData = data;\n    this.#isExtracted = outline instanceof ContourDrawOutline;\n    this.description = description;\n    let drawingOptions;\n    if (this.#isExtracted) {\n      drawingOptions = SignatureEditor.getDefaultDrawingOptions();\n    } else {\n      drawingOptions = SignatureEditor._defaultDrawnSignatureOptions.clone();\n      drawingOptions.updateProperties({\n        \"stroke-width\": outline.thickness\n      });\n    }\n    this._addOutlines({\n      drawOutlines: outline,\n      drawingOptions\n    });\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    const [, pageHeight] = this.pageDimensions;\n    let newHeight = heightInPage / pageHeight;\n    newHeight = newHeight >= 1 ? 0.5 : newHeight;\n    this.width *= newHeight / this.height;\n    if (this.width >= 1) {\n      newHeight *= 0.9 / this.width;\n      this.width = 0.9;\n    }\n    this.height = newHeight;\n    this.setDims(parentWidth * this.width, parentHeight * this.height);\n    this.x = savedX;\n    this.y = savedY;\n    this.center();\n    this._onResized();\n    this.onScaleChanging();\n    this.rotate();\n    this._uiManager.addToAnnotationStorage(this);\n    this.setUuid(uuid);\n    this._reportTelemetry({\n      action: \"pdfjs.signature.inserted\",\n      data: {\n        hasBeenSaved: !!uuid,\n        hasDescription: !!description\n      }\n    });\n    this.div.hidden = false;\n  }\n  getFromImage(bitmap) {\n    const {\n      rawDims: {\n        pageWidth,\n        pageHeight\n      },\n      rotation\n    } = this.parent.viewport;\n    return SignatureExtractor.process(bitmap, pageWidth, pageHeight, rotation, SignatureEditor._INNER_MARGIN);\n  }\n  getFromText(text, fontInfo) {\n    const {\n      rawDims: {\n        pageWidth,\n        pageHeight\n      },\n      rotation\n    } = this.parent.viewport;\n    return SignatureExtractor.extractContoursFromText(text, fontInfo, pageWidth, pageHeight, rotation, SignatureEditor._INNER_MARGIN);\n  }\n  getDrawnSignature(curves) {\n    const {\n      rawDims: {\n        pageWidth,\n        pageHeight\n      },\n      rotation\n    } = this.parent.viewport;\n    return SignatureExtractor.processDrawnLines({\n      lines: curves,\n      pageWidth,\n      pageHeight,\n      rotation,\n      innerMargin: SignatureEditor._INNER_MARGIN,\n      mustSmooth: false,\n      areContours: false\n    });\n  }\n  createDrawingOptions({\n    areContours,\n    thickness\n  }) {\n    if (areContours) {\n      this._drawingOptions = SignatureEditor.getDefaultDrawingOptions();\n    } else {\n      this._drawingOptions = SignatureEditor._defaultDrawnSignatureOptions.clone();\n      this._drawingOptions.updateProperties({\n        \"stroke-width\": thickness\n      });\n    }\n  }\n  serialize(isForCopying = false) {\n    if (this.isEmpty()) {\n      return null;\n    }\n    const {\n      lines,\n      points,\n      rect\n    } = this.serializeDraw(isForCopying);\n    const {\n      _drawingOptions: {\n        \"stroke-width\": thickness\n      }\n    } = this;\n    const serialized = {\n      annotationType: AnnotationEditorType.SIGNATURE,\n      isSignature: true,\n      areContours: this.#isExtracted,\n      color: [0, 0, 0],\n      thickness: this.#isExtracted ? 0 : thickness,\n      pageIndex: this.pageIndex,\n      rect,\n      rotation: this.rotation,\n      structTreeParentId: this._structTreeParentId\n    };\n    this.addComment(serialized);\n    if (isForCopying) {\n      serialized.paths = {\n        lines,\n        points\n      };\n      serialized.uuid = this.#signatureUUID;\n      serialized.isCopy = true;\n    } else {\n      serialized.lines = lines;\n    }\n    if (this.#description) {\n      serialized.accessibilityData = {\n        type: \"Figure\",\n        alt: this.#description\n      };\n    }\n    return serialized;\n  }\n  static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {\n    if (data.areContours) {\n      return ContourDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);\n    }\n    return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);\n  }\n  static async deserialize(data, parent, uiManager) {\n    const editor = await super.deserialize(data, parent, uiManager);\n    editor.#isExtracted = data.areContours;\n    editor.description = data.accessibilityData?.alt || \"\";\n    editor.#signatureUUID = data.uuid;\n    return editor;\n  }\n}\n\n;// ./src/display/editor/stamp.js\n\n\n\n\nclass StampEditor extends AnnotationEditor {\n  #bitmap = null;\n  #bitmapId = null;\n  #bitmapPromise = null;\n  #bitmapUrl = null;\n  #bitmapFile = null;\n  #bitmapFileName = \"\";\n  #canvas = null;\n  #missingCanvas = false;\n  #resizeTimeoutId = null;\n  #isSvg = false;\n  #hasBeenAddedInUndoStack = false;\n  static _type = \"stamp\";\n  static _editorType = AnnotationEditorType.STAMP;\n  constructor(params) {\n    super({\n      ...params,\n      name: \"stampEditor\"\n    });\n    this.#bitmapUrl = params.bitmapUrl;\n    this.#bitmapFile = params.bitmapFile;\n    this.defaultL10nId = \"pdfjs-editor-stamp-editor\";\n  }\n  static initialize(l10n, uiManager) {\n    AnnotationEditor.initialize(l10n, uiManager);\n  }\n  static isHandlingMimeForPasting(mime) {\n    return SupportedImageMimeTypes.includes(mime);\n  }\n  static paste(item, parent) {\n    parent.pasteEditor({\n      mode: AnnotationEditorType.STAMP\n    }, {\n      bitmapFile: item.getAsFile()\n    });\n  }\n  altTextFinish() {\n    if (this._uiManager.useNewAltTextFlow) {\n      this.div.hidden = false;\n    }\n    super.altTextFinish();\n  }\n  get telemetryFinalData() {\n    return {\n      type: \"stamp\",\n      hasAltText: !!this.altTextData?.altText\n    };\n  }\n  static computeTelemetryFinalData(data) {\n    const hasAltTextStats = data.get(\"hasAltText\");\n    return {\n      hasAltText: hasAltTextStats.get(true) ?? 0,\n      hasNoAltText: hasAltTextStats.get(false) ?? 0\n    };\n  }\n  #getBitmapFetched(data, fromId = false) {\n    if (!data) {\n      this.remove();\n      return;\n    }\n    this.#bitmap = data.bitmap;\n    if (!fromId) {\n      this.#bitmapId = data.id;\n      this.#isSvg = data.isSvg;\n    }\n    if (data.file) {\n      this.#bitmapFileName = data.file.name;\n    }\n    this.#createCanvas();\n  }\n  #getBitmapDone() {\n    this.#bitmapPromise = null;\n    this._uiManager.enableWaiting(false);\n    if (!this.#canvas) {\n      return;\n    }\n    if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {\n      this.addEditToolbar().then(() => {\n        this._editToolbar.hide();\n        this._uiManager.editAltText(this, true);\n      });\n      return;\n    }\n    if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {\n      this._reportTelemetry({\n        action: \"pdfjs.image.image_added\",\n        data: {\n          alt_text_modal: false,\n          alt_text_type: \"empty\"\n        }\n      });\n      try {\n        this.mlGuessAltText();\n      } catch {}\n    }\n    this.div.focus();\n  }\n  async mlGuessAltText(imageData = null, updateAltTextData = true) {\n    if (this.hasAltTextData()) {\n      return null;\n    }\n    const {\n      mlManager\n    } = this._uiManager;\n    if (!mlManager) {\n      throw new Error(\"No ML.\");\n    }\n    if (!(await mlManager.isEnabledFor(\"altText\"))) {\n      throw new Error(\"ML isn't enabled for alt text.\");\n    }\n    const {\n      data,\n      width,\n      height\n    } = imageData || this.copyCanvas(null, null, true).imageData;\n    const response = await mlManager.guess({\n      name: \"altText\",\n      request: {\n        data,\n        width,\n        height,\n        channels: data.length / (width * height)\n      }\n    });\n    if (!response) {\n      throw new Error(\"No response from the AI service.\");\n    }\n    if (response.error) {\n      throw new Error(\"Error from the AI service.\");\n    }\n    if (response.cancel) {\n      return null;\n    }\n    if (!response.output) {\n      throw new Error(\"No valid response from the AI service.\");\n    }\n    const altText = response.output;\n    await this.setGuessedAltText(altText);\n    if (updateAltTextData && !this.hasAltTextData()) {\n      this.altTextData = {\n        alt: altText,\n        decorative: false\n      };\n    }\n    return altText;\n  }\n  #getBitmap() {\n    if (this.#bitmapId) {\n      this._uiManager.enableWaiting(true);\n      this._uiManager.imageManager.getFromId(this.#bitmapId).then(data => this.#getBitmapFetched(data, true)).finally(() => this.#getBitmapDone());\n      return;\n    }\n    if (this.#bitmapUrl) {\n      const url = this.#bitmapUrl;\n      this.#bitmapUrl = null;\n      this._uiManager.enableWaiting(true);\n      this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url).then(data => this.#getBitmapFetched(data)).finally(() => this.#getBitmapDone());\n      return;\n    }\n    if (this.#bitmapFile) {\n      const file = this.#bitmapFile;\n      this.#bitmapFile = null;\n      this._uiManager.enableWaiting(true);\n      this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file).then(data => this.#getBitmapFetched(data)).finally(() => this.#getBitmapDone());\n      return;\n    }\n    const input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.accept = SupportedImageMimeTypes.join(\",\");\n    const signal = this._uiManager._signal;\n    this.#bitmapPromise = new Promise(resolve => {\n      input.addEventListener(\"change\", async () => {\n        if (!input.files || input.files.length === 0) {\n          this.remove();\n        } else {\n          this._uiManager.enableWaiting(true);\n          const data = await this._uiManager.imageManager.getFromFile(input.files[0]);\n          this._reportTelemetry({\n            action: \"pdfjs.image.image_selected\",\n            data: {\n              alt_text_modal: this._uiManager.useNewAltTextFlow\n            }\n          });\n          this.#getBitmapFetched(data);\n        }\n        resolve();\n      }, {\n        signal\n      });\n      input.addEventListener(\"cancel\", () => {\n        this.remove();\n        resolve();\n      }, {\n        signal\n      });\n    }).finally(() => this.#getBitmapDone());\n    input.click();\n  }\n  remove() {\n    if (this.#bitmapId) {\n      this.#bitmap = null;\n      this._uiManager.imageManager.deleteId(this.#bitmapId);\n      this.#canvas?.remove();\n      this.#canvas = null;\n      if (this.#resizeTimeoutId) {\n        clearTimeout(this.#resizeTimeoutId);\n        this.#resizeTimeoutId = null;\n      }\n    }\n    super.remove();\n  }\n  rebuild() {\n    if (!this.parent) {\n      if (this.#bitmapId) {\n        this.#getBitmap();\n      }\n      return;\n    }\n    super.rebuild();\n    if (this.div === null) {\n      return;\n    }\n    if (this.#bitmapId && this.#canvas === null) {\n      this.#getBitmap();\n    }\n    if (!this.isAttachedToDOM) {\n      this.parent.add(this);\n    }\n  }\n  onceAdded(focus) {\n    this._isDraggable = true;\n    if (focus) {\n      this.div.focus();\n    }\n  }\n  isEmpty() {\n    return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile || this.#bitmapId || this.#missingCanvas);\n  }\n  get toolbarButtons() {\n    return [[\"altText\", this.createAltText()]];\n  }\n  get isResizable() {\n    return true;\n  }\n  render() {\n    if (this.div) {\n      return this.div;\n    }\n    let baseX, baseY;\n    if (this._isCopy) {\n      baseX = this.x;\n      baseY = this.y;\n    }\n    super.render();\n    this.div.hidden = true;\n    this.createAltText();\n    if (!this.#missingCanvas) {\n      if (this.#bitmap) {\n        this.#createCanvas();\n      } else {\n        this.#getBitmap();\n      }\n    }\n    if (this._isCopy) {\n      this._moveAfterPaste(baseX, baseY);\n    }\n    this._uiManager.addShouldRescale(this);\n    return this.div;\n  }\n  setCanvas(annotationElementId, canvas) {\n    const {\n      id: bitmapId,\n      bitmap\n    } = this._uiManager.imageManager.getFromCanvas(annotationElementId, canvas);\n    canvas.remove();\n    if (bitmapId && this._uiManager.imageManager.isValidId(bitmapId)) {\n      this.#bitmapId = bitmapId;\n      if (bitmap) {\n        this.#bitmap = bitmap;\n      }\n      this.#missingCanvas = false;\n      this.#createCanvas();\n    }\n  }\n  _onResized() {\n    this.onScaleChanging();\n  }\n  onScaleChanging() {\n    if (!this.parent) {\n      return;\n    }\n    if (this.#resizeTimeoutId !== null) {\n      clearTimeout(this.#resizeTimeoutId);\n    }\n    const TIME_TO_WAIT = 200;\n    this.#resizeTimeoutId = setTimeout(() => {\n      this.#resizeTimeoutId = null;\n      this.#drawBitmap();\n    }, TIME_TO_WAIT);\n  }\n  #createCanvas() {\n    const {\n      div\n    } = this;\n    let {\n      width,\n      height\n    } = this.#bitmap;\n    const [pageWidth, pageHeight] = this.pageDimensions;\n    const MAX_RATIO = 0.75;\n    if (this.width) {\n      width = this.width * pageWidth;\n      height = this.height * pageHeight;\n    } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {\n      const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);\n      width *= factor;\n      height *= factor;\n    }\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.setDims(width * parentWidth / pageWidth, height * parentHeight / pageHeight);\n    this._uiManager.enableWaiting(false);\n    const canvas = this.#canvas = document.createElement(\"canvas\");\n    canvas.setAttribute(\"role\", \"img\");\n    this.addContainer(canvas);\n    this.width = width / pageWidth;\n    this.height = height / pageHeight;\n    if (this._initialOptions?.isCentered) {\n      this.center();\n    } else {\n      this.fixAndSetPosition();\n    }\n    this._initialOptions = null;\n    if (!this._uiManager.useNewAltTextWhenAddingImage || !this._uiManager.useNewAltTextFlow || this.annotationElementId) {\n      div.hidden = false;\n    }\n    this.#drawBitmap();\n    if (!this.#hasBeenAddedInUndoStack) {\n      this.parent.addUndoableEditor(this);\n      this.#hasBeenAddedInUndoStack = true;\n    }\n    this._reportTelemetry({\n      action: \"inserted_image\"\n    });\n    if (this.#bitmapFileName) {\n      this.div.setAttribute(\"aria-description\", this.#bitmapFileName);\n    }\n    if (!this.annotationElementId) {\n      this._uiManager.a11yAlert(\"pdfjs-editor-stamp-added-alert\");\n    }\n  }\n  copyCanvas(maxDataDimension, maxPreviewDimension, createImageData = false) {\n    if (!maxDataDimension) {\n      maxDataDimension = 224;\n    }\n    const {\n      width: bitmapWidth,\n      height: bitmapHeight\n    } = this.#bitmap;\n    const outputScale = new OutputScale();\n    let bitmap = this.#bitmap;\n    let width = bitmapWidth,\n      height = bitmapHeight;\n    let canvas = null;\n    if (maxPreviewDimension) {\n      if (bitmapWidth > maxPreviewDimension || bitmapHeight > maxPreviewDimension) {\n        const ratio = Math.min(maxPreviewDimension / bitmapWidth, maxPreviewDimension / bitmapHeight);\n        width = Math.floor(bitmapWidth * ratio);\n        height = Math.floor(bitmapHeight * ratio);\n      }\n      canvas = document.createElement(\"canvas\");\n      const scaledWidth = canvas.width = Math.ceil(width * outputScale.sx);\n      const scaledHeight = canvas.height = Math.ceil(height * outputScale.sy);\n      if (!this.#isSvg) {\n        bitmap = this.#scaleBitmap(scaledWidth, scaledHeight);\n      }\n      const ctx = canvas.getContext(\"2d\");\n      ctx.filter = this._uiManager.hcmFilter;\n      let white = \"white\",\n        black = \"#cfcfd8\";\n      if (this._uiManager.hcmFilter !== \"none\") {\n        black = \"black\";\n      } else if (window.matchMedia?.(\"(prefers-color-scheme: dark)\").matches) {\n        white = \"#8f8f9d\";\n        black = \"#42414d\";\n      }\n      const boxDim = 15;\n      const boxDimWidth = boxDim * outputScale.sx;\n      const boxDimHeight = boxDim * outputScale.sy;\n      const pattern = new OffscreenCanvas(boxDimWidth * 2, boxDimHeight * 2);\n      const patternCtx = pattern.getContext(\"2d\");\n      patternCtx.fillStyle = white;\n      patternCtx.fillRect(0, 0, boxDimWidth * 2, boxDimHeight * 2);\n      patternCtx.fillStyle = black;\n      patternCtx.fillRect(0, 0, boxDimWidth, boxDimHeight);\n      patternCtx.fillRect(boxDimWidth, boxDimHeight, boxDimWidth, boxDimHeight);\n      ctx.fillStyle = ctx.createPattern(pattern, \"repeat\");\n      ctx.fillRect(0, 0, scaledWidth, scaledHeight);\n      ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);\n    }\n    let imageData = null;\n    if (createImageData) {\n      let dataWidth, dataHeight;\n      if (outputScale.symmetric && bitmap.width < maxDataDimension && bitmap.height < maxDataDimension) {\n        dataWidth = bitmap.width;\n        dataHeight = bitmap.height;\n      } else {\n        bitmap = this.#bitmap;\n        if (bitmapWidth > maxDataDimension || bitmapHeight > maxDataDimension) {\n          const ratio = Math.min(maxDataDimension / bitmapWidth, maxDataDimension / bitmapHeight);\n          dataWidth = Math.floor(bitmapWidth * ratio);\n          dataHeight = Math.floor(bitmapHeight * ratio);\n          if (!this.#isSvg) {\n            bitmap = this.#scaleBitmap(dataWidth, dataHeight);\n          }\n        }\n      }\n      const offscreen = new OffscreenCanvas(dataWidth, dataHeight);\n      const offscreenCtx = offscreen.getContext(\"2d\", {\n        willReadFrequently: true\n      });\n      offscreenCtx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, dataWidth, dataHeight);\n      imageData = {\n        width: dataWidth,\n        height: dataHeight,\n        data: offscreenCtx.getImageData(0, 0, dataWidth, dataHeight).data\n      };\n    }\n    return {\n      canvas,\n      width,\n      height,\n      imageData\n    };\n  }\n  #scaleBitmap(width, height) {\n    const {\n      width: bitmapWidth,\n      height: bitmapHeight\n    } = this.#bitmap;\n    let newWidth = bitmapWidth;\n    let newHeight = bitmapHeight;\n    let bitmap = this.#bitmap;\n    while (newWidth > 2 * width || newHeight > 2 * height) {\n      const prevWidth = newWidth;\n      const prevHeight = newHeight;\n      if (newWidth > 2 * width) {\n        newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);\n      }\n      if (newHeight > 2 * height) {\n        newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);\n      }\n      const offscreen = new OffscreenCanvas(newWidth, newHeight);\n      const ctx = offscreen.getContext(\"2d\");\n      ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);\n      bitmap = offscreen.transferToImageBitmap();\n    }\n    return bitmap;\n  }\n  #drawBitmap() {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    const {\n      width,\n      height\n    } = this;\n    const outputScale = new OutputScale();\n    const scaledWidth = Math.ceil(width * parentWidth * outputScale.sx);\n    const scaledHeight = Math.ceil(height * parentHeight * outputScale.sy);\n    const canvas = this.#canvas;\n    if (!canvas || canvas.width === scaledWidth && canvas.height === scaledHeight) {\n      return;\n    }\n    canvas.width = scaledWidth;\n    canvas.height = scaledHeight;\n    const bitmap = this.#isSvg ? this.#bitmap : this.#scaleBitmap(scaledWidth, scaledHeight);\n    const ctx = canvas.getContext(\"2d\");\n    ctx.filter = this._uiManager.hcmFilter;\n    ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);\n  }\n  #serializeBitmap(toUrl) {\n    if (toUrl) {\n      if (this.#isSvg) {\n        const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);\n        if (url) {\n          return url;\n        }\n      }\n      const canvas = document.createElement(\"canvas\");\n      ({\n        width: canvas.width,\n        height: canvas.height\n      } = this.#bitmap);\n      const ctx = canvas.getContext(\"2d\");\n      ctx.drawImage(this.#bitmap, 0, 0);\n      return canvas.toDataURL();\n    }\n    if (this.#isSvg) {\n      const [pageWidth, pageHeight] = this.pageDimensions;\n      const width = Math.round(this.width * pageWidth * PixelsPerInch.PDF_TO_CSS_UNITS);\n      const height = Math.round(this.height * pageHeight * PixelsPerInch.PDF_TO_CSS_UNITS);\n      const offscreen = new OffscreenCanvas(width, height);\n      const ctx = offscreen.getContext(\"2d\");\n      ctx.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width, height);\n      return offscreen.transferToImageBitmap();\n    }\n    return structuredClone(this.#bitmap);\n  }\n  static async deserialize(data, parent, uiManager) {\n    let initialData = null;\n    let missingCanvas = false;\n    if (data instanceof StampAnnotationElement) {\n      const {\n        data: {\n          rect,\n          rotation,\n          id,\n          structParent,\n          popupRef,\n          contentsObj\n        },\n        container,\n        parent: {\n          page: {\n            pageNumber\n          }\n        },\n        canvas\n      } = data;\n      let bitmapId, bitmap;\n      if (canvas) {\n        delete data.canvas;\n        ({\n          id: bitmapId,\n          bitmap\n        } = uiManager.imageManager.getFromCanvas(container.id, canvas));\n        canvas.remove();\n      } else {\n        missingCanvas = true;\n        data._hasNoCanvas = true;\n      }\n      const altText = (await parent._structTree.getAriaAttributes(`${AnnotationPrefix}${id}`))?.get(\"aria-label\") || \"\";\n      initialData = data = {\n        annotationType: AnnotationEditorType.STAMP,\n        bitmapId,\n        bitmap,\n        pageIndex: pageNumber - 1,\n        rect: rect.slice(0),\n        rotation,\n        annotationElementId: id,\n        id,\n        deleted: false,\n        accessibilityData: {\n          decorative: false,\n          altText\n        },\n        isSvg: false,\n        structParent,\n        popupRef,\n        comment: contentsObj?.str || null\n      };\n    }\n    const editor = await super.deserialize(data, parent, uiManager);\n    const {\n      rect,\n      bitmap,\n      bitmapUrl,\n      bitmapId,\n      isSvg,\n      accessibilityData\n    } = data;\n    if (missingCanvas) {\n      uiManager.addMissingCanvas(data.id, editor);\n      editor.#missingCanvas = true;\n    } else if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {\n      editor.#bitmapId = bitmapId;\n      if (bitmap) {\n        editor.#bitmap = bitmap;\n      }\n    } else {\n      editor.#bitmapUrl = bitmapUrl;\n    }\n    editor.#isSvg = isSvg;\n    const [parentWidth, parentHeight] = editor.pageDimensions;\n    editor.width = (rect[2] - rect[0]) / parentWidth;\n    editor.height = (rect[3] - rect[1]) / parentHeight;\n    if (accessibilityData) {\n      editor.altTextData = accessibilityData;\n    }\n    editor._initialData = initialData;\n    if (data.comment) {\n      editor.setCommentData(data.comment);\n    }\n    editor.#hasBeenAddedInUndoStack = !!initialData;\n    return editor;\n  }\n  serialize(isForCopying = false, context = null) {\n    if (this.isEmpty()) {\n      return null;\n    }\n    if (this.deleted) {\n      return this.serializeDeleted();\n    }\n    const serialized = {\n      annotationType: AnnotationEditorType.STAMP,\n      bitmapId: this.#bitmapId,\n      pageIndex: this.pageIndex,\n      rect: this.getPDFRect(),\n      rotation: this.rotation,\n      isSvg: this.#isSvg,\n      structTreeParentId: this._structTreeParentId\n    };\n    this.addComment(serialized);\n    if (isForCopying) {\n      serialized.bitmapUrl = this.#serializeBitmap(true);\n      serialized.accessibilityData = this.serializeAltText(true);\n      serialized.isCopy = true;\n      return serialized;\n    }\n    const {\n      decorative,\n      altText\n    } = this.serializeAltText(false);\n    if (!decorative && altText) {\n      serialized.accessibilityData = {\n        type: \"Figure\",\n        alt: altText\n      };\n    }\n    if (this.annotationElementId) {\n      const changes = this.#hasElementChanged(serialized);\n      if (changes.isSame) {\n        return null;\n      }\n      if (changes.isSameAltText) {\n        delete serialized.accessibilityData;\n      } else {\n        serialized.accessibilityData.structParent = this._initialData.structParent ?? -1;\n      }\n    }\n    serialized.id = this.annotationElementId;\n    if (context === null) {\n      return serialized;\n    }\n    context.stamps ||= new Map();\n    const area = this.#isSvg ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;\n    if (!context.stamps.has(this.#bitmapId)) {\n      context.stamps.set(this.#bitmapId, {\n        area,\n        serialized\n      });\n      serialized.bitmap = this.#serializeBitmap(false);\n    } else if (this.#isSvg) {\n      const prevData = context.stamps.get(this.#bitmapId);\n      if (area > prevData.area) {\n        prevData.area = area;\n        prevData.serialized.bitmap.close();\n        prevData.serialized.bitmap = this.#serializeBitmap(false);\n      }\n    }\n    return serialized;\n  }\n  #hasElementChanged(serialized) {\n    const {\n      pageIndex,\n      accessibilityData: {\n        altText\n      }\n    } = this._initialData;\n    const isSamePageIndex = serialized.pageIndex === pageIndex;\n    const isSameAltText = (serialized.accessibilityData?.alt || \"\") === altText;\n    return {\n      isSame: !this.hasEditedComment && !this._hasBeenMoved && !this._hasBeenResized && isSamePageIndex && isSameAltText,\n      isSameAltText\n    };\n  }\n  renderAnnotationElement(annotation) {\n    if (this.deleted) {\n      annotation.hide();\n      return null;\n    }\n    const params = {\n      rect: this.getPDFRect()\n    };\n    if (this.hasEditedComment) {\n      params.popup = this.comment;\n    }\n    annotation.updateEdited(params);\n    return null;\n  }\n}\n\n;// ./src/display/editor/annotation_editor_layer.js\n\n\n\n\n\n\n\n\nclass AnnotationEditorLayer {\n  #accessibilityManager;\n  #allowClick = false;\n  #annotationLayer = null;\n  #clickAC = null;\n  #editorFocusTimeoutId = null;\n  #editors = new Map();\n  #hadPointerDown = false;\n  #isDisabling = false;\n  #isEnabling = false;\n  #drawingAC = null;\n  #focusedElement = null;\n  #textLayer = null;\n  #textSelectionAC = null;\n  #textLayerDblClickAC = null;\n  #lastPointerDownTimestamp = -1;\n  #uiManager;\n  static _initialized = false;\n  static #editorTypes = new Map([FreeTextEditor, InkEditor, StampEditor, HighlightEditor, SignatureEditor].map(type => [type._editorType, type]));\n  constructor({\n    uiManager,\n    pageIndex,\n    div,\n    structTreeLayer,\n    accessibilityManager,\n    annotationLayer,\n    drawLayer,\n    textLayer,\n    viewport,\n    l10n\n  }) {\n    const editorTypes = [...AnnotationEditorLayer.#editorTypes.values()];\n    if (!AnnotationEditorLayer._initialized) {\n      AnnotationEditorLayer._initialized = true;\n      for (const editorType of editorTypes) {\n        editorType.initialize(l10n, uiManager);\n      }\n    }\n    uiManager.registerEditorTypes(editorTypes);\n    this.#uiManager = uiManager;\n    this.pageIndex = pageIndex;\n    this.div = div;\n    this.#accessibilityManager = accessibilityManager;\n    this.#annotationLayer = annotationLayer;\n    this.viewport = viewport;\n    this.#textLayer = textLayer;\n    this.drawLayer = drawLayer;\n    this._structTree = structTreeLayer;\n    this.#uiManager.addLayer(this);\n  }\n  get isEmpty() {\n    return this.#editors.size === 0;\n  }\n  get isInvisible() {\n    return this.isEmpty && this.#uiManager.getMode() === AnnotationEditorType.NONE;\n  }\n  updateToolbar(options) {\n    this.#uiManager.updateToolbar(options);\n  }\n  updateMode(mode = this.#uiManager.getMode()) {\n    this.#cleanup();\n    switch (mode) {\n      case AnnotationEditorType.NONE:\n        this.disableTextSelection();\n        this.togglePointerEvents(false);\n        this.toggleAnnotationLayerPointerEvents(true);\n        this.disableClick();\n        return;\n      case AnnotationEditorType.INK:\n        this.disableTextSelection();\n        this.togglePointerEvents(true);\n        this.enableClick();\n        break;\n      case AnnotationEditorType.HIGHLIGHT:\n        this.enableTextSelection();\n        this.togglePointerEvents(false);\n        this.disableClick();\n        break;\n      default:\n        this.disableTextSelection();\n        this.togglePointerEvents(true);\n        this.enableClick();\n    }\n    this.toggleAnnotationLayerPointerEvents(false);\n    const {\n      classList\n    } = this.div;\n    for (const editorType of AnnotationEditorLayer.#editorTypes.values()) {\n      classList.toggle(`${editorType._type}Editing`, mode === editorType._editorType);\n    }\n    this.div.hidden = false;\n  }\n  hasTextLayer(textLayer) {\n    return textLayer === this.#textLayer?.div;\n  }\n  setEditingState(isEditing) {\n    this.#uiManager.setEditingState(isEditing);\n  }\n  addCommands(params) {\n    this.#uiManager.addCommands(params);\n  }\n  cleanUndoStack(type) {\n    this.#uiManager.cleanUndoStack(type);\n  }\n  toggleDrawing(enabled = false) {\n    this.div.classList.toggle(\"drawing\", !enabled);\n  }\n  togglePointerEvents(enabled = false) {\n    this.div.classList.toggle(\"disabled\", !enabled);\n  }\n  toggleAnnotationLayerPointerEvents(enabled = false) {\n    this.#annotationLayer?.div.classList.toggle(\"disabled\", !enabled);\n  }\n  async enable() {\n    this.#isEnabling = true;\n    this.div.tabIndex = 0;\n    this.togglePointerEvents(true);\n    this.#textLayerDblClickAC?.abort();\n    this.#textLayerDblClickAC = null;\n    const annotationElementIds = new Set();\n    for (const editor of this.#editors.values()) {\n      editor.enableEditing();\n      editor.show(true);\n      if (editor.annotationElementId) {\n        this.#uiManager.removeChangedExistingAnnotation(editor);\n        annotationElementIds.add(editor.annotationElementId);\n      }\n    }\n    if (!this.#annotationLayer) {\n      this.#isEnabling = false;\n      return;\n    }\n    const editables = this.#annotationLayer.getEditableAnnotations();\n    for (const editable of editables) {\n      editable.hide();\n      if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) {\n        continue;\n      }\n      if (annotationElementIds.has(editable.data.id)) {\n        continue;\n      }\n      const editor = await this.deserialize(editable);\n      if (!editor) {\n        continue;\n      }\n      this.addOrRebuild(editor);\n      editor.enableEditing();\n    }\n    this.#isEnabling = false;\n  }\n  disable() {\n    this.#isDisabling = true;\n    this.div.tabIndex = -1;\n    this.togglePointerEvents(false);\n    if (this.#textLayer && !this.#textLayerDblClickAC) {\n      this.#textLayerDblClickAC = new AbortController();\n      const signal = this.#uiManager.combinedSignal(this.#textLayerDblClickAC);\n      this.#textLayer.div.addEventListener(\"pointerdown\", e => {\n        const DBL_CLICK_THRESHOLD = 500;\n        const {\n          clientX,\n          clientY,\n          timeStamp\n        } = e;\n        const lastPointerDownTimestamp = this.#lastPointerDownTimestamp;\n        if (timeStamp - lastPointerDownTimestamp > DBL_CLICK_THRESHOLD) {\n          this.#lastPointerDownTimestamp = timeStamp;\n          return;\n        }\n        this.#lastPointerDownTimestamp = -1;\n        const {\n          classList\n        } = this.div;\n        classList.toggle(\"getElements\", true);\n        const elements = document.elementsFromPoint(clientX, clientY);\n        classList.toggle(\"getElements\", false);\n        if (!this.div.contains(elements[0])) {\n          return;\n        }\n        let id;\n        const regex = new RegExp(`^${AnnotationEditorPrefix}[0-9]+$`);\n        for (const element of elements) {\n          if (regex.test(element.id)) {\n            id = element.id;\n            break;\n          }\n        }\n        if (!id) {\n          return;\n        }\n        const editor = this.#editors.get(id);\n        if (editor?.annotationElementId === null) {\n          e.stopPropagation();\n          e.preventDefault();\n          editor.dblclick();\n        }\n      }, {\n        signal,\n        capture: true\n      });\n    }\n    const changedAnnotations = new Map();\n    const resetAnnotations = new Map();\n    for (const editor of this.#editors.values()) {\n      editor.disableEditing();\n      if (!editor.annotationElementId) {\n        continue;\n      }\n      if (editor.serialize() !== null) {\n        changedAnnotations.set(editor.annotationElementId, editor);\n        continue;\n      } else {\n        resetAnnotations.set(editor.annotationElementId, editor);\n      }\n      this.getEditableAnnotation(editor.annotationElementId)?.show();\n      editor.remove();\n    }\n    if (this.#annotationLayer) {\n      const editables = this.#annotationLayer.getEditableAnnotations();\n      for (const editable of editables) {\n        const {\n          id\n        } = editable.data;\n        if (this.#uiManager.isDeletedAnnotationElement(id)) {\n          editable.updateEdited({\n            deleted: true\n          });\n          continue;\n        }\n        let editor = resetAnnotations.get(id);\n        if (editor) {\n          editor.resetAnnotationElement(editable);\n          editor.show(false);\n          editable.show();\n          continue;\n        }\n        editor = changedAnnotations.get(id);\n        if (editor) {\n          this.#uiManager.addChangedExistingAnnotation(editor);\n          if (editor.renderAnnotationElement(editable)) {\n            editor.show(false);\n          }\n        }\n        editable.show();\n      }\n    }\n    this.#cleanup();\n    if (this.isEmpty) {\n      this.div.hidden = true;\n    }\n    const {\n      classList\n    } = this.div;\n    for (const editorType of AnnotationEditorLayer.#editorTypes.values()) {\n      classList.remove(`${editorType._type}Editing`);\n    }\n    this.disableTextSelection();\n    this.toggleAnnotationLayerPointerEvents(true);\n    this.#isDisabling = false;\n  }\n  getEditableAnnotation(id) {\n    return this.#annotationLayer?.getEditableAnnotation(id) || null;\n  }\n  setActiveEditor(editor) {\n    const currentActive = this.#uiManager.getActive();\n    if (currentActive === editor) {\n      return;\n    }\n    this.#uiManager.setActiveEditor(editor);\n  }\n  enableTextSelection() {\n    this.div.tabIndex = -1;\n    if (this.#textLayer?.div && !this.#textSelectionAC) {\n      this.#textSelectionAC = new AbortController();\n      const signal = this.#uiManager.combinedSignal(this.#textSelectionAC);\n      this.#textLayer.div.addEventListener(\"pointerdown\", this.#textLayerPointerDown.bind(this), {\n        signal\n      });\n      this.#textLayer.div.classList.add(\"highlighting\");\n    }\n  }\n  disableTextSelection() {\n    this.div.tabIndex = 0;\n    if (this.#textLayer?.div && this.#textSelectionAC) {\n      this.#textSelectionAC.abort();\n      this.#textSelectionAC = null;\n      this.#textLayer.div.classList.remove(\"highlighting\");\n    }\n  }\n  #textLayerPointerDown(event) {\n    this.#uiManager.unselectAll();\n    const {\n      target\n    } = event;\n    if (target === this.#textLayer.div || (target.getAttribute(\"role\") === \"img\" || target.classList.contains(\"endOfContent\")) && this.#textLayer.div.contains(target)) {\n      const {\n        isMac\n      } = util_FeatureTest.platform;\n      if (event.button !== 0 || event.ctrlKey && isMac) {\n        return;\n      }\n      this.#uiManager.showAllEditors(\"highlight\", true, true);\n      this.#textLayer.div.classList.add(\"free\");\n      this.toggleDrawing();\n      HighlightEditor.startHighlighting(this, this.#uiManager.direction === \"ltr\", {\n        target: this.#textLayer.div,\n        x: event.x,\n        y: event.y\n      });\n      this.#textLayer.div.addEventListener(\"pointerup\", () => {\n        this.#textLayer.div.classList.remove(\"free\");\n        this.toggleDrawing(true);\n      }, {\n        once: true,\n        signal: this.#uiManager._signal\n      });\n      event.preventDefault();\n    }\n  }\n  enableClick() {\n    if (this.#clickAC) {\n      return;\n    }\n    this.#clickAC = new AbortController();\n    const signal = this.#uiManager.combinedSignal(this.#clickAC);\n    this.div.addEventListener(\"pointerdown\", this.pointerdown.bind(this), {\n      signal\n    });\n    const pointerup = this.pointerup.bind(this);\n    this.div.addEventListener(\"pointerup\", pointerup, {\n      signal\n    });\n    this.div.addEventListener(\"pointercancel\", pointerup, {\n      signal\n    });\n  }\n  disableClick() {\n    this.#clickAC?.abort();\n    this.#clickAC = null;\n  }\n  attach(editor) {\n    this.#editors.set(editor.id, editor);\n    const {\n      annotationElementId\n    } = editor;\n    if (annotationElementId && this.#uiManager.isDeletedAnnotationElement(annotationElementId)) {\n      this.#uiManager.removeDeletedAnnotationElement(editor);\n    }\n  }\n  detach(editor) {\n    this.#editors.delete(editor.id);\n    this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n    if (!this.#isDisabling && editor.annotationElementId) {\n      this.#uiManager.addDeletedAnnotationElement(editor);\n    }\n  }\n  remove(editor) {\n    this.detach(editor);\n    this.#uiManager.removeEditor(editor);\n    editor.div.remove();\n    editor.isAttachedToDOM = false;\n  }\n  changeParent(editor) {\n    if (editor.parent === this) {\n      return;\n    }\n    if (editor.parent && editor.annotationElementId) {\n      this.#uiManager.addDeletedAnnotationElement(editor.annotationElementId);\n      AnnotationEditor.deleteAnnotationElement(editor);\n      editor.annotationElementId = null;\n    }\n    this.attach(editor);\n    editor.parent?.detach(editor);\n    editor.setParent(this);\n    if (editor.div && editor.isAttachedToDOM) {\n      editor.div.remove();\n      this.div.append(editor.div);\n    }\n  }\n  add(editor) {\n    if (editor.parent === this && editor.isAttachedToDOM) {\n      return;\n    }\n    this.changeParent(editor);\n    this.#uiManager.addEditor(editor);\n    this.attach(editor);\n    if (!editor.isAttachedToDOM) {\n      const div = editor.render();\n      this.div.append(div);\n      editor.isAttachedToDOM = true;\n    }\n    editor.fixAndSetPosition();\n    editor.onceAdded(!this.#isEnabling);\n    this.#uiManager.addToAnnotationStorage(editor);\n    editor._reportTelemetry(editor.telemetryInitialData);\n  }\n  moveEditorInDOM(editor) {\n    if (!editor.isAttachedToDOM) {\n      return;\n    }\n    const {\n      activeElement\n    } = document;\n    if (editor.div.contains(activeElement) && !this.#editorFocusTimeoutId) {\n      editor._focusEventsAllowed = false;\n      this.#editorFocusTimeoutId = setTimeout(() => {\n        this.#editorFocusTimeoutId = null;\n        if (!editor.div.contains(document.activeElement)) {\n          editor.div.addEventListener(\"focusin\", () => {\n            editor._focusEventsAllowed = true;\n          }, {\n            once: true,\n            signal: this.#uiManager._signal\n          });\n          activeElement.focus();\n        } else {\n          editor._focusEventsAllowed = true;\n        }\n      }, 0);\n    }\n    editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);\n  }\n  addOrRebuild(editor) {\n    if (editor.needsToBeRebuilt()) {\n      editor.parent ||= this;\n      editor.rebuild();\n      editor.show();\n    } else {\n      this.add(editor);\n    }\n  }\n  addUndoableEditor(editor) {\n    const cmd = () => editor._uiManager.rebuild(editor);\n    const undo = () => {\n      editor.remove();\n    };\n    this.addCommands({\n      cmd,\n      undo,\n      mustExec: false\n    });\n  }\n  getNextId() {\n    return this.#uiManager.getId();\n  }\n  get #currentEditorType() {\n    return AnnotationEditorLayer.#editorTypes.get(this.#uiManager.getMode());\n  }\n  combinedSignal(ac) {\n    return this.#uiManager.combinedSignal(ac);\n  }\n  #createNewEditor(params) {\n    const editorType = this.#currentEditorType;\n    return editorType ? new editorType.prototype.constructor(params) : null;\n  }\n  canCreateNewEmptyEditor() {\n    return this.#currentEditorType?.canCreateNewEmptyEditor();\n  }\n  async pasteEditor(options, params) {\n    this.updateToolbar(options);\n    await this.#uiManager.updateMode(options.mode);\n    const {\n      offsetX,\n      offsetY\n    } = this.#getCenterPoint();\n    const id = this.getNextId();\n    const editor = this.#createNewEditor({\n      parent: this,\n      id,\n      x: offsetX,\n      y: offsetY,\n      uiManager: this.#uiManager,\n      isCentered: true,\n      ...params\n    });\n    if (editor) {\n      this.add(editor);\n    }\n  }\n  async deserialize(data) {\n    return (await AnnotationEditorLayer.#editorTypes.get(data.annotationType ?? data.annotationEditorType)?.deserialize(data, this, this.#uiManager)) || null;\n  }\n  createAndAddNewEditor(event, isCentered, data = {}) {\n    const id = this.getNextId();\n    const editor = this.#createNewEditor({\n      parent: this,\n      id,\n      x: event.offsetX,\n      y: event.offsetY,\n      uiManager: this.#uiManager,\n      isCentered,\n      ...data\n    });\n    if (editor) {\n      this.add(editor);\n    }\n    return editor;\n  }\n  #getCenterPoint() {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this.div.getBoundingClientRect();\n    const tlX = Math.max(0, x);\n    const tlY = Math.max(0, y);\n    const brX = Math.min(window.innerWidth, x + width);\n    const brY = Math.min(window.innerHeight, y + height);\n    const centerX = (tlX + brX) / 2 - x;\n    const centerY = (tlY + brY) / 2 - y;\n    const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [centerX, centerY] : [centerY, centerX];\n    return {\n      offsetX,\n      offsetY\n    };\n  }\n  addNewEditor(data = {}) {\n    this.createAndAddNewEditor(this.#getCenterPoint(), true, data);\n  }\n  setSelected(editor) {\n    this.#uiManager.setSelected(editor);\n  }\n  toggleSelected(editor) {\n    this.#uiManager.toggleSelected(editor);\n  }\n  unselect(editor) {\n    this.#uiManager.unselect(editor);\n  }\n  pointerup(event) {\n    const {\n      isMac\n    } = util_FeatureTest.platform;\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      return;\n    }\n    if (event.target !== this.div) {\n      return;\n    }\n    if (!this.#hadPointerDown) {\n      return;\n    }\n    this.#hadPointerDown = false;\n    if (this.#currentEditorType?.isDrawer && this.#currentEditorType.supportMultipleDrawings) {\n      return;\n    }\n    if (!this.#allowClick) {\n      this.#allowClick = true;\n      return;\n    }\n    const currentMode = this.#uiManager.getMode();\n    if (currentMode === AnnotationEditorType.STAMP || currentMode === AnnotationEditorType.SIGNATURE) {\n      this.#uiManager.unselectAll();\n      return;\n    }\n    this.createAndAddNewEditor(event, false);\n  }\n  pointerdown(event) {\n    if (this.#uiManager.getMode() === AnnotationEditorType.HIGHLIGHT) {\n      this.enableTextSelection();\n    }\n    if (this.#hadPointerDown) {\n      this.#hadPointerDown = false;\n      return;\n    }\n    const {\n      isMac\n    } = util_FeatureTest.platform;\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      return;\n    }\n    if (event.target !== this.div) {\n      return;\n    }\n    this.#hadPointerDown = true;\n    if (this.#currentEditorType?.isDrawer) {\n      this.startDrawingSession(event);\n      return;\n    }\n    const editor = this.#uiManager.getActive();\n    this.#allowClick = !editor || editor.isEmpty();\n  }\n  startDrawingSession(event) {\n    this.div.focus({\n      preventScroll: true\n    });\n    if (this.#drawingAC) {\n      this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);\n      return;\n    }\n    this.#uiManager.setCurrentDrawingSession(this);\n    this.#drawingAC = new AbortController();\n    const signal = this.#uiManager.combinedSignal(this.#drawingAC);\n    this.div.addEventListener(\"blur\", ({\n      relatedTarget\n    }) => {\n      if (relatedTarget && !this.div.contains(relatedTarget)) {\n        this.#focusedElement = null;\n        this.commitOrRemove();\n      }\n    }, {\n      signal\n    });\n    this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);\n  }\n  pause(on) {\n    if (on) {\n      const {\n        activeElement\n      } = document;\n      if (this.div.contains(activeElement)) {\n        this.#focusedElement = activeElement;\n      }\n      return;\n    }\n    if (this.#focusedElement) {\n      setTimeout(() => {\n        this.#focusedElement?.focus();\n        this.#focusedElement = null;\n      }, 0);\n    }\n  }\n  endDrawingSession(isAborted = false) {\n    if (!this.#drawingAC) {\n      return null;\n    }\n    this.#uiManager.setCurrentDrawingSession(null);\n    this.#drawingAC.abort();\n    this.#drawingAC = null;\n    this.#focusedElement = null;\n    return this.#currentEditorType.endDrawing(isAborted);\n  }\n  findNewParent(editor, x, y) {\n    const layer = this.#uiManager.findParent(x, y);\n    if (layer === null || layer === this) {\n      return false;\n    }\n    layer.changeParent(editor);\n    return true;\n  }\n  commitOrRemove() {\n    if (this.#drawingAC) {\n      this.endDrawingSession();\n      return true;\n    }\n    return false;\n  }\n  onScaleChanging() {\n    if (!this.#drawingAC) {\n      return;\n    }\n    this.#currentEditorType.onScaleChangingWhenDrawing(this);\n  }\n  destroy() {\n    this.commitOrRemove();\n    if (this.#uiManager.getActive()?.parent === this) {\n      this.#uiManager.commitOrRemove();\n      this.#uiManager.setActiveEditor(null);\n    }\n    if (this.#editorFocusTimeoutId) {\n      clearTimeout(this.#editorFocusTimeoutId);\n      this.#editorFocusTimeoutId = null;\n    }\n    for (const editor of this.#editors.values()) {\n      this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n      editor.setParent(null);\n      editor.isAttachedToDOM = false;\n      editor.div.remove();\n    }\n    this.div = null;\n    this.#editors.clear();\n    this.#uiManager.removeLayer(this);\n  }\n  #cleanup() {\n    for (const editor of this.#editors.values()) {\n      if (editor.isEmpty()) {\n        editor.remove();\n      }\n    }\n  }\n  render({\n    viewport\n  }) {\n    this.viewport = viewport;\n    setLayerDimensions(this.div, viewport);\n    for (const editor of this.#uiManager.getEditors(this.pageIndex)) {\n      this.add(editor);\n      editor.rebuild();\n    }\n    this.updateMode();\n  }\n  update({\n    viewport\n  }) {\n    this.#uiManager.commitOrRemove();\n    this.#cleanup();\n    const oldRotation = this.viewport.rotation;\n    const rotation = viewport.rotation;\n    this.viewport = viewport;\n    setLayerDimensions(this.div, {\n      rotation\n    });\n    if (oldRotation !== rotation) {\n      for (const editor of this.#editors.values()) {\n        editor.rotate(rotation);\n      }\n    }\n  }\n  get pageDimensions() {\n    const {\n      pageWidth,\n      pageHeight\n    } = this.viewport.rawDims;\n    return [pageWidth, pageHeight];\n  }\n  get scale() {\n    return this.#uiManager.viewParameters.realScale;\n  }\n}\n\n;// ./src/display/draw_layer.js\n\n\nclass DrawLayer {\n  #parent = null;\n  #mapping = new Map();\n  #toUpdate = new Map();\n  static #id = 0;\n  constructor({\n    pageIndex\n  }) {\n    this.pageIndex = pageIndex;\n  }\n  setParent(parent) {\n    if (!this.#parent) {\n      this.#parent = parent;\n      return;\n    }\n    if (this.#parent !== parent) {\n      if (this.#mapping.size > 0) {\n        for (const root of this.#mapping.values()) {\n          root.remove();\n          parent.append(root);\n        }\n      }\n      this.#parent = parent;\n    }\n  }\n  static get _svgFactory() {\n    return shadow(this, \"_svgFactory\", new DOMSVGFactory());\n  }\n  static #setBox(element, [x, y, width, height]) {\n    const {\n      style\n    } = element;\n    style.top = `${100 * y}%`;\n    style.left = `${100 * x}%`;\n    style.width = `${100 * width}%`;\n    style.height = `${100 * height}%`;\n  }\n  #createSVG() {\n    const svg = DrawLayer._svgFactory.create(1, 1, true);\n    this.#parent.append(svg);\n    svg.setAttribute(\"aria-hidden\", true);\n    return svg;\n  }\n  #createClipPath(defs, pathId) {\n    const clipPath = DrawLayer._svgFactory.createElement(\"clipPath\");\n    defs.append(clipPath);\n    const clipPathId = `clip_${pathId}`;\n    clipPath.setAttribute(\"id\", clipPathId);\n    clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n    const clipPathUse = DrawLayer._svgFactory.createElement(\"use\");\n    clipPath.append(clipPathUse);\n    clipPathUse.setAttribute(\"href\", `#${pathId}`);\n    clipPathUse.classList.add(\"clip\");\n    return clipPathId;\n  }\n  #updateProperties(element, properties) {\n    for (const [key, value] of Object.entries(properties)) {\n      if (value === null) {\n        element.removeAttribute(key);\n      } else {\n        element.setAttribute(key, value);\n      }\n    }\n  }\n  draw(properties, isPathUpdatable = false, hasClip = false) {\n    const id = DrawLayer.#id++;\n    const root = this.#createSVG();\n    const defs = DrawLayer._svgFactory.createElement(\"defs\");\n    root.append(defs);\n    const path = DrawLayer._svgFactory.createElement(\"path\");\n    defs.append(path);\n    const pathId = `path_p${this.pageIndex}_${id}`;\n    path.setAttribute(\"id\", pathId);\n    path.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\n    if (isPathUpdatable) {\n      this.#toUpdate.set(id, path);\n    }\n    const clipPathId = hasClip ? this.#createClipPath(defs, pathId) : null;\n    const use = DrawLayer._svgFactory.createElement(\"use\");\n    root.append(use);\n    use.setAttribute(\"href\", `#${pathId}`);\n    this.updateProperties(root, properties);\n    this.#mapping.set(id, root);\n    return {\n      id,\n      clipPathId: `url(#${clipPathId})`\n    };\n  }\n  drawOutline(properties, mustRemoveSelfIntersections) {\n    const id = DrawLayer.#id++;\n    const root = this.#createSVG();\n    const defs = DrawLayer._svgFactory.createElement(\"defs\");\n    root.append(defs);\n    const path = DrawLayer._svgFactory.createElement(\"path\");\n    defs.append(path);\n    const pathId = `path_p${this.pageIndex}_${id}`;\n    path.setAttribute(\"id\", pathId);\n    path.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\n    let maskId;\n    if (mustRemoveSelfIntersections) {\n      const mask = DrawLayer._svgFactory.createElement(\"mask\");\n      defs.append(mask);\n      maskId = `mask_p${this.pageIndex}_${id}`;\n      mask.setAttribute(\"id\", maskId);\n      mask.setAttribute(\"maskUnits\", \"objectBoundingBox\");\n      const rect = DrawLayer._svgFactory.createElement(\"rect\");\n      mask.append(rect);\n      rect.setAttribute(\"width\", \"1\");\n      rect.setAttribute(\"height\", \"1\");\n      rect.setAttribute(\"fill\", \"white\");\n      const use = DrawLayer._svgFactory.createElement(\"use\");\n      mask.append(use);\n      use.setAttribute(\"href\", `#${pathId}`);\n      use.setAttribute(\"stroke\", \"none\");\n      use.setAttribute(\"fill\", \"black\");\n      use.setAttribute(\"fill-rule\", \"nonzero\");\n      use.classList.add(\"mask\");\n    }\n    const use1 = DrawLayer._svgFactory.createElement(\"use\");\n    root.append(use1);\n    use1.setAttribute(\"href\", `#${pathId}`);\n    if (maskId) {\n      use1.setAttribute(\"mask\", `url(#${maskId})`);\n    }\n    const use2 = use1.cloneNode();\n    root.append(use2);\n    use1.classList.add(\"mainOutline\");\n    use2.classList.add(\"secondaryOutline\");\n    this.updateProperties(root, properties);\n    this.#mapping.set(id, root);\n    return id;\n  }\n  finalizeDraw(id, properties) {\n    this.#toUpdate.delete(id);\n    this.updateProperties(id, properties);\n  }\n  updateProperties(elementOrId, properties) {\n    if (!properties) {\n      return;\n    }\n    const {\n      root,\n      bbox,\n      rootClass,\n      path\n    } = properties;\n    const element = typeof elementOrId === \"number\" ? this.#mapping.get(elementOrId) : elementOrId;\n    if (!element) {\n      return;\n    }\n    if (root) {\n      this.#updateProperties(element, root);\n    }\n    if (bbox) {\n      DrawLayer.#setBox(element, bbox);\n    }\n    if (rootClass) {\n      const {\n        classList\n      } = element;\n      for (const [className, value] of Object.entries(rootClass)) {\n        classList.toggle(className, value);\n      }\n    }\n    if (path) {\n      const defs = element.firstChild;\n      const pathElement = defs.firstChild;\n      this.#updateProperties(pathElement, path);\n    }\n  }\n  updateParent(id, layer) {\n    if (layer === this) {\n      return;\n    }\n    const root = this.#mapping.get(id);\n    if (!root) {\n      return;\n    }\n    layer.#parent.append(root);\n    this.#mapping.delete(id);\n    layer.#mapping.set(id, root);\n  }\n  remove(id) {\n    this.#toUpdate.delete(id);\n    if (this.#parent === null) {\n      return;\n    }\n    this.#mapping.get(id).remove();\n    this.#mapping.delete(id);\n  }\n  destroy() {\n    this.#parent = null;\n    for (const root of this.#mapping.values()) {\n      root.remove();\n    }\n    this.#mapping.clear();\n    this.#toUpdate.clear();\n  }\n}\n\n;// ./src/pdf.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n{\n  globalThis._pdfjsTestingUtils = {\n    HighlightOutliner: HighlightOutliner\n  };\n}\nglobalThis.pdfjsLib = {\n  AbortException: AbortException,\n  AnnotationEditorLayer: AnnotationEditorLayer,\n  AnnotationEditorParamsType: AnnotationEditorParamsType,\n  AnnotationEditorType: AnnotationEditorType,\n  AnnotationEditorUIManager: AnnotationEditorUIManager,\n  AnnotationLayer: AnnotationLayer,\n  AnnotationMode: AnnotationMode,\n  AnnotationType: AnnotationType,\n  build: build,\n  ColorPicker: ColorPicker,\n  createValidAbsoluteUrl: createValidAbsoluteUrl,\n  DOMSVGFactory: DOMSVGFactory,\n  DrawLayer: DrawLayer,\n  FeatureTest: util_FeatureTest,\n  fetchData: fetchData,\n  getDocument: getDocument,\n  getFilenameFromUrl: getFilenameFromUrl,\n  getPdfFilenameFromUrl: getPdfFilenameFromUrl,\n  getRGB: getRGB,\n  getUuid: getUuid,\n  getXfaPageViewport: getXfaPageViewport,\n  GlobalWorkerOptions: GlobalWorkerOptions,\n  ImageKind: util_ImageKind,\n  InvalidPDFException: InvalidPDFException,\n  isDataScheme: isDataScheme,\n  isPdfFile: isPdfFile,\n  isValidExplicitDest: isValidExplicitDest,\n  MathClamp: MathClamp,\n  noContextMenu: noContextMenu,\n  normalizeUnicode: normalizeUnicode,\n  OPS: OPS,\n  OutputScale: OutputScale,\n  PasswordResponses: PasswordResponses,\n  PDFDataRangeTransport: PDFDataRangeTransport,\n  PDFDateString: PDFDateString,\n  PDFWorker: PDFWorker,\n  PermissionFlag: PermissionFlag,\n  PixelsPerInch: PixelsPerInch,\n  RenderingCancelledException: RenderingCancelledException,\n  ResponseException: ResponseException,\n  setLayerDimensions: setLayerDimensions,\n  shadow: shadow,\n  SignatureExtractor: SignatureExtractor,\n  stopEvent: stopEvent,\n  SupportedImageMimeTypes: SupportedImageMimeTypes,\n  TextLayer: TextLayer,\n  TouchManager: TouchManager,\n  updateUrlHash: updateUrlHash,\n  Util: Util,\n  VerbosityLevel: VerbosityLevel,\n  version: version,\n  XfaLayer: XfaLayer\n};\n\n\n\n//# sourceMappingURL=pdf.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGRmanMtZGlzdC9idWlsZC9wZGYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOEJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBLGVBQWUsOEJBQW1CLHdCQUF3Qiw4QkFBbUI7QUFDN0UsbURBQW1ELHdDQUF3QztBQUMzRjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0IsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLElBQUk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsSUFBSTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxXQUFXLEtBQUssT0FBTztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYyxFQUFFLGNBQWMsRUFBRSxjQUFjO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsQ0FBd3BCO0FBQ3h1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isb0NBQW9DLEdBQUc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLEtBQUs7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHFCQUFxQixzQkFBc0IsRUFBRSxZQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsMkJBQTJCLEVBQUUsbUJBQW1CLEVBQUU7QUFDdEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsTUFBTTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNkNBQTZDLFVBQVU7QUFDdkQseUNBQXlDLFdBQVc7QUFDcEQsK0NBQStDLEVBQUUsbUNBQW1DLEVBQUU7QUFDdEYsNENBQTRDLEVBQUUsbUNBQW1DLEVBQUU7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEMsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw4QkFBOEIsUUFBUTtBQUN0Qyx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QixFQUFFLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msd0lBQXdJO0FBQzVLO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhLEdBQUcsV0FBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLElBQUk7QUFDN0U7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sd0JBQXdCLGFBQWEsR0FBRyxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUs7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYSxHQUFHLFdBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxhQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsWUFBWTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUFRRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sb0JBQW9CLHFCQUFxQjtBQUN6QyxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekMsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHFCQUFxQix1Q0FBdUM7QUFDNUQ7QUFDQSx3QkFBd0IseUNBQXlDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1EQUFtRDtBQUMxRTtBQUNBO0FBQ0Esd0JBQXdCLHFEQUFxRDtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhDQUE4QztBQUM1RSwrQkFBK0IsOENBQThDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVDQUF1QztBQUMvRDtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3Qix1Q0FBdUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixJQUFJLEdBQUcsMkJBQTJCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHlDQUF5QyxrQkFBa0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHVDQUF1QyxzQkFBc0IsTUFBTSxHQUFHO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxXQUFXLEVBQUUsc0JBQXNCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTLFdBQVcsRUFBRTtBQUM5RCw4QkFBOEIsZUFBZSxlQUFlLEVBQUUsTUFBTSxLQUFLO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2QkFBNkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZSxTQUFTLHdCQUF3QixFQUFFO0FBQzlFO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZSxnQkFBZ0IsRUFBRSxNQUFNLEtBQUs7QUFDdEUsTUFBTTtBQUNOLGdDQUFnQyw2QkFBNkI7QUFDN0Q7QUFDQSxzQ0FBc0MsNkJBQTZCLElBQUk7QUFDdkU7QUFDQSwwQkFBMEIsZUFBZSw0QkFBNEIsRUFBRSxFQUFFLElBQUksTUFBTSxLQUFLO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixzREFBc0QsR0FBRztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsSUFBSTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxXQUFXO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxZQUFZO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFdBQVc7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx3Q0FBd0MsbUNBQW1DLFdBQVcsSUFBSTtBQUMxRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYyxHQUFHLEdBQUc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWSxnQkFBZ0IsV0FBVztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVEsR0FBRyxRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVksYUFBYSxXQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZLGtCQUFrQixXQUFXO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUSxHQUFHLFFBQVEsR0FBRyxXQUFXLEdBQUcsV0FBVztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWSxPQUFPLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYSxFQUFFLFNBQVM7QUFDM0M7QUFDQSxzREFBc0QsSUFBSTtBQUMxRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQWEsRUFBRSxTQUFTO0FBQzNDO0FBQ0Esc0RBQXNELElBQUk7QUFDMUQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7OztBQU9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsMkZBQWU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxNQUFNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0Isd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxVQUFVO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCLDZDQUE2QyxjQUFjO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0EsSUFBSTtBQUNKLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0EsSUFBSTtBQUNKLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7OztBQU1EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSix1Q0FBdUMsYUFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxLQUFLLEtBQUsscUJBQXFCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVEsRUFBRSxNQUFNLEVBQUUsZ0JBQWdCLEtBQUssU0FBUztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscUJBQXFCO0FBQ3RELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFFBQVE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1Isa0RBQWtELFFBQVE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELEdBQUc7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHNEQUFzRCxHQUFHO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxzREFBc0QsR0FBRztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esc0RBQXNELEdBQUc7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEdBQUc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsR0FBRyxHQUFHLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxREFBcUQsT0FBTztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEVBQUU7QUFDaEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELE9BQU8sMEJBQTBCLElBQUk7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxJQUFJO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxNQUFNLEdBQUcsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxlQUFlLGNBQWMsdUJBQXVCO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFdBQVcsR0FBRyxhQUFhO0FBQ3hFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsZUFBZSxjQUFjLDhCQUE4QjtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsTUFBTTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxnQkFBZ0I7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixvRUFBb0UsMENBQTBDLCtCQUErQixpREFBaUQ7QUFDOUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMENBQTBDO0FBQ25FLHdCQUF3QiwwQ0FBMEM7QUFDbEUsTUFBTTtBQUNOLHlCQUF5QixlQUFlLEVBQUUsZ0JBQWdCO0FBQzFELHdCQUF3QixlQUFlLEVBQUUsZUFBZTtBQUN4RDtBQUNBLDJCQUEyQixlQUFlLEVBQUUsaURBQWlEO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLDhCQUE4QixrQ0FBa0MsSUFBSSxVQUFVO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUIsT0FBTyxVQUFVO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSyxLQUFLLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCRDtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdDQUFnQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsSUFBSSxHQUFHO0FBQzlDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDJFQUEyRSxlQUFlO0FBQzFGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsZUFBZTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxjQUFjO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsS0FBSztBQUNqRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxLQUFLO0FBQzFEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxpQkFBaUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRLFFBQVEsUUFBUSxHQUFHLFFBQVE7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsb0JBQW9CO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQ0FBa0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsQ0FBMEs7QUFDOU8sb0VBQW9FLENBQThDOztBQUVsSCxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekMsb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBLHVDQUF1QyxPQUFPLEVBQUUsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0IsR0FBRyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3Q0FBd0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0NBQXdDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7QUFPRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEVBQUUsSUFBSSxFQUFFLEtBQUssS0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esb0JBQW9CLG9DQUFvQztBQUN4RCxtQkFBbUIsa0RBQWtEO0FBQ3JFO0FBQ0EsdUJBQXVCLHNDQUFzQztBQUM3RCx3QkFBd0IsdUNBQXVDO0FBQy9ELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBaUIseUNBQXlDLGVBQWU7QUFDeEc7QUFDQSxRQUFRO0FBQ1IsK0JBQStCLE1BQU0seUNBQXlDLE9BQU87QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG9CQUFvQixvQ0FBb0M7QUFDeEQsbUJBQW1CLHFDQUFxQztBQUN4RDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQyx3QkFBd0IsMEJBQTBCO0FBQ2xELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0JBQXdCO0FBQ3ZELGdDQUFnQywwQkFBMEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsVUFBVTtBQUNuRTtBQUNBLHdDQUF3QyxVQUFVO0FBQ2xELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLDRDQUE0QyxzSUFBc0ksWUFBWSxrQkFBa0IsWUFBWTtBQUM1TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsRUFBRSxPQUFPLEVBQUUsV0FBVyxVQUFVLFlBQVksV0FBVztBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsR0FBRztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxHQUFHO0FBQzVFO0FBQ0EsOERBQThELEdBQUc7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsR0FBRztBQUMxRTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDhEQUE4RCxHQUFHO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxVQUFVO0FBQ3hEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsaUJBQWlCLEVBQUUsR0FBRztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTix5QkFBeUIsK0JBQStCO0FBQ3hELHdCQUF3QiwrQkFBK0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsV0FBVztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZUFBZTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixvQkFBb0Isa0JBQWtCO0FBQ3RDLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBLHFCQUFxQixFQUFFLEdBQUcsRUFBRTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTLEdBQUcsUUFBUTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVMsR0FBRyxRQUFRO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUyxHQUFHLFFBQVE7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTLEdBQUcsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSwwQ0FBMEMsT0FBTyxFQUFFLE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx1QkFBdUIsd0JBQXdCLGFBQWEsdURBQXVEO0FBQ25IO0FBQ0EsMkNBQTJDLGlDQUFpQyxHQUFHO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsaUJBQWlCLEVBQUUsR0FBRztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLEdBQUc7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7O0FBTUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxLQUFLO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw2QkFBNkIsZUFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0IsRUFBRSxNQUFNLEVBQUUsdUJBQXVCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNkJBQTZCLGVBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxFQUFFLE9BQU87QUFDckMsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBLHdCQUF3QixZQUFZLEVBQUUsV0FBVztBQUNqRCxRQUFRO0FBQ1Isd0JBQXdCLFFBQVEsRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsV0FBVztBQUNyRztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBLHdCQUF3QixlQUFlLEVBQUUsY0FBYztBQUN2RCxRQUFRO0FBQ1Isd0JBQXdCLFdBQVcsRUFBRSxlQUFlLEVBQUUsZUFBZSxFQUFFLGVBQWUsRUFBRSxlQUFlLEVBQUUsY0FBYztBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2QkFBNkIsRUFBRSw4QkFBOEIsR0FBRyw2QkFBNkIsRUFBRSw4QkFBOEIsR0FBRyxVQUFVLEVBQUUsVUFBVSxHQUFHLGFBQWEsRUFBRSxhQUFhLEdBQUcsOEJBQThCLEVBQUUsK0JBQStCLEdBQUcsOEJBQThCLEVBQUUsK0JBQStCO0FBQ3hVO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXLEVBQUUsV0FBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCLEVBQUUsMkJBQTJCLEdBQUcsVUFBVSxFQUFFLFVBQVUsR0FBRyxhQUFhLEVBQUUsYUFBYSxHQUFHLDZCQUE2QixFQUFFLDZCQUE2QjtBQUNsTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCLEVBQUUsaUJBQWlCO0FBQzdELCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0Esd0JBQXdCLHNCQUFzQixFQUFFLHFCQUFxQjtBQUNyRTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQixFQUFFLHNCQUFzQixFQUFFLHNCQUFzQixFQUFFLHNCQUFzQixFQUFFLHNCQUFzQixFQUFFLHFCQUFxQjtBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU8sRUFBRSxNQUFNO0FBQ3JDLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEVBQUU7QUFDNUI7QUFDQSxVQUFVO0FBQ1YsMEJBQTBCLEVBQUU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7OztBQVFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZ0JBQWdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CLElBQUksUUFBUSxFQUFFLFFBQVE7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsK0JBQStCLElBQUksUUFBUSxFQUFFLE9BQU87QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUIsSUFBSSxTQUFTLEVBQUUsUUFBUTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVEsRUFBRSxPQUFPO0FBQ3hDO0FBQ0E7QUFDQSwwREFBMEQsUUFBUTtBQUNsRTtBQUNBLHNCQUFzQixLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLEVBQUU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0JBQXNCLDJCQUEyQixFQUFFLDBCQUEwQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QixFQUFFLDJCQUEyQjtBQUNqRjtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQSx3QkFBd0IsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxFQUFFO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsK0JBQStCLHFCQUFxQixFQUFFLG9CQUFvQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUscUJBQXFCLEVBQUUsb0JBQW9CO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx3QkFBd0IsRUFBRSx1QkFBdUI7QUFDbEYsd0JBQXdCLHdCQUF3QixZQUFZLElBQUksRUFBRSxHQUFHO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUIsRUFBRSxvQkFBb0I7QUFDMUUsc0JBQXNCLHdCQUF3QixRQUFRLEtBQUssRUFBRSxJQUFJLG1CQUFtQiwyQkFBMkIsRUFBRSwwQkFBMEIsVUFBVSxLQUFLLEVBQUUsSUFBSSxtQkFBbUIsNEJBQTRCLEVBQUUsMkJBQTJCO0FBQzVPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaUNBQWlDLHdCQUF3QixFQUFFLHVCQUF1QjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLCtCQUErQix3QkFBd0IsRUFBRSx1QkFBdUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsK0JBQStCLHdCQUF3QixFQUFFLHVCQUF1QjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLCtCQUErQiwyQkFBMkIsRUFBRSwwQkFBMEI7QUFDdEY7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7OztBQU9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0JBQStCLFdBQVcsRUFBRSxZQUFZLEVBQUUsU0FBUyxLQUFLLFdBQVc7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZ0JBQWdCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQ0FBa0M7QUFDMUQ7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1DQUFtQyxFQUFFO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7O0FBUUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxpQkFBaUIsRUFBRSxHQUFHO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7Ozs7O0FBU0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdUJBQXVCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQixRQUFRO0FBQzVCLHFCQUFxQixZQUFZO0FBQ2pDLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWUsR0FBRyxHQUFHO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlLEdBQUcsR0FBRztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZSxHQUFHLEdBQUc7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5MkI7O0FBRXoyQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWR5YnVkZHktYWktbXZwLy4vbm9kZV9tb2R1bGVzL3BkZmpzLWRpc3QvYnVpbGQvcGRmLm1qcz82OWFhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY3N0YXJ0IFRoZSBmb2xsb3dpbmcgaXMgdGhlIGVudGlyZSBsaWNlbnNlIG5vdGljZSBmb3IgdGhlXG4gKiBKYXZhU2NyaXB0IGNvZGUgaW4gdGhpcyBwYWdlXG4gKlxuICogQ29weXJpZ2h0IDIwMjQgTW96aWxsYSBGb3VuZGF0aW9uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBsaWNlbmQgVGhlIGFib3ZlIGlzIHRoZSBlbnRpcmUgbGljZW5zZSBub3RpY2UgZm9yIHRoZVxuICogSmF2YVNjcmlwdCBjb2RlIGluIHRoaXMgcGFnZVxuICovXG5cbi8qKlxuICogcGRmanNWZXJzaW9uID0gNS40LjE0OVxuICogcGRmanNCdWlsZCA9IDllMmU5ZTIwOVxuICovXG4vKioqKioqLyAvLyBUaGUgcmVxdWlyZSBzY29wZVxuLyoqKioqKi8gdmFyIF9fd2VicGFja19yZXF1aXJlX18gPSB7fTtcbi8qKioqKiovIFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIC8qIHdlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyAqL1xuLyoqKioqKi8gKCgpID0+IHtcbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuLyoqKioqKi8gXHRcdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovIH0pKCk7XG4vKioqKioqLyBcbi8qKioqKiovIC8qIHdlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQgKi9cbi8qKioqKiovICgoKSA9PiB7XG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSlcbi8qKioqKiovIH0pKCk7XG4vKioqKioqLyBcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IHt9O1xuXG47Ly8gLi9zcmMvc2hhcmVkL3V0aWwuanNcbmNvbnN0IGlzTm9kZUpTID0gdHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2VzcyArIFwiXCIgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiICYmICFwcm9jZXNzLnZlcnNpb25zLm53ICYmICEocHJvY2Vzcy52ZXJzaW9ucy5lbGVjdHJvbiAmJiBwcm9jZXNzLnR5cGUgJiYgcHJvY2Vzcy50eXBlICE9PSBcImJyb3dzZXJcIik7XG5jb25zdCBGT05UX0lERU5USVRZX01BVFJJWCA9IFswLjAwMSwgMCwgMCwgMC4wMDEsIDAsIDBdO1xuY29uc3QgTElORV9GQUNUT1IgPSAxLjM1O1xuY29uc3QgTElORV9ERVNDRU5UX0ZBQ1RPUiA9IDAuMzU7XG5jb25zdCBCQVNFTElORV9GQUNUT1IgPSBMSU5FX0RFU0NFTlRfRkFDVE9SIC8gTElORV9GQUNUT1I7XG5jb25zdCBSZW5kZXJpbmdJbnRlbnRGbGFnID0ge1xuICBBTlk6IDB4MDEsXG4gIERJU1BMQVk6IDB4MDIsXG4gIFBSSU5UOiAweDA0LFxuICBTQVZFOiAweDA4LFxuICBBTk5PVEFUSU9OU19GT1JNUzogMHgxMCxcbiAgQU5OT1RBVElPTlNfU1RPUkFHRTogMHgyMCxcbiAgQU5OT1RBVElPTlNfRElTQUJMRTogMHg0MCxcbiAgSVNfRURJVElORzogMHg4MCxcbiAgT1BMSVNUOiAweDEwMFxufTtcbmNvbnN0IEFubm90YXRpb25Nb2RlID0ge1xuICBESVNBQkxFOiAwLFxuICBFTkFCTEU6IDEsXG4gIEVOQUJMRV9GT1JNUzogMixcbiAgRU5BQkxFX1NUT1JBR0U6IDNcbn07XG5jb25zdCBBbm5vdGF0aW9uRWRpdG9yUHJlZml4ID0gXCJwZGZqc19pbnRlcm5hbF9lZGl0b3JfXCI7XG5jb25zdCBBbm5vdGF0aW9uRWRpdG9yVHlwZSA9IHtcbiAgRElTQUJMRTogLTEsXG4gIE5PTkU6IDAsXG4gIEZSRUVURVhUOiAzLFxuICBISUdITElHSFQ6IDksXG4gIFNUQU1QOiAxMyxcbiAgSU5LOiAxNSxcbiAgUE9QVVA6IDE2LFxuICBTSUdOQVRVUkU6IDEwMSxcbiAgQ09NTUVOVDogMTAyXG59O1xuY29uc3QgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUgPSB7XG4gIFJFU0laRTogMSxcbiAgQ1JFQVRFOiAyLFxuICBGUkVFVEVYVF9TSVpFOiAxMSxcbiAgRlJFRVRFWFRfQ09MT1I6IDEyLFxuICBGUkVFVEVYVF9PUEFDSVRZOiAxMyxcbiAgSU5LX0NPTE9SOiAyMSxcbiAgSU5LX1RISUNLTkVTUzogMjIsXG4gIElOS19PUEFDSVRZOiAyMyxcbiAgSElHSExJR0hUX0NPTE9SOiAzMSxcbiAgSElHSExJR0hUX1RISUNLTkVTUzogMzIsXG4gIEhJR0hMSUdIVF9GUkVFOiAzMyxcbiAgSElHSExJR0hUX1NIT1dfQUxMOiAzNCxcbiAgRFJBV19TVEVQOiA0MVxufTtcbmNvbnN0IFBlcm1pc3Npb25GbGFnID0ge1xuICBQUklOVDogMHgwNCxcbiAgTU9ESUZZX0NPTlRFTlRTOiAweDA4LFxuICBDT1BZOiAweDEwLFxuICBNT0RJRllfQU5OT1RBVElPTlM6IDB4MjAsXG4gIEZJTExfSU5URVJBQ1RJVkVfRk9STVM6IDB4MTAwLFxuICBDT1BZX0ZPUl9BQ0NFU1NJQklMSVRZOiAweDIwMCxcbiAgQVNTRU1CTEU6IDB4NDAwLFxuICBQUklOVF9ISUdIX1FVQUxJVFk6IDB4ODAwXG59O1xuY29uc3QgVGV4dFJlbmRlcmluZ01vZGUgPSB7XG4gIEZJTEw6IDAsXG4gIFNUUk9LRTogMSxcbiAgRklMTF9TVFJPS0U6IDIsXG4gIElOVklTSUJMRTogMyxcbiAgRklMTF9BRERfVE9fUEFUSDogNCxcbiAgU1RST0tFX0FERF9UT19QQVRIOiA1LFxuICBGSUxMX1NUUk9LRV9BRERfVE9fUEFUSDogNixcbiAgQUREX1RPX1BBVEg6IDcsXG4gIEZJTExfU1RST0tFX01BU0s6IDMsXG4gIEFERF9UT19QQVRIX0ZMQUc6IDRcbn07XG5jb25zdCB1dGlsX0ltYWdlS2luZCA9IHtcbiAgR1JBWVNDQUxFXzFCUFA6IDEsXG4gIFJHQl8yNEJQUDogMixcbiAgUkdCQV8zMkJQUDogM1xufTtcbmNvbnN0IEFubm90YXRpb25UeXBlID0ge1xuICBURVhUOiAxLFxuICBMSU5LOiAyLFxuICBGUkVFVEVYVDogMyxcbiAgTElORTogNCxcbiAgU1FVQVJFOiA1LFxuICBDSVJDTEU6IDYsXG4gIFBPTFlHT046IDcsXG4gIFBPTFlMSU5FOiA4LFxuICBISUdITElHSFQ6IDksXG4gIFVOREVSTElORTogMTAsXG4gIFNRVUlHR0xZOiAxMSxcbiAgU1RSSUtFT1VUOiAxMixcbiAgU1RBTVA6IDEzLFxuICBDQVJFVDogMTQsXG4gIElOSzogMTUsXG4gIFBPUFVQOiAxNixcbiAgRklMRUFUVEFDSE1FTlQ6IDE3LFxuICBTT1VORDogMTgsXG4gIE1PVklFOiAxOSxcbiAgV0lER0VUOiAyMCxcbiAgU0NSRUVOOiAyMSxcbiAgUFJJTlRFUk1BUks6IDIyLFxuICBUUkFQTkVUOiAyMyxcbiAgV0FURVJNQVJLOiAyNCxcbiAgVEhSRUVEOiAyNSxcbiAgUkVEQUNUOiAyNlxufTtcbmNvbnN0IEFubm90YXRpb25SZXBseVR5cGUgPSB7XG4gIEdST1VQOiBcIkdyb3VwXCIsXG4gIFJFUExZOiBcIlJcIlxufTtcbmNvbnN0IEFubm90YXRpb25GbGFnID0ge1xuICBJTlZJU0lCTEU6IDB4MDEsXG4gIEhJRERFTjogMHgwMixcbiAgUFJJTlQ6IDB4MDQsXG4gIE5PWk9PTTogMHgwOCxcbiAgTk9ST1RBVEU6IDB4MTAsXG4gIE5PVklFVzogMHgyMCxcbiAgUkVBRE9OTFk6IDB4NDAsXG4gIExPQ0tFRDogMHg4MCxcbiAgVE9HR0xFTk9WSUVXOiAweDEwMCxcbiAgTE9DS0VEQ09OVEVOVFM6IDB4MjAwXG59O1xuY29uc3QgQW5ub3RhdGlvbkZpZWxkRmxhZyA9IHtcbiAgUkVBRE9OTFk6IDB4MDAwMDAwMSxcbiAgUkVRVUlSRUQ6IDB4MDAwMDAwMixcbiAgTk9FWFBPUlQ6IDB4MDAwMDAwNCxcbiAgTVVMVElMSU5FOiAweDAwMDEwMDAsXG4gIFBBU1NXT1JEOiAweDAwMDIwMDAsXG4gIE5PVE9HR0xFVE9PRkY6IDB4MDAwNDAwMCxcbiAgUkFESU86IDB4MDAwODAwMCxcbiAgUFVTSEJVVFRPTjogMHgwMDEwMDAwLFxuICBDT01CTzogMHgwMDIwMDAwLFxuICBFRElUOiAweDAwNDAwMDAsXG4gIFNPUlQ6IDB4MDA4MDAwMCxcbiAgRklMRVNFTEVDVDogMHgwMTAwMDAwLFxuICBNVUxUSVNFTEVDVDogMHgwMjAwMDAwLFxuICBET05PVFNQRUxMQ0hFQ0s6IDB4MDQwMDAwMCxcbiAgRE9OT1RTQ1JPTEw6IDB4MDgwMDAwMCxcbiAgQ09NQjogMHgxMDAwMDAwLFxuICBSSUNIVEVYVDogMHgyMDAwMDAwLFxuICBSQURJT1NJTlVOSVNPTjogMHgyMDAwMDAwLFxuICBDT01NSVRPTlNFTENIQU5HRTogMHg0MDAwMDAwXG59O1xuY29uc3QgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZSA9IHtcbiAgU09MSUQ6IDEsXG4gIERBU0hFRDogMixcbiAgQkVWRUxFRDogMyxcbiAgSU5TRVQ6IDQsXG4gIFVOREVSTElORTogNVxufTtcbmNvbnN0IEFubm90YXRpb25BY3Rpb25FdmVudFR5cGUgPSB7XG4gIEU6IFwiTW91c2UgRW50ZXJcIixcbiAgWDogXCJNb3VzZSBFeGl0XCIsXG4gIEQ6IFwiTW91c2UgRG93blwiLFxuICBVOiBcIk1vdXNlIFVwXCIsXG4gIEZvOiBcIkZvY3VzXCIsXG4gIEJsOiBcIkJsdXJcIixcbiAgUE86IFwiUGFnZU9wZW5cIixcbiAgUEM6IFwiUGFnZUNsb3NlXCIsXG4gIFBWOiBcIlBhZ2VWaXNpYmxlXCIsXG4gIFBJOiBcIlBhZ2VJbnZpc2libGVcIixcbiAgSzogXCJLZXlzdHJva2VcIixcbiAgRjogXCJGb3JtYXRcIixcbiAgVjogXCJWYWxpZGF0ZVwiLFxuICBDOiBcIkNhbGN1bGF0ZVwiXG59O1xuY29uc3QgRG9jdW1lbnRBY3Rpb25FdmVudFR5cGUgPSB7XG4gIFdDOiBcIldpbGxDbG9zZVwiLFxuICBXUzogXCJXaWxsU2F2ZVwiLFxuICBEUzogXCJEaWRTYXZlXCIsXG4gIFdQOiBcIldpbGxQcmludFwiLFxuICBEUDogXCJEaWRQcmludFwiXG59O1xuY29uc3QgUGFnZUFjdGlvbkV2ZW50VHlwZSA9IHtcbiAgTzogXCJQYWdlT3BlblwiLFxuICBDOiBcIlBhZ2VDbG9zZVwiXG59O1xuY29uc3QgVmVyYm9zaXR5TGV2ZWwgPSB7XG4gIEVSUk9SUzogMCxcbiAgV0FSTklOR1M6IDEsXG4gIElORk9TOiA1XG59O1xuY29uc3QgT1BTID0ge1xuICBkZXBlbmRlbmN5OiAxLFxuICBzZXRMaW5lV2lkdGg6IDIsXG4gIHNldExpbmVDYXA6IDMsXG4gIHNldExpbmVKb2luOiA0LFxuICBzZXRNaXRlckxpbWl0OiA1LFxuICBzZXREYXNoOiA2LFxuICBzZXRSZW5kZXJpbmdJbnRlbnQ6IDcsXG4gIHNldEZsYXRuZXNzOiA4LFxuICBzZXRHU3RhdGU6IDksXG4gIHNhdmU6IDEwLFxuICByZXN0b3JlOiAxMSxcbiAgdHJhbnNmb3JtOiAxMixcbiAgbW92ZVRvOiAxMyxcbiAgbGluZVRvOiAxNCxcbiAgY3VydmVUbzogMTUsXG4gIGN1cnZlVG8yOiAxNixcbiAgY3VydmVUbzM6IDE3LFxuICBjbG9zZVBhdGg6IDE4LFxuICByZWN0YW5nbGU6IDE5LFxuICBzdHJva2U6IDIwLFxuICBjbG9zZVN0cm9rZTogMjEsXG4gIGZpbGw6IDIyLFxuICBlb0ZpbGw6IDIzLFxuICBmaWxsU3Ryb2tlOiAyNCxcbiAgZW9GaWxsU3Ryb2tlOiAyNSxcbiAgY2xvc2VGaWxsU3Ryb2tlOiAyNixcbiAgY2xvc2VFT0ZpbGxTdHJva2U6IDI3LFxuICBlbmRQYXRoOiAyOCxcbiAgY2xpcDogMjksXG4gIGVvQ2xpcDogMzAsXG4gIGJlZ2luVGV4dDogMzEsXG4gIGVuZFRleHQ6IDMyLFxuICBzZXRDaGFyU3BhY2luZzogMzMsXG4gIHNldFdvcmRTcGFjaW5nOiAzNCxcbiAgc2V0SFNjYWxlOiAzNSxcbiAgc2V0TGVhZGluZzogMzYsXG4gIHNldEZvbnQ6IDM3LFxuICBzZXRUZXh0UmVuZGVyaW5nTW9kZTogMzgsXG4gIHNldFRleHRSaXNlOiAzOSxcbiAgbW92ZVRleHQ6IDQwLFxuICBzZXRMZWFkaW5nTW92ZVRleHQ6IDQxLFxuICBzZXRUZXh0TWF0cml4OiA0MixcbiAgbmV4dExpbmU6IDQzLFxuICBzaG93VGV4dDogNDQsXG4gIHNob3dTcGFjZWRUZXh0OiA0NSxcbiAgbmV4dExpbmVTaG93VGV4dDogNDYsXG4gIG5leHRMaW5lU2V0U3BhY2luZ1Nob3dUZXh0OiA0NyxcbiAgc2V0Q2hhcldpZHRoOiA0OCxcbiAgc2V0Q2hhcldpZHRoQW5kQm91bmRzOiA0OSxcbiAgc2V0U3Ryb2tlQ29sb3JTcGFjZTogNTAsXG4gIHNldEZpbGxDb2xvclNwYWNlOiA1MSxcbiAgc2V0U3Ryb2tlQ29sb3I6IDUyLFxuICBzZXRTdHJva2VDb2xvck46IDUzLFxuICBzZXRGaWxsQ29sb3I6IDU0LFxuICBzZXRGaWxsQ29sb3JOOiA1NSxcbiAgc2V0U3Ryb2tlR3JheTogNTYsXG4gIHNldEZpbGxHcmF5OiA1NyxcbiAgc2V0U3Ryb2tlUkdCQ29sb3I6IDU4LFxuICBzZXRGaWxsUkdCQ29sb3I6IDU5LFxuICBzZXRTdHJva2VDTVlLQ29sb3I6IDYwLFxuICBzZXRGaWxsQ01ZS0NvbG9yOiA2MSxcbiAgc2hhZGluZ0ZpbGw6IDYyLFxuICBiZWdpbklubGluZUltYWdlOiA2MyxcbiAgYmVnaW5JbWFnZURhdGE6IDY0LFxuICBlbmRJbmxpbmVJbWFnZTogNjUsXG4gIHBhaW50WE9iamVjdDogNjYsXG4gIG1hcmtQb2ludDogNjcsXG4gIG1hcmtQb2ludFByb3BzOiA2OCxcbiAgYmVnaW5NYXJrZWRDb250ZW50OiA2OSxcbiAgYmVnaW5NYXJrZWRDb250ZW50UHJvcHM6IDcwLFxuICBlbmRNYXJrZWRDb250ZW50OiA3MSxcbiAgYmVnaW5Db21wYXQ6IDcyLFxuICBlbmRDb21wYXQ6IDczLFxuICBwYWludEZvcm1YT2JqZWN0QmVnaW46IDc0LFxuICBwYWludEZvcm1YT2JqZWN0RW5kOiA3NSxcbiAgYmVnaW5Hcm91cDogNzYsXG4gIGVuZEdyb3VwOiA3NyxcbiAgYmVnaW5Bbm5vdGF0aW9uOiA4MCxcbiAgZW5kQW5ub3RhdGlvbjogODEsXG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdDogODMsXG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwOiA4NCxcbiAgcGFpbnRJbWFnZVhPYmplY3Q6IDg1LFxuICBwYWludElubGluZUltYWdlWE9iamVjdDogODYsXG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXA6IDg3LFxuICBwYWludEltYWdlWE9iamVjdFJlcGVhdDogODgsXG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdFJlcGVhdDogODksXG4gIHBhaW50U29saWRDb2xvckltYWdlTWFzazogOTAsXG4gIGNvbnN0cnVjdFBhdGg6IDkxLFxuICBzZXRTdHJva2VUcmFuc3BhcmVudDogOTIsXG4gIHNldEZpbGxUcmFuc3BhcmVudDogOTMsXG4gIHJhd0ZpbGxQYXRoOiA5NFxufTtcbmNvbnN0IERyYXdPUFMgPSB7XG4gIG1vdmVUbzogMCxcbiAgbGluZVRvOiAxLFxuICBjdXJ2ZVRvOiAyLFxuICBjbG9zZVBhdGg6IDNcbn07XG5jb25zdCBQYXNzd29yZFJlc3BvbnNlcyA9IHtcbiAgTkVFRF9QQVNTV09SRDogMSxcbiAgSU5DT1JSRUNUX1BBU1NXT1JEOiAyXG59O1xubGV0IHZlcmJvc2l0eSA9IFZlcmJvc2l0eUxldmVsLldBUk5JTkdTO1xuZnVuY3Rpb24gc2V0VmVyYm9zaXR5TGV2ZWwobGV2ZWwpIHtcbiAgaWYgKE51bWJlci5pc0ludGVnZXIobGV2ZWwpKSB7XG4gICAgdmVyYm9zaXR5ID0gbGV2ZWw7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFZlcmJvc2l0eUxldmVsKCkge1xuICByZXR1cm4gdmVyYm9zaXR5O1xufVxuZnVuY3Rpb24gaW5mbyhtc2cpIHtcbiAgaWYgKHZlcmJvc2l0eSA+PSBWZXJib3NpdHlMZXZlbC5JTkZPUykge1xuICAgIGNvbnNvbGUubG9nKGBJbmZvOiAke21zZ31gKTtcbiAgfVxufVxuZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgaWYgKHZlcmJvc2l0eSA+PSBWZXJib3NpdHlMZXZlbC5XQVJOSU5HUykge1xuICAgIGNvbnNvbGUubG9nKGBXYXJuaW5nOiAke21zZ31gKTtcbiAgfVxufVxuZnVuY3Rpb24gdW5yZWFjaGFibGUobXNnKSB7XG4gIHRocm93IG5ldyBFcnJvcihtc2cpO1xufVxuZnVuY3Rpb24gYXNzZXJ0KGNvbmQsIG1zZykge1xuICBpZiAoIWNvbmQpIHtcbiAgICB1bnJlYWNoYWJsZShtc2cpO1xuICB9XG59XG5mdW5jdGlvbiBfaXNWYWxpZFByb3RvY29sKHVybCkge1xuICBzd2l0Y2ggKHVybD8ucHJvdG9jb2wpIHtcbiAgICBjYXNlIFwiaHR0cDpcIjpcbiAgICBjYXNlIFwiaHR0cHM6XCI6XG4gICAgY2FzZSBcImZ0cDpcIjpcbiAgICBjYXNlIFwibWFpbHRvOlwiOlxuICAgIGNhc2UgXCJ0ZWw6XCI6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVWYWxpZEFic29sdXRlVXJsKHVybCwgYmFzZVVybCA9IG51bGwsIG9wdGlvbnMgPSBudWxsKSB7XG4gIGlmICghdXJsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIHVybCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChvcHRpb25zLmFkZERlZmF1bHRQcm90b2NvbCAmJiB1cmwuc3RhcnRzV2l0aChcInd3dy5cIikpIHtcbiAgICAgIGNvbnN0IGRvdHMgPSB1cmwubWF0Y2goL1xcLi9nKTtcbiAgICAgIGlmIChkb3RzPy5sZW5ndGggPj0gMikge1xuICAgICAgICB1cmwgPSBgaHR0cDovLyR7dXJsfWA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRyeUNvbnZlcnRFbmNvZGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdXJsID0gc3RyaW5nVG9VVEY4U3RyaW5nKHVybCk7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfVxuICB9XG4gIGNvbnN0IGFic29sdXRlVXJsID0gYmFzZVVybCA/IFVSTC5wYXJzZSh1cmwsIGJhc2VVcmwpIDogVVJMLnBhcnNlKHVybCk7XG4gIHJldHVybiBfaXNWYWxpZFByb3RvY29sKGFic29sdXRlVXJsKSA/IGFic29sdXRlVXJsIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVVybEhhc2godXJsLCBoYXNoLCBhbGxvd1JlbCA9IGZhbHNlKSB7XG4gIGNvbnN0IHJlcyA9IFVSTC5wYXJzZSh1cmwpO1xuICBpZiAocmVzKSB7XG4gICAgcmVzLmhhc2ggPSBoYXNoO1xuICAgIHJldHVybiByZXMuaHJlZjtcbiAgfVxuICBpZiAoYWxsb3dSZWwgJiYgY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCh1cmwsIFwiaHR0cDovL2V4YW1wbGUuY29tXCIpKSB7XG4gICAgcmV0dXJuIHVybC5zcGxpdChcIiNcIiwgMSlbMF0gKyBgJHtoYXNoID8gYCMke2hhc2h9YCA6IFwiXCJ9YDtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cbmZ1bmN0aW9uIHNoYWRvdyhvYmosIHByb3AsIHZhbHVlLCBub25TZXJpYWxpemFibGUgPSBmYWxzZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG4gICAgdmFsdWUsXG4gICAgZW51bWVyYWJsZTogIW5vblNlcmlhbGl6YWJsZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCBCYXNlRXhjZXB0aW9uID0gZnVuY3Rpb24gQmFzZUV4Y2VwdGlvbkNsb3N1cmUoKSB7XG4gIGZ1bmN0aW9uIEJhc2VFeGNlcHRpb24obWVzc2FnZSwgbmFtZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgfVxuICBCYXNlRXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICBCYXNlRXhjZXB0aW9uLmNvbnN0cnVjdG9yID0gQmFzZUV4Y2VwdGlvbjtcbiAgcmV0dXJuIEJhc2VFeGNlcHRpb247XG59KCk7XG5jbGFzcyBQYXNzd29yZEV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIGNvZGUpIHtcbiAgICBzdXBlcihtc2csIFwiUGFzc3dvcmRFeGNlcHRpb25cIik7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgfVxufVxuY2xhc3MgVW5rbm93bkVycm9yRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgZGV0YWlscykge1xuICAgIHN1cGVyKG1zZywgXCJVbmtub3duRXJyb3JFeGNlcHRpb25cIik7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufVxuY2xhc3MgSW52YWxpZFBERkV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICBzdXBlcihtc2csIFwiSW52YWxpZFBERkV4Y2VwdGlvblwiKTtcbiAgfVxufVxuY2xhc3MgUmVzcG9uc2VFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnLCBzdGF0dXMsIG1pc3NpbmcpIHtcbiAgICBzdXBlcihtc2csIFwiUmVzcG9uc2VFeGNlcHRpb25cIik7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5taXNzaW5nID0gbWlzc2luZztcbiAgfVxufVxuY2xhc3MgRm9ybWF0RXJyb3IgZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgc3VwZXIobXNnLCBcIkZvcm1hdEVycm9yXCIpO1xuICB9XG59XG5jbGFzcyBBYm9ydEV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICBzdXBlcihtc2csIFwiQWJvcnRFeGNlcHRpb25cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGJ5dGVzVG9TdHJpbmcoYnl0ZXMpIHtcbiAgaWYgKHR5cGVvZiBieXRlcyAhPT0gXCJvYmplY3RcIiB8fCBieXRlcz8ubGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICB1bnJlYWNoYWJsZShcIkludmFsaWQgYXJndW1lbnQgZm9yIGJ5dGVzVG9TdHJpbmdcIik7XG4gIH1cbiAgY29uc3QgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICBjb25zdCBNQVhfQVJHVU1FTlRfQ09VTlQgPSA4MTkyO1xuICBpZiAobGVuZ3RoIDwgTUFYX0FSR1VNRU5UX0NPVU5UKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnl0ZXMpO1xuICB9XG4gIGNvbnN0IHN0ckJ1ZiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBNQVhfQVJHVU1FTlRfQ09VTlQpIHtcbiAgICBjb25zdCBjaHVua0VuZCA9IE1hdGgubWluKGkgKyBNQVhfQVJHVU1FTlRfQ09VTlQsIGxlbmd0aCk7XG4gICAgY29uc3QgY2h1bmsgPSBieXRlcy5zdWJhcnJheShpLCBjaHVua0VuZCk7XG4gICAgc3RyQnVmLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjaHVuaykpO1xuICB9XG4gIHJldHVybiBzdHJCdWYuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdW5yZWFjaGFibGUoXCJJbnZhbGlkIGFyZ3VtZW50IGZvciBzdHJpbmdUb0J5dGVzXCIpO1xuICB9XG4gIGNvbnN0IGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGJ5dGVzW2ldID0gc3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmO1xuICB9XG4gIHJldHVybiBieXRlcztcbn1cbmZ1bmN0aW9uIHN0cmluZzMyKHZhbHVlKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHZhbHVlID4+IDI0ICYgMHhmZiwgdmFsdWUgPj4gMTYgJiAweGZmLCB2YWx1ZSA+PiA4ICYgMHhmZiwgdmFsdWUgJiAweGZmKTtcbn1cbmZ1bmN0aW9uIG9iamVjdFNpemUob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGlzTGl0dGxlRW5kaWFuKCkge1xuICBjb25zdCBidWZmZXI4ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gIGJ1ZmZlcjhbMF0gPSAxO1xuICBjb25zdCB2aWV3MzIgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyOC5idWZmZXIsIDAsIDEpO1xuICByZXR1cm4gdmlldzMyWzBdID09PSAxO1xufVxuZnVuY3Rpb24gaXNFdmFsU3VwcG9ydGVkKCkge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbihcIlwiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5jbGFzcyB1dGlsX0ZlYXR1cmVUZXN0IHtcbiAgc3RhdGljIGdldCBpc0xpdHRsZUVuZGlhbigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNMaXR0bGVFbmRpYW5cIiwgaXNMaXR0bGVFbmRpYW4oKSk7XG4gIH1cbiAgc3RhdGljIGdldCBpc0V2YWxTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzRXZhbFN1cHBvcnRlZFwiLCBpc0V2YWxTdXBwb3J0ZWQoKSk7XG4gIH1cbiAgc3RhdGljIGdldCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWRcIiwgdHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gXCJ1bmRlZmluZWRcIik7XG4gIH1cbiAgc3RhdGljIGdldCBpc0ltYWdlRGVjb2RlclN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNJbWFnZURlY29kZXJTdXBwb3J0ZWRcIiwgdHlwZW9mIEltYWdlRGVjb2RlciAhPT0gXCJ1bmRlZmluZWRcIik7XG4gIH1cbiAgc3RhdGljIGdldCBwbGF0Zm9ybSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIHVzZXJBZ2VudFxuICAgIH0gPSBuYXZpZ2F0b3I7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcInBsYXRmb3JtXCIsIHtcbiAgICAgIGlzQW5kcm9pZDogdXNlckFnZW50LmluY2x1ZGVzKFwiQW5kcm9pZFwiKSxcbiAgICAgIGlzTGludXg6IHBsYXRmb3JtLmluY2x1ZGVzKFwiTGludXhcIiksXG4gICAgICBpc01hYzogcGxhdGZvcm0uaW5jbHVkZXMoXCJNYWNcIiksXG4gICAgICBpc1dpbmRvd3M6IHBsYXRmb3JtLmluY2x1ZGVzKFwiV2luXCIpLFxuICAgICAgaXNGaXJlZm94OiB1c2VyQWdlbnQuaW5jbHVkZXMoXCJGaXJlZm94XCIpXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldCBpc0NTU1JvdW5kU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0NTU1JvdW5kU3VwcG9ydGVkXCIsIGdsb2JhbFRoaXMuQ1NTPy5zdXBwb3J0cz8uKFwid2lkdGg6IHJvdW5kKDEuNXB4LCAxcHgpXCIpKTtcbiAgfVxufVxuY29uc3QgaGV4TnVtYmVycyA9IEFycmF5LmZyb20oQXJyYXkoMjU2KS5rZXlzKCksIG4gPT4gbi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKTtcbmNsYXNzIFV0aWwge1xuICBzdGF0aWMgbWFrZUhleENvbG9yKHIsIGcsIGIpIHtcbiAgICByZXR1cm4gYCMke2hleE51bWJlcnNbcl19JHtoZXhOdW1iZXJzW2ddfSR7aGV4TnVtYmVyc1tiXX1gO1xuICB9XG4gIHN0YXRpYyBkb21NYXRyaXhUb1RyYW5zZm9ybShkbSkge1xuICAgIHJldHVybiBbZG0uYSwgZG0uYiwgZG0uYywgZG0uZCwgZG0uZSwgZG0uZl07XG4gIH1cbiAgc3RhdGljIHNjYWxlTWluTWF4KHRyYW5zZm9ybSwgbWluTWF4KSB7XG4gICAgbGV0IHRlbXA7XG4gICAgaWYgKHRyYW5zZm9ybVswXSkge1xuICAgICAgaWYgKHRyYW5zZm9ybVswXSA8IDApIHtcbiAgICAgICAgdGVtcCA9IG1pbk1heFswXTtcbiAgICAgICAgbWluTWF4WzBdID0gbWluTWF4WzJdO1xuICAgICAgICBtaW5NYXhbMl0gPSB0ZW1wO1xuICAgICAgfVxuICAgICAgbWluTWF4WzBdICo9IHRyYW5zZm9ybVswXTtcbiAgICAgIG1pbk1heFsyXSAqPSB0cmFuc2Zvcm1bMF07XG4gICAgICBpZiAodHJhbnNmb3JtWzNdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzFdO1xuICAgICAgICBtaW5NYXhbMV0gPSBtaW5NYXhbM107XG4gICAgICAgIG1pbk1heFszXSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBtaW5NYXhbMV0gKj0gdHJhbnNmb3JtWzNdO1xuICAgICAgbWluTWF4WzNdICo9IHRyYW5zZm9ybVszXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGVtcCA9IG1pbk1heFswXTtcbiAgICAgIG1pbk1heFswXSA9IG1pbk1heFsxXTtcbiAgICAgIG1pbk1heFsxXSA9IHRlbXA7XG4gICAgICB0ZW1wID0gbWluTWF4WzJdO1xuICAgICAgbWluTWF4WzJdID0gbWluTWF4WzNdO1xuICAgICAgbWluTWF4WzNdID0gdGVtcDtcbiAgICAgIGlmICh0cmFuc2Zvcm1bMV0gPCAwKSB7XG4gICAgICAgIHRlbXAgPSBtaW5NYXhbMV07XG4gICAgICAgIG1pbk1heFsxXSA9IG1pbk1heFszXTtcbiAgICAgICAgbWluTWF4WzNdID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIG1pbk1heFsxXSAqPSB0cmFuc2Zvcm1bMV07XG4gICAgICBtaW5NYXhbM10gKj0gdHJhbnNmb3JtWzFdO1xuICAgICAgaWYgKHRyYW5zZm9ybVsyXSA8IDApIHtcbiAgICAgICAgdGVtcCA9IG1pbk1heFswXTtcbiAgICAgICAgbWluTWF4WzBdID0gbWluTWF4WzJdO1xuICAgICAgICBtaW5NYXhbMl0gPSB0ZW1wO1xuICAgICAgfVxuICAgICAgbWluTWF4WzBdICo9IHRyYW5zZm9ybVsyXTtcbiAgICAgIG1pbk1heFsyXSAqPSB0cmFuc2Zvcm1bMl07XG4gICAgfVxuICAgIG1pbk1heFswXSArPSB0cmFuc2Zvcm1bNF07XG4gICAgbWluTWF4WzFdICs9IHRyYW5zZm9ybVs1XTtcbiAgICBtaW5NYXhbMl0gKz0gdHJhbnNmb3JtWzRdO1xuICAgIG1pbk1heFszXSArPSB0cmFuc2Zvcm1bNV07XG4gIH1cbiAgc3RhdGljIHRyYW5zZm9ybShtMSwgbTIpIHtcbiAgICByZXR1cm4gW20xWzBdICogbTJbMF0gKyBtMVsyXSAqIG0yWzFdLCBtMVsxXSAqIG0yWzBdICsgbTFbM10gKiBtMlsxXSwgbTFbMF0gKiBtMlsyXSArIG0xWzJdICogbTJbM10sIG0xWzFdICogbTJbMl0gKyBtMVszXSAqIG0yWzNdLCBtMVswXSAqIG0yWzRdICsgbTFbMl0gKiBtMls1XSArIG0xWzRdLCBtMVsxXSAqIG0yWzRdICsgbTFbM10gKiBtMls1XSArIG0xWzVdXTtcbiAgfVxuICBzdGF0aWMgbXVsdGlwbHlCeURPTU1hdHJpeChtLCBtZCkge1xuICAgIHJldHVybiBbbVswXSAqIG1kLmEgKyBtWzJdICogbWQuYiwgbVsxXSAqIG1kLmEgKyBtWzNdICogbWQuYiwgbVswXSAqIG1kLmMgKyBtWzJdICogbWQuZCwgbVsxXSAqIG1kLmMgKyBtWzNdICogbWQuZCwgbVswXSAqIG1kLmUgKyBtWzJdICogbWQuZiArIG1bNF0sIG1bMV0gKiBtZC5lICsgbVszXSAqIG1kLmYgKyBtWzVdXTtcbiAgfVxuICBzdGF0aWMgYXBwbHlUcmFuc2Zvcm0ocCwgbSwgcG9zID0gMCkge1xuICAgIGNvbnN0IHAwID0gcFtwb3NdO1xuICAgIGNvbnN0IHAxID0gcFtwb3MgKyAxXTtcbiAgICBwW3Bvc10gPSBwMCAqIG1bMF0gKyBwMSAqIG1bMl0gKyBtWzRdO1xuICAgIHBbcG9zICsgMV0gPSBwMCAqIG1bMV0gKyBwMSAqIG1bM10gKyBtWzVdO1xuICB9XG4gIHN0YXRpYyBhcHBseVRyYW5zZm9ybVRvQmV6aWVyKHAsIHRyYW5zZm9ybSwgcG9zID0gMCkge1xuICAgIGNvbnN0IG0wID0gdHJhbnNmb3JtWzBdO1xuICAgIGNvbnN0IG0xID0gdHJhbnNmb3JtWzFdO1xuICAgIGNvbnN0IG0yID0gdHJhbnNmb3JtWzJdO1xuICAgIGNvbnN0IG0zID0gdHJhbnNmb3JtWzNdO1xuICAgIGNvbnN0IG00ID0gdHJhbnNmb3JtWzRdO1xuICAgIGNvbnN0IG01ID0gdHJhbnNmb3JtWzVdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSArPSAyKSB7XG4gICAgICBjb25zdCBwSSA9IHBbcG9zICsgaV07XG4gICAgICBjb25zdCBwSTEgPSBwW3BvcyArIGkgKyAxXTtcbiAgICAgIHBbcG9zICsgaV0gPSBwSSAqIG0wICsgcEkxICogbTIgKyBtNDtcbiAgICAgIHBbcG9zICsgaSArIDFdID0gcEkgKiBtMSArIHBJMSAqIG0zICsgbTU7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBhcHBseUludmVyc2VUcmFuc2Zvcm0ocCwgbSkge1xuICAgIGNvbnN0IHAwID0gcFswXTtcbiAgICBjb25zdCBwMSA9IHBbMV07XG4gICAgY29uc3QgZCA9IG1bMF0gKiBtWzNdIC0gbVsxXSAqIG1bMl07XG4gICAgcFswXSA9IChwMCAqIG1bM10gLSBwMSAqIG1bMl0gKyBtWzJdICogbVs1XSAtIG1bNF0gKiBtWzNdKSAvIGQ7XG4gICAgcFsxXSA9ICgtcDAgKiBtWzFdICsgcDEgKiBtWzBdICsgbVs0XSAqIG1bMV0gLSBtWzVdICogbVswXSkgLyBkO1xuICB9XG4gIHN0YXRpYyBheGlhbEFsaWduZWRCb3VuZGluZ0JveChyZWN0LCB0cmFuc2Zvcm0sIG91dHB1dCkge1xuICAgIGNvbnN0IG0wID0gdHJhbnNmb3JtWzBdO1xuICAgIGNvbnN0IG0xID0gdHJhbnNmb3JtWzFdO1xuICAgIGNvbnN0IG0yID0gdHJhbnNmb3JtWzJdO1xuICAgIGNvbnN0IG0zID0gdHJhbnNmb3JtWzNdO1xuICAgIGNvbnN0IG00ID0gdHJhbnNmb3JtWzRdO1xuICAgIGNvbnN0IG01ID0gdHJhbnNmb3JtWzVdO1xuICAgIGNvbnN0IHIwID0gcmVjdFswXTtcbiAgICBjb25zdCByMSA9IHJlY3RbMV07XG4gICAgY29uc3QgcjIgPSByZWN0WzJdO1xuICAgIGNvbnN0IHIzID0gcmVjdFszXTtcbiAgICBsZXQgYTAgPSBtMCAqIHIwICsgbTQ7XG4gICAgbGV0IGEyID0gYTA7XG4gICAgbGV0IGExID0gbTAgKiByMiArIG00O1xuICAgIGxldCBhMyA9IGExO1xuICAgIGxldCBiMCA9IG0zICogcjEgKyBtNTtcbiAgICBsZXQgYjIgPSBiMDtcbiAgICBsZXQgYjEgPSBtMyAqIHIzICsgbTU7XG4gICAgbGV0IGIzID0gYjE7XG4gICAgaWYgKG0xICE9PSAwIHx8IG0yICE9PSAwKSB7XG4gICAgICBjb25zdCBtMXIwID0gbTEgKiByMDtcbiAgICAgIGNvbnN0IG0xcjIgPSBtMSAqIHIyO1xuICAgICAgY29uc3QgbTJyMSA9IG0yICogcjE7XG4gICAgICBjb25zdCBtMnIzID0gbTIgKiByMztcbiAgICAgIGEwICs9IG0ycjE7XG4gICAgICBhMyArPSBtMnIxO1xuICAgICAgYTEgKz0gbTJyMztcbiAgICAgIGEyICs9IG0ycjM7XG4gICAgICBiMCArPSBtMXIwO1xuICAgICAgYjMgKz0gbTFyMDtcbiAgICAgIGIxICs9IG0xcjI7XG4gICAgICBiMiArPSBtMXIyO1xuICAgIH1cbiAgICBvdXRwdXRbMF0gPSBNYXRoLm1pbihvdXRwdXRbMF0sIGEwLCBhMSwgYTIsIGEzKTtcbiAgICBvdXRwdXRbMV0gPSBNYXRoLm1pbihvdXRwdXRbMV0sIGIwLCBiMSwgYjIsIGIzKTtcbiAgICBvdXRwdXRbMl0gPSBNYXRoLm1heChvdXRwdXRbMl0sIGEwLCBhMSwgYTIsIGEzKTtcbiAgICBvdXRwdXRbM10gPSBNYXRoLm1heChvdXRwdXRbM10sIGIwLCBiMSwgYjIsIGIzKTtcbiAgfVxuICBzdGF0aWMgaW52ZXJzZVRyYW5zZm9ybShtKSB7XG4gICAgY29uc3QgZCA9IG1bMF0gKiBtWzNdIC0gbVsxXSAqIG1bMl07XG4gICAgcmV0dXJuIFttWzNdIC8gZCwgLW1bMV0gLyBkLCAtbVsyXSAvIGQsIG1bMF0gLyBkLCAobVsyXSAqIG1bNV0gLSBtWzRdICogbVszXSkgLyBkLCAobVs0XSAqIG1bMV0gLSBtWzVdICogbVswXSkgLyBkXTtcbiAgfVxuICBzdGF0aWMgc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUobWF0cml4LCBvdXRwdXQpIHtcbiAgICBjb25zdCBtMCA9IG1hdHJpeFswXTtcbiAgICBjb25zdCBtMSA9IG1hdHJpeFsxXTtcbiAgICBjb25zdCBtMiA9IG1hdHJpeFsyXTtcbiAgICBjb25zdCBtMyA9IG1hdHJpeFszXTtcbiAgICBjb25zdCBhID0gbTAgKiogMiArIG0xICoqIDI7XG4gICAgY29uc3QgYiA9IG0wICogbTIgKyBtMSAqIG0zO1xuICAgIGNvbnN0IGMgPSBtMiAqKiAyICsgbTMgKiogMjtcbiAgICBjb25zdCBmaXJzdCA9IChhICsgYykgLyAyO1xuICAgIGNvbnN0IHNlY29uZCA9IE1hdGguc3FydChmaXJzdCAqKiAyIC0gKGEgKiBjIC0gYiAqKiAyKSk7XG4gICAgb3V0cHV0WzBdID0gTWF0aC5zcXJ0KGZpcnN0ICsgc2Vjb25kIHx8IDEpO1xuICAgIG91dHB1dFsxXSA9IE1hdGguc3FydChmaXJzdCAtIHNlY29uZCB8fCAxKTtcbiAgfVxuICBzdGF0aWMgbm9ybWFsaXplUmVjdChyZWN0KSB7XG4gICAgY29uc3QgciA9IHJlY3Quc2xpY2UoMCk7XG4gICAgaWYgKHJlY3RbMF0gPiByZWN0WzJdKSB7XG4gICAgICByWzBdID0gcmVjdFsyXTtcbiAgICAgIHJbMl0gPSByZWN0WzBdO1xuICAgIH1cbiAgICBpZiAocmVjdFsxXSA+IHJlY3RbM10pIHtcbiAgICAgIHJbMV0gPSByZWN0WzNdO1xuICAgICAgclszXSA9IHJlY3RbMV07XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHN0YXRpYyBpbnRlcnNlY3QocmVjdDEsIHJlY3QyKSB7XG4gICAgY29uc3QgeExvdyA9IE1hdGgubWF4KE1hdGgubWluKHJlY3QxWzBdLCByZWN0MVsyXSksIE1hdGgubWluKHJlY3QyWzBdLCByZWN0MlsyXSkpO1xuICAgIGNvbnN0IHhIaWdoID0gTWF0aC5taW4oTWF0aC5tYXgocmVjdDFbMF0sIHJlY3QxWzJdKSwgTWF0aC5tYXgocmVjdDJbMF0sIHJlY3QyWzJdKSk7XG4gICAgaWYgKHhMb3cgPiB4SGlnaCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHlMb3cgPSBNYXRoLm1heChNYXRoLm1pbihyZWN0MVsxXSwgcmVjdDFbM10pLCBNYXRoLm1pbihyZWN0MlsxXSwgcmVjdDJbM10pKTtcbiAgICBjb25zdCB5SGlnaCA9IE1hdGgubWluKE1hdGgubWF4KHJlY3QxWzFdLCByZWN0MVszXSksIE1hdGgubWF4KHJlY3QyWzFdLCByZWN0MlszXSkpO1xuICAgIGlmICh5TG93ID4geUhpZ2gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gW3hMb3csIHlMb3csIHhIaWdoLCB5SGlnaF07XG4gIH1cbiAgc3RhdGljIHBvaW50Qm91bmRpbmdCb3goeCwgeSwgbWluTWF4KSB7XG4gICAgbWluTWF4WzBdID0gTWF0aC5taW4obWluTWF4WzBdLCB4KTtcbiAgICBtaW5NYXhbMV0gPSBNYXRoLm1pbihtaW5NYXhbMV0sIHkpO1xuICAgIG1pbk1heFsyXSA9IE1hdGgubWF4KG1pbk1heFsyXSwgeCk7XG4gICAgbWluTWF4WzNdID0gTWF0aC5tYXgobWluTWF4WzNdLCB5KTtcbiAgfVxuICBzdGF0aWMgcmVjdEJvdW5kaW5nQm94KHgwLCB5MCwgeDEsIHkxLCBtaW5NYXgpIHtcbiAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIHgwLCB4MSk7XG4gICAgbWluTWF4WzFdID0gTWF0aC5taW4obWluTWF4WzFdLCB5MCwgeTEpO1xuICAgIG1pbk1heFsyXSA9IE1hdGgubWF4KG1pbk1heFsyXSwgeDAsIHgxKTtcbiAgICBtaW5NYXhbM10gPSBNYXRoLm1heChtaW5NYXhbM10sIHkwLCB5MSk7XG4gIH1cbiAgc3RhdGljICNnZXRFeHRyZW11bU9uQ3VydmUoeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCB0LCBtaW5NYXgpIHtcbiAgICBpZiAodCA8PSAwIHx8IHQgPj0gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtdCA9IDEgLSB0O1xuICAgIGNvbnN0IHR0ID0gdCAqIHQ7XG4gICAgY29uc3QgdHR0ID0gdHQgKiB0O1xuICAgIGNvbnN0IHggPSBtdCAqIChtdCAqIChtdCAqIHgwICsgMyAqIHQgKiB4MSkgKyAzICogdHQgKiB4MikgKyB0dHQgKiB4MztcbiAgICBjb25zdCB5ID0gbXQgKiAobXQgKiAobXQgKiB5MCArIDMgKiB0ICogeTEpICsgMyAqIHR0ICogeTIpICsgdHR0ICogeTM7XG4gICAgbWluTWF4WzBdID0gTWF0aC5taW4obWluTWF4WzBdLCB4KTtcbiAgICBtaW5NYXhbMV0gPSBNYXRoLm1pbihtaW5NYXhbMV0sIHkpO1xuICAgIG1pbk1heFsyXSA9IE1hdGgubWF4KG1pbk1heFsyXSwgeCk7XG4gICAgbWluTWF4WzNdID0gTWF0aC5tYXgobWluTWF4WzNdLCB5KTtcbiAgfVxuICBzdGF0aWMgI2dldEV4dHJlbXVtKHgwLCB4MSwgeDIsIHgzLCB5MCwgeTEsIHkyLCB5MywgYSwgYiwgYywgbWluTWF4KSB7XG4gICAgaWYgKE1hdGguYWJzKGEpIDwgMWUtMTIpIHtcbiAgICAgIGlmIChNYXRoLmFicyhiKSA+PSAxZS0xMikge1xuICAgICAgICB0aGlzLiNnZXRFeHRyZW11bU9uQ3VydmUoeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCAtYyAvIGIsIG1pbk1heCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRlbHRhID0gYiAqKiAyIC0gNCAqIGMgKiBhO1xuICAgIGlmIChkZWx0YSA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3FydERlbHRhID0gTWF0aC5zcXJ0KGRlbHRhKTtcbiAgICBjb25zdCBhMiA9IDIgKiBhO1xuICAgIHRoaXMuI2dldEV4dHJlbXVtT25DdXJ2ZSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsICgtYiArIHNxcnREZWx0YSkgLyBhMiwgbWluTWF4KTtcbiAgICB0aGlzLiNnZXRFeHRyZW11bU9uQ3VydmUoeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCAoLWIgLSBzcXJ0RGVsdGEpIC8gYTIsIG1pbk1heCk7XG4gIH1cbiAgc3RhdGljIGJlemllckJvdW5kaW5nQm94KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgbWluTWF4KSB7XG4gICAgbWluTWF4WzBdID0gTWF0aC5taW4obWluTWF4WzBdLCB4MCwgeDMpO1xuICAgIG1pbk1heFsxXSA9IE1hdGgubWluKG1pbk1heFsxXSwgeTAsIHkzKTtcbiAgICBtaW5NYXhbMl0gPSBNYXRoLm1heChtaW5NYXhbMl0sIHgwLCB4Myk7XG4gICAgbWluTWF4WzNdID0gTWF0aC5tYXgobWluTWF4WzNdLCB5MCwgeTMpO1xuICAgIHRoaXMuI2dldEV4dHJlbXVtKHgwLCB4MSwgeDIsIHgzLCB5MCwgeTEsIHkyLCB5MywgMyAqICgteDAgKyAzICogKHgxIC0geDIpICsgeDMpLCA2ICogKHgwIC0gMiAqIHgxICsgeDIpLCAzICogKHgxIC0geDApLCBtaW5NYXgpO1xuICAgIHRoaXMuI2dldEV4dHJlbXVtKHgwLCB4MSwgeDIsIHgzLCB5MCwgeTEsIHkyLCB5MywgMyAqICgteTAgKyAzICogKHkxIC0geTIpICsgeTMpLCA2ICogKHkwIC0gMiAqIHkxICsgeTIpLCAzICogKHkxIC0geTApLCBtaW5NYXgpO1xuICB9XG59XG5jb25zdCBQREZTdHJpbmdUcmFuc2xhdGVUYWJsZSA9ICgvKiB1bnVzZWQgcHVyZSBleHByZXNzaW9uIG9yIHN1cGVyICovIG51bGwgJiYgKFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAweDJkOCwgMHgyYzcsIDB4MmM2LCAweDJkOSwgMHgyZGQsIDB4MmRiLCAweDJkYSwgMHgyZGMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDB4MjAyMiwgMHgyMDIwLCAweDIwMjEsIDB4MjAyNiwgMHgyMDE0LCAweDIwMTMsIDB4MTkyLCAweDIwNDQsIDB4MjAzOSwgMHgyMDNhLCAweDIyMTIsIDB4MjAzMCwgMHgyMDFlLCAweDIwMWMsIDB4MjAxZCwgMHgyMDE4LCAweDIwMTksIDB4MjAxYSwgMHgyMTIyLCAweGZiMDEsIDB4ZmIwMiwgMHgxNDEsIDB4MTUyLCAweDE2MCwgMHgxNzgsIDB4MTdkLCAweDEzMSwgMHgxNDIsIDB4MTUzLCAweDE2MSwgMHgxN2UsIDAsIDB4MjBhY10pKTtcbmZ1bmN0aW9uIHN0cmluZ1RvUERGU3RyaW5nKHN0ciwga2VlcEVzY2FwZVNlcXVlbmNlID0gZmFsc2UpIHtcbiAgaWYgKHN0clswXSA+PSBcIlxceEVGXCIpIHtcbiAgICBsZXQgZW5jb2Rpbmc7XG4gICAgaWYgKHN0clswXSA9PT0gXCJcXHhGRVwiICYmIHN0clsxXSA9PT0gXCJcXHhGRlwiKSB7XG4gICAgICBlbmNvZGluZyA9IFwidXRmLTE2YmVcIjtcbiAgICAgIGlmIChzdHIubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RyWzBdID09PSBcIlxceEZGXCIgJiYgc3RyWzFdID09PSBcIlxceEZFXCIpIHtcbiAgICAgIGVuY29kaW5nID0gXCJ1dGYtMTZsZVwiO1xuICAgICAgaWYgKHN0ci5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdHJbMF0gPT09IFwiXFx4RUZcIiAmJiBzdHJbMV0gPT09IFwiXFx4QkJcIiAmJiBzdHJbMl0gPT09IFwiXFx4QkZcIikge1xuICAgICAgZW5jb2RpbmcgPSBcInV0Zi04XCI7XG4gICAgfVxuICAgIGlmIChlbmNvZGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZywge1xuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBzdHJpbmdUb0J5dGVzKHN0cik7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIpO1xuICAgICAgICBpZiAoa2VlcEVzY2FwZVNlcXVlbmNlIHx8ICFkZWNvZGVkLmluY2x1ZGVzKFwiXFx4MWJcIikpIHtcbiAgICAgICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjb2RlZC5yZXBsYWNlQWxsKC9cXHgxYlteXFx4MWJdKig/OlxceDFifCQpL2csIFwiXCIpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgd2Fybihgc3RyaW5nVG9QREZTdHJpbmc6IFwiJHtleH1cIi5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3Qgc3RyQnVmID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IHN0ci5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgY29uc3QgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoIWtlZXBFc2NhcGVTZXF1ZW5jZSAmJiBjaGFyQ29kZSA9PT0gMHgxYikge1xuICAgICAgd2hpbGUgKCsraSA8IGlpICYmIHN0ci5jaGFyQ29kZUF0KGkpICE9PSAweDFiKSB7fVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGNvZGUgPSBQREZTdHJpbmdUcmFuc2xhdGVUYWJsZVtjaGFyQ29kZV07XG4gICAgc3RyQnVmLnB1c2goY29kZSA/IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgOiBzdHIuY2hhckF0KGkpKTtcbiAgfVxuICByZXR1cm4gc3RyQnVmLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBzdHJpbmdUb1VURjhTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHN0cikpO1xufVxuZnVuY3Rpb24gdXRmOFN0cmluZ1RvU3RyaW5nKHN0cikge1xuICByZXR1cm4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpO1xufVxuZnVuY3Rpb24gaXNBcnJheUVxdWFsKGFycjEsIGFycjIpIHtcbiAgaWYgKGFycjEubGVuZ3RoICE9PSBhcnIyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgaWkgPSBhcnIxLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICBpZiAoYXJyMVtpXSAhPT0gYXJyMltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldE1vZGlmaWNhdGlvbkRhdGUoZGF0ZSA9IG5ldyBEYXRlKCkpIHtcbiAgaWYgKCEoZGF0ZSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICB9XG4gIGNvbnN0IGJ1ZmZlciA9IFtkYXRlLmdldFVUQ0Z1bGxZZWFyKCkudG9TdHJpbmcoKSwgKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ0RhdGUoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgZGF0ZS5nZXRVVENIb3VycygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ01pbnV0ZXMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgZGF0ZS5nZXRVVENTZWNvbmRzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIildO1xuICByZXR1cm4gYnVmZmVyLmpvaW4oXCJcIik7XG59XG5sZXQgTm9ybWFsaXplUmVnZXggPSBudWxsO1xubGV0IE5vcm1hbGl6YXRpb25NYXAgPSBudWxsO1xuZnVuY3Rpb24gbm9ybWFsaXplVW5pY29kZShzdHIpIHtcbiAgaWYgKCFOb3JtYWxpemVSZWdleCkge1xuICAgIE5vcm1hbGl6ZVJlZ2V4ID0gLyhbXFx1MDBhMFxcdTAwYjVcXHUwMzdlXFx1MGViM1xcdTIwMDAtXFx1MjAwYVxcdTIwMmZcXHUyMTI2XFx1ZmIwMC1cXHVmYjA0XFx1ZmIwNlxcdWZiMjAtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwLVxcdWZiNDFcXHVmYjQzLVxcdWZiNDRcXHVmYjQ2LVxcdWZiYTFcXHVmYmE0LVxcdWZiYTlcXHVmYmFlLVxcdWZiYjFcXHVmYmQzLVxcdWZiZGNcXHVmYmRlLVxcdWZiZTdcXHVmYmVhLVxcdWZiZjhcXHVmYmZjLVxcdWZiZmRcXHVmYzAwLVxcdWZjNWRcXHVmYzY0LVxcdWZjZjFcXHVmY2Y1LVxcdWZkM2RcXHVmZDg4XFx1ZmRmNFxcdWZkZmEtXFx1ZmRmYlxcdWZlNzFcXHVmZTc3XFx1ZmU3OVxcdWZlN2JcXHVmZTdkXSspfChcXHVmYjA1KykvZ3U7XG4gICAgTm9ybWFsaXphdGlvbk1hcCA9IG5ldyBNYXAoW1tcIu+shVwiLCBcIsW/dFwiXV0pO1xuICB9XG4gIHJldHVybiBzdHIucmVwbGFjZUFsbChOb3JtYWxpemVSZWdleCwgKF8sIHAxLCBwMikgPT4gcDEgPyBwMS5ub3JtYWxpemUoXCJORktDXCIpIDogTm9ybWFsaXphdGlvbk1hcC5nZXQocDIpKTtcbn1cbmZ1bmN0aW9uIGdldFV1aWQoKSB7XG4gIGlmICh0eXBlb2YgY3J5cHRvLnJhbmRvbVVVSUQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICB9XG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhidWYpO1xuICByZXR1cm4gYnl0ZXNUb1N0cmluZyhidWYpO1xufVxuY29uc3QgQW5ub3RhdGlvblByZWZpeCA9IFwicGRmanNfaW50ZXJuYWxfaWRfXCI7XG5mdW5jdGlvbiBfaXNWYWxpZEV4cGxpY2l0RGVzdCh2YWxpZFJlZiwgdmFsaWROYW1lLCBkZXN0KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShkZXN0KSB8fCBkZXN0Lmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgW3BhZ2UsIHpvb20sIC4uLmFyZ3NdID0gZGVzdDtcbiAgaWYgKCF2YWxpZFJlZihwYWdlKSAmJiAhTnVtYmVyLmlzSW50ZWdlcihwYWdlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIXZhbGlkTmFtZSh6b29tKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBhcmdzTGVuID0gYXJncy5sZW5ndGg7XG4gIGxldCBhbGxvd051bGwgPSB0cnVlO1xuICBzd2l0Y2ggKHpvb20ubmFtZSkge1xuICAgIGNhc2UgXCJYWVpcIjpcbiAgICAgIGlmIChhcmdzTGVuIDwgMiB8fCBhcmdzTGVuID4gMykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiRml0XCI6XG4gICAgY2FzZSBcIkZpdEJcIjpcbiAgICAgIHJldHVybiBhcmdzTGVuID09PSAwO1xuICAgIGNhc2UgXCJGaXRIXCI6XG4gICAgY2FzZSBcIkZpdEJIXCI6XG4gICAgY2FzZSBcIkZpdFZcIjpcbiAgICBjYXNlIFwiRml0QlZcIjpcbiAgICAgIGlmIChhcmdzTGVuID4gMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiRml0UlwiOlxuICAgICAgaWYgKGFyZ3NMZW4gIT09IDQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYWxsb3dOdWxsID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJudW1iZXJcIiB8fCBhbGxvd051bGwgJiYgYXJnID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gTWF0aENsYW1wKHYsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2LCBtaW4pLCBtYXgpO1xufVxuZnVuY3Rpb24gdG9IZXhVdGlsKGFycikge1xuICBpZiAoVWludDhBcnJheS5wcm90b3R5cGUudG9IZXgpIHtcbiAgICByZXR1cm4gYXJyLnRvSGV4KCk7XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oYXJyLCBudW0gPT4gaGV4TnVtYmVyc1tudW1dKS5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gdG9CYXNlNjRVdGlsKGFycikge1xuICBpZiAoVWludDhBcnJheS5wcm90b3R5cGUudG9CYXNlNjQpIHtcbiAgICByZXR1cm4gYXJyLnRvQmFzZTY0KCk7XG4gIH1cbiAgcmV0dXJuIGJ0b2EoYnl0ZXNUb1N0cmluZyhhcnIpKTtcbn1cbmZ1bmN0aW9uIGZyb21CYXNlNjRVdGlsKHN0cikge1xuICBpZiAoVWludDhBcnJheS5mcm9tQmFzZTY0KSB7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbUJhc2U2NChzdHIpO1xuICB9XG4gIHJldHVybiBzdHJpbmdUb0J5dGVzKGF0b2Ioc3RyKSk7XG59XG5pZiAodHlwZW9mIFByb21pc2UudHJ5ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgUHJvbWlzZS50cnkgPSBmdW5jdGlvbiAoZm4sIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICB9KTtcbiAgfTtcbn1cbmlmICh0eXBlb2YgTWF0aC5zdW1QcmVjaXNlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgTWF0aC5zdW1QcmVjaXNlID0gZnVuY3Rpb24gKG51bWJlcnMpIHtcbiAgICByZXR1cm4gbnVtYmVycy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcbiAgfTtcbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZGlzcGxheV91dGlscy5qc1xuXG5jb25zdCBTVkdfTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG5jbGFzcyBQaXhlbHNQZXJJbmNoIHtcbiAgc3RhdGljIENTUyA9IDk2LjA7XG4gIHN0YXRpYyBQREYgPSA3Mi4wO1xuICBzdGF0aWMgUERGX1RPX0NTU19VTklUUyA9IHRoaXMuQ1NTIC8gdGhpcy5QREY7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaERhdGEodXJsLCB0eXBlID0gXCJ0ZXh0XCIpIHtcbiAgaWYgKGlzVmFsaWRGZXRjaFVybCh1cmwsIGRvY3VtZW50LmJhc2VVUkkpKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiYXJyYXlidWZmZXJcIjpcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICBjYXNlIFwiYmxvYlwiOlxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuYmxvYigpO1xuICAgICAgY2FzZSBcImpzb25cIjpcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICByZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgdXJsLCB0cnVlKTtcbiAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHR5cGU7XG4gICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAocmVxdWVzdC5yZWFkeVN0YXRlICE9PSBYTUxIdHRwUmVxdWVzdC5ET05FKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMjAwIHx8IHJlcXVlc3Quc3RhdHVzID09PSAwKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJhcnJheWJ1ZmZlclwiOlxuICAgICAgICAgIGNhc2UgXCJibG9iXCI6XG4gICAgICAgICAgY2FzZSBcImpzb25cIjpcbiAgICAgICAgICAgIHJlc29sdmUocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlamVjdChuZXcgRXJyb3IocmVxdWVzdC5zdGF0dXNUZXh0KSk7XG4gICAgfTtcbiAgICByZXF1ZXN0LnNlbmQobnVsbCk7XG4gIH0pO1xufVxuY2xhc3MgUGFnZVZpZXdwb3J0IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHZpZXdCb3gsXG4gICAgdXNlclVuaXQsXG4gICAgc2NhbGUsXG4gICAgcm90YXRpb24sXG4gICAgb2Zmc2V0WCA9IDAsXG4gICAgb2Zmc2V0WSA9IDAsXG4gICAgZG9udEZsaXAgPSBmYWxzZVxuICB9KSB7XG4gICAgdGhpcy52aWV3Qm94ID0gdmlld0JveDtcbiAgICB0aGlzLnVzZXJVbml0ID0gdXNlclVuaXQ7XG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLm9mZnNldFggPSBvZmZzZXRYO1xuICAgIHRoaXMub2Zmc2V0WSA9IG9mZnNldFk7XG4gICAgc2NhbGUgKj0gdXNlclVuaXQ7XG4gICAgY29uc3QgY2VudGVyWCA9ICh2aWV3Qm94WzJdICsgdmlld0JveFswXSkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSAodmlld0JveFszXSArIHZpZXdCb3hbMV0pIC8gMjtcbiAgICBsZXQgcm90YXRlQSwgcm90YXRlQiwgcm90YXRlQywgcm90YXRlRDtcbiAgICByb3RhdGlvbiAlPSAzNjA7XG4gICAgaWYgKHJvdGF0aW9uIDwgMCkge1xuICAgICAgcm90YXRpb24gKz0gMzYwO1xuICAgIH1cbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcm90YXRlQSA9IC0xO1xuICAgICAgICByb3RhdGVCID0gMDtcbiAgICAgICAgcm90YXRlQyA9IDA7XG4gICAgICAgIHJvdGF0ZUQgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJvdGF0ZUEgPSAwO1xuICAgICAgICByb3RhdGVCID0gMTtcbiAgICAgICAgcm90YXRlQyA9IDE7XG4gICAgICAgIHJvdGF0ZUQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByb3RhdGVBID0gMDtcbiAgICAgICAgcm90YXRlQiA9IC0xO1xuICAgICAgICByb3RhdGVDID0gLTE7XG4gICAgICAgIHJvdGF0ZUQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcm90YXRlQSA9IDE7XG4gICAgICAgIHJvdGF0ZUIgPSAwO1xuICAgICAgICByb3RhdGVDID0gMDtcbiAgICAgICAgcm90YXRlRCA9IC0xO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhZ2VWaWV3cG9ydDogSW52YWxpZCByb3RhdGlvbiwgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDkwIGRlZ3JlZXMuXCIpO1xuICAgIH1cbiAgICBpZiAoZG9udEZsaXApIHtcbiAgICAgIHJvdGF0ZUMgPSAtcm90YXRlQztcbiAgICAgIHJvdGF0ZUQgPSAtcm90YXRlRDtcbiAgICB9XG4gICAgbGV0IG9mZnNldENhbnZhc1gsIG9mZnNldENhbnZhc1k7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG4gICAgaWYgKHJvdGF0ZUEgPT09IDApIHtcbiAgICAgIG9mZnNldENhbnZhc1ggPSBNYXRoLmFicyhjZW50ZXJZIC0gdmlld0JveFsxXSkgKiBzY2FsZSArIG9mZnNldFg7XG4gICAgICBvZmZzZXRDYW52YXNZID0gTWF0aC5hYnMoY2VudGVyWCAtIHZpZXdCb3hbMF0pICogc2NhbGUgKyBvZmZzZXRZO1xuICAgICAgd2lkdGggPSAodmlld0JveFszXSAtIHZpZXdCb3hbMV0pICogc2NhbGU7XG4gICAgICBoZWlnaHQgPSAodmlld0JveFsyXSAtIHZpZXdCb3hbMF0pICogc2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldENhbnZhc1ggPSBNYXRoLmFicyhjZW50ZXJYIC0gdmlld0JveFswXSkgKiBzY2FsZSArIG9mZnNldFg7XG4gICAgICBvZmZzZXRDYW52YXNZID0gTWF0aC5hYnMoY2VudGVyWSAtIHZpZXdCb3hbMV0pICogc2NhbGUgKyBvZmZzZXRZO1xuICAgICAgd2lkdGggPSAodmlld0JveFsyXSAtIHZpZXdCb3hbMF0pICogc2NhbGU7XG4gICAgICBoZWlnaHQgPSAodmlld0JveFszXSAtIHZpZXdCb3hbMV0pICogc2NhbGU7XG4gICAgfVxuICAgIHRoaXMudHJhbnNmb3JtID0gW3JvdGF0ZUEgKiBzY2FsZSwgcm90YXRlQiAqIHNjYWxlLCByb3RhdGVDICogc2NhbGUsIHJvdGF0ZUQgKiBzY2FsZSwgb2Zmc2V0Q2FudmFzWCAtIHJvdGF0ZUEgKiBzY2FsZSAqIGNlbnRlclggLSByb3RhdGVDICogc2NhbGUgKiBjZW50ZXJZLCBvZmZzZXRDYW52YXNZIC0gcm90YXRlQiAqIHNjYWxlICogY2VudGVyWCAtIHJvdGF0ZUQgKiBzY2FsZSAqIGNlbnRlclldO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuICBnZXQgcmF3RGltcygpIHtcbiAgICBjb25zdCBkaW1zID0gdGhpcy52aWV3Qm94O1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJyYXdEaW1zXCIsIHtcbiAgICAgIHBhZ2VXaWR0aDogZGltc1syXSAtIGRpbXNbMF0sXG4gICAgICBwYWdlSGVpZ2h0OiBkaW1zWzNdIC0gZGltc1sxXSxcbiAgICAgIHBhZ2VYOiBkaW1zWzBdLFxuICAgICAgcGFnZVk6IGRpbXNbMV1cbiAgICB9KTtcbiAgfVxuICBjbG9uZSh7XG4gICAgc2NhbGUgPSB0aGlzLnNjYWxlLFxuICAgIHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbixcbiAgICBvZmZzZXRYID0gdGhpcy5vZmZzZXRYLFxuICAgIG9mZnNldFkgPSB0aGlzLm9mZnNldFksXG4gICAgZG9udEZsaXAgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFBhZ2VWaWV3cG9ydCh7XG4gICAgICB2aWV3Qm94OiB0aGlzLnZpZXdCb3guc2xpY2UoKSxcbiAgICAgIHVzZXJVbml0OiB0aGlzLnVzZXJVbml0LFxuICAgICAgc2NhbGUsXG4gICAgICByb3RhdGlvbixcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZLFxuICAgICAgZG9udEZsaXBcbiAgICB9KTtcbiAgfVxuICBjb252ZXJ0VG9WaWV3cG9ydFBvaW50KHgsIHkpIHtcbiAgICBjb25zdCBwID0gW3gsIHldO1xuICAgIFV0aWwuYXBwbHlUcmFuc2Zvcm0ocCwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIHJldHVybiBwO1xuICB9XG4gIGNvbnZlcnRUb1ZpZXdwb3J0UmVjdGFuZ2xlKHJlY3QpIHtcbiAgICBjb25zdCB0b3BMZWZ0ID0gW3JlY3RbMF0sIHJlY3RbMV1dO1xuICAgIFV0aWwuYXBwbHlUcmFuc2Zvcm0odG9wTGVmdCwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIGNvbnN0IGJvdHRvbVJpZ2h0ID0gW3JlY3RbMl0sIHJlY3RbM11dO1xuICAgIFV0aWwuYXBwbHlUcmFuc2Zvcm0oYm90dG9tUmlnaHQsIHRoaXMudHJhbnNmb3JtKTtcbiAgICByZXR1cm4gW3RvcExlZnRbMF0sIHRvcExlZnRbMV0sIGJvdHRvbVJpZ2h0WzBdLCBib3R0b21SaWdodFsxXV07XG4gIH1cbiAgY29udmVydFRvUGRmUG9pbnQoeCwgeSkge1xuICAgIGNvbnN0IHAgPSBbeCwgeV07XG4gICAgVXRpbC5hcHBseUludmVyc2VUcmFuc2Zvcm0ocCwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIHJldHVybiBwO1xuICB9XG59XG5jbGFzcyBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnLCBleHRyYURlbGF5ID0gMCkge1xuICAgIHN1cGVyKG1zZywgXCJSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb25cIik7XG4gICAgdGhpcy5leHRyYURlbGF5ID0gZXh0cmFEZWxheTtcbiAgfVxufVxuZnVuY3Rpb24gaXNEYXRhU2NoZW1lKHVybCkge1xuICBjb25zdCBpaSA9IHVybC5sZW5ndGg7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgPCBpaSAmJiB1cmxbaV0udHJpbSgpID09PSBcIlwiKSB7XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiB1cmwuc3Vic3RyaW5nKGksIGkgKyA1KS50b0xvd2VyQ2FzZSgpID09PSBcImRhdGE6XCI7XG59XG5mdW5jdGlvbiBpc1BkZkZpbGUoZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHR5cGVvZiBmaWxlbmFtZSA9PT0gXCJzdHJpbmdcIiAmJiAvXFwucGRmJC9pLnRlc3QoZmlsZW5hbWUpO1xufVxuZnVuY3Rpb24gZ2V0RmlsZW5hbWVGcm9tVXJsKHVybCkge1xuICBbdXJsXSA9IHVybC5zcGxpdCgvWyM/XS8sIDEpO1xuICByZXR1cm4gdXJsLnN1YnN0cmluZyh1cmwubGFzdEluZGV4T2YoXCIvXCIpICsgMSk7XG59XG5mdW5jdGlvbiBnZXRQZGZGaWxlbmFtZUZyb21VcmwodXJsLCBkZWZhdWx0RmlsZW5hbWUgPSBcImRvY3VtZW50LnBkZlwiKSB7XG4gIGlmICh0eXBlb2YgdXJsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRGaWxlbmFtZTtcbiAgfVxuICBpZiAoaXNEYXRhU2NoZW1lKHVybCkpIHtcbiAgICB3YXJuKCdnZXRQZGZGaWxlbmFtZUZyb21Vcmw6IGlnbm9yZSBcImRhdGE6XCItVVJMIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLicpO1xuICAgIHJldHVybiBkZWZhdWx0RmlsZW5hbWU7XG4gIH1cbiAgY29uc3QgZ2V0VVJMID0gdXJsU3RyaW5nID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBVUkwodXJsU3RyaW5nKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgVVJMKGRlY29kZVVSSUNvbXBvbmVudCh1cmxTdHJpbmcpKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBuZXcgVVJMKHVybFN0cmluZywgXCJodHRwczovL2Zvby5iYXJcIik7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVSTChkZWNvZGVVUklDb21wb25lbnQodXJsU3RyaW5nKSwgXCJodHRwczovL2Zvby5iYXJcIik7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IG5ld1VSTCA9IGdldFVSTCh1cmwpO1xuICBpZiAoIW5ld1VSTCkge1xuICAgIHJldHVybiBkZWZhdWx0RmlsZW5hbWU7XG4gIH1cbiAgY29uc3QgZGVjb2RlID0gbmFtZSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBkZWNvZGVkID0gZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpO1xuICAgICAgaWYgKGRlY29kZWQuaW5jbHVkZXMoXCIvXCIpKSB7XG4gICAgICAgIGRlY29kZWQgPSBkZWNvZGVkLnNwbGl0KFwiL1wiKS5hdCgtMSk7XG4gICAgICAgIGlmIChkZWNvZGVkLnRlc3QoL15cXC5wZGYkL2kpKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGRmUmVnZXggPSAvXFwucGRmJC9pO1xuICBjb25zdCBmaWxlbmFtZSA9IG5ld1VSTC5wYXRobmFtZS5zcGxpdChcIi9cIikuYXQoLTEpO1xuICBpZiAocGRmUmVnZXgudGVzdChmaWxlbmFtZSkpIHtcbiAgICByZXR1cm4gZGVjb2RlKGZpbGVuYW1lKTtcbiAgfVxuICBpZiAobmV3VVJMLnNlYXJjaFBhcmFtcy5zaXplID4gMCkge1xuICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5LmZyb20obmV3VVJMLnNlYXJjaFBhcmFtcy52YWx1ZXMoKSkucmV2ZXJzZSgpO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAocGRmUmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGtleXMgPSBBcnJheS5mcm9tKG5ld1VSTC5zZWFyY2hQYXJhbXMua2V5cygpKS5yZXZlcnNlKCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgaWYgKHBkZlJlZ2V4LnRlc3Qoa2V5KSkge1xuICAgICAgICByZXR1cm4gZGVjb2RlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChuZXdVUkwuaGFzaCkge1xuICAgIGNvbnN0IHJlRmlsZW5hbWUgPSAvW14vPyM9XStcXC5wZGZcXGIoPyEuKlxcLnBkZlxcYikvaTtcbiAgICBjb25zdCBoYXNoRmlsZW5hbWUgPSByZUZpbGVuYW1lLmV4ZWMobmV3VVJMLmhhc2gpO1xuICAgIGlmIChoYXNoRmlsZW5hbWUpIHtcbiAgICAgIHJldHVybiBkZWNvZGUoaGFzaEZpbGVuYW1lWzBdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRGaWxlbmFtZTtcbn1cbmNsYXNzIFN0YXRUaW1lciB7XG4gIHN0YXJ0ZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aW1lcyA9IFtdO1xuICB0aW1lKG5hbWUpIHtcbiAgICBpZiAobmFtZSBpbiB0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHdhcm4oYFRpbWVyIGlzIGFscmVhZHkgcnVubmluZyBmb3IgJHtuYW1lfWApO1xuICAgIH1cbiAgICB0aGlzLnN0YXJ0ZWRbbmFtZV0gPSBEYXRlLm5vdygpO1xuICB9XG4gIHRpbWVFbmQobmFtZSkge1xuICAgIGlmICghKG5hbWUgaW4gdGhpcy5zdGFydGVkKSkge1xuICAgICAgd2FybihgVGltZXIgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQgZm9yICR7bmFtZX1gKTtcbiAgICB9XG4gICAgdGhpcy50aW1lcy5wdXNoKHtcbiAgICAgIG5hbWUsXG4gICAgICBzdGFydDogdGhpcy5zdGFydGVkW25hbWVdLFxuICAgICAgZW5kOiBEYXRlLm5vdygpXG4gICAgfSk7XG4gICAgZGVsZXRlIHRoaXMuc3RhcnRlZFtuYW1lXTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCBvdXRCdWYgPSBbXTtcbiAgICBsZXQgbG9uZ2VzdCA9IDA7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBuYW1lXG4gICAgfSBvZiB0aGlzLnRpbWVzKSB7XG4gICAgICBsb25nZXN0ID0gTWF0aC5tYXgobmFtZS5sZW5ndGgsIGxvbmdlc3QpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBzdGFydCxcbiAgICAgIGVuZFxuICAgIH0gb2YgdGhpcy50aW1lcykge1xuICAgICAgb3V0QnVmLnB1c2goYCR7bmFtZS5wYWRFbmQobG9uZ2VzdCl9ICR7ZW5kIC0gc3RhcnR9bXNcXG5gKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dEJ1Zi5qb2luKFwiXCIpO1xuICB9XG59XG5mdW5jdGlvbiBpc1ZhbGlkRmV0Y2hVcmwodXJsLCBiYXNlVXJsKSB7XG4gIGNvbnN0IHJlcyA9IGJhc2VVcmwgPyBVUkwucGFyc2UodXJsLCBiYXNlVXJsKSA6IFVSTC5wYXJzZSh1cmwpO1xuICByZXR1cm4gcmVzPy5wcm90b2NvbCA9PT0gXCJodHRwOlwiIHx8IHJlcz8ucHJvdG9jb2wgPT09IFwiaHR0cHM6XCI7XG59XG5mdW5jdGlvbiBub0NvbnRleHRNZW51KGUpIHtcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xufVxuZnVuY3Rpb24gc3RvcEV2ZW50KGUpIHtcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICBlLnN0b3BQcm9wYWdhdGlvbigpO1xufVxuZnVuY3Rpb24gZGVwcmVjYXRlZChkZXRhaWxzKSB7XG4gIGNvbnNvbGUubG9nKFwiRGVwcmVjYXRlZCBBUEkgdXNhZ2U6IFwiICsgZGV0YWlscyk7XG59XG5jbGFzcyBQREZEYXRlU3RyaW5nIHtcbiAgc3RhdGljICNyZWdleDtcbiAgc3RhdGljIHRvRGF0ZU9iamVjdChpbnB1dCkge1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgaWYgKCFpbnB1dCB8fCB0eXBlb2YgaW5wdXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNyZWdleCB8fD0gbmV3IFJlZ0V4cChcIl5EOlwiICsgXCIoXFxcXGR7NH0pXCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihbWnwrfC1dKT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiJz9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiJz9cIik7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuI3JlZ2V4LmV4ZWMoaW5wdXQpO1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHllYXIgPSBwYXJzZUludChtYXRjaGVzWzFdLCAxMCk7XG4gICAgbGV0IG1vbnRoID0gcGFyc2VJbnQobWF0Y2hlc1syXSwgMTApO1xuICAgIG1vbnRoID0gbW9udGggPj0gMSAmJiBtb250aCA8PSAxMiA/IG1vbnRoIC0gMSA6IDA7XG4gICAgbGV0IGRheSA9IHBhcnNlSW50KG1hdGNoZXNbM10sIDEwKTtcbiAgICBkYXkgPSBkYXkgPj0gMSAmJiBkYXkgPD0gMzEgPyBkYXkgOiAxO1xuICAgIGxldCBob3VyID0gcGFyc2VJbnQobWF0Y2hlc1s0XSwgMTApO1xuICAgIGhvdXIgPSBob3VyID49IDAgJiYgaG91ciA8PSAyMyA/IGhvdXIgOiAwO1xuICAgIGxldCBtaW51dGUgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG4gICAgbWludXRlID0gbWludXRlID49IDAgJiYgbWludXRlIDw9IDU5ID8gbWludXRlIDogMDtcbiAgICBsZXQgc2Vjb25kID0gcGFyc2VJbnQobWF0Y2hlc1s2XSwgMTApO1xuICAgIHNlY29uZCA9IHNlY29uZCA+PSAwICYmIHNlY29uZCA8PSA1OSA/IHNlY29uZCA6IDA7XG4gICAgY29uc3QgdW5pdmVyc2FsVGltZVJlbGF0aW9uID0gbWF0Y2hlc1s3XSB8fCBcIlpcIjtcbiAgICBsZXQgb2Zmc2V0SG91ciA9IHBhcnNlSW50KG1hdGNoZXNbOF0sIDEwKTtcbiAgICBvZmZzZXRIb3VyID0gb2Zmc2V0SG91ciA+PSAwICYmIG9mZnNldEhvdXIgPD0gMjMgPyBvZmZzZXRIb3VyIDogMDtcbiAgICBsZXQgb2Zmc2V0TWludXRlID0gcGFyc2VJbnQobWF0Y2hlc1s5XSwgMTApIHx8IDA7XG4gICAgb2Zmc2V0TWludXRlID0gb2Zmc2V0TWludXRlID49IDAgJiYgb2Zmc2V0TWludXRlIDw9IDU5ID8gb2Zmc2V0TWludXRlIDogMDtcbiAgICBpZiAodW5pdmVyc2FsVGltZVJlbGF0aW9uID09PSBcIi1cIikge1xuICAgICAgaG91ciArPSBvZmZzZXRIb3VyO1xuICAgICAgbWludXRlICs9IG9mZnNldE1pbnV0ZTtcbiAgICB9IGVsc2UgaWYgKHVuaXZlcnNhbFRpbWVSZWxhdGlvbiA9PT0gXCIrXCIpIHtcbiAgICAgIGhvdXIgLT0gb2Zmc2V0SG91cjtcbiAgICAgIG1pbnV0ZSAtPSBvZmZzZXRNaW51dGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCkpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRYZmFQYWdlVmlld3BvcnQoeGZhUGFnZSwge1xuICBzY2FsZSA9IDEsXG4gIHJvdGF0aW9uID0gMFxufSkge1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gPSB4ZmFQYWdlLmF0dHJpYnV0ZXMuc3R5bGU7XG4gIGNvbnN0IHZpZXdCb3ggPSBbMCwgMCwgcGFyc2VJbnQod2lkdGgpLCBwYXJzZUludChoZWlnaHQpXTtcbiAgcmV0dXJuIG5ldyBQYWdlVmlld3BvcnQoe1xuICAgIHZpZXdCb3gsXG4gICAgdXNlclVuaXQ6IDEsXG4gICAgc2NhbGUsXG4gICAgcm90YXRpb25cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRSR0IoY29sb3IpIHtcbiAgaWYgKGNvbG9yLnN0YXJ0c1dpdGgoXCIjXCIpKSB7XG4gICAgY29uc3QgY29sb3JSR0IgPSBwYXJzZUludChjb2xvci5zbGljZSgxKSwgMTYpO1xuICAgIHJldHVybiBbKGNvbG9yUkdCICYgMHhmZjAwMDApID4+IDE2LCAoY29sb3JSR0IgJiAweDAwZmYwMCkgPj4gOCwgY29sb3JSR0IgJiAweDAwMDBmZl07XG4gIH1cbiAgaWYgKGNvbG9yLnN0YXJ0c1dpdGgoXCJyZ2IoXCIpKSB7XG4gICAgcmV0dXJuIGNvbG9yLnNsaWNlKDQsIC0xKS5zcGxpdChcIixcIikubWFwKHggPT4gcGFyc2VJbnQoeCkpO1xuICB9XG4gIGlmIChjb2xvci5zdGFydHNXaXRoKFwicmdiYShcIikpIHtcbiAgICByZXR1cm4gY29sb3Iuc2xpY2UoNSwgLTEpLnNwbGl0KFwiLFwiKS5tYXAoeCA9PiBwYXJzZUludCh4KSkuc2xpY2UoMCwgMyk7XG4gIH1cbiAgd2FybihgTm90IGEgdmFsaWQgY29sb3IgZm9ybWF0OiBcIiR7Y29sb3J9XCJgKTtcbiAgcmV0dXJuIFswLCAwLCAwXTtcbn1cbmZ1bmN0aW9uIGdldENvbG9yVmFsdWVzKGNvbG9ycykge1xuICBjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gIHNwYW4uc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gIHNwYW4uc3R5bGUuY29sb3JTY2hlbWUgPSBcIm9ubHkgbGlnaHRcIjtcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmQoc3Bhbik7XG4gIGZvciAoY29uc3QgbmFtZSBvZiBjb2xvcnMua2V5cygpKSB7XG4gICAgc3Bhbi5zdHlsZS5jb2xvciA9IG5hbWU7XG4gICAgY29uc3QgY29tcHV0ZWRDb2xvciA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHNwYW4pLmNvbG9yO1xuICAgIGNvbG9ycy5zZXQobmFtZSwgZ2V0UkdCKGNvbXB1dGVkQ29sb3IpKTtcbiAgfVxuICBzcGFuLnJlbW92ZSgpO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpIHtcbiAgY29uc3Qge1xuICAgIGEsXG4gICAgYixcbiAgICBjLFxuICAgIGQsXG4gICAgZSxcbiAgICBmXG4gIH0gPSBjdHguZ2V0VHJhbnNmb3JtKCk7XG4gIHJldHVybiBbYSwgYiwgYywgZCwgZSwgZl07XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpIHtcbiAgY29uc3Qge1xuICAgIGEsXG4gICAgYixcbiAgICBjLFxuICAgIGQsXG4gICAgZSxcbiAgICBmXG4gIH0gPSBjdHguZ2V0VHJhbnNmb3JtKCkuaW52ZXJ0U2VsZigpO1xuICByZXR1cm4gW2EsIGIsIGMsIGQsIGUsIGZdO1xufVxuZnVuY3Rpb24gc2V0TGF5ZXJEaW1lbnNpb25zKGRpdiwgdmlld3BvcnQsIG11c3RGbGlwID0gZmFsc2UsIG11c3RSb3RhdGUgPSB0cnVlKSB7XG4gIGlmICh2aWV3cG9ydCBpbnN0YW5jZW9mIFBhZ2VWaWV3cG9ydCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHRcbiAgICB9ID0gdmlld3BvcnQucmF3RGltcztcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBkaXY7XG4gICAgY29uc3QgdXNlUm91bmQgPSB1dGlsX0ZlYXR1cmVUZXN0LmlzQ1NTUm91bmRTdXBwb3J0ZWQ7XG4gICAgY29uc3QgdyA9IGB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpICogJHtwYWdlV2lkdGh9cHhgLFxuICAgICAgaCA9IGB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpICogJHtwYWdlSGVpZ2h0fXB4YDtcbiAgICBjb25zdCB3aWR0aFN0ciA9IHVzZVJvdW5kID8gYHJvdW5kKGRvd24sICR7d30sIHZhcigtLXNjYWxlLXJvdW5kLXgpKWAgOiBgY2FsYygke3d9KWAsXG4gICAgICBoZWlnaHRTdHIgPSB1c2VSb3VuZCA/IGByb3VuZChkb3duLCAke2h9LCB2YXIoLS1zY2FsZS1yb3VuZC15KSlgIDogYGNhbGMoJHtofSlgO1xuICAgIGlmICghbXVzdEZsaXAgfHwgdmlld3BvcnQucm90YXRpb24gJSAxODAgPT09IDApIHtcbiAgICAgIHN0eWxlLndpZHRoID0gd2lkdGhTdHI7XG4gICAgICBzdHlsZS5oZWlnaHQgPSBoZWlnaHRTdHI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLndpZHRoID0gaGVpZ2h0U3RyO1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gd2lkdGhTdHI7XG4gICAgfVxuICB9XG4gIGlmIChtdXN0Um90YXRlKSB7XG4gICAgZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbWFpbi1yb3RhdGlvblwiLCB2aWV3cG9ydC5yb3RhdGlvbik7XG4gIH1cbn1cbmNsYXNzIE91dHB1dFNjYWxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGl4ZWxSYXRpb1xuICAgIH0gPSBPdXRwdXRTY2FsZTtcbiAgICB0aGlzLnN4ID0gcGl4ZWxSYXRpbztcbiAgICB0aGlzLnN5ID0gcGl4ZWxSYXRpbztcbiAgfVxuICBnZXQgc2NhbGVkKCkge1xuICAgIHJldHVybiB0aGlzLnN4ICE9PSAxIHx8IHRoaXMuc3kgIT09IDE7XG4gIH1cbiAgZ2V0IHN5bW1ldHJpYygpIHtcbiAgICByZXR1cm4gdGhpcy5zeCA9PT0gdGhpcy5zeTtcbiAgfVxuICBsaW1pdENhbnZhcyh3aWR0aCwgaGVpZ2h0LCBtYXhQaXhlbHMsIG1heERpbSwgY2FwQXJlYUZhY3RvciA9IC0xKSB7XG4gICAgbGV0IG1heEFyZWFTY2FsZSA9IEluZmluaXR5LFxuICAgICAgbWF4V2lkdGhTY2FsZSA9IEluZmluaXR5LFxuICAgICAgbWF4SGVpZ2h0U2NhbGUgPSBJbmZpbml0eTtcbiAgICBtYXhQaXhlbHMgPSBPdXRwdXRTY2FsZS5jYXBQaXhlbHMobWF4UGl4ZWxzLCBjYXBBcmVhRmFjdG9yKTtcbiAgICBpZiAobWF4UGl4ZWxzID4gMCkge1xuICAgICAgbWF4QXJlYVNjYWxlID0gTWF0aC5zcXJ0KG1heFBpeGVscyAvICh3aWR0aCAqIGhlaWdodCkpO1xuICAgIH1cbiAgICBpZiAobWF4RGltICE9PSAtMSkge1xuICAgICAgbWF4V2lkdGhTY2FsZSA9IG1heERpbSAvIHdpZHRoO1xuICAgICAgbWF4SGVpZ2h0U2NhbGUgPSBtYXhEaW0gLyBoZWlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IG1heFNjYWxlID0gTWF0aC5taW4obWF4QXJlYVNjYWxlLCBtYXhXaWR0aFNjYWxlLCBtYXhIZWlnaHRTY2FsZSk7XG4gICAgaWYgKHRoaXMuc3ggPiBtYXhTY2FsZSB8fCB0aGlzLnN5ID4gbWF4U2NhbGUpIHtcbiAgICAgIHRoaXMuc3ggPSBtYXhTY2FsZTtcbiAgICAgIHRoaXMuc3kgPSBtYXhTY2FsZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGdldCBwaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgfVxuICBzdGF0aWMgY2FwUGl4ZWxzKG1heFBpeGVscywgY2FwQXJlYUZhY3Rvcikge1xuICAgIGlmIChjYXBBcmVhRmFjdG9yID49IDApIHtcbiAgICAgIGNvbnN0IHdpblBpeGVscyA9IE1hdGguY2VpbCh3aW5kb3cuc2NyZWVuLmF2YWlsV2lkdGggKiB3aW5kb3cuc2NyZWVuLmF2YWlsSGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvICoqIDIgKiAoMSArIGNhcEFyZWFGYWN0b3IgLyAxMDApKTtcbiAgICAgIHJldHVybiBtYXhQaXhlbHMgPiAwID8gTWF0aC5taW4obWF4UGl4ZWxzLCB3aW5QaXhlbHMpIDogd2luUGl4ZWxzO1xuICAgIH1cbiAgICByZXR1cm4gbWF4UGl4ZWxzO1xuICB9XG59XG5jb25zdCBTdXBwb3J0ZWRJbWFnZU1pbWVUeXBlcyA9IFtcImltYWdlL2FwbmdcIiwgXCJpbWFnZS9hdmlmXCIsIFwiaW1hZ2UvYm1wXCIsIFwiaW1hZ2UvZ2lmXCIsIFwiaW1hZ2UvanBlZ1wiLCBcImltYWdlL3BuZ1wiLCBcImltYWdlL3N2Zyt4bWxcIiwgXCJpbWFnZS93ZWJwXCIsIFwiaW1hZ2UveC1pY29uXCJdO1xuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvdG9vbGJhci5qc1xuXG5jbGFzcyBFZGl0b3JUb29sYmFyIHtcbiAgI3Rvb2xiYXIgPSBudWxsO1xuICAjY29sb3JQaWNrZXIgPSBudWxsO1xuICAjZWRpdG9yO1xuICAjYnV0dG9ucyA9IG51bGw7XG4gICNhbHRUZXh0ID0gbnVsbDtcbiAgI2NvbW1lbnQgPSBudWxsO1xuICAjc2lnbmF0dXJlRGVzY3JpcHRpb25CdXR0b24gPSBudWxsO1xuICBzdGF0aWMgI2wxMG5SZW1vdmUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3IgPSBlZGl0b3I7XG4gICAgRWRpdG9yVG9vbGJhci4jbDEwblJlbW92ZSB8fD0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBmcmVldGV4dDogXCJwZGZqcy1lZGl0b3ItcmVtb3ZlLWZyZWV0ZXh0LWJ1dHRvblwiLFxuICAgICAgaGlnaGxpZ2h0OiBcInBkZmpzLWVkaXRvci1yZW1vdmUtaGlnaGxpZ2h0LWJ1dHRvblwiLFxuICAgICAgaW5rOiBcInBkZmpzLWVkaXRvci1yZW1vdmUtaW5rLWJ1dHRvblwiLFxuICAgICAgc3RhbXA6IFwicGRmanMtZWRpdG9yLXJlbW92ZS1zdGFtcC1idXR0b25cIixcbiAgICAgIHNpZ25hdHVyZTogXCJwZGZqcy1lZGl0b3ItcmVtb3ZlLXNpZ25hdHVyZS1idXR0b25cIlxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBlZGl0VG9vbGJhciA9IHRoaXMuI3Rvb2xiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGVkaXRUb29sYmFyLmNsYXNzTGlzdC5hZGQoXCJlZGl0VG9vbGJhclwiLCBcImhpZGRlblwiKTtcbiAgICBlZGl0VG9vbGJhci5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidG9vbGJhclwiKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIGlmIChzaWduYWwgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCAmJiAhc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGVkaXRUb29sYmFyLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBlZGl0VG9vbGJhci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgRWRpdG9yVG9vbGJhci4jcG9pbnRlckRvd24sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYnV0dG9ucyA9IHRoaXMuI2J1dHRvbnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGJ1dHRvbnMuY2xhc3NOYW1lID0gXCJidXR0b25zXCI7XG4gICAgZWRpdFRvb2xiYXIuYXBwZW5kKGJ1dHRvbnMpO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy4jZWRpdG9yLnRvb2xiYXJQb3NpdGlvbjtcbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3R5bGVcbiAgICAgIH0gPSBlZGl0VG9vbGJhcjtcbiAgICAgIGNvbnN0IHggPSB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5kaXJlY3Rpb24gPT09IFwibHRyXCIgPyAxIC0gcG9zaXRpb25bMF0gOiBwb3NpdGlvblswXTtcbiAgICAgIHN0eWxlLmluc2V0SW5saW5lRW5kID0gYCR7MTAwICogeH0lYDtcbiAgICAgIHN0eWxlLnRvcCA9IGBjYWxjKCR7MTAwICogcG9zaXRpb25bMV19JSArIHZhcigtLWVkaXRvci10b29sYmFyLXZlcnQtb2Zmc2V0KSlgO1xuICAgIH1cbiAgICByZXR1cm4gZWRpdFRvb2xiYXI7XG4gIH1cbiAgZ2V0IGRpdigpIHtcbiAgICByZXR1cm4gdGhpcy4jdG9vbGJhcjtcbiAgfVxuICBzdGF0aWMgI3BvaW50ZXJEb3duKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG4gICNmb2N1c0luKGUpIHtcbiAgICB0aGlzLiNlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IGZhbHNlO1xuICAgIHN0b3BFdmVudChlKTtcbiAgfVxuICAjZm9jdXNPdXQoZSkge1xuICAgIHRoaXMuI2VkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgICBzdG9wRXZlbnQoZSk7XG4gIH1cbiAgI2FkZExpc3RlbmVyc1RvRWxlbWVudChlbGVtZW50KSB7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBpZiAoIShzaWduYWwgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCkgfHwgc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCB0aGlzLiNmb2N1c0luLmJpbmQodGhpcyksIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCB0aGlzLiNmb2N1c091dC5iaW5kKHRoaXMpLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICB0aGlzLiN0b29sYmFyLmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gICAgdGhpcy4jY29sb3JQaWNrZXI/LmhpZGVEcm9wZG93bigpO1xuICB9XG4gIHNob3coKSB7XG4gICAgdGhpcy4jdG9vbGJhci5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xuICAgIHRoaXMuI2FsdFRleHQ/LnNob3duKCk7XG4gICAgdGhpcy4jY29tbWVudD8uc2hvd24oKTtcbiAgfVxuICBhZGREZWxldGVCdXR0b24oKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWRpdG9yVHlwZSxcbiAgICAgIF91aU1hbmFnZXJcbiAgICB9ID0gdGhpcy4jZWRpdG9yO1xuICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJiYXNpY1wiLCBcImRlbGV0ZUJ1dHRvblwiKTtcbiAgICBidXR0b24udGFiSW5kZXggPSAwO1xuICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgRWRpdG9yVG9vbGJhci4jbDEwblJlbW92ZVtlZGl0b3JUeXBlXSk7XG4gICAgaWYgKHRoaXMuI2FkZExpc3RlbmVyc1RvRWxlbWVudChidXR0b24pKSB7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGUgPT4ge1xuICAgICAgICBfdWlNYW5hZ2VyLmRlbGV0ZSgpO1xuICAgICAgfSwge1xuICAgICAgICBzaWduYWw6IF91aU1hbmFnZXIuX3NpZ25hbFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuI2J1dHRvbnMuYXBwZW5kKGJ1dHRvbik7XG4gIH1cbiAgZ2V0ICNkaXZpZGVyKCkge1xuICAgIGNvbnN0IGRpdmlkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdmlkZXIuY2xhc3NOYW1lID0gXCJkaXZpZGVyXCI7XG4gICAgcmV0dXJuIGRpdmlkZXI7XG4gIH1cbiAgYXN5bmMgYWRkQWx0VGV4dChhbHRUZXh0KSB7XG4gICAgY29uc3QgYnV0dG9uID0gYXdhaXQgYWx0VGV4dC5yZW5kZXIoKTtcbiAgICB0aGlzLiNhZGRMaXN0ZW5lcnNUb0VsZW1lbnQoYnV0dG9uKTtcbiAgICB0aGlzLiNidXR0b25zLmFwcGVuZChidXR0b24sIHRoaXMuI2RpdmlkZXIpO1xuICAgIHRoaXMuI2FsdFRleHQgPSBhbHRUZXh0O1xuICB9XG4gIGFkZENvbW1lbnQoY29tbWVudCkge1xuICAgIGlmICh0aGlzLiNjb21tZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJ1dHRvbiA9IGNvbW1lbnQucmVuZGVyKCk7XG4gICAgaWYgKCFidXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWRkTGlzdGVuZXJzVG9FbGVtZW50KGJ1dHRvbik7XG4gICAgdGhpcy4jYnV0dG9ucy5hcHBlbmQoYnV0dG9uLCB0aGlzLiNkaXZpZGVyKTtcbiAgICB0aGlzLiNjb21tZW50ID0gY29tbWVudDtcbiAgICBjb21tZW50LnRvb2xiYXIgPSB0aGlzO1xuICB9XG4gIGFkZENvbG9yUGlja2VyKGNvbG9yUGlja2VyKSB7XG4gICAgaWYgKHRoaXMuI2NvbG9yUGlja2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbG9yUGlja2VyID0gY29sb3JQaWNrZXI7XG4gICAgY29uc3QgYnV0dG9uID0gY29sb3JQaWNrZXIucmVuZGVyQnV0dG9uKCk7XG4gICAgdGhpcy4jYWRkTGlzdGVuZXJzVG9FbGVtZW50KGJ1dHRvbik7XG4gICAgdGhpcy4jYnV0dG9ucy5hcHBlbmQoYnV0dG9uLCB0aGlzLiNkaXZpZGVyKTtcbiAgfVxuICBhc3luYyBhZGRFZGl0U2lnbmF0dXJlQnV0dG9uKHNpZ25hdHVyZU1hbmFnZXIpIHtcbiAgICBjb25zdCBidXR0b24gPSB0aGlzLiNzaWduYXR1cmVEZXNjcmlwdGlvbkJ1dHRvbiA9IGF3YWl0IHNpZ25hdHVyZU1hbmFnZXIucmVuZGVyRWRpdEJ1dHRvbih0aGlzLiNlZGl0b3IpO1xuICAgIHRoaXMuI2FkZExpc3RlbmVyc1RvRWxlbWVudChidXR0b24pO1xuICAgIHRoaXMuI2J1dHRvbnMuYXBwZW5kKGJ1dHRvbiwgdGhpcy4jZGl2aWRlcik7XG4gIH1cbiAgYXN5bmMgYWRkQnV0dG9uKG5hbWUsIHRvb2wpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgXCJjb2xvclBpY2tlclwiOlxuICAgICAgICB0aGlzLmFkZENvbG9yUGlja2VyKHRvb2wpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJhbHRUZXh0XCI6XG4gICAgICAgIGF3YWl0IHRoaXMuYWRkQWx0VGV4dCh0b29sKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZWRpdFNpZ25hdHVyZVwiOlxuICAgICAgICBhd2FpdCB0aGlzLmFkZEVkaXRTaWduYXR1cmVCdXR0b24odG9vbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRlbGV0ZVwiOlxuICAgICAgICB0aGlzLmFkZERlbGV0ZUJ1dHRvbigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjb21tZW50XCI6XG4gICAgICAgIHRoaXMuYWRkQ29tbWVudCh0b29sKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUVkaXRTaWduYXR1cmVCdXR0b24oZGVzY3JpcHRpb24pIHtcbiAgICBpZiAodGhpcy4jc2lnbmF0dXJlRGVzY3JpcHRpb25CdXR0b24pIHtcbiAgICAgIHRoaXMuI3NpZ25hdHVyZURlc2NyaXB0aW9uQnV0dG9uLnRpdGxlID0gZGVzY3JpcHRpb247XG4gICAgfVxuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLiN0b29sYmFyLnJlbW92ZSgpO1xuICAgIHRoaXMuI2NvbG9yUGlja2VyPy5kZXN0cm95KCk7XG4gICAgdGhpcy4jY29sb3JQaWNrZXIgPSBudWxsO1xuICB9XG59XG5jbGFzcyBGbG9hdGluZ1Rvb2xiYXIge1xuICAjYnV0dG9ucyA9IG51bGw7XG4gICN0b29sYmFyID0gbnVsbDtcbiAgI3VpTWFuYWdlcjtcbiAgY29uc3RydWN0b3IodWlNYW5hZ2VyKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyID0gdWlNYW5hZ2VyO1xuICB9XG4gICNyZW5kZXIoKSB7XG4gICAgY29uc3QgZWRpdFRvb2xiYXIgPSB0aGlzLiN0b29sYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBlZGl0VG9vbGJhci5jbGFzc05hbWUgPSBcImVkaXRUb29sYmFyXCI7XG4gICAgZWRpdFRvb2xiYXIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRvb2xiYXJcIik7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgaWYgKHNpZ25hbCBpbnN0YW5jZW9mIEFib3J0U2lnbmFsICYmICFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgZWRpdFRvb2xiYXIuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYnV0dG9ucyA9IHRoaXMuI2J1dHRvbnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGJ1dHRvbnMuY2xhc3NOYW1lID0gXCJidXR0b25zXCI7XG4gICAgZWRpdFRvb2xiYXIuYXBwZW5kKGJ1dHRvbnMpO1xuICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuaGFzQ29tbWVudE1hbmFnZXIoKSkge1xuICAgICAgdGhpcy4jbWFrZUJ1dHRvbihcImNvbW1lbnRCdXR0b25cIiwgYHBkZmpzLWNvbW1lbnQtZmxvYXRpbmctYnV0dG9uYCwgXCJwZGZqcy1jb21tZW50LWZsb2F0aW5nLWJ1dHRvbi1sYWJlbFwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI3VpTWFuYWdlci5jb21tZW50U2VsZWN0aW9uKFwiZmxvYXRpbmdfYnV0dG9uXCIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuI21ha2VCdXR0b24oXCJoaWdobGlnaHRCdXR0b25cIiwgYHBkZmpzLWhpZ2hsaWdodC1mbG9hdGluZy1idXR0b24xYCwgXCJwZGZqcy1oaWdobGlnaHQtZmxvYXRpbmctYnV0dG9uLWxhYmVsXCIsICgpID0+IHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5oaWdobGlnaHRTZWxlY3Rpb24oXCJmbG9hdGluZ19idXR0b25cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVkaXRUb29sYmFyO1xuICB9XG4gICNnZXRMYXN0UG9pbnQoYm94ZXMsIGlzTFRSKSB7XG4gICAgbGV0IGxhc3RZID0gMDtcbiAgICBsZXQgbGFzdFggPSAwO1xuICAgIGZvciAoY29uc3QgYm94IG9mIGJveGVzKSB7XG4gICAgICBjb25zdCB5ID0gYm94LnkgKyBib3guaGVpZ2h0O1xuICAgICAgaWYgKHkgPCBsYXN0WSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHggPSBib3gueCArIChpc0xUUiA/IGJveC53aWR0aCA6IDApO1xuICAgICAgaWYgKHkgPiBsYXN0WSkge1xuICAgICAgICBsYXN0WCA9IHg7XG4gICAgICAgIGxhc3RZID0geTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNMVFIpIHtcbiAgICAgICAgaWYgKHggPiBsYXN0WCkge1xuICAgICAgICAgIGxhc3RYID0geDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh4IDwgbGFzdFgpIHtcbiAgICAgICAgbGFzdFggPSB4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2lzTFRSID8gMSAtIGxhc3RYIDogbGFzdFgsIGxhc3RZXTtcbiAgfVxuICBzaG93KHBhcmVudCwgYm94ZXMsIGlzTFRSKSB7XG4gICAgY29uc3QgW3gsIHldID0gdGhpcy4jZ2V0TGFzdFBvaW50KGJveGVzLCBpc0xUUik7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy4jdG9vbGJhciB8fD0gdGhpcy4jcmVuZGVyKCk7XG4gICAgcGFyZW50LmFwcGVuZCh0aGlzLiN0b29sYmFyKTtcbiAgICBzdHlsZS5pbnNldElubGluZUVuZCA9IGAkezEwMCAqIHh9JWA7XG4gICAgc3R5bGUudG9wID0gYGNhbGMoJHsxMDAgKiB5fSUgKyB2YXIoLS1lZGl0b3ItdG9vbGJhci12ZXJ0LW9mZnNldCkpYDtcbiAgfVxuICBoaWRlKCkge1xuICAgIHRoaXMuI3Rvb2xiYXIucmVtb3ZlKCk7XG4gIH1cbiAgI21ha2VCdXR0b24oYnV0dG9uQ2xhc3MsIGwxMG5JZCwgbGFiZWxMMTBuSWQsIGNsaWNrSGFuZGxlcikge1xuICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJiYXNpY1wiLCBidXR0b25DbGFzcyk7XG4gICAgYnV0dG9uLnRhYkluZGV4ID0gMDtcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIGwxMG5JZCk7XG4gICAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGJ1dHRvbi5hcHBlbmQoc3Bhbik7XG4gICAgc3Bhbi5jbGFzc05hbWUgPSBcInZpc3VhbGx5SGlkZGVuXCI7XG4gICAgc3Bhbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgbGFiZWxMMTBuSWQpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIGlmIChzaWduYWwgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCAmJiAhc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBjbGlja0hhbmRsZXIsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy4jYnV0dG9ucy5hcHBlbmQoYnV0dG9uKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvdG9vbHMuanNcblxuXG5cbmZ1bmN0aW9uIGJpbmRFdmVudHMob2JqLCBlbGVtZW50LCBuYW1lcykge1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgbmFtZXMpIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgb2JqW25hbWVdLmJpbmQob2JqKSk7XG4gIH1cbn1cbmNsYXNzIElkTWFuYWdlciB7XG4gICNpZCA9IDA7XG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gYCR7QW5ub3RhdGlvbkVkaXRvclByZWZpeH0ke3RoaXMuI2lkKyt9YDtcbiAgfVxufVxuY2xhc3MgSW1hZ2VNYW5hZ2VyIHtcbiAgI2Jhc2VJZCA9IGdldFV1aWQoKTtcbiAgI2lkID0gMDtcbiAgI2NhY2hlID0gbnVsbDtcbiAgc3RhdGljIGdldCBfaXNTVkdGaXR0aW5nQ2FudmFzKCkge1xuICAgIGNvbnN0IHN2ZyA9IGBkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD1VVEYtOCw8c3ZnIHZpZXdCb3g9XCIwIDAgMSAxXCIgd2lkdGg9XCIxXCIgaGVpZ2h0PVwiMVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cmVjdCB3aWR0aD1cIjFcIiBoZWlnaHQ9XCIxXCIgc3R5bGU9XCJmaWxsOnJlZDtcIi8+PC9zdmc+YDtcbiAgICBjb25zdCBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDMpO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWFnZS5zcmMgPSBzdmc7XG4gICAgY29uc3QgcHJvbWlzZSA9IGltYWdlLmRlY29kZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgMSwgMSwgMCwgMCwgMSwgMyk7XG4gICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YS5idWZmZXIpWzBdID09PSAwO1xuICAgIH0pO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfaXNTVkdGaXR0aW5nQ2FudmFzXCIsIHByb21pc2UpO1xuICB9XG4gIGFzeW5jICNnZXQoa2V5LCByYXdEYXRhKSB7XG4gICAgdGhpcy4jY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgICBsZXQgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChrZXkpO1xuICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGRhdGE/LmJpdG1hcCkge1xuICAgICAgZGF0YS5yZWZDb3VudGVyICs9IDE7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGRhdGEgfHw9IHtcbiAgICAgICAgYml0bWFwOiBudWxsLFxuICAgICAgICBpZDogYGltYWdlXyR7dGhpcy4jYmFzZUlkfV8ke3RoaXMuI2lkKyt9YCxcbiAgICAgICAgcmVmQ291bnRlcjogMCxcbiAgICAgICAgaXNTdmc6IGZhbHNlXG4gICAgICB9O1xuICAgICAgbGV0IGltYWdlO1xuICAgICAgaWYgKHR5cGVvZiByYXdEYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGRhdGEudXJsID0gcmF3RGF0YTtcbiAgICAgICAgaW1hZ2UgPSBhd2FpdCBmZXRjaERhdGEocmF3RGF0YSwgXCJibG9iXCIpO1xuICAgICAgfSBlbHNlIGlmIChyYXdEYXRhIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICBpbWFnZSA9IGRhdGEuZmlsZSA9IHJhd0RhdGE7XG4gICAgICB9IGVsc2UgaWYgKHJhd0RhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGltYWdlID0gcmF3RGF0YTtcbiAgICAgIH1cbiAgICAgIGlmIChpbWFnZS50eXBlID09PSBcImltYWdlL3N2Zyt4bWxcIikge1xuICAgICAgICBjb25zdCBtdXN0UmVtb3ZlQXNwZWN0UmF0aW9Qcm9taXNlID0gSW1hZ2VNYW5hZ2VyLl9pc1NWR0ZpdHRpbmdDYW52YXM7XG4gICAgICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICBjb25zdCBpbWFnZUVsZW1lbnQgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgY29uc3QgaW1hZ2VQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGltYWdlRWxlbWVudC5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBkYXRhLmJpdG1hcCA9IGltYWdlRWxlbWVudDtcbiAgICAgICAgICAgIGRhdGEuaXNTdmcgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBkYXRhLnN2Z1VybCA9IGZpbGVSZWFkZXIucmVzdWx0O1xuICAgICAgICAgICAgaW1hZ2VFbGVtZW50LnNyYyA9IChhd2FpdCBtdXN0UmVtb3ZlQXNwZWN0UmF0aW9Qcm9taXNlKSA/IGAke3VybH0jc3ZnVmlldyhwcmVzZXJ2ZUFzcGVjdFJhdGlvKG5vbmUpKWAgOiB1cmw7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpbWFnZUVsZW1lbnQub25lcnJvciA9IGZpbGVSZWFkZXIub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbGVSZWFkZXIucmVhZEFzRGF0YVVSTChpbWFnZSk7XG4gICAgICAgIGF3YWl0IGltYWdlUHJvbWlzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEuYml0bWFwID0gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoaW1hZ2UpO1xuICAgICAgfVxuICAgICAgZGF0YS5yZWZDb3VudGVyID0gMTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKGUpO1xuICAgICAgZGF0YSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuI2NhY2hlLnNldChrZXksIGRhdGEpO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICB0aGlzLiNjYWNoZS5zZXQoZGF0YS5pZCwgZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGFzeW5jIGdldEZyb21GaWxlKGZpbGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBsYXN0TW9kaWZpZWQsXG4gICAgICBuYW1lLFxuICAgICAgc2l6ZSxcbiAgICAgIHR5cGVcbiAgICB9ID0gZmlsZTtcbiAgICByZXR1cm4gdGhpcy4jZ2V0KGAke2xhc3RNb2RpZmllZH1fJHtuYW1lfV8ke3NpemV9XyR7dHlwZX1gLCBmaWxlKTtcbiAgfVxuICBhc3luYyBnZXRGcm9tVXJsKHVybCkge1xuICAgIHJldHVybiB0aGlzLiNnZXQodXJsLCB1cmwpO1xuICB9XG4gIGFzeW5jIGdldEZyb21CbG9iKGlkLCBibG9iUHJvbWlzZSkge1xuICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBibG9iUHJvbWlzZTtcbiAgICByZXR1cm4gdGhpcy4jZ2V0KGlkLCBibG9iKTtcbiAgfVxuICBhc3luYyBnZXRGcm9tSWQoaWQpIHtcbiAgICB0aGlzLiNjYWNoZSB8fD0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLiNjYWNoZS5nZXQoaWQpO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChkYXRhLmJpdG1hcCkge1xuICAgICAgZGF0YS5yZWZDb3VudGVyICs9IDE7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKGRhdGEuZmlsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RnJvbUZpbGUoZGF0YS5maWxlKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuYmxvYlByb21pc2UpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYmxvYlByb21pc2VcbiAgICAgIH0gPSBkYXRhO1xuICAgICAgZGVsZXRlIGRhdGEuYmxvYlByb21pc2U7XG4gICAgICByZXR1cm4gdGhpcy5nZXRGcm9tQmxvYihkYXRhLmlkLCBibG9iUHJvbWlzZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEZyb21VcmwoZGF0YS51cmwpO1xuICB9XG4gIGdldEZyb21DYW52YXMoaWQsIGNhbnZhcykge1xuICAgIHRoaXMuI2NhY2hlIHx8PSBuZXcgTWFwKCk7XG4gICAgbGV0IGRhdGEgPSB0aGlzLiNjYWNoZS5nZXQoaWQpO1xuICAgIGlmIChkYXRhPy5iaXRtYXApIHtcbiAgICAgIGRhdGEucmVmQ291bnRlciArPSAxO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGN0eC5kcmF3SW1hZ2UoY2FudmFzLCAwLCAwKTtcbiAgICBkYXRhID0ge1xuICAgICAgYml0bWFwOiBvZmZzY3JlZW4udHJhbnNmZXJUb0ltYWdlQml0bWFwKCksXG4gICAgICBpZDogYGltYWdlXyR7dGhpcy4jYmFzZUlkfV8ke3RoaXMuI2lkKyt9YCxcbiAgICAgIHJlZkNvdW50ZXI6IDEsXG4gICAgICBpc1N2ZzogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMuI2NhY2hlLnNldChpZCwgZGF0YSk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KGRhdGEuaWQsIGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGdldFN2Z1VybChpZCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLiNjYWNoZS5nZXQoaWQpO1xuICAgIGlmICghZGF0YT8uaXNTdmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YS5zdmdVcmw7XG4gIH1cbiAgZGVsZXRlSWQoaWQpIHtcbiAgICB0aGlzLiNjYWNoZSB8fD0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLiNjYWNoZS5nZXQoaWQpO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkYXRhLnJlZkNvdW50ZXIgLT0gMTtcbiAgICBpZiAoZGF0YS5yZWZDb3VudGVyICE9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGJpdG1hcFxuICAgIH0gPSBkYXRhO1xuICAgIGlmICghZGF0YS51cmwgJiYgIWRhdGEuZmlsZSkge1xuICAgICAgY29uc3QgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhiaXRtYXAud2lkdGgsIGJpdG1hcC5oZWlnaHQpO1xuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCJiaXRtYXByZW5kZXJlclwiKTtcbiAgICAgIGN0eC50cmFuc2ZlckZyb21JbWFnZUJpdG1hcChiaXRtYXApO1xuICAgICAgZGF0YS5ibG9iUHJvbWlzZSA9IGNhbnZhcy5jb252ZXJ0VG9CbG9iKCk7XG4gICAgfVxuICAgIGJpdG1hcC5jbG9zZT8uKCk7XG4gICAgZGF0YS5iaXRtYXAgPSBudWxsO1xuICB9XG4gIGlzVmFsaWRJZChpZCkge1xuICAgIHJldHVybiBpZC5zdGFydHNXaXRoKGBpbWFnZV8ke3RoaXMuI2Jhc2VJZH1fYCk7XG4gIH1cbn1cbmNsYXNzIENvbW1hbmRNYW5hZ2VyIHtcbiAgI2NvbW1hbmRzID0gW107XG4gICNsb2NrZWQgPSBmYWxzZTtcbiAgI21heFNpemU7XG4gICNwb3NpdGlvbiA9IC0xO1xuICBjb25zdHJ1Y3RvcihtYXhTaXplID0gMTI4KSB7XG4gICAgdGhpcy4jbWF4U2l6ZSA9IG1heFNpemU7XG4gIH1cbiAgYWRkKHtcbiAgICBjbWQsXG4gICAgdW5kbyxcbiAgICBwb3N0LFxuICAgIG11c3RFeGVjLFxuICAgIHR5cGUgPSBOYU4sXG4gICAgb3ZlcndyaXRlSWZTYW1lVHlwZSA9IGZhbHNlLFxuICAgIGtlZXBVbmRvID0gZmFsc2VcbiAgfSkge1xuICAgIGlmIChtdXN0RXhlYykge1xuICAgICAgY21kKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNsb2NrZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2F2ZSA9IHtcbiAgICAgIGNtZCxcbiAgICAgIHVuZG8sXG4gICAgICBwb3N0LFxuICAgICAgdHlwZVxuICAgIH07XG4gICAgaWYgKHRoaXMuI3Bvc2l0aW9uID09PSAtMSkge1xuICAgICAgaWYgKHRoaXMuI2NvbW1hbmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy4jY29tbWFuZHMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3Bvc2l0aW9uID0gMDtcbiAgICAgIHRoaXMuI2NvbW1hbmRzLnB1c2goc2F2ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvdmVyd3JpdGVJZlNhbWVUeXBlICYmIHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXS50eXBlID09PSB0eXBlKSB7XG4gICAgICBpZiAoa2VlcFVuZG8pIHtcbiAgICAgICAgc2F2ZS51bmRvID0gdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dLnVuZG87XG4gICAgICB9XG4gICAgICB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl0gPSBzYXZlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXh0ID0gdGhpcy4jcG9zaXRpb24gKyAxO1xuICAgIGlmIChuZXh0ID09PSB0aGlzLiNtYXhTaXplKSB7XG4gICAgICB0aGlzLiNjb21tYW5kcy5zcGxpY2UoMCwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI3Bvc2l0aW9uID0gbmV4dDtcbiAgICAgIGlmIChuZXh0IDwgdGhpcy4jY29tbWFuZHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuI2NvbW1hbmRzLnNwbGljZShuZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jY29tbWFuZHMucHVzaChzYXZlKTtcbiAgfVxuICB1bmRvKCkge1xuICAgIGlmICh0aGlzLiNwb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jbG9ja2VkID0gdHJ1ZTtcbiAgICBjb25zdCB7XG4gICAgICB1bmRvLFxuICAgICAgcG9zdFxuICAgIH0gPSB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl07XG4gICAgdW5kbygpO1xuICAgIHBvc3Q/LigpO1xuICAgIHRoaXMuI2xvY2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuI3Bvc2l0aW9uIC09IDE7XG4gIH1cbiAgcmVkbygpIHtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gPCB0aGlzLiNjb21tYW5kcy5sZW5ndGggLSAxKSB7XG4gICAgICB0aGlzLiNwb3NpdGlvbiArPSAxO1xuICAgICAgdGhpcy4jbG9ja2VkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY21kLFxuICAgICAgICBwb3N0XG4gICAgICB9ID0gdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dO1xuICAgICAgY21kKCk7XG4gICAgICBwb3N0Py4oKTtcbiAgICAgIHRoaXMuI2xvY2tlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBoYXNTb21ldGhpbmdUb1VuZG8oKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Bvc2l0aW9uICE9PSAtMTtcbiAgfVxuICBoYXNTb21ldGhpbmdUb1JlZG8oKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Bvc2l0aW9uIDwgdGhpcy4jY29tbWFuZHMubGVuZ3RoIC0gMTtcbiAgfVxuICBjbGVhblR5cGUodHlwZSkge1xuICAgIGlmICh0aGlzLiNwb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuI3Bvc2l0aW9uOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKHRoaXMuI2NvbW1hbmRzW2ldLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgdGhpcy4jY29tbWFuZHMuc3BsaWNlKGkgKyAxLCB0aGlzLiNwb3NpdGlvbiAtIGkpO1xuICAgICAgICB0aGlzLiNwb3NpdGlvbiA9IGk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jY29tbWFuZHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLiNwb3NpdGlvbiA9IC0xO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jY29tbWFuZHMgPSBudWxsO1xuICB9XG59XG5jbGFzcyBLZXlib2FyZE1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihjYWxsYmFja3MpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYWxsS2V5cyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGZvciAoY29uc3QgW2tleXMsIGNhbGxiYWNrLCBvcHRpb25zID0ge31dIG9mIGNhbGxiYWNrcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBjb25zdCBpc01hY0tleSA9IGtleS5zdGFydHNXaXRoKFwibWFjK1wiKTtcbiAgICAgICAgaWYgKGlzTWFjICYmIGlzTWFjS2V5KSB7XG4gICAgICAgICAgdGhpcy5jYWxsYmFja3Muc2V0KGtleS5zbGljZSg0KSwge1xuICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5hbGxLZXlzLmFkZChrZXkuc3BsaXQoXCIrXCIpLmF0KC0xKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzTWFjICYmICFpc01hY0tleSkge1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLnNldChrZXksIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuYWxsS2V5cy5hZGQoa2V5LnNwbGl0KFwiK1wiKS5hdCgtMSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNzZXJpYWxpemUoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5KSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwiYWx0XCIpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQuY3RybEtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcImN0cmxcIik7XG4gICAgfVxuICAgIGlmIChldmVudC5tZXRhS2V5KSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwibWV0YVwiKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwic2hpZnRcIik7XG4gICAgfVxuICAgIHRoaXMuYnVmZmVyLnB1c2goZXZlbnQua2V5KTtcbiAgICBjb25zdCBzdHIgPSB0aGlzLmJ1ZmZlci5qb2luKFwiK1wiKTtcbiAgICB0aGlzLmJ1ZmZlci5sZW5ndGggPSAwO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgZXhlYyhzZWxmLCBldmVudCkge1xuICAgIGlmICghdGhpcy5hbGxLZXlzLmhhcyhldmVudC5rZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluZm8gPSB0aGlzLmNhbGxiYWNrcy5nZXQodGhpcy4jc2VyaWFsaXplKGV2ZW50KSk7XG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBidWJibGVzID0gZmFsc2UsXG4gICAgICAgIGFyZ3MgPSBbXSxcbiAgICAgICAgY2hlY2tlciA9IG51bGxcbiAgICAgIH1cbiAgICB9ID0gaW5mbztcbiAgICBpZiAoY2hlY2tlciAmJiAhY2hlY2tlcihzZWxmLCBldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2suYmluZChzZWxmLCAuLi5hcmdzLCBldmVudCkoKTtcbiAgICBpZiAoIWJ1YmJsZXMpIHtcbiAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBDb2xvck1hbmFnZXIge1xuICBzdGF0aWMgX2NvbG9yc01hcHBpbmcgPSBuZXcgTWFwKFtbXCJDYW52YXNUZXh0XCIsIFswLCAwLCAwXV0sIFtcIkNhbnZhc1wiLCBbMjU1LCAyNTUsIDI1NV1dXSk7XG4gIGdldCBfY29sb3JzKCkge1xuICAgIGNvbnN0IGNvbG9ycyA9IG5ldyBNYXAoW1tcIkNhbnZhc1RleHRcIiwgbnVsbF0sIFtcIkNhbnZhc1wiLCBudWxsXV0pO1xuICAgIGdldENvbG9yVmFsdWVzKGNvbG9ycyk7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9jb2xvcnNcIiwgY29sb3JzKTtcbiAgfVxuICBjb252ZXJ0KGNvbG9yKSB7XG4gICAgY29uc3QgcmdiID0gZ2V0UkdCKGNvbG9yKTtcbiAgICBpZiAoIXdpbmRvdy5tYXRjaE1lZGlhKFwiKGZvcmNlZC1jb2xvcnM6IGFjdGl2ZSlcIikubWF0Y2hlcykge1xuICAgICAgcmV0dXJuIHJnYjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbbmFtZSwgUkdCXSBvZiB0aGlzLl9jb2xvcnMpIHtcbiAgICAgIGlmIChSR0IuZXZlcnkoKHgsIGkpID0+IHggPT09IHJnYltpXSkpIHtcbiAgICAgICAgcmV0dXJuIENvbG9yTWFuYWdlci5fY29sb3JzTWFwcGluZy5nZXQobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZ2I7XG4gIH1cbiAgZ2V0SGV4Q29kZShuYW1lKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fY29sb3JzLmdldChuYW1lKTtcbiAgICBpZiAoIXJnYikge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBVdGlsLm1ha2VIZXhDb2xvciguLi5yZ2IpO1xuICB9XG59XG5jbGFzcyBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyIHtcbiAgI2Fib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgI2FjdGl2ZUVkaXRvciA9IG51bGw7XG4gICNhbGxFZGl0YWJsZUFubm90YXRpb25zID0gbnVsbDtcbiAgI2FsbEVkaXRvcnMgPSBuZXcgTWFwKCk7XG4gICNhbGxMYXllcnMgPSBuZXcgTWFwKCk7XG4gICNhbHRUZXh0TWFuYWdlciA9IG51bGw7XG4gICNhbm5vdGF0aW9uU3RvcmFnZSA9IG51bGw7XG4gICNjaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9ucyA9IG51bGw7XG4gICNjb21tYW5kTWFuYWdlciA9IG5ldyBDb21tYW5kTWFuYWdlcigpO1xuICAjY29tbWVudE1hbmFnZXIgPSBudWxsO1xuICAjY29weVBhc3RlQUMgPSBudWxsO1xuICAjY3VycmVudERyYXdpbmdTZXNzaW9uID0gbnVsbDtcbiAgI2N1cnJlbnRQYWdlSW5kZXggPSAwO1xuICAjZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcyA9IG5ldyBTZXQoKTtcbiAgI2RyYWdnaW5nRWRpdG9ycyA9IG51bGw7XG4gICNlZGl0b3JUeXBlcyA9IG51bGw7XG4gICNlZGl0b3JzVG9SZXNjYWxlID0gbmV3IFNldCgpO1xuICBfZWRpdG9yVW5kb0JhciA9IG51bGw7XG4gICNlbmFibGVIaWdobGlnaHRGbG9hdGluZ0J1dHRvbiA9IGZhbHNlO1xuICAjZW5hYmxlVXBkYXRlZEFkZEltYWdlID0gZmFsc2U7XG4gICNlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlID0gZmFsc2U7XG4gICNmaWx0ZXJGYWN0b3J5ID0gbnVsbDtcbiAgI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCA9IG51bGw7XG4gICNmb2N1c01hbmFnZXJBQyA9IG51bGw7XG4gICNoaWdobGlnaHRDb2xvcnMgPSBudWxsO1xuICAjaGlnaGxpZ2h0V2hlblNoaWZ0VXAgPSBmYWxzZTtcbiAgI2Zsb2F0aW5nVG9vbGJhciA9IG51bGw7XG4gICNpZE1hbmFnZXIgPSBuZXcgSWRNYW5hZ2VyKCk7XG4gICNpc0VuYWJsZWQgPSBmYWxzZTtcbiAgI2lzUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgI2lzV2FpdGluZyA9IGZhbHNlO1xuICAja2V5Ym9hcmRNYW5hZ2VyQUMgPSBudWxsO1xuICAjbGFzdEFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAjbWFpbkhpZ2hsaWdodENvbG9yUGlja2VyID0gbnVsbDtcbiAgI21pc3NpbmdDYW52YXNlcyA9IG51bGw7XG4gICNtbE1hbmFnZXIgPSBudWxsO1xuICAjbW9kZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkU7XG4gICNzZWxlY3RlZEVkaXRvcnMgPSBuZXcgU2V0KCk7XG4gICNzZWxlY3RlZFRleHROb2RlID0gbnVsbDtcbiAgI3NpZ25hdHVyZU1hbmFnZXIgPSBudWxsO1xuICAjcGFnZUNvbG9ycyA9IG51bGw7XG4gICNzaG93QWxsU3RhdGVzID0gbnVsbDtcbiAgI3BkZkRvY3VtZW50ID0gbnVsbDtcbiAgI3ByZXZpb3VzU3RhdGVzID0ge1xuICAgIGlzRWRpdGluZzogZmFsc2UsXG4gICAgaXNFbXB0eTogdHJ1ZSxcbiAgICBoYXNTb21ldGhpbmdUb1VuZG86IGZhbHNlLFxuICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogZmFsc2UsXG4gICAgaGFzU2VsZWN0ZWRFZGl0b3I6IGZhbHNlLFxuICAgIGhhc1NlbGVjdGVkVGV4dDogZmFsc2VcbiAgfTtcbiAgI3RyYW5zbGF0aW9uID0gWzAsIDBdO1xuICAjdHJhbnNsYXRpb25UaW1lb3V0SWQgPSBudWxsO1xuICAjY29udGFpbmVyID0gbnVsbDtcbiAgI3ZpZXdlciA9IG51bGw7XG4gICN2aWV3ZXJBbGVydCA9IG51bGw7XG4gICN1cGRhdGVNb2RlQ2FwYWJpbGl0eSA9IG51bGw7XG4gIHN0YXRpYyBUUkFOU0xBVEVfU01BTEwgPSAxO1xuICBzdGF0aWMgVFJBTlNMQVRFX0JJRyA9IDEwO1xuICBzdGF0aWMgZ2V0IF9rZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgY29uc3QgcHJvdG8gPSBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLnByb3RvdHlwZTtcbiAgICBjb25zdCBhcnJvd0NoZWNrZXIgPSBzZWxmID0+IHNlbGYuI2NvbnRhaW5lci5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LnRhZ05hbWUgIT09IFwiQlVUVE9OXCIgJiYgc2VsZi5oYXNTb21ldGhpbmdUb0NvbnRyb2woKTtcbiAgICBjb25zdCB0ZXh0SW5wdXRDaGVja2VyID0gKF9zZWxmLCB7XG4gICAgICB0YXJnZXQ6IGVsXG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGVsIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdHlwZVxuICAgICAgICB9ID0gZWw7XG4gICAgICAgIHJldHVybiB0eXBlICE9PSBcInRleHRcIiAmJiB0eXBlICE9PSBcIm51bWJlclwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBzbWFsbCA9IHRoaXMuVFJBTlNMQVRFX1NNQUxMO1xuICAgIGNvbnN0IGJpZyA9IHRoaXMuVFJBTlNMQVRFX0JJRztcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiY3RybCthXCIsIFwibWFjK21ldGErYVwiXSwgcHJvdG8uc2VsZWN0QWxsLCB7XG4gICAgICBjaGVja2VyOiB0ZXh0SW5wdXRDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK3pcIiwgXCJtYWMrbWV0YSt6XCJdLCBwcm90by51bmRvLCB7XG4gICAgICBjaGVja2VyOiB0ZXh0SW5wdXRDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK3lcIiwgXCJjdHJsK3NoaWZ0K3pcIiwgXCJtYWMrbWV0YStzaGlmdCt6XCIsIFwiY3RybCtzaGlmdCtaXCIsIFwibWFjK21ldGErc2hpZnQrWlwiXSwgcHJvdG8ucmVkbywge1xuICAgICAgY2hlY2tlcjogdGV4dElucHV0Q2hlY2tlclxuICAgIH1dLCBbW1wiQmFja3NwYWNlXCIsIFwiYWx0K0JhY2tzcGFjZVwiLCBcImN0cmwrQmFja3NwYWNlXCIsIFwic2hpZnQrQmFja3NwYWNlXCIsIFwibWFjK0JhY2tzcGFjZVwiLCBcIm1hYythbHQrQmFja3NwYWNlXCIsIFwibWFjK2N0cmwrQmFja3NwYWNlXCIsIFwiRGVsZXRlXCIsIFwiY3RybCtEZWxldGVcIiwgXCJzaGlmdCtEZWxldGVcIiwgXCJtYWMrRGVsZXRlXCJdLCBwcm90by5kZWxldGUsIHtcbiAgICAgIGNoZWNrZXI6IHRleHRJbnB1dENoZWNrZXJcbiAgICB9XSwgW1tcIkVudGVyXCIsIFwibWFjK0VudGVyXCJdLCBwcm90by5hZGROZXdFZGl0b3JGcm9tS2V5Ym9hcmQsIHtcbiAgICAgIGNoZWNrZXI6IChzZWxmLCB7XG4gICAgICAgIHRhcmdldDogZWxcbiAgICAgIH0pID0+ICEoZWwgaW5zdGFuY2VvZiBIVE1MQnV0dG9uRWxlbWVudCkgJiYgc2VsZi4jY29udGFpbmVyLmNvbnRhaW5zKGVsKSAmJiAhc2VsZi5pc0VudGVySGFuZGxlZFxuICAgIH1dLCBbW1wiIFwiLCBcIm1hYysgXCJdLCBwcm90by5hZGROZXdFZGl0b3JGcm9tS2V5Ym9hcmQsIHtcbiAgICAgIGNoZWNrZXI6IChzZWxmLCB7XG4gICAgICAgIHRhcmdldDogZWxcbiAgICAgIH0pID0+ICEoZWwgaW5zdGFuY2VvZiBIVE1MQnV0dG9uRWxlbWVudCkgJiYgc2VsZi4jY29udGFpbmVyLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpXG4gICAgfV0sIFtbXCJFc2NhcGVcIiwgXCJtYWMrRXNjYXBlXCJdLCBwcm90by51bnNlbGVjdEFsbF0sIFtbXCJBcnJvd0xlZnRcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFstc21hbGwsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93TGVmdFwiLCBcIm1hYytzaGlmdCtBcnJvd0xlZnRcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWy1iaWcsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogW3NtYWxsLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1JpZ2h0XCIsIFwibWFjK3NoaWZ0K0Fycm93UmlnaHRcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogW2JpZywgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93VXBcIiwgXCJtYWMrQXJyb3dVcFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbMCwgLXNtYWxsXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1VwXCIsIFwibWFjK3NoaWZ0K0Fycm93VXBcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWzAsIC1iaWddLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd0Rvd25cIiwgXCJtYWMrQXJyb3dEb3duXCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFswLCBzbWFsbF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dEb3duXCIsIFwibWFjK3NoaWZ0K0Fycm93RG93blwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbMCwgYmlnXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dXSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgdmlld2VyLCB2aWV3ZXJBbGVydCwgYWx0VGV4dE1hbmFnZXIsIGNvbW1lbnRNYW5hZ2VyLCBzaWduYXR1cmVNYW5hZ2VyLCBldmVudEJ1cywgcGRmRG9jdW1lbnQsIHBhZ2VDb2xvcnMsIGhpZ2hsaWdodENvbG9ycywgZW5hYmxlSGlnaGxpZ2h0RmxvYXRpbmdCdXR0b24sIGVuYWJsZVVwZGF0ZWRBZGRJbWFnZSwgZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSwgbWxNYW5hZ2VyLCBlZGl0b3JVbmRvQmFyLCBzdXBwb3J0c1BpbmNoVG9ab29tKSB7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fc2lnbmFsID0gdGhpcy4jYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgICB0aGlzLiNjb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy4jdmlld2VyID0gdmlld2VyO1xuICAgIHRoaXMuI3ZpZXdlckFsZXJ0ID0gdmlld2VyQWxlcnQ7XG4gICAgdGhpcy4jYWx0VGV4dE1hbmFnZXIgPSBhbHRUZXh0TWFuYWdlcjtcbiAgICB0aGlzLiNjb21tZW50TWFuYWdlciA9IGNvbW1lbnRNYW5hZ2VyO1xuICAgIHRoaXMuI3NpZ25hdHVyZU1hbmFnZXIgPSBzaWduYXR1cmVNYW5hZ2VyO1xuICAgIHRoaXMuI3BkZkRvY3VtZW50ID0gcGRmRG9jdW1lbnQ7XG4gICAgdGhpcy5fZXZlbnRCdXMgPSBldmVudEJ1cztcbiAgICBldmVudEJ1cy5fb24oXCJlZGl0aW5nYWN0aW9uXCIsIHRoaXMub25FZGl0aW5nQWN0aW9uLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGV2ZW50QnVzLl9vbihcInBhZ2VjaGFuZ2luZ1wiLCB0aGlzLm9uUGFnZUNoYW5naW5nLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGV2ZW50QnVzLl9vbihcInNjYWxlY2hhbmdpbmdcIiwgdGhpcy5vblNjYWxlQ2hhbmdpbmcuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZXZlbnRCdXMuX29uKFwicm90YXRpb25jaGFuZ2luZ1wiLCB0aGlzLm9uUm90YXRpb25DaGFuZ2luZy5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBldmVudEJ1cy5fb24oXCJzZXRwcmVmZXJlbmNlXCIsIHRoaXMub25TZXRQcmVmZXJlbmNlLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGV2ZW50QnVzLl9vbihcInN3aXRjaGFubm90YXRpb25lZGl0b3JwYXJhbXNcIiwgZXZ0ID0+IHRoaXMudXBkYXRlUGFyYW1zKGV2dC50eXBlLCBldnQudmFsdWUpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsICgpID0+IHtcbiAgICAgIHRoaXMuI2lzUG9pbnRlckRvd24gPSB0cnVlO1xuICAgIH0sIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLiNpc1BvaW50ZXJEb3duID0gZmFsc2U7XG4gICAgfSwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuI2FkZFNlbGVjdGlvbkxpc3RlbmVyKCk7XG4gICAgdGhpcy4jYWRkRHJhZ0FuZERyb3BMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLiNhZGRLZXlib2FyZE1hbmFnZXIoKTtcbiAgICB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZSA9IHBkZkRvY3VtZW50LmFubm90YXRpb25TdG9yYWdlO1xuICAgIHRoaXMuI2ZpbHRlckZhY3RvcnkgPSBwZGZEb2N1bWVudC5maWx0ZXJGYWN0b3J5O1xuICAgIHRoaXMuI3BhZ2VDb2xvcnMgPSBwYWdlQ29sb3JzO1xuICAgIHRoaXMuI2hpZ2hsaWdodENvbG9ycyA9IGhpZ2hsaWdodENvbG9ycyB8fCBudWxsO1xuICAgIHRoaXMuI2VuYWJsZUhpZ2hsaWdodEZsb2F0aW5nQnV0dG9uID0gZW5hYmxlSGlnaGxpZ2h0RmxvYXRpbmdCdXR0b247XG4gICAgdGhpcy4jZW5hYmxlVXBkYXRlZEFkZEltYWdlID0gZW5hYmxlVXBkYXRlZEFkZEltYWdlO1xuICAgIHRoaXMuI2VuYWJsZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UgPSBlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlO1xuICAgIHRoaXMuI21sTWFuYWdlciA9IG1sTWFuYWdlciB8fCBudWxsO1xuICAgIHRoaXMudmlld1BhcmFtZXRlcnMgPSB7XG4gICAgICByZWFsU2NhbGU6IFBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUyxcbiAgICAgIHJvdGF0aW9uOiAwXG4gICAgfTtcbiAgICB0aGlzLmlzU2hpZnRLZXlEb3duID0gZmFsc2U7XG4gICAgdGhpcy5fZWRpdG9yVW5kb0JhciA9IGVkaXRvclVuZG9CYXIgfHwgbnVsbDtcbiAgICB0aGlzLl9zdXBwb3J0c1BpbmNoVG9ab29tID0gc3VwcG9ydHNQaW5jaFRvWm9vbSAhPT0gZmFsc2U7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eT8ucmVzb2x2ZSgpO1xuICAgIHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5ID0gbnVsbDtcbiAgICB0aGlzLiNhYm9ydENvbnRyb2xsZXI/LmFib3J0KCk7XG4gICAgdGhpcy4jYWJvcnRDb250cm9sbGVyID0gbnVsbDtcbiAgICB0aGlzLl9zaWduYWwgPSBudWxsO1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICBsYXllci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuI2FsbExheWVycy5jbGVhcigpO1xuICAgIHRoaXMuI2FsbEVkaXRvcnMuY2xlYXIoKTtcbiAgICB0aGlzLiNlZGl0b3JzVG9SZXNjYWxlLmNsZWFyKCk7XG4gICAgdGhpcy4jbWlzc2luZ0NhbnZhc2VzPy5jbGVhcigpO1xuICAgIHRoaXMuI2FjdGl2ZUVkaXRvciA9IG51bGw7XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuI2FsdFRleHRNYW5hZ2VyPy5kZXN0cm95KCk7XG4gICAgdGhpcy4jY29tbWVudE1hbmFnZXI/LmRlc3Ryb3koKTtcbiAgICB0aGlzLiNzaWduYXR1cmVNYW5hZ2VyPy5kZXN0cm95KCk7XG4gICAgdGhpcy4jZmxvYXRpbmdUb29sYmFyPy5oaWRlKCk7XG4gICAgdGhpcy4jZmxvYXRpbmdUb29sYmFyID0gbnVsbDtcbiAgICB0aGlzLiNtYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXI/LmRlc3Ryb3koKTtcbiAgICB0aGlzLiNtYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIgPSBudWxsO1xuICAgIHRoaXMuI2FsbEVkaXRhYmxlQW5ub3RhdGlvbnMgPSBudWxsO1xuICAgIGlmICh0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQpO1xuICAgICAgdGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQpO1xuICAgICAgdGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0b3JVbmRvQmFyPy5kZXN0cm95KCk7XG4gICAgdGhpcy4jcGRmRG9jdW1lbnQgPSBudWxsO1xuICB9XG4gIGNvbWJpbmVkU2lnbmFsKGFjKSB7XG4gICAgcmV0dXJuIEFib3J0U2lnbmFsLmFueShbdGhpcy5fc2lnbmFsLCBhYy5zaWduYWxdKTtcbiAgfVxuICBnZXQgbWxNYW5hZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLiNtbE1hbmFnZXI7XG4gIH1cbiAgZ2V0IHVzZU5ld0FsdFRleHRGbG93KCkge1xuICAgIHJldHVybiB0aGlzLiNlbmFibGVVcGRhdGVkQWRkSW1hZ2U7XG4gIH1cbiAgZ2V0IHVzZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VuYWJsZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2U7XG4gIH1cbiAgZ2V0IGhjbUZpbHRlcigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaGNtRmlsdGVyXCIsIHRoaXMuI3BhZ2VDb2xvcnMgPyB0aGlzLiNmaWx0ZXJGYWN0b3J5LmFkZEhDTUZpbHRlcih0aGlzLiNwYWdlQ29sb3JzLmZvcmVncm91bmQsIHRoaXMuI3BhZ2VDb2xvcnMuYmFja2dyb3VuZCkgOiBcIm5vbmVcIik7XG4gIH1cbiAgZ2V0IGRpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiZGlyZWN0aW9uXCIsIGdldENvbXB1dGVkU3R5bGUodGhpcy4jY29udGFpbmVyKS5kaXJlY3Rpb24pO1xuICB9XG4gIGdldCBfaGlnaGxpZ2h0Q29sb3JzKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfaGlnaGxpZ2h0Q29sb3JzXCIsIHRoaXMuI2hpZ2hsaWdodENvbG9ycyA/IG5ldyBNYXAodGhpcy4jaGlnaGxpZ2h0Q29sb3JzLnNwbGl0KFwiLFwiKS5tYXAocGFpciA9PiB7XG4gICAgICBwYWlyID0gcGFpci5zcGxpdChcIj1cIikubWFwKHggPT4geC50cmltKCkpO1xuICAgICAgcGFpclsxXSA9IHBhaXJbMV0udG9VcHBlckNhc2UoKTtcbiAgICAgIHJldHVybiBwYWlyO1xuICAgIH0pKSA6IG51bGwpO1xuICB9XG4gIGdldCBoaWdobGlnaHRDb2xvcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgX2hpZ2hsaWdodENvbG9yc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghX2hpZ2hsaWdodENvbG9ycykge1xuICAgICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImhpZ2hsaWdodENvbG9yc1wiLCBudWxsKTtcbiAgICB9XG4gICAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGhhc0hDTSA9ICEhdGhpcy4jcGFnZUNvbG9ycztcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBjb2xvcl0gb2YgX2hpZ2hsaWdodENvbG9ycykge1xuICAgICAgY29uc3QgaXNOYW1lRm9ySENNID0gbmFtZS5lbmRzV2l0aChcIl9IQ01cIik7XG4gICAgICBpZiAoaGFzSENNICYmIGlzTmFtZUZvckhDTSkge1xuICAgICAgICBtYXAuc2V0KG5hbWUucmVwbGFjZShcIl9IQ01cIiwgXCJcIiksIGNvbG9yKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWhhc0hDTSAmJiAhaXNOYW1lRm9ySENNKSB7XG4gICAgICAgIG1hcC5zZXQobmFtZSwgY29sb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaGlnaGxpZ2h0Q29sb3JzXCIsIG1hcCk7XG4gIH1cbiAgZ2V0IGhpZ2hsaWdodENvbG9yTmFtZXMoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImhpZ2hsaWdodENvbG9yTmFtZXNcIiwgdGhpcy5oaWdobGlnaHRDb2xvcnMgPyBuZXcgTWFwKEFycmF5LmZyb20odGhpcy5oaWdobGlnaHRDb2xvcnMsIGUgPT4gZS5yZXZlcnNlKCkpKSA6IG51bGwpO1xuICB9XG4gIGdldE5vbkhDTUNvbG9yKGNvbG9yKSB7XG4gICAgaWYgKCF0aGlzLl9oaWdobGlnaHRDb2xvcnMpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgY29uc3QgY29sb3JOYW1lID0gdGhpcy5oaWdobGlnaHRDb2xvck5hbWVzLmdldChjb2xvcik7XG4gICAgcmV0dXJuIHRoaXMuX2hpZ2hsaWdodENvbG9ycy5nZXQoY29sb3JOYW1lKSB8fCBjb2xvcjtcbiAgfVxuICBnZXROb25IQ01Db2xvck5hbWUoY29sb3IpIHtcbiAgICByZXR1cm4gdGhpcy5oaWdobGlnaHRDb2xvck5hbWVzLmdldChjb2xvcikgfHwgY29sb3I7XG4gIH1cbiAgc2V0Q3VycmVudERyYXdpbmdTZXNzaW9uKGxheWVyKSB7XG4gICAgaWYgKGxheWVyKSB7XG4gICAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG4gICAgICB0aGlzLmRpc2FibGVVc2VyU2VsZWN0KHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc2FibGVVc2VyU2VsZWN0KGZhbHNlKTtcbiAgICB9XG4gICAgdGhpcy4jY3VycmVudERyYXdpbmdTZXNzaW9uID0gbGF5ZXI7XG4gIH1cbiAgc2V0TWFpbkhpZ2hsaWdodENvbG9yUGlja2VyKGNvbG9yUGlja2VyKSB7XG4gICAgdGhpcy4jbWFpbkhpZ2hsaWdodENvbG9yUGlja2VyID0gY29sb3JQaWNrZXI7XG4gIH1cbiAgZWRpdEFsdFRleHQoZWRpdG9yLCBmaXJzdFRpbWUgPSBmYWxzZSkge1xuICAgIHRoaXMuI2FsdFRleHRNYW5hZ2VyPy5lZGl0QWx0VGV4dCh0aGlzLCBlZGl0b3IsIGZpcnN0VGltZSk7XG4gIH1cbiAgaGFzQ29tbWVudE1hbmFnZXIoKSB7XG4gICAgcmV0dXJuICEhdGhpcy4jY29tbWVudE1hbmFnZXI7XG4gIH1cbiAgZWRpdENvbW1lbnQoZWRpdG9yLCBwb3NpdGlvbikge1xuICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyPy5vcGVuKHRoaXMsIGVkaXRvciwgcG9zaXRpb24pO1xuICB9XG4gIGdldFNpZ25hdHVyZShlZGl0b3IpIHtcbiAgICB0aGlzLiNzaWduYXR1cmVNYW5hZ2VyPy5nZXRTaWduYXR1cmUoe1xuICAgICAgdWlNYW5hZ2VyOiB0aGlzLFxuICAgICAgZWRpdG9yXG4gICAgfSk7XG4gIH1cbiAgZ2V0IHNpZ25hdHVyZU1hbmFnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NpZ25hdHVyZU1hbmFnZXI7XG4gIH1cbiAgc3dpdGNoVG9Nb2RlKG1vZGUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fZXZlbnRCdXMub24oXCJhbm5vdGF0aW9uZWRpdG9ybW9kZWNoYW5nZWRcIiwgY2FsbGJhY2ssIHtcbiAgICAgIG9uY2U6IHRydWUsXG4gICAgICBzaWduYWw6IHRoaXMuX3NpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwic2hvd2Fubm90YXRpb25lZGl0b3J1aVwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBtb2RlXG4gICAgfSk7XG4gIH1cbiAgc2V0UHJlZmVyZW5jZShuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwic2V0cHJlZmVyZW5jZVwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBuYW1lLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgfVxuICBvblNldFByZWZlcmVuY2Uoe1xuICAgIG5hbWUsXG4gICAgdmFsdWVcbiAgfSkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSBcImVuYWJsZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2VcIjpcbiAgICAgICAgdGhpcy4jZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgb25QYWdlQ2hhbmdpbmcoe1xuICAgIHBhZ2VOdW1iZXJcbiAgfSkge1xuICAgIHRoaXMuI2N1cnJlbnRQYWdlSW5kZXggPSBwYWdlTnVtYmVyIC0gMTtcbiAgfVxuICBmb2N1c01haW5Db250YWluZXIoKSB7XG4gICAgdGhpcy4jY29udGFpbmVyLmZvY3VzKCk7XG4gIH1cbiAgZmluZFBhcmVudCh4LCB5KSB7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeDogbGF5ZXJYLFxuICAgICAgICB5OiBsYXllclksXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSBsYXllci5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAoeCA+PSBsYXllclggJiYgeCA8PSBsYXllclggKyB3aWR0aCAmJiB5ID49IGxheWVyWSAmJiB5IDw9IGxheWVyWSArIGhlaWdodCkge1xuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGRpc2FibGVVc2VyU2VsZWN0KHZhbHVlID0gZmFsc2UpIHtcbiAgICB0aGlzLiN2aWV3ZXIuY2xhc3NMaXN0LnRvZ2dsZShcIm5vVXNlclNlbGVjdFwiLCB2YWx1ZSk7XG4gIH1cbiAgYWRkU2hvdWxkUmVzY2FsZShlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3JzVG9SZXNjYWxlLmFkZChlZGl0b3IpO1xuICB9XG4gIHJlbW92ZVNob3VsZFJlc2NhbGUoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yc1RvUmVzY2FsZS5kZWxldGUoZWRpdG9yKTtcbiAgfVxuICBvblNjYWxlQ2hhbmdpbmcoe1xuICAgIHNjYWxlXG4gIH0pIHtcbiAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgdGhpcy52aWV3UGFyYW1ldGVycy5yZWFsU2NhbGUgPSBzY2FsZSAqIFBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUztcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzVG9SZXNjYWxlKSB7XG4gICAgICBlZGl0b3Iub25TY2FsZUNoYW5naW5nKCk7XG4gICAgfVxuICAgIHRoaXMuI2N1cnJlbnREcmF3aW5nU2Vzc2lvbj8ub25TY2FsZUNoYW5naW5nKCk7XG4gIH1cbiAgb25Sb3RhdGlvbkNoYW5naW5nKHtcbiAgICBwYWdlc1JvdGF0aW9uXG4gIH0pIHtcbiAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgdGhpcy52aWV3UGFyYW1ldGVycy5yb3RhdGlvbiA9IHBhZ2VzUm90YXRpb247XG4gIH1cbiAgI2dldEFuY2hvckVsZW1lbnRGb3JTZWxlY3Rpb24oe1xuICAgIGFuY2hvck5vZGVcbiAgfSkge1xuICAgIHJldHVybiBhbmNob3JOb2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSA/IGFuY2hvck5vZGUucGFyZW50RWxlbWVudCA6IGFuY2hvck5vZGU7XG4gIH1cbiAgI2dldExheWVyRm9yVGV4dExheWVyKHRleHRMYXllcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRMYXllclxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChjdXJyZW50TGF5ZXIuaGFzVGV4dExheWVyKHRleHRMYXllcikpIHtcbiAgICAgIHJldHVybiBjdXJyZW50TGF5ZXI7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICBpZiAobGF5ZXIuaGFzVGV4dExheWVyKHRleHRMYXllcikpIHtcbiAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBoaWdobGlnaHRTZWxlY3Rpb24obWV0aG9kT2ZDcmVhdGlvbiA9IFwiXCIsIGNvbW1lbnQgPSBmYWxzZSkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXRcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIGNvbnN0IHRleHQgPSBzZWxlY3Rpb24udG9TdHJpbmcoKTtcbiAgICBjb25zdCBhbmNob3JFbGVtZW50ID0gdGhpcy4jZ2V0QW5jaG9yRWxlbWVudEZvclNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGNvbnN0IHRleHRMYXllciA9IGFuY2hvckVsZW1lbnQuY2xvc2VzdChcIi50ZXh0TGF5ZXJcIik7XG4gICAgY29uc3QgYm94ZXMgPSB0aGlzLmdldFNlbGVjdGlvbkJveGVzKHRleHRMYXllcik7XG4gICAgaWYgKCFib3hlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxlY3Rpb24uZW1wdHkoKTtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuI2dldExheWVyRm9yVGV4dExheWVyKHRleHRMYXllcik7XG4gICAgY29uc3QgaXNOb25lTW9kZSA9IHRoaXMuI21vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkU7XG4gICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICBjb25zdCBlZGl0b3IgPSBsYXllcj8uY3JlYXRlQW5kQWRkTmV3RWRpdG9yKHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSwgZmFsc2UsIHtcbiAgICAgICAgbWV0aG9kT2ZDcmVhdGlvbixcbiAgICAgICAgYm94ZXMsXG4gICAgICAgIGFuY2hvck5vZGUsXG4gICAgICAgIGFuY2hvck9mZnNldCxcbiAgICAgICAgZm9jdXNOb2RlLFxuICAgICAgICBmb2N1c09mZnNldCxcbiAgICAgICAgdGV4dFxuICAgICAgfSk7XG4gICAgICBpZiAoaXNOb25lTW9kZSkge1xuICAgICAgICB0aGlzLnNob3dBbGxFZGl0b3JzKFwiaGlnaGxpZ2h0XCIsIHRydWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgZWRpdG9yPy5lZGl0Q29tbWVudCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzTm9uZU1vZGUpIHtcbiAgICAgIHRoaXMuc3dpdGNoVG9Nb2RlKEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjaygpO1xuICB9XG4gIGNvbW1lbnRTZWxlY3Rpb24obWV0aG9kT2ZDcmVhdGlvbiA9IFwiXCIpIHtcbiAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbihtZXRob2RPZkNyZWF0aW9uLCB0cnVlKTtcbiAgfVxuICAjZGlzcGxheUZsb2F0aW5nVG9vbGJhcigpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yRWxlbWVudCA9IHRoaXMuI2dldEFuY2hvckVsZW1lbnRGb3JTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICBjb25zdCB0ZXh0TGF5ZXIgPSBhbmNob3JFbGVtZW50LmNsb3Nlc3QoXCIudGV4dExheWVyXCIpO1xuICAgIGNvbnN0IGJveGVzID0gdGhpcy5nZXRTZWxlY3Rpb25Cb3hlcyh0ZXh0TGF5ZXIpO1xuICAgIGlmICghYm94ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZmxvYXRpbmdUb29sYmFyIHx8PSBuZXcgRmxvYXRpbmdUb29sYmFyKHRoaXMpO1xuICAgIHRoaXMuI2Zsb2F0aW5nVG9vbGJhci5zaG93KHRleHRMYXllciwgYm94ZXMsIHRoaXMuZGlyZWN0aW9uID09PSBcImx0clwiKTtcbiAgfVxuICBhZGRUb0Fubm90YXRpb25TdG9yYWdlKGVkaXRvcikge1xuICAgIGlmICghZWRpdG9yLmlzRW1wdHkoKSAmJiB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZSAmJiAhdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2UuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKGVkaXRvci5pZCwgZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgYTExeUFsZXJ0KG1lc3NhZ2VJZCwgYXJncyA9IG51bGwpIHtcbiAgICBjb25zdCB2aWV3ZXJBbGVydCA9IHRoaXMuI3ZpZXdlckFsZXJ0O1xuICAgIGlmICghdmlld2VyQWxlcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmlld2VyQWxlcnQuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIG1lc3NhZ2VJZCk7XG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgIHZpZXdlckFsZXJ0LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1hcmdzXCIsIEpTT04uc3RyaW5naWZ5KGFyZ3MpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlld2VyQWxlcnQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1sMTBuLWFyZ3NcIik7XG4gICAgfVxuICB9XG4gICNzZWxlY3Rpb25DaGFuZ2UoKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSB7XG4gICAgICBpZiAodGhpcy4jc2VsZWN0ZWRUZXh0Tm9kZSkge1xuICAgICAgICB0aGlzLiNmbG9hdGluZ1Rvb2xiYXI/LmhpZGUoKTtcbiAgICAgICAgdGhpcy4jc2VsZWN0ZWRUZXh0Tm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgICBoYXNTZWxlY3RlZFRleHQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbmNob3JOb2RlXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICBpZiAoYW5jaG9yTm9kZSA9PT0gdGhpcy4jc2VsZWN0ZWRUZXh0Tm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JFbGVtZW50ID0gdGhpcy4jZ2V0QW5jaG9yRWxlbWVudEZvclNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGNvbnN0IHRleHRMYXllciA9IGFuY2hvckVsZW1lbnQuY2xvc2VzdChcIi50ZXh0TGF5ZXJcIik7XG4gICAgaWYgKCF0ZXh0TGF5ZXIpIHtcbiAgICAgIGlmICh0aGlzLiNzZWxlY3RlZFRleHROb2RlKSB7XG4gICAgICAgIHRoaXMuI2Zsb2F0aW5nVG9vbGJhcj8uaGlkZSgpO1xuICAgICAgICB0aGlzLiNzZWxlY3RlZFRleHROb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICAgIGhhc1NlbGVjdGVkVGV4dDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2Zsb2F0aW5nVG9vbGJhcj8uaGlkZSgpO1xuICAgIHRoaXMuI3NlbGVjdGVkVGV4dE5vZGUgPSBhbmNob3JOb2RlO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkVGV4dDogdHJ1ZVxuICAgIH0pO1xuICAgIGlmICh0aGlzLiNtb2RlICE9PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQgJiYgdGhpcy4jbW9kZSAhPT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUKSB7XG4gICAgICB0aGlzLnNob3dBbGxFZGl0b3JzKFwiaGlnaGxpZ2h0XCIsIHRydWUsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLiNoaWdobGlnaHRXaGVuU2hpZnRVcCA9IHRoaXMuaXNTaGlmdEtleURvd247XG4gICAgaWYgKCF0aGlzLmlzU2hpZnRLZXlEb3duKSB7XG4gICAgICBjb25zdCBhY3RpdmVMYXllciA9IHRoaXMuI21vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCA/IHRoaXMuI2dldExheWVyRm9yVGV4dExheWVyKHRleHRMYXllcikgOiBudWxsO1xuICAgICAgYWN0aXZlTGF5ZXI/LnRvZ2dsZURyYXdpbmcoKTtcbiAgICAgIGlmICh0aGlzLiNpc1BvaW50ZXJEb3duKSB7XG4gICAgICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBjb25zdCBzaWduYWwgPSB0aGlzLmNvbWJpbmVkU2lnbmFsKGFjKTtcbiAgICAgICAgY29uc3QgcG9pbnRlcnVwID0gZSA9PiB7XG4gICAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJwb2ludGVydXBcIiAmJiBlLmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhYy5hYm9ydCgpO1xuICAgICAgICAgIGFjdGl2ZUxheWVyPy50b2dnbGVEcmF3aW5nKHRydWUpO1xuICAgICAgICAgIGlmIChlLnR5cGUgPT09IFwicG9pbnRlcnVwXCIpIHtcbiAgICAgICAgICAgIHRoaXMuI29uU2VsZWN0RW5kKFwibWFpbl90b29sYmFyXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlcnVwLCB7XG4gICAgICAgICAgc2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgcG9pbnRlcnVwLCB7XG4gICAgICAgICAgc2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZlTGF5ZXI/LnRvZ2dsZURyYXdpbmcodHJ1ZSk7XG4gICAgICAgIHRoaXMuI29uU2VsZWN0RW5kKFwibWFpbl90b29sYmFyXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjb25TZWxlY3RFbmQobWV0aG9kT2ZDcmVhdGlvbiA9IFwiXCIpIHtcbiAgICBpZiAodGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUKSB7XG4gICAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbihtZXRob2RPZkNyZWF0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI2VuYWJsZUhpZ2hsaWdodEZsb2F0aW5nQnV0dG9uKSB7XG4gICAgICB0aGlzLiNkaXNwbGF5RmxvYXRpbmdUb29sYmFyKCk7XG4gICAgfVxuICB9XG4gICNhZGRTZWxlY3Rpb25MaXN0ZW5lcigpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMuI3NlbGVjdGlvbkNoYW5nZS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWw6IHRoaXMuX3NpZ25hbFxuICAgIH0pO1xuICB9XG4gICNhZGRGb2N1c01hbmFnZXIoKSB7XG4gICAgaWYgKHRoaXMuI2ZvY3VzTWFuYWdlckFDKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2ZvY3VzTWFuYWdlckFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuY29tYmluZWRTaWduYWwodGhpcy4jZm9jdXNNYW5hZ2VyQUMpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5mb2N1cy5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5ibHVyLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gICNyZW1vdmVGb2N1c01hbmFnZXIoKSB7XG4gICAgdGhpcy4jZm9jdXNNYW5hZ2VyQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jZm9jdXNNYW5hZ2VyQUMgPSBudWxsO1xuICB9XG4gIGJsdXIoKSB7XG4gICAgdGhpcy5pc1NoaWZ0S2V5RG93biA9IGZhbHNlO1xuICAgIGlmICh0aGlzLiNoaWdobGlnaHRXaGVuU2hpZnRVcCkge1xuICAgICAgdGhpcy4jaGlnaGxpZ2h0V2hlblNoaWZ0VXAgPSBmYWxzZTtcbiAgICAgIHRoaXMuI29uU2VsZWN0RW5kKFwibWFpbl90b29sYmFyXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFjdGl2ZUVsZW1lbnRcbiAgICB9ID0gZG9jdW1lbnQ7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBpZiAoZWRpdG9yLmRpdi5jb250YWlucyhhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICB0aGlzLiNsYXN0QWN0aXZlRWxlbWVudCA9IFtlZGl0b3IsIGFjdGl2ZUVsZW1lbnRdO1xuICAgICAgICBlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9jdXMoKSB7XG4gICAgaWYgKCF0aGlzLiNsYXN0QWN0aXZlRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbbGFzdEVkaXRvciwgbGFzdEFjdGl2ZUVsZW1lbnRdID0gdGhpcy4jbGFzdEFjdGl2ZUVsZW1lbnQ7XG4gICAgdGhpcy4jbGFzdEFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgIGxhc3RBY3RpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsICgpID0+IHtcbiAgICAgIGxhc3RFZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gICAgfSwge1xuICAgICAgb25jZTogdHJ1ZSxcbiAgICAgIHNpZ25hbDogdGhpcy5fc2lnbmFsXG4gICAgfSk7XG4gICAgbGFzdEFjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgfVxuICAjYWRkS2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGlmICh0aGlzLiNrZXlib2FyZE1hbmFnZXJBQykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNrZXlib2FyZE1hbmFnZXJBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2tleWJvYXJkTWFuYWdlckFDKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5rZXlkb3duLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5rZXl1cC5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICAjcmVtb3ZlS2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIHRoaXMuI2tleWJvYXJkTWFuYWdlckFDPy5hYm9ydCgpO1xuICAgIHRoaXMuI2tleWJvYXJkTWFuYWdlckFDID0gbnVsbDtcbiAgfVxuICAjYWRkQ29weVBhc3RlTGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLiNjb3B5UGFzdGVBQykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb3B5UGFzdGVBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2NvcHlQYXN0ZUFDKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY29weVwiLCB0aGlzLmNvcHkuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImN1dFwiLCB0aGlzLmN1dC5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicGFzdGVcIiwgdGhpcy5wYXN0ZS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICAjcmVtb3ZlQ29weVBhc3RlTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuI2NvcHlQYXN0ZUFDPy5hYm9ydCgpO1xuICAgIHRoaXMuI2NvcHlQYXN0ZUFDID0gbnVsbDtcbiAgfVxuICAjYWRkRHJhZ0FuZERyb3BMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fc2lnbmFsO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLCB0aGlzLmRyYWdPdmVyLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIHRoaXMuZHJvcC5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICBhZGRFZGl0TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuI2FkZEtleWJvYXJkTWFuYWdlcigpO1xuICAgIHRoaXMuI2FkZENvcHlQYXN0ZUxpc3RlbmVycygpO1xuICB9XG4gIHJlbW92ZUVkaXRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy4jcmVtb3ZlS2V5Ym9hcmRNYW5hZ2VyKCk7XG4gICAgdGhpcy4jcmVtb3ZlQ29weVBhc3RlTGlzdGVuZXJzKCk7XG4gIH1cbiAgZHJhZ092ZXIoZXZlbnQpIHtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9IG9mIGV2ZW50LmRhdGFUcmFuc2Zlci5pdGVtcykge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICAgIGlmIChlZGl0b3JUeXBlLmlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyh0eXBlKSkge1xuICAgICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gXCJjb3B5XCI7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZHJvcChldmVudCkge1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBldmVudC5kYXRhVHJhbnNmZXIuaXRlbXMpIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiB0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgICBpZiAoZWRpdG9yVHlwZS5pc0hhbmRsaW5nTWltZUZvclBhc3RpbmcoaXRlbS50eXBlKSkge1xuICAgICAgICAgIGVkaXRvclR5cGUucGFzdGUoaXRlbSwgdGhpcy5jdXJyZW50TGF5ZXIpO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvcHkoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuI2FjdGl2ZUVkaXRvcj8uY29tbWl0T3JSZW1vdmUoKTtcbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBlZGl0b3Iuc2VyaWFsaXplKHRydWUpO1xuICAgICAgaWYgKHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgZWRpdG9ycy5wdXNoKHNlcmlhbGl6ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZWRpdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZlbnQuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwiYXBwbGljYXRpb24vcGRmanNcIiwgSlNPTi5zdHJpbmdpZnkoZWRpdG9ycykpO1xuICB9XG4gIGN1dChldmVudCkge1xuICAgIHRoaXMuY29weShldmVudCk7XG4gICAgdGhpcy5kZWxldGUoKTtcbiAgfVxuICBhc3luYyBwYXN0ZShldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3Qge1xuICAgICAgY2xpcGJvYXJkRGF0YVxuICAgIH0gPSBldmVudDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY2xpcGJvYXJkRGF0YS5pdGVtcykge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICAgIGlmIChlZGl0b3JUeXBlLmlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyhpdGVtLnR5cGUpKSB7XG4gICAgICAgICAgZWRpdG9yVHlwZS5wYXN0ZShpdGVtLCB0aGlzLmN1cnJlbnRMYXllcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBkYXRhID0gY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwiYXBwbGljYXRpb24vcGRmanNcIik7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgd2FybihgcGFzdGU6IFwiJHtleC5tZXNzYWdlfVwiLmApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5jdXJyZW50TGF5ZXI7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG5ld0VkaXRvcnMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGRhdGEpIHtcbiAgICAgICAgY29uc3QgZGVzZXJpYWxpemVkRWRpdG9yID0gYXdhaXQgbGF5ZXIuZGVzZXJpYWxpemUoZWRpdG9yKTtcbiAgICAgICAgaWYgKCFkZXNlcmlhbGl6ZWRFZGl0b3IpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbmV3RWRpdG9ycy5wdXNoKGRlc2VyaWFsaXplZEVkaXRvcik7XG4gICAgICB9XG4gICAgICBjb25zdCBjbWQgPSAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIG5ld0VkaXRvcnMpIHtcbiAgICAgICAgICB0aGlzLiNhZGRFZGl0b3JUb0xheWVyKGVkaXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jc2VsZWN0RWRpdG9ycyhuZXdFZGl0b3JzKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB1bmRvID0gKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBuZXdFZGl0b3JzKSB7XG4gICAgICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICAgIGNtZCxcbiAgICAgICAgdW5kbyxcbiAgICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICB3YXJuKGBwYXN0ZTogXCIke2V4Lm1lc3NhZ2V9XCIuYCk7XG4gICAgfVxuICB9XG4gIGtleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuaXNTaGlmdEtleURvd24gJiYgZXZlbnQua2V5ID09PSBcIlNoaWZ0XCIpIHtcbiAgICAgIHRoaXMuaXNTaGlmdEtleURvd24gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy4jbW9kZSAhPT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSAmJiAhdGhpcy5pc0VkaXRvckhhbmRsaW5nS2V5Ym9hcmQpIHtcbiAgICAgIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIuX2tleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH1cbiAga2V5dXAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5pc1NoaWZ0S2V5RG93biAmJiBldmVudC5rZXkgPT09IFwiU2hpZnRcIikge1xuICAgICAgdGhpcy5pc1NoaWZ0S2V5RG93biA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuI2hpZ2hsaWdodFdoZW5TaGlmdFVwKSB7XG4gICAgICAgIHRoaXMuI2hpZ2hsaWdodFdoZW5TaGlmdFVwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI29uU2VsZWN0RW5kKFwibWFpbl90b29sYmFyXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbkVkaXRpbmdBY3Rpb24oe1xuICAgIG5hbWVcbiAgfSkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSBcInVuZG9cIjpcbiAgICAgIGNhc2UgXCJyZWRvXCI6XG4gICAgICBjYXNlIFwiZGVsZXRlXCI6XG4gICAgICBjYXNlIFwic2VsZWN0QWxsXCI6XG4gICAgICAgIHRoaXNbbmFtZV0oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaGlnaGxpZ2h0U2VsZWN0aW9uXCI6XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uKFwiY29udGV4dF9tZW51XCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjb21tZW50U2VsZWN0aW9uXCI6XG4gICAgICAgIHRoaXMuY29tbWVudFNlbGVjdGlvbihcImNvbnRleHRfbWVudVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gICNkaXNwYXRjaFVwZGF0ZVN0YXRlcyhkZXRhaWxzKSB7XG4gICAgY29uc3QgaGFzQ2hhbmdlZCA9IE9iamVjdC5lbnRyaWVzKGRldGFpbHMpLnNvbWUoKFtrZXksIHZhbHVlXSkgPT4gdGhpcy4jcHJldmlvdXNTdGF0ZXNba2V5XSAhPT0gdmFsdWUpO1xuICAgIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9ldmVudEJ1cy5kaXNwYXRjaChcImFubm90YXRpb25lZGl0b3JzdGF0ZXNjaGFuZ2VkXCIsIHtcbiAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICBkZXRhaWxzOiBPYmplY3QuYXNzaWduKHRoaXMuI3ByZXZpb3VzU3RhdGVzLCBkZXRhaWxzKVxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUICYmIGRldGFpbHMuaGFzU2VsZWN0ZWRFZGl0b3IgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfRlJFRSwgdHJ1ZV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI2Rpc3BhdGNoVXBkYXRlVUkoZGV0YWlscykge1xuICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwiYW5ub3RhdGlvbmVkaXRvcnBhcmFtc2NoYW5nZWRcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgZGV0YWlsc1xuICAgIH0pO1xuICB9XG4gIHNldEVkaXRpbmdTdGF0ZShpc0VkaXRpbmcpIHtcbiAgICBpZiAoaXNFZGl0aW5nKSB7XG4gICAgICB0aGlzLiNhZGRGb2N1c01hbmFnZXIoKTtcbiAgICAgIHRoaXMuI2FkZENvcHlQYXN0ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICBpc0VkaXRpbmc6IHRoaXMuI21vZGUgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUsXG4gICAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKSxcbiAgICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1VuZG8oKSxcbiAgICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1JlZG8oKSxcbiAgICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jcmVtb3ZlRm9jdXNNYW5hZ2VyKCk7XG4gICAgICB0aGlzLiNyZW1vdmVDb3B5UGFzdGVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgaXNFZGl0aW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmRpc2FibGVVc2VyU2VsZWN0KGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJFZGl0b3JUeXBlcyh0eXBlcykge1xuICAgIGlmICh0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNlZGl0b3JUeXBlcyA9IHR5cGVzO1xuICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiB0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3JUeXBlLmRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIH1cbiAgfVxuICBnZXRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jaWRNYW5hZ2VyLmlkO1xuICB9XG4gIGdldCBjdXJyZW50TGF5ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsbExheWVycy5nZXQodGhpcy4jY3VycmVudFBhZ2VJbmRleCk7XG4gIH1cbiAgZ2V0TGF5ZXIocGFnZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsbExheWVycy5nZXQocGFnZUluZGV4KTtcbiAgfVxuICBnZXQgY3VycmVudFBhZ2VJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY3VycmVudFBhZ2VJbmRleDtcbiAgfVxuICBhZGRMYXllcihsYXllcikge1xuICAgIHRoaXMuI2FsbExheWVycy5zZXQobGF5ZXIucGFnZUluZGV4LCBsYXllcik7XG4gICAgaWYgKHRoaXMuI2lzRW5hYmxlZCkge1xuICAgICAgbGF5ZXIuZW5hYmxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxheWVyLmRpc2FibGUoKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlTGF5ZXIobGF5ZXIpIHtcbiAgICB0aGlzLiNhbGxMYXllcnMuZGVsZXRlKGxheWVyLnBhZ2VJbmRleCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTW9kZShtb2RlLCBlZGl0SWQgPSBudWxsLCBpc0Zyb21LZXlib2FyZCA9IGZhbHNlLCBtdXN0RW50ZXJJbkVkaXRNb2RlID0gZmFsc2UsIGVkaXRDb21tZW50ID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy4jbW9kZSA9PT0gbW9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkpIHtcbiAgICAgIGF3YWl0IHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICBpZiAoIXRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLiNjdXJyZW50RHJhd2luZ1Nlc3Npb24/LmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgaWYgKHRoaXMuI21vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLlBPUFVQKSB7XG4gICAgICB0aGlzLiNjb21tZW50TWFuYWdlcj8uaGlkZVNpZGViYXIoKTtcbiAgICB9XG4gICAgdGhpcy4jbW9kZSA9IG1vZGU7XG4gICAgaWYgKG1vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUpIHtcbiAgICAgIHRoaXMuc2V0RWRpdGluZ1N0YXRlKGZhbHNlKTtcbiAgICAgIHRoaXMuI2Rpc2FibGVBbGwoKTtcbiAgICAgIHRoaXMuX2VkaXRvclVuZG9CYXI/LmhpZGUoKTtcbiAgICAgIHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLlNJR05BVFVSRSkge1xuICAgICAgYXdhaXQgdGhpcy4jc2lnbmF0dXJlTWFuYWdlcj8ubG9hZFNpZ25hdHVyZXMoKTtcbiAgICB9XG4gICAgaWYgKG1vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLlBPUFVQKSB7XG4gICAgICB0aGlzLiNhbGxFZGl0YWJsZUFubm90YXRpb25zIHx8PSBhd2FpdCB0aGlzLiNwZGZEb2N1bWVudC5nZXRBbm5vdGF0aW9uc0J5VHlwZShuZXcgU2V0KHRoaXMuI2VkaXRvclR5cGVzLm1hcChlZGl0b3JDbGFzcyA9PiBlZGl0b3JDbGFzcy5fZWRpdG9yVHlwZSkpKTtcbiAgICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyPy5zaG93U2lkZWJhcih0aGlzLiNhbGxFZGl0YWJsZUFubm90YXRpb25zKTtcbiAgICB9XG4gICAgdGhpcy5zZXRFZGl0aW5nU3RhdGUodHJ1ZSk7XG4gICAgYXdhaXQgdGhpcy4jZW5hYmxlQWxsKCk7XG4gICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICBsYXllci51cGRhdGVNb2RlKG1vZGUpO1xuICAgIH1cbiAgICBpZiAoIWVkaXRJZCkge1xuICAgICAgaWYgKGlzRnJvbUtleWJvYXJkKSB7XG4gICAgICAgIHRoaXMuYWRkTmV3RWRpdG9yRnJvbUtleWJvYXJkKCk7XG4gICAgICB9XG4gICAgICB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCA9PT0gZWRpdElkIHx8IGVkaXRvci5pZCA9PT0gZWRpdElkKSB7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0ZWQoZWRpdG9yKTtcbiAgICAgICAgaWYgKGVkaXRDb21tZW50KSB7XG4gICAgICAgICAgZWRpdG9yLmVkaXRDb21tZW50KCk7XG4gICAgICAgIH0gZWxzZSBpZiAobXVzdEVudGVySW5FZGl0TW9kZSkge1xuICAgICAgICAgIGVkaXRvci5lbnRlckluRWRpdE1vZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuICBhZGROZXdFZGl0b3JGcm9tS2V5Ym9hcmQoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudExheWVyLmNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yKCkpIHtcbiAgICAgIHRoaXMuY3VycmVudExheWVyLmFkZE5ld0VkaXRvcigpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVUb29sYmFyKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5tb2RlID09PSB0aGlzLiNtb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwic3dpdGNoYW5ub3RhdGlvbmVkaXRvcm1vZGVcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICghdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkNSRUFURTpcbiAgICAgICAgdGhpcy5jdXJyZW50TGF5ZXIuYWRkTmV3RWRpdG9yKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfU0hPV19BTEw6XG4gICAgICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwicmVwb3J0dGVsZW1ldHJ5XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgdHlwZTogXCJlZGl0aW5nXCIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiaGlnaGxpZ2h0XCIsXG4gICAgICAgICAgICAgIGFjdGlvbjogXCJ0b2dnbGVfdmlzaWJpbGl0eVwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgKHRoaXMuI3Nob3dBbGxTdGF0ZXMgfHw9IG5ldyBNYXAoKSkuc2V0KHR5cGUsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5zaG93QWxsRWRpdG9ycyhcImhpZ2hsaWdodFwiLCB2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgICBlZGl0b3IudXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICAgIGVkaXRvclR5cGUudXBkYXRlRGVmYXVsdFBhcmFtcyh0eXBlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNob3dBbGxFZGl0b3JzKHR5cGUsIHZpc2libGUsIHVwZGF0ZUJ1dHRvbiA9IGZhbHNlKSB7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVkaXRvci5lZGl0b3JUeXBlID09PSB0eXBlKSB7XG4gICAgICAgIGVkaXRvci5zaG93KHZpc2libGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuI3Nob3dBbGxTdGF0ZXM/LmdldChBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfU0hPV19BTEwpID8/IHRydWU7XG4gICAgaWYgKHN0YXRlICE9PSB2aXNpYmxlKSB7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX1NIT1dfQUxMLCB2aXNpYmxlXV0pO1xuICAgIH1cbiAgfVxuICBlbmFibGVXYWl0aW5nKG11c3RXYWl0ID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy4jaXNXYWl0aW5nID09PSBtdXN0V2FpdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNpc1dhaXRpbmcgPSBtdXN0V2FpdDtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKG11c3RXYWl0KSB7XG4gICAgICAgIGxheWVyLmRpc2FibGVDbGljaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGF5ZXIuZW5hYmxlQ2xpY2soKTtcbiAgICAgIH1cbiAgICAgIGxheWVyLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwid2FpdGluZ1wiLCBtdXN0V2FpdCk7XG4gICAgfVxuICB9XG4gIGFzeW5jICNlbmFibGVBbGwoKSB7XG4gICAgaWYgKCF0aGlzLiNpc0VuYWJsZWQpIHtcbiAgICAgIHRoaXMuI2lzRW5hYmxlZCA9IHRydWU7XG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChsYXllci5lbmFibGUoKSk7XG4gICAgICB9XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIGVkaXRvci5lbmFibGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI2Rpc2FibGVBbGwoKSB7XG4gICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuICAgIGlmICh0aGlzLiNpc0VuYWJsZWQpIHtcbiAgICAgIHRoaXMuI2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgICAgbGF5ZXIuZGlzYWJsZSgpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgICBlZGl0b3IuZGlzYWJsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRFZGl0b3JzKHBhZ2VJbmRleCkge1xuICAgIGNvbnN0IGVkaXRvcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZWRpdG9yLnBhZ2VJbmRleCA9PT0gcGFnZUluZGV4KSB7XG4gICAgICAgIGVkaXRvcnMucHVzaChlZGl0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWRpdG9ycztcbiAgfVxuICBnZXRFZGl0b3IoaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jYWxsRWRpdG9ycy5nZXQoaWQpO1xuICB9XG4gIGFkZEVkaXRvcihlZGl0b3IpIHtcbiAgICB0aGlzLiNhbGxFZGl0b3JzLnNldChlZGl0b3IuaWQsIGVkaXRvcik7XG4gIH1cbiAgcmVtb3ZlRWRpdG9yKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IuZGl2LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICBpZiAodGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQpO1xuICAgICAgfVxuICAgICAgdGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuZm9jdXNNYWluQ29udGFpbmVyKCk7XG4gICAgICAgIHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgdGhpcy4jYWxsRWRpdG9ycy5kZWxldGUoZWRpdG9yLmlkKTtcbiAgICBpZiAoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMuI21pc3NpbmdDYW52YXNlcz8uZGVsZXRlKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICB9XG4gICAgdGhpcy51bnNlbGVjdChlZGl0b3IpO1xuICAgIGlmICghZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgfHwgIXRoaXMuI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMuaGFzKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSkge1xuICAgICAgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2U/LnJlbW92ZShlZGl0b3IuaWQpO1xuICAgIH1cbiAgfVxuICBhZGREZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKSB7XG4gICAgdGhpcy4jZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcy5hZGQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgIHRoaXMuYWRkQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbihlZGl0b3IpO1xuICAgIGVkaXRvci5kZWxldGVkID0gdHJ1ZTtcbiAgfVxuICBpc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMuaGFzKGFubm90YXRpb25FbGVtZW50SWQpO1xuICB9XG4gIHJlbW92ZURlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpIHtcbiAgICB0aGlzLiNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzLmRlbGV0ZShlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgdGhpcy5yZW1vdmVDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKGVkaXRvcik7XG4gICAgZWRpdG9yLmRlbGV0ZWQgPSBmYWxzZTtcbiAgfVxuICAjYWRkRWRpdG9yVG9MYXllcihlZGl0b3IpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuI2FsbExheWVycy5nZXQoZWRpdG9yLnBhZ2VJbmRleCk7XG4gICAgaWYgKGxheWVyKSB7XG4gICAgICBsYXllci5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRFZGl0b3IoZWRpdG9yKTtcbiAgICAgIHRoaXMuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBzZXRBY3RpdmVFZGl0b3IoZWRpdG9yKSB7XG4gICAgaWYgKHRoaXMuI2FjdGl2ZUVkaXRvciA9PT0gZWRpdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FjdGl2ZUVkaXRvciA9IGVkaXRvcjtcbiAgICBpZiAoZWRpdG9yKSB7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvci5wcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIH1cbiAgfVxuICBnZXQgI2xhc3RTZWxlY3RlZEVkaXRvcigpIHtcbiAgICBsZXQgZWQgPSBudWxsO1xuICAgIGZvciAoZWQgb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7fVxuICAgIHJldHVybiBlZDtcbiAgfVxuICB1cGRhdGVVSShlZGl0b3IpIHtcbiAgICBpZiAodGhpcy4jbGFzdFNlbGVjdGVkRWRpdG9yID09PSBlZGl0b3IpIHtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yLnByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVVJRm9yRGVmYXVsdFByb3BlcnRpZXMoZWRpdG9yVHlwZSkge1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yVHlwZS5kZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKTtcbiAgfVxuICB0b2dnbGVTZWxlY3RlZChlZGl0b3IpIHtcbiAgICBpZiAodGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmhhcyhlZGl0b3IpKSB7XG4gICAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuZGVsZXRlKGVkaXRvcik7XG4gICAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRoaXMuaGFzU2VsZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmFkZChlZGl0b3IpO1xuICAgIGVkaXRvci5zZWxlY3QoKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvci5wcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgc2V0U2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgdGhpcy51cGRhdGVUb29sYmFyKHtcbiAgICAgIG1vZGU6IGVkaXRvci5tb2RlLFxuICAgICAgZWRpdElkOiBlZGl0b3IuaWRcbiAgICB9KTtcbiAgICB0aGlzLiNjdXJyZW50RHJhd2luZ1Nlc3Npb24/LmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgZm9yIChjb25zdCBlZCBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGlmIChlZCAhPT0gZWRpdG9yKSB7XG4gICAgICAgIGVkLnVuc2VsZWN0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5hZGQoZWRpdG9yKTtcbiAgICBlZGl0b3Iuc2VsZWN0KCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3IucHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGlzU2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5oYXMoZWRpdG9yKTtcbiAgfVxuICBnZXQgZmlyc3RTZWxlY3RlZEVkaXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgfVxuICB1bnNlbGVjdChlZGl0b3IpIHtcbiAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuZGVsZXRlKGVkaXRvcik7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRoaXMuaGFzU2VsZWN0aW9uXG4gICAgfSk7XG4gIH1cbiAgZ2V0IGhhc1NlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLnNpemUgIT09IDA7XG4gIH1cbiAgZ2V0IGlzRW50ZXJIYW5kbGVkKCkge1xuICAgIHJldHVybiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuc2l6ZSA9PT0gMSAmJiB0aGlzLmZpcnN0U2VsZWN0ZWRFZGl0b3IuaXNFbnRlckhhbmRsZWQ7XG4gIH1cbiAgdW5kbygpIHtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci51bmRvKCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1VuZG8oKSxcbiAgICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogdHJ1ZSxcbiAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKVxuICAgIH0pO1xuICAgIHRoaXMuX2VkaXRvclVuZG9CYXI/LmhpZGUoKTtcbiAgfVxuICByZWRvKCkge1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLnJlZG8oKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTb21ldGhpbmdUb1VuZG86IHRydWUsXG4gICAgICBoYXNTb21ldGhpbmdUb1JlZG86IHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmhhc1NvbWV0aGluZ1RvUmVkbygpLFxuICAgICAgaXNFbXB0eTogdGhpcy4jaXNFbXB0eSgpXG4gICAgfSk7XG4gIH1cbiAgYWRkQ29tbWFuZHMocGFyYW1zKSB7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIuYWRkKHBhcmFtcyk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0cnVlLFxuICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiBmYWxzZSxcbiAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKVxuICAgIH0pO1xuICB9XG4gIGNsZWFuVW5kb1N0YWNrKHR5cGUpIHtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci5jbGVhblR5cGUodHlwZSk7XG4gIH1cbiAgI2lzRW1wdHkoKSB7XG4gICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLnNpemUgPT09IDEpIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgcmV0dXJuIGVkaXRvci5pc0VtcHR5KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkZWxldGUoKSB7XG4gICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIGNvbnN0IGRyYXdpbmdFZGl0b3IgPSB0aGlzLmN1cnJlbnRMYXllcj8uZW5kRHJhd2luZ1Nlc3Npb24odHJ1ZSk7XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbiAmJiAhZHJhd2luZ0VkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3JzID0gZHJhd2luZ0VkaXRvciA/IFtkcmF3aW5nRWRpdG9yXSA6IFsuLi50aGlzLiNzZWxlY3RlZEVkaXRvcnNdO1xuICAgIGNvbnN0IGNtZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VkaXRvclVuZG9CYXI/LnNob3codW5kbywgZWRpdG9ycy5sZW5ndGggPT09IDEgPyBlZGl0b3JzWzBdLmVkaXRvclR5cGUgOiBlZGl0b3JzLmxlbmd0aCk7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgIHRoaXMuI2FkZEVkaXRvclRvTGF5ZXIoZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kLFxuICAgICAgdW5kbyxcbiAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgY29tbWl0T3JSZW1vdmUoKSB7XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yPy5jb21taXRPclJlbW92ZSgpO1xuICB9XG4gIGhhc1NvbWV0aGluZ1RvQ29udHJvbCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWN0aXZlRWRpdG9yIHx8IHRoaXMuaGFzU2VsZWN0aW9uO1xuICB9XG4gICNzZWxlY3RFZGl0b3JzKGVkaXRvcnMpIHtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci51bnNlbGVjdCgpO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICBpZiAoZWRpdG9yLmlzRW1wdHkoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5hZGQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5zZWxlY3QoKTtcbiAgICB9XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRoaXMuaGFzU2VsZWN0aW9uXG4gICAgfSk7XG4gIH1cbiAgc2VsZWN0QWxsKCkge1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgZWRpdG9yLmNvbW1pdCgpO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RFZGl0b3JzKHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpO1xuICB9XG4gIHVuc2VsZWN0QWxsKCkge1xuICAgIGlmICh0aGlzLiNhY3RpdmVFZGl0b3IpIHtcbiAgICAgIHRoaXMuI2FjdGl2ZUVkaXRvci5jb21taXRPclJlbW92ZSgpO1xuICAgICAgaWYgKHRoaXMuI21vZGUgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy4jY3VycmVudERyYXdpbmdTZXNzaW9uPy5jb21taXRPclJlbW92ZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgdHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzKHgsIHksIG5vQ29tbWl0ID0gZmFsc2UpIHtcbiAgICBpZiAoIW5vQ29tbWl0KSB7XG4gICAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdHJhbnNsYXRpb25bMF0gKz0geDtcbiAgICB0aGlzLiN0cmFuc2xhdGlvblsxXSArPSB5O1xuICAgIGNvbnN0IFt0b3RhbFgsIHRvdGFsWV0gPSB0aGlzLiN0cmFuc2xhdGlvbjtcbiAgICBjb25zdCBlZGl0b3JzID0gWy4uLnRoaXMuI3NlbGVjdGVkRWRpdG9yc107XG4gICAgY29uc3QgVElNRV9UT19XQUlUID0gMTAwMDtcbiAgICBpZiAodGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCk7XG4gICAgfVxuICAgIHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB0aGlzLiN0cmFuc2xhdGlvblswXSA9IHRoaXMuI3RyYW5zbGF0aW9uWzFdID0gMDtcbiAgICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5oYXMoZWRpdG9yLmlkKSkge1xuICAgICAgICAgICAgICBlZGl0b3IudHJhbnNsYXRlSW5QYWdlKHRvdGFsWCwgdG90YWxZKTtcbiAgICAgICAgICAgICAgZWRpdG9yLnRyYW5zbGF0aW9uRG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLmhhcyhlZGl0b3IuaWQpKSB7XG4gICAgICAgICAgICAgIGVkaXRvci50cmFuc2xhdGVJblBhZ2UoLXRvdGFsWCwgLXRvdGFsWSk7XG4gICAgICAgICAgICAgIGVkaXRvci50cmFuc2xhdGlvbkRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG11c3RFeGVjOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSwgVElNRV9UT19XQUlUKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICBlZGl0b3IudHJhbnNsYXRlSW5QYWdlKHgsIHkpO1xuICAgICAgZWRpdG9yLnRyYW5zbGF0aW9uRG9uZSgpO1xuICAgIH1cbiAgfVxuICBzZXRVcERyYWdTZXNzaW9uKCkge1xuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kaXNhYmxlVXNlclNlbGVjdCh0cnVlKTtcbiAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMuc2V0KGVkaXRvciwge1xuICAgICAgICBzYXZlZFg6IGVkaXRvci54LFxuICAgICAgICBzYXZlZFk6IGVkaXRvci55LFxuICAgICAgICBzYXZlZFBhZ2VJbmRleDogZWRpdG9yLnBhZ2VJbmRleCxcbiAgICAgICAgbmV3WDogMCxcbiAgICAgICAgbmV3WTogMCxcbiAgICAgICAgbmV3UGFnZUluZGV4OiAtMVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGVuZERyYWdTZXNzaW9uKCkge1xuICAgIGlmICghdGhpcy4jZHJhZ2dpbmdFZGl0b3JzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QoZmFsc2UpO1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuI2RyYWdnaW5nRWRpdG9ycztcbiAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMgPSBudWxsO1xuICAgIGxldCBtdXN0QmVBZGRlZEluVW5kb1N0YWNrID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBbe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBwYWdlSW5kZXhcbiAgICB9LCB2YWx1ZV0gb2YgbWFwKSB7XG4gICAgICB2YWx1ZS5uZXdYID0geDtcbiAgICAgIHZhbHVlLm5ld1kgPSB5O1xuICAgICAgdmFsdWUubmV3UGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgICAgbXVzdEJlQWRkZWRJblVuZG9TdGFjayB8fD0geCAhPT0gdmFsdWUuc2F2ZWRYIHx8IHkgIT09IHZhbHVlLnNhdmVkWSB8fCBwYWdlSW5kZXggIT09IHZhbHVlLnNhdmVkUGFnZUluZGV4O1xuICAgIH1cbiAgICBpZiAoIW11c3RCZUFkZGVkSW5VbmRvU3RhY2spIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbW92ZSA9IChlZGl0b3IsIHgsIHksIHBhZ2VJbmRleCkgPT4ge1xuICAgICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy4jYWxsTGF5ZXJzLmdldChwYWdlSW5kZXgpO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgZWRpdG9yLl9zZXRQYXJlbnRBbmRQb3NpdGlvbihwYXJlbnQsIHgsIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkaXRvci5wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgICAgICAgZWRpdG9yLnggPSB4O1xuICAgICAgICAgIGVkaXRvci55ID0geTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBbZWRpdG9yLCB7XG4gICAgICAgICAgbmV3WCxcbiAgICAgICAgICBuZXdZLFxuICAgICAgICAgIG5ld1BhZ2VJbmRleFxuICAgICAgICB9XSBvZiBtYXApIHtcbiAgICAgICAgICBtb3ZlKGVkaXRvciwgbmV3WCwgbmV3WSwgbmV3UGFnZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBbZWRpdG9yLCB7XG4gICAgICAgICAgc2F2ZWRYLFxuICAgICAgICAgIHNhdmVkWSxcbiAgICAgICAgICBzYXZlZFBhZ2VJbmRleFxuICAgICAgICB9XSBvZiBtYXApIHtcbiAgICAgICAgICBtb3ZlKGVkaXRvciwgc2F2ZWRYLCBzYXZlZFksIHNhdmVkUGFnZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZHJhZ1NlbGVjdGVkRWRpdG9ycyh0eCwgdHkpIHtcbiAgICBpZiAoIXRoaXMuI2RyYWdnaW5nRWRpdG9ycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMua2V5cygpKSB7XG4gICAgICBlZGl0b3IuZHJhZyh0eCwgdHkpO1xuICAgIH1cbiAgfVxuICByZWJ1aWxkKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IucGFyZW50ID09PSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldExheWVyKGVkaXRvci5wYWdlSW5kZXgpO1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuY2hhbmdlUGFyZW50KGVkaXRvcik7XG4gICAgICAgIHBhcmVudC5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkRWRpdG9yKGVkaXRvcik7XG4gICAgICAgIHRoaXMuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShlZGl0b3IpO1xuICAgICAgICBlZGl0b3IucmVidWlsZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlZGl0b3IucGFyZW50LmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBnZXQgaXNFZGl0b3JIYW5kbGluZ0tleWJvYXJkKCkge1xuICAgIHJldHVybiB0aGlzLmdldEFjdGl2ZSgpPy5zaG91bGRHZXRLZXlib2FyZEV2ZW50cygpIHx8IHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5zaXplID09PSAxICYmIHRoaXMuZmlyc3RTZWxlY3RlZEVkaXRvci5zaG91bGRHZXRLZXlib2FyZEV2ZW50cygpO1xuICB9XG4gIGlzQWN0aXZlKGVkaXRvcikge1xuICAgIHJldHVybiB0aGlzLiNhY3RpdmVFZGl0b3IgPT09IGVkaXRvcjtcbiAgfVxuICBnZXRBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FjdGl2ZUVkaXRvcjtcbiAgfVxuICBnZXRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLiNtb2RlO1xuICB9XG4gIGdldCBpbWFnZU1hbmFnZXIoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImltYWdlTWFuYWdlclwiLCBuZXcgSW1hZ2VNYW5hZ2VyKCkpO1xuICB9XG4gIGdldFNlbGVjdGlvbkJveGVzKHRleHRMYXllcikge1xuICAgIGlmICghdGV4dExheWVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc2VsZWN0aW9uLnJhbmdlQ291bnQ7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBpZiAoIXRleHRMYXllci5jb250YWlucyhzZWxlY3Rpb24uZ2V0UmFuZ2VBdChpKS5jb21tb25BbmNlc3RvckNvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHg6IGxheWVyWCxcbiAgICAgIHk6IGxheWVyWSxcbiAgICAgIHdpZHRoOiBwYXJlbnRXaWR0aCxcbiAgICAgIGhlaWdodDogcGFyZW50SGVpZ2h0XG4gICAgfSA9IHRleHRMYXllci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgcm90YXRvcjtcbiAgICBzd2l0Y2ggKHRleHRMYXllci5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1haW4tcm90YXRpb25cIikpIHtcbiAgICAgIGNhc2UgXCI5MFwiOlxuICAgICAgICByb3RhdG9yID0gKHgsIHksIHcsIGgpID0+ICh7XG4gICAgICAgICAgeDogKHkgLSBsYXllclkpIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIHk6IDEgLSAoeCArIHcgLSBsYXllclgpIC8gcGFyZW50V2lkdGgsXG4gICAgICAgICAgd2lkdGg6IGggLyBwYXJlbnRIZWlnaHQsXG4gICAgICAgICAgaGVpZ2h0OiB3IC8gcGFyZW50V2lkdGhcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIjE4MFwiOlxuICAgICAgICByb3RhdG9yID0gKHgsIHksIHcsIGgpID0+ICh7XG4gICAgICAgICAgeDogMSAtICh4ICsgdyAtIGxheWVyWCkgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICB5OiAxIC0gKHkgKyBoIC0gbGF5ZXJZKSAvIHBhcmVudEhlaWdodCxcbiAgICAgICAgICB3aWR0aDogdyAvIHBhcmVudFdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaCAvIHBhcmVudEhlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiMjcwXCI6XG4gICAgICAgIHJvdGF0b3IgPSAoeCwgeSwgdywgaCkgPT4gKHtcbiAgICAgICAgICB4OiAxIC0gKHkgKyBoIC0gbGF5ZXJZKSAvIHBhcmVudEhlaWdodCxcbiAgICAgICAgICB5OiAoeCAtIGxheWVyWCkgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICB3aWR0aDogaCAvIHBhcmVudEhlaWdodCxcbiAgICAgICAgICBoZWlnaHQ6IHcgLyBwYXJlbnRXaWR0aFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByb3RhdG9yID0gKHgsIHksIHcsIGgpID0+ICh7XG4gICAgICAgICAgeDogKHggLSBsYXllclgpIC8gcGFyZW50V2lkdGgsXG4gICAgICAgICAgeTogKHkgLSBsYXllclkpIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiB3IC8gcGFyZW50V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoIC8gcGFyZW50SGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgYm94ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzZWxlY3Rpb24ucmFuZ2VDb3VudDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoaSk7XG4gICAgICBpZiAocmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gb2YgcmFuZ2UuZ2V0Q2xpZW50UmVjdHMoKSkge1xuICAgICAgICBpZiAod2lkdGggPT09IDAgfHwgaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYm94ZXMucHVzaChyb3RhdG9yKHgsIHksIHdpZHRoLCBoZWlnaHQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJveGVzLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBib3hlcztcbiAgfVxuICBhZGRDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKHtcbiAgICBhbm5vdGF0aW9uRWxlbWVudElkLFxuICAgIGlkXG4gIH0pIHtcbiAgICAodGhpcy4jY2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbnMgfHw9IG5ldyBNYXAoKSkuc2V0KGFubm90YXRpb25FbGVtZW50SWQsIGlkKTtcbiAgfVxuICByZW1vdmVDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKHtcbiAgICBhbm5vdGF0aW9uRWxlbWVudElkXG4gIH0pIHtcbiAgICB0aGlzLiNjaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9ucz8uZGVsZXRlKGFubm90YXRpb25FbGVtZW50SWQpO1xuICB9XG4gIHJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBjb25zdCBlZGl0b3JJZCA9IHRoaXMuI2NoYW5nZWRFeGlzdGluZ0Fubm90YXRpb25zPy5nZXQoYW5ub3RhdGlvbi5kYXRhLmlkKTtcbiAgICBpZiAoIWVkaXRvcklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI2Fubm90YXRpb25TdG9yYWdlLmdldFJhd1ZhbHVlKGVkaXRvcklkKTtcbiAgICBpZiAoIWVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSAmJiAhZWRpdG9yLmhhc0JlZW5Nb2RpZmllZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZGl0b3IucmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbik7XG4gIH1cbiAgc2V0TWlzc2luZ0NhbnZhcyhhbm5vdGF0aW9uSWQsIGFubm90YXRpb25FbGVtZW50SWQsIGNhbnZhcykge1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI21pc3NpbmdDYW52YXNlcz8uZ2V0KGFubm90YXRpb25JZCk7XG4gICAgaWYgKCFlZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWRpdG9yLnNldENhbnZhcyhhbm5vdGF0aW9uRWxlbWVudElkLCBjYW52YXMpO1xuICAgIHRoaXMuI21pc3NpbmdDYW52YXNlcy5kZWxldGUoYW5ub3RhdGlvbklkKTtcbiAgfVxuICBhZGRNaXNzaW5nQ2FudmFzKGFubm90YXRpb25JZCwgZWRpdG9yKSB7XG4gICAgKHRoaXMuI21pc3NpbmdDYW52YXNlcyB8fD0gbmV3IE1hcCgpKS5zZXQoYW5ub3RhdGlvbklkLCBlZGl0b3IpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9hbHRfdGV4dC5qc1xuXG5jbGFzcyBBbHRUZXh0IHtcbiAgI2FsdFRleHQgPSBudWxsO1xuICAjYWx0VGV4dERlY29yYXRpdmUgPSBmYWxzZTtcbiAgI2FsdFRleHRCdXR0b24gPSBudWxsO1xuICAjYWx0VGV4dEJ1dHRvbkxhYmVsID0gbnVsbDtcbiAgI2FsdFRleHRUb29sdGlwID0gbnVsbDtcbiAgI2FsdFRleHRUb29sdGlwVGltZW91dCA9IG51bGw7XG4gICNhbHRUZXh0V2FzRnJvbUtleUJvYXJkID0gZmFsc2U7XG4gICNiYWRnZSA9IG51bGw7XG4gICNlZGl0b3IgPSBudWxsO1xuICAjZ3Vlc3NlZFRleHQgPSBudWxsO1xuICAjdGV4dFdpdGhEaXNjbGFpbWVyID0gbnVsbDtcbiAgI3VzZU5ld0FsdFRleHRGbG93ID0gZmFsc2U7XG4gIHN0YXRpYyAjbDEwbk5ld0J1dHRvbiA9IG51bGw7XG4gIHN0YXRpYyBfbDEwbiA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvciA9IGVkaXRvcjtcbiAgICB0aGlzLiN1c2VOZXdBbHRUZXh0RmxvdyA9IGVkaXRvci5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRGbG93O1xuICAgIEFsdFRleHQuI2wxMG5OZXdCdXR0b24gfHw9IE9iamVjdC5mcmVlemUoe1xuICAgICAgYWRkZWQ6IFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC1hZGRlZC1idXR0b25cIixcbiAgICAgIFwiYWRkZWQtbGFiZWxcIjogXCJwZGZqcy1lZGl0b3ItbmV3LWFsdC10ZXh0LWFkZGVkLWJ1dHRvbi1sYWJlbFwiLFxuICAgICAgbWlzc2luZzogXCJwZGZqcy1lZGl0b3ItbmV3LWFsdC10ZXh0LW1pc3NpbmctYnV0dG9uXCIsXG4gICAgICBcIm1pc3NpbmctbGFiZWxcIjogXCJwZGZqcy1lZGl0b3ItbmV3LWFsdC10ZXh0LW1pc3NpbmctYnV0dG9uLWxhYmVsXCIsXG4gICAgICByZXZpZXc6IFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC10by1yZXZpZXctYnV0dG9uXCIsXG4gICAgICBcInJldmlldy1sYWJlbFwiOiBcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtdG8tcmV2aWV3LWJ1dHRvbi1sYWJlbFwiXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbikge1xuICAgIEFsdFRleHQuX2wxMG4gPz89IGwxMG47XG4gIH1cbiAgYXN5bmMgcmVuZGVyKCkge1xuICAgIGNvbnN0IGFsdFRleHQgPSB0aGlzLiNhbHRUZXh0QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBhbHRUZXh0LmNsYXNzTmFtZSA9IFwiYWx0VGV4dFwiO1xuICAgIGFsdFRleHQudGFiSW5kZXggPSBcIjBcIjtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuI2FsdFRleHRCdXR0b25MYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGFsdFRleHQuYXBwZW5kKGxhYmVsKTtcbiAgICBpZiAodGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cpIHtcbiAgICAgIGFsdFRleHQuY2xhc3NMaXN0LmFkZChcIm5ld1wiKTtcbiAgICAgIGFsdFRleHQuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEFsdFRleHQuI2wxMG5OZXdCdXR0b24ubWlzc2luZyk7XG4gICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQWx0VGV4dC4jbDEwbk5ld0J1dHRvbltcIm1pc3NpbmctbGFiZWxcIl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbHRUZXh0LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWVkaXRvci1hbHQtdGV4dC1idXR0b25cIik7XG4gICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItYWx0LXRleHQtYnV0dG9uLWxhYmVsXCIpO1xuICAgIH1cbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIGFsdFRleHQuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGFsdFRleHQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGV2ZW50ID0+IGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCBvbkNsaWNrID0gZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLmVkaXRBbHRUZXh0KHRoaXMuI2VkaXRvcik7XG4gICAgICBpZiAodGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cpIHtcbiAgICAgICAgdGhpcy4jZWRpdG9yLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgICAgIGFjdGlvbjogXCJwZGZqcy5pbWFnZS5hbHRfdGV4dC5pbWFnZV9zdGF0dXNfbGFiZWxfY2xpY2tlZFwiLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGxhYmVsOiB0aGlzLiNsYWJlbFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBhbHRUZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBvbkNsaWNrLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgYWx0VGV4dC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBhbHRUZXh0ICYmIGV2ZW50LmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICAgIHRoaXMuI2FsdFRleHRXYXNGcm9tS2V5Qm9hcmQgPSB0cnVlO1xuICAgICAgICBvbkNsaWNrKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBhd2FpdCB0aGlzLiNzZXRTdGF0ZSgpO1xuICAgIHJldHVybiBhbHRUZXh0O1xuICB9XG4gIGdldCAjbGFiZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsdFRleHQgJiYgXCJhZGRlZFwiIHx8IHRoaXMuI2FsdFRleHQgPT09IG51bGwgJiYgdGhpcy5ndWVzc2VkVGV4dCAmJiBcInJldmlld1wiIHx8IFwibWlzc2luZ1wiO1xuICB9XG4gIGZpbmlzaCgpIHtcbiAgICBpZiAoIXRoaXMuI2FsdFRleHRCdXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbi5mb2N1cyh7XG4gICAgICBmb2N1c1Zpc2libGU6IHRoaXMuI2FsdFRleHRXYXNGcm9tS2V5Qm9hcmRcbiAgICB9KTtcbiAgICB0aGlzLiNhbHRUZXh0V2FzRnJvbUtleUJvYXJkID0gZmFsc2U7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICBpZiAodGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cpIHtcbiAgICAgIHJldHVybiB0aGlzLiNhbHRUZXh0ID09PSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gIXRoaXMuI2FsdFRleHQgJiYgIXRoaXMuI2FsdFRleHREZWNvcmF0aXZlO1xuICB9XG4gIGhhc0RhdGEoKSB7XG4gICAgaWYgKHRoaXMuI3VzZU5ld0FsdFRleHRGbG93KSB7XG4gICAgICByZXR1cm4gdGhpcy4jYWx0VGV4dCAhPT0gbnVsbCB8fCAhIXRoaXMuI2d1ZXNzZWRUZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pc0VtcHR5KCk7XG4gIH1cbiAgZ2V0IGd1ZXNzZWRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiNndWVzc2VkVGV4dDtcbiAgfVxuICBhc3luYyBzZXRHdWVzc2VkVGV4dChndWVzc2VkVGV4dCkge1xuICAgIGlmICh0aGlzLiNhbHRUZXh0ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2d1ZXNzZWRUZXh0ID0gZ3Vlc3NlZFRleHQ7XG4gICAgdGhpcy4jdGV4dFdpdGhEaXNjbGFpbWVyID0gYXdhaXQgQWx0VGV4dC5fbDEwbi5nZXQoXCJwZGZqcy1lZGl0b3ItbmV3LWFsdC10ZXh0LWdlbmVyYXRlZC1hbHQtdGV4dC13aXRoLWRpc2NsYWltZXJcIiwge1xuICAgICAgZ2VuZXJhdGVkQWx0VGV4dDogZ3Vlc3NlZFRleHRcbiAgICB9KTtcbiAgICB0aGlzLiNzZXRTdGF0ZSgpO1xuICB9XG4gIHRvZ2dsZUFsdFRleHRCYWRnZSh2aXNpYmlsaXR5ID0gZmFsc2UpIHtcbiAgICBpZiAoIXRoaXMuI3VzZU5ld0FsdFRleHRGbG93IHx8IHRoaXMuI2FsdFRleHQpIHtcbiAgICAgIHRoaXMuI2JhZGdlPy5yZW1vdmUoKTtcbiAgICAgIHRoaXMuI2JhZGdlID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNiYWRnZSkge1xuICAgICAgY29uc3QgYmFkZ2UgPSB0aGlzLiNiYWRnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBiYWRnZS5jbGFzc05hbWUgPSBcIm5vQWx0VGV4dEJhZGdlXCI7XG4gICAgICB0aGlzLiNlZGl0b3IuZGl2LmFwcGVuZChiYWRnZSk7XG4gICAgfVxuICAgIHRoaXMuI2JhZGdlLmNsYXNzTGlzdC50b2dnbGUoXCJoaWRkZW5cIiwgIXZpc2liaWxpdHkpO1xuICB9XG4gIHNlcmlhbGl6ZShpc0ZvckNvcHlpbmcpIHtcbiAgICBsZXQgYWx0VGV4dCA9IHRoaXMuI2FsdFRleHQ7XG4gICAgaWYgKCFpc0ZvckNvcHlpbmcgJiYgdGhpcy4jZ3Vlc3NlZFRleHQgPT09IGFsdFRleHQpIHtcbiAgICAgIGFsdFRleHQgPSB0aGlzLiN0ZXh0V2l0aERpc2NsYWltZXI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBhbHRUZXh0LFxuICAgICAgZGVjb3JhdGl2ZTogdGhpcy4jYWx0VGV4dERlY29yYXRpdmUsXG4gICAgICBndWVzc2VkVGV4dDogdGhpcy4jZ3Vlc3NlZFRleHQsXG4gICAgICB0ZXh0V2l0aERpc2NsYWltZXI6IHRoaXMuI3RleHRXaXRoRGlzY2xhaW1lclxuICAgIH07XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFsdFRleHQ6IHRoaXMuI2FsdFRleHQsXG4gICAgICBkZWNvcmF0aXZlOiB0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZVxuICAgIH07XG4gIH1cbiAgc2V0IGRhdGEoe1xuICAgIGFsdFRleHQsXG4gICAgZGVjb3JhdGl2ZSxcbiAgICBndWVzc2VkVGV4dCxcbiAgICB0ZXh0V2l0aERpc2NsYWltZXIsXG4gICAgY2FuY2VsID0gZmFsc2VcbiAgfSkge1xuICAgIGlmIChndWVzc2VkVGV4dCkge1xuICAgICAgdGhpcy4jZ3Vlc3NlZFRleHQgPSBndWVzc2VkVGV4dDtcbiAgICAgIHRoaXMuI3RleHRXaXRoRGlzY2xhaW1lciA9IHRleHRXaXRoRGlzY2xhaW1lcjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2FsdFRleHQgPT09IGFsdFRleHQgJiYgdGhpcy4jYWx0VGV4dERlY29yYXRpdmUgPT09IGRlY29yYXRpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjYW5jZWwpIHtcbiAgICAgIHRoaXMuI2FsdFRleHQgPSBhbHRUZXh0O1xuICAgICAgdGhpcy4jYWx0VGV4dERlY29yYXRpdmUgPSBkZWNvcmF0aXZlO1xuICAgIH1cbiAgICB0aGlzLiNzZXRTdGF0ZSgpO1xuICB9XG4gIHRvZ2dsZShlbmFibGVkID0gZmFsc2UpIHtcbiAgICBpZiAoIXRoaXMuI2FsdFRleHRCdXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFlbmFibGVkICYmIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCk7XG4gICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNhbHRUZXh0QnV0dG9uLmRpc2FibGVkID0gIWVuYWJsZWQ7XG4gIH1cbiAgc2hvd24oKSB7XG4gICAgdGhpcy4jZWRpdG9yLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgYWN0aW9uOiBcInBkZmpzLmltYWdlLmFsdF90ZXh0LmltYWdlX3N0YXR1c19sYWJlbF9kaXNwbGF5ZWRcIixcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuI2xhYmVsXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNhbHRUZXh0QnV0dG9uPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNhbHRUZXh0QnV0dG9uID0gbnVsbDtcbiAgICB0aGlzLiNhbHRUZXh0QnV0dG9uTGFiZWwgPSBudWxsO1xuICAgIHRoaXMuI2FsdFRleHRUb29sdGlwID0gbnVsbDtcbiAgICB0aGlzLiNiYWRnZT8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jYmFkZ2UgPSBudWxsO1xuICB9XG4gIGFzeW5jICNzZXRTdGF0ZSgpIHtcbiAgICBjb25zdCBidXR0b24gPSB0aGlzLiNhbHRUZXh0QnV0dG9uO1xuICAgIGlmICghYnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiN1c2VOZXdBbHRUZXh0Rmxvdykge1xuICAgICAgYnV0dG9uLmNsYXNzTGlzdC50b2dnbGUoXCJkb25lXCIsICEhdGhpcy4jYWx0VGV4dCk7XG4gICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEFsdFRleHQuI2wxMG5OZXdCdXR0b25bdGhpcy4jbGFiZWxdKTtcbiAgICAgIHRoaXMuI2FsdFRleHRCdXR0b25MYWJlbD8uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEFsdFRleHQuI2wxMG5OZXdCdXR0b25bYCR7dGhpcy4jbGFiZWx9LWxhYmVsYF0pO1xuICAgICAgaWYgKCF0aGlzLiNhbHRUZXh0KSB7XG4gICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwPy5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuI2FsdFRleHQgJiYgIXRoaXMuI2FsdFRleHREZWNvcmF0aXZlKSB7XG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwiZG9uZVwiKTtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXA/LnJlbW92ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBidXR0b24uY2xhc3NMaXN0LmFkZChcImRvbmVcIik7XG4gICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZWRpdG9yLWFsdC10ZXh0LWVkaXQtYnV0dG9uXCIpO1xuICAgIH1cbiAgICBsZXQgdG9vbHRpcCA9IHRoaXMuI2FsdFRleHRUb29sdGlwO1xuICAgIGlmICghdG9vbHRpcCkge1xuICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXAgPSB0b29sdGlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICB0b29sdGlwLmNsYXNzTmFtZSA9IFwidG9vbHRpcFwiO1xuICAgICAgdG9vbHRpcC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidG9vbHRpcFwiKTtcbiAgICAgIHRvb2x0aXAuaWQgPSBgYWx0LXRleHQtdG9vbHRpcC0ke3RoaXMuI2VkaXRvci5pZH1gO1xuICAgICAgY29uc3QgREVMQVlfVE9fU0hPV19UT09MVElQID0gMTAwO1xuICAgICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0KTtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgIH0sIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwLmNsYXNzTGlzdC5hZGQoXCJzaG93XCIpO1xuICAgICAgICAgIHRoaXMuI2VkaXRvci5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgICAgICAgIGFjdGlvbjogXCJhbHRfdGV4dF90b29sdGlwXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgREVMQVlfVE9fU0hPV19UT09MVElQKTtcbiAgICAgIH0sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0KTtcbiAgICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwPy5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKTtcbiAgICAgIH0sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2FsdFRleHREZWNvcmF0aXZlKSB7XG4gICAgICB0b29sdGlwLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWVkaXRvci1hbHQtdGV4dC1kZWNvcmF0aXZlLXRvb2x0aXBcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvb2x0aXAucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIpO1xuICAgICAgdG9vbHRpcC50ZXh0Q29udGVudCA9IHRoaXMuI2FsdFRleHQ7XG4gICAgfVxuICAgIGlmICghdG9vbHRpcC5wYXJlbnROb2RlKSB7XG4gICAgICBidXR0b24uYXBwZW5kKHRvb2x0aXApO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy4jZWRpdG9yLmdldEVsZW1lbnRGb3JBbHRUZXh0KCk7XG4gICAgZWxlbWVudD8uc2V0QXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiLCB0b29sdGlwLmlkKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvY29tbWVudC5qc1xuXG5jbGFzcyBDb21tZW50IHtcbiAgI2NvbW1lbnRCdXR0b24gPSBudWxsO1xuICAjY29tbWVudFdhc0Zyb21LZXlCb2FyZCA9IGZhbHNlO1xuICAjZWRpdG9yID0gbnVsbDtcbiAgI2luaXRpYWxUZXh0ID0gbnVsbDtcbiAgI3RleHQgPSBudWxsO1xuICAjZGF0ZSA9IG51bGw7XG4gICNkZWxldGVkID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvciA9IGVkaXRvcjtcbiAgICB0aGlzLnRvb2xiYXIgPSBudWxsO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLmhhc0NvbW1lbnRNYW5hZ2VyKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBjb21tZW50ID0gdGhpcy4jY29tbWVudEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgY29tbWVudC5jbGFzc05hbWUgPSBcImNvbW1lbnRcIjtcbiAgICBjb21tZW50LnRhYkluZGV4ID0gXCIwXCI7XG4gICAgY29tbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItZWRpdC1jb21tZW50LWJ1dHRvblwiKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIGlmICghKHNpZ25hbCBpbnN0YW5jZW9mIEFib3J0U2lnbmFsKSB8fCBzaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIGNvbW1lbnQ7XG4gICAgfVxuICAgIGNvbW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGNvbW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGV2ZW50ID0+IGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCBvbkNsaWNrID0gZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuZWRpdCgpO1xuICAgIH07XG4gICAgY29tbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgb25DbGljaywge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGNvbW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gY29tbWVudCAmJiBldmVudC5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICB0aGlzLiNjb21tZW50V2FzRnJvbUtleUJvYXJkID0gdHJ1ZTtcbiAgICAgICAgb25DbGljayhldmVudCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbW1lbnQ7XG4gIH1cbiAgZWRpdCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBib3R0b20sXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9ID0gdGhpcy4jZWRpdG9yLmdldENsaWVudERpbWVuc2lvbnMoKTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHtcbiAgICAgIHRvcDogYm90dG9tXG4gICAgfTtcbiAgICBpZiAodGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuZGlyZWN0aW9uID09PSBcImx0clwiKSB7XG4gICAgICBwb3NpdGlvbi5yaWdodCA9IHJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3NpdGlvbi5sZWZ0ID0gbGVmdDtcbiAgICB9XG4gICAgdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuZWRpdENvbW1lbnQodGhpcy4jZWRpdG9yLCBwb3NpdGlvbik7XG4gIH1cbiAgZmluaXNoKCkge1xuICAgIGlmICghdGhpcy4jY29tbWVudEJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb21tZW50QnV0dG9uLmZvY3VzKHtcbiAgICAgIGZvY3VzVmlzaWJsZTogdGhpcy4jY29tbWVudFdhc0Zyb21LZXlCb2FyZFxuICAgIH0pO1xuICAgIHRoaXMuI2NvbW1lbnRXYXNGcm9tS2V5Qm9hcmQgPSBmYWxzZTtcbiAgfVxuICBpc0RlbGV0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RlbGV0ZWQgfHwgdGhpcy4jdGV4dCA9PT0gXCJcIjtcbiAgfVxuICBoYXNCZWVuRWRpdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmlzRGVsZXRlZCgpIHx8IHRoaXMuI3RleHQgIT09IHRoaXMuI2luaXRpYWxUZXh0O1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiB0aGlzLiN0ZXh0LFxuICAgICAgZGF0ZTogdGhpcy4jZGF0ZSxcbiAgICAgIGRlbGV0ZWQ6IHRoaXMuI2RlbGV0ZWRcbiAgICB9O1xuICB9XG4gIHNldCBkYXRhKHRleHQpIHtcbiAgICBpZiAodGV4dCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy4jdGV4dCA9IFwiXCI7XG4gICAgICB0aGlzLiNkZWxldGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdGV4dCA9IHRleHQ7XG4gICAgdGhpcy4jZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgdGhpcy4jZGVsZXRlZCA9IGZhbHNlO1xuICB9XG4gIHNldEluaXRpYWxUZXh0KHRleHQpIHtcbiAgICB0aGlzLiNpbml0aWFsVGV4dCA9IHRleHQ7XG4gICAgdGhpcy5kYXRhID0gdGV4dDtcbiAgfVxuICB0b2dnbGUoZW5hYmxlZCA9IGZhbHNlKSB7XG4gICAgaWYgKCF0aGlzLiNjb21tZW50QnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbW1lbnRCdXR0b24uZGlzYWJsZWQgPSAhZW5hYmxlZDtcbiAgfVxuICBzaG93bigpIHt9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jY29tbWVudEJ1dHRvbj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jY29tbWVudEJ1dHRvbiA9IG51bGw7XG4gICAgdGhpcy4jdGV4dCA9IFwiXCI7XG4gICAgdGhpcy4jZGF0ZSA9IG51bGw7XG4gICAgdGhpcy4jZWRpdG9yID0gbnVsbDtcbiAgICB0aGlzLiNjb21tZW50V2FzRnJvbUtleUJvYXJkID0gZmFsc2U7XG4gICAgdGhpcy4jZGVsZXRlZCA9IGZhbHNlO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3RvdWNoX21hbmFnZXIuanNcblxuY2xhc3MgVG91Y2hNYW5hZ2VyIHtcbiAgI2NvbnRhaW5lcjtcbiAgI2lzUGluY2hpbmcgPSBmYWxzZTtcbiAgI2lzUGluY2hpbmdTdG9wcGVkID0gbnVsbDtcbiAgI2lzUGluY2hpbmdEaXNhYmxlZDtcbiAgI29uUGluY2hTdGFydDtcbiAgI29uUGluY2hpbmc7XG4gICNvblBpbmNoRW5kO1xuICAjcG9pbnRlckRvd25BQyA9IG51bGw7XG4gICNzaWduYWw7XG4gICN0b3VjaEluZm8gPSBudWxsO1xuICAjdG91Y2hNYW5hZ2VyQUM7XG4gICN0b3VjaE1vdmVBQyA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb250YWluZXIsXG4gICAgaXNQaW5jaGluZ0Rpc2FibGVkID0gbnVsbCxcbiAgICBpc1BpbmNoaW5nU3RvcHBlZCA9IG51bGwsXG4gICAgb25QaW5jaFN0YXJ0ID0gbnVsbCxcbiAgICBvblBpbmNoaW5nID0gbnVsbCxcbiAgICBvblBpbmNoRW5kID0gbnVsbCxcbiAgICBzaWduYWxcbiAgfSkge1xuICAgIHRoaXMuI2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLiNpc1BpbmNoaW5nU3RvcHBlZCA9IGlzUGluY2hpbmdTdG9wcGVkO1xuICAgIHRoaXMuI2lzUGluY2hpbmdEaXNhYmxlZCA9IGlzUGluY2hpbmdEaXNhYmxlZDtcbiAgICB0aGlzLiNvblBpbmNoU3RhcnQgPSBvblBpbmNoU3RhcnQ7XG4gICAgdGhpcy4jb25QaW5jaGluZyA9IG9uUGluY2hpbmc7XG4gICAgdGhpcy4jb25QaW5jaEVuZCA9IG9uUGluY2hFbmQ7XG4gICAgdGhpcy4jdG91Y2hNYW5hZ2VyQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy4jc2lnbmFsID0gQWJvcnRTaWduYWwuYW55KFtzaWduYWwsIHRoaXMuI3RvdWNoTWFuYWdlckFDLnNpZ25hbF0pO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLiNvblRvdWNoU3RhcnQuYmluZCh0aGlzKSwge1xuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBzaWduYWw6IHRoaXMuI3NpZ25hbFxuICAgIH0pO1xuICB9XG4gIGdldCBNSU5fVE9VQ0hfRElTVEFOQ0VfVE9fUElOQ0goKSB7XG4gICAgcmV0dXJuIDM1IC8gT3V0cHV0U2NhbGUucGl4ZWxSYXRpbztcbiAgfVxuICAjb25Ub3VjaFN0YXJ0KGV2dCkge1xuICAgIGlmICh0aGlzLiNpc1BpbmNoaW5nRGlzYWJsZWQ/LigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldnQudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmICh0aGlzLiNwb2ludGVyRG93bkFDKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvaW50ZXJEb3duQUMgPSB0aGlzLiNwb2ludGVyRG93bkFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gQWJvcnRTaWduYWwuYW55KFt0aGlzLiNzaWduYWwsIHBvaW50ZXJEb3duQUMuc2lnbmFsXSk7XG4gICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLiNjb250YWluZXI7XG4gICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICBzaWduYWwsXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgY29uc3QgY2FuY2VsUG9pbnRlckRvd24gPSBlID0+IHtcbiAgICAgICAgaWYgKGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgICAgIHRoaXMuI3BvaW50ZXJEb3duQUM/LmFib3J0KCk7XG4gICAgICAgICAgdGhpcy4jcG9pbnRlckRvd25BQyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGUgPT4ge1xuICAgICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSB7XG4gICAgICAgICAgc3RvcEV2ZW50KGUpO1xuICAgICAgICAgIGNhbmNlbFBvaW50ZXJEb3duKGUpO1xuICAgICAgICB9XG4gICAgICB9LCBvcHRzKTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIGNhbmNlbFBvaW50ZXJEb3duLCBvcHRzKTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLCBjYW5jZWxQb2ludGVyRG93biwgb3B0cyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jdG91Y2hNb3ZlQUMpIHtcbiAgICAgIHRoaXMuI3RvdWNoTW92ZUFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gQWJvcnRTaWduYWwuYW55KFt0aGlzLiNzaWduYWwsIHRoaXMuI3RvdWNoTW92ZUFDLnNpZ25hbF0pO1xuICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy4jY29udGFpbmVyO1xuICAgICAgY29uc3Qgb3B0ID0ge1xuICAgICAgICBzaWduYWwsXG4gICAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuI29uVG91Y2hNb3ZlLmJpbmQodGhpcyksIG9wdCk7XG4gICAgICBjb25zdCBvblRvdWNoRW5kID0gdGhpcy4jb25Ub3VjaEVuZC5iaW5kKHRoaXMpO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBvblRvdWNoRW5kLCBvcHQpO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCBvblRvdWNoRW5kLCBvcHQpO1xuICAgICAgb3B0LmNhcHR1cmUgPSB0cnVlO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBzdG9wRXZlbnQsIG9wdCk7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHN0b3BFdmVudCwgb3B0KTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLCBzdG9wRXZlbnQsIG9wdCk7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBzdG9wRXZlbnQsIG9wdCk7XG4gICAgICB0aGlzLiNvblBpbmNoU3RhcnQ/LigpO1xuICAgIH1cbiAgICBzdG9wRXZlbnQoZXZ0KTtcbiAgICBpZiAoZXZ0LnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8IHRoaXMuI2lzUGluY2hpbmdTdG9wcGVkPy4oKSkge1xuICAgICAgdGhpcy4jdG91Y2hJbmZvID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IFt0b3VjaDAsIHRvdWNoMV0gPSBldnQudG91Y2hlcztcbiAgICBpZiAodG91Y2gwLmlkZW50aWZpZXIgPiB0b3VjaDEuaWRlbnRpZmllcikge1xuICAgICAgW3RvdWNoMCwgdG91Y2gxXSA9IFt0b3VjaDEsIHRvdWNoMF07XG4gICAgfVxuICAgIHRoaXMuI3RvdWNoSW5mbyA9IHtcbiAgICAgIHRvdWNoMFg6IHRvdWNoMC5zY3JlZW5YLFxuICAgICAgdG91Y2gwWTogdG91Y2gwLnNjcmVlblksXG4gICAgICB0b3VjaDFYOiB0b3VjaDEuc2NyZWVuWCxcbiAgICAgIHRvdWNoMVk6IHRvdWNoMS5zY3JlZW5ZXG4gICAgfTtcbiAgfVxuICAjb25Ub3VjaE1vdmUoZXZ0KSB7XG4gICAgaWYgKCF0aGlzLiN0b3VjaEluZm8gfHwgZXZ0LnRvdWNoZXMubGVuZ3RoICE9PSAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0b3BFdmVudChldnQpO1xuICAgIGxldCBbdG91Y2gwLCB0b3VjaDFdID0gZXZ0LnRvdWNoZXM7XG4gICAgaWYgKHRvdWNoMC5pZGVudGlmaWVyID4gdG91Y2gxLmlkZW50aWZpZXIpIHtcbiAgICAgIFt0b3VjaDAsIHRvdWNoMV0gPSBbdG91Y2gxLCB0b3VjaDBdO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzY3JlZW5YOiBzY3JlZW4wWCxcbiAgICAgIHNjcmVlblk6IHNjcmVlbjBZXG4gICAgfSA9IHRvdWNoMDtcbiAgICBjb25zdCB7XG4gICAgICBzY3JlZW5YOiBzY3JlZW4xWCxcbiAgICAgIHNjcmVlblk6IHNjcmVlbjFZXG4gICAgfSA9IHRvdWNoMTtcbiAgICBjb25zdCB0b3VjaEluZm8gPSB0aGlzLiN0b3VjaEluZm87XG4gICAgY29uc3Qge1xuICAgICAgdG91Y2gwWDogcFRvdWNoMFgsXG4gICAgICB0b3VjaDBZOiBwVG91Y2gwWSxcbiAgICAgIHRvdWNoMVg6IHBUb3VjaDFYLFxuICAgICAgdG91Y2gxWTogcFRvdWNoMVlcbiAgICB9ID0gdG91Y2hJbmZvO1xuICAgIGNvbnN0IHByZXZHYXBYID0gcFRvdWNoMVggLSBwVG91Y2gwWDtcbiAgICBjb25zdCBwcmV2R2FwWSA9IHBUb3VjaDFZIC0gcFRvdWNoMFk7XG4gICAgY29uc3QgY3VyckdhcFggPSBzY3JlZW4xWCAtIHNjcmVlbjBYO1xuICAgIGNvbnN0IGN1cnJHYXBZID0gc2NyZWVuMVkgLSBzY3JlZW4wWTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguaHlwb3QoY3VyckdhcFgsIGN1cnJHYXBZKSB8fCAxO1xuICAgIGNvbnN0IHBEaXN0YW5jZSA9IE1hdGguaHlwb3QocHJldkdhcFgsIHByZXZHYXBZKSB8fCAxO1xuICAgIGlmICghdGhpcy4jaXNQaW5jaGluZyAmJiBNYXRoLmFicyhwRGlzdGFuY2UgLSBkaXN0YW5jZSkgPD0gVG91Y2hNYW5hZ2VyLk1JTl9UT1VDSF9ESVNUQU5DRV9UT19QSU5DSCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0b3VjaEluZm8udG91Y2gwWCA9IHNjcmVlbjBYO1xuICAgIHRvdWNoSW5mby50b3VjaDBZID0gc2NyZWVuMFk7XG4gICAgdG91Y2hJbmZvLnRvdWNoMVggPSBzY3JlZW4xWDtcbiAgICB0b3VjaEluZm8udG91Y2gxWSA9IHNjcmVlbjFZO1xuICAgIGlmICghdGhpcy4jaXNQaW5jaGluZykge1xuICAgICAgdGhpcy4jaXNQaW5jaGluZyA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbiA9IFsoc2NyZWVuMFggKyBzY3JlZW4xWCkgLyAyLCAoc2NyZWVuMFkgKyBzY3JlZW4xWSkgLyAyXTtcbiAgICB0aGlzLiNvblBpbmNoaW5nPy4ob3JpZ2luLCBwRGlzdGFuY2UsIGRpc3RhbmNlKTtcbiAgfVxuICAjb25Ub3VjaEVuZChldnQpIHtcbiAgICBpZiAoZXZ0LnRvdWNoZXMubGVuZ3RoID49IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3RvdWNoTW92ZUFDKSB7XG4gICAgICB0aGlzLiN0b3VjaE1vdmVBQy5hYm9ydCgpO1xuICAgICAgdGhpcy4jdG91Y2hNb3ZlQUMgPSBudWxsO1xuICAgICAgdGhpcy4jb25QaW5jaEVuZD8uKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy4jdG91Y2hJbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0b3BFdmVudChldnQpO1xuICAgIHRoaXMuI3RvdWNoSW5mbyA9IG51bGw7XG4gICAgdGhpcy4jaXNQaW5jaGluZyA9IGZhbHNlO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jdG91Y2hNYW5hZ2VyQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jdG91Y2hNYW5hZ2VyQUMgPSBudWxsO1xuICAgIHRoaXMuI3BvaW50ZXJEb3duQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jcG9pbnRlckRvd25BQyA9IG51bGw7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2VkaXRvci5qc1xuXG5cblxuXG5cblxuXG5jbGFzcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2FjY2Vzc2liaWxpdHlEYXRhID0gbnVsbDtcbiAgI2FsbFJlc2l6ZXJEaXZzID0gbnVsbDtcbiAgI2FsdFRleHQgPSBudWxsO1xuICAjY29tbWVudCA9IG51bGw7XG4gICNkaXNhYmxlZCA9IGZhbHNlO1xuICAjZHJhZ1BvaW50ZXJJZCA9IG51bGw7XG4gICNkcmFnUG9pbnRlclR5cGUgPSBcIlwiO1xuICAja2VlcEFzcGVjdFJhdGlvID0gZmFsc2U7XG4gICNyZXNpemVyc0RpdiA9IG51bGw7XG4gICNsYXN0UG9pbnRlckNvb3JkcyA9IG51bGw7XG4gICNzYXZlZERpbWVuc2lvbnMgPSBudWxsO1xuICAjZm9jdXNBQyA9IG51bGw7XG4gICNmb2N1c2VkUmVzaXplck5hbWUgPSBcIlwiO1xuICAjaGFzQmVlbkNsaWNrZWQgPSBmYWxzZTtcbiAgI2luaXRpYWxSZWN0ID0gbnVsbDtcbiAgI2lzRWRpdGluZyA9IGZhbHNlO1xuICAjaXNJbkVkaXRNb2RlID0gZmFsc2U7XG4gICNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQgPSBmYWxzZTtcbiAgI21vdmVJbkRPTVRpbWVvdXQgPSBudWxsO1xuICAjcHJldkRyYWdYID0gMDtcbiAgI3ByZXZEcmFnWSA9IDA7XG4gICN0ZWxlbWV0cnlUaW1lb3V0cyA9IG51bGw7XG4gICN0b3VjaE1hbmFnZXIgPSBudWxsO1xuICBpc1NlbGVjdGVkID0gZmFsc2U7XG4gIF9pc0NvcHkgPSBmYWxzZTtcbiAgX2VkaXRUb29sYmFyID0gbnVsbDtcbiAgX2luaXRpYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgX2luaXRpYWxEYXRhID0gbnVsbDtcbiAgX2lzVmlzaWJsZSA9IHRydWU7XG4gIF91aU1hbmFnZXIgPSBudWxsO1xuICBfZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgc3RhdGljIF9sMTBuID0gbnVsbDtcbiAgc3RhdGljIF9sMTBuUmVzaXplciA9IG51bGw7XG4gICNpc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAjekluZGV4ID0gQW5ub3RhdGlvbkVkaXRvci5fekluZGV4Kys7XG4gIHN0YXRpYyBfYm9yZGVyTGluZVdpZHRoID0gLTE7XG4gIHN0YXRpYyBfY29sb3JNYW5hZ2VyID0gbmV3IENvbG9yTWFuYWdlcigpO1xuICBzdGF0aWMgX3pJbmRleCA9IDE7XG4gIHN0YXRpYyBfdGVsZW1ldHJ5VGltZW91dCA9IDEwMDA7XG4gIHN0YXRpYyBnZXQgX3Jlc2l6ZXJLZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgY29uc3QgcmVzaXplID0gQW5ub3RhdGlvbkVkaXRvci5wcm90b3R5cGUuX3Jlc2l6ZVdpdGhLZXlib2FyZDtcbiAgICBjb25zdCBzbWFsbCA9IEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIuVFJBTlNMQVRFX1NNQUxMO1xuICAgIGNvbnN0IGJpZyA9IEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIuVFJBTlNMQVRFX0JJRztcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX3Jlc2l6ZXJLZXlib2FyZE1hbmFnZXJcIiwgbmV3IEtleWJvYXJkTWFuYWdlcihbW1tcIkFycm93TGVmdFwiLCBcIm1hYytBcnJvd0xlZnRcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogWy1zbWFsbCwgMF1cbiAgICB9XSwgW1tcImN0cmwrQXJyb3dMZWZ0XCIsIFwibWFjK3NoaWZ0K0Fycm93TGVmdFwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbLWJpZywgMF1cbiAgICB9XSwgW1tcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dSaWdodFwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbc21hbGwsIDBdXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93UmlnaHRcIiwgXCJtYWMrc2hpZnQrQXJyb3dSaWdodFwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbYmlnLCAwXVxuICAgIH1dLCBbW1wiQXJyb3dVcFwiLCBcIm1hYytBcnJvd1VwXCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFswLCAtc21hbGxdXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93VXBcIiwgXCJtYWMrc2hpZnQrQXJyb3dVcFwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbMCwgLWJpZ11cbiAgICB9XSwgW1tcIkFycm93RG93blwiLCBcIm1hYytBcnJvd0Rvd25cIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogWzAsIHNtYWxsXVxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0Rvd25cIiwgXCJtYWMrc2hpZnQrQXJyb3dEb3duXCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFswLCBiaWddXG4gICAgfV0sIFtbXCJFc2NhcGVcIiwgXCJtYWMrRXNjYXBlXCJdLCBBbm5vdGF0aW9uRWRpdG9yLnByb3RvdHlwZS5fc3RvcFJlc2l6aW5nV2l0aEtleWJvYXJkXV0pKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJhbWV0ZXJzLnBhcmVudDtcbiAgICB0aGlzLmlkID0gcGFyYW1ldGVycy5pZDtcbiAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSBudWxsO1xuICAgIHRoaXMucGFnZUluZGV4ID0gcGFyYW1ldGVycy5wYXJlbnQucGFnZUluZGV4O1xuICAgIHRoaXMubmFtZSA9IHBhcmFtZXRlcnMubmFtZTtcbiAgICB0aGlzLmRpdiA9IG51bGw7XG4gICAgdGhpcy5fdWlNYW5hZ2VyID0gcGFyYW1ldGVycy51aU1hbmFnZXI7XG4gICAgdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkID0gbnVsbDtcbiAgICB0aGlzLl93aWxsS2VlcEFzcGVjdFJhdGlvID0gZmFsc2U7XG4gICAgdGhpcy5faW5pdGlhbE9wdGlvbnMuaXNDZW50ZXJlZCA9IHBhcmFtZXRlcnMuaXNDZW50ZXJlZDtcbiAgICB0aGlzLl9zdHJ1Y3RUcmVlUGFyZW50SWQgPSBudWxsO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IHBhcmFtZXRlcnMuYW5ub3RhdGlvbkVsZW1lbnRJZCB8fCBudWxsO1xuICAgIGNvbnN0IHtcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgcmF3RGltczoge1xuICAgICAgICBwYWdlV2lkdGgsXG4gICAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICAgIHBhZ2VYLFxuICAgICAgICBwYWdlWVxuICAgICAgfVxuICAgIH0gPSB0aGlzLnBhcmVudC52aWV3cG9ydDtcbiAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb247XG4gICAgdGhpcy5wYWdlUm90YXRpb24gPSAoMzYwICsgcm90YXRpb24gLSB0aGlzLl91aU1hbmFnZXIudmlld1BhcmFtZXRlcnMucm90YXRpb24pICUgMzYwO1xuICAgIHRoaXMucGFnZURpbWVuc2lvbnMgPSBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XTtcbiAgICB0aGlzLnBhZ2VUcmFuc2xhdGlvbiA9IFtwYWdlWCwgcGFnZVldO1xuICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLnggPSBwYXJhbWV0ZXJzLnggLyB3aWR0aDtcbiAgICB0aGlzLnkgPSBwYXJhbWV0ZXJzLnkgLyBoZWlnaHQ7XG4gICAgdGhpcy5pc0F0dGFjaGVkVG9ET00gPSBmYWxzZTtcbiAgICB0aGlzLmRlbGV0ZWQgPSBmYWxzZTtcbiAgfVxuICBnZXQgZWRpdG9yVHlwZSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yLl90eXBlO1xuICB9XG4gIGdldCBtb2RlKCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IuX2VkaXRvclR5cGU7XG4gIH1cbiAgc3RhdGljIGdldCBpc0RyYXdlcigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGdldCBfZGVmYXVsdExpbmVDb2xvcigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2RlZmF1bHRMaW5lQ29sb3JcIiwgdGhpcy5fY29sb3JNYW5hZ2VyLmdldEhleENvZGUoXCJDYW52YXNUZXh0XCIpKTtcbiAgfVxuICBzdGF0aWMgZGVsZXRlQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKSB7XG4gICAgY29uc3QgZmFrZUVkaXRvciA9IG5ldyBGYWtlRWRpdG9yKHtcbiAgICAgIGlkOiBlZGl0b3IucGFyZW50LmdldE5leHRJZCgpLFxuICAgICAgcGFyZW50OiBlZGl0b3IucGFyZW50LFxuICAgICAgdWlNYW5hZ2VyOiBlZGl0b3IuX3VpTWFuYWdlclxuICAgIH0pO1xuICAgIGZha2VFZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIGZha2VFZGl0b3IuZGVsZXRlZCA9IHRydWU7XG4gICAgZmFrZUVkaXRvci5fdWlNYW5hZ2VyLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZmFrZUVkaXRvcik7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbiwgX3VpTWFuYWdlcikge1xuICAgIEFubm90YXRpb25FZGl0b3IuX2wxMG4gPz89IGwxMG47XG4gICAgQW5ub3RhdGlvbkVkaXRvci5fbDEwblJlc2l6ZXIgfHw9IE9iamVjdC5mcmVlemUoe1xuICAgICAgdG9wTGVmdDogXCJwZGZqcy1lZGl0b3ItcmVzaXplci10b3AtbGVmdFwiLFxuICAgICAgdG9wTWlkZGxlOiBcInBkZmpzLWVkaXRvci1yZXNpemVyLXRvcC1taWRkbGVcIixcbiAgICAgIHRvcFJpZ2h0OiBcInBkZmpzLWVkaXRvci1yZXNpemVyLXRvcC1yaWdodFwiLFxuICAgICAgbWlkZGxlUmlnaHQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItbWlkZGxlLXJpZ2h0XCIsXG4gICAgICBib3R0b21SaWdodDogXCJwZGZqcy1lZGl0b3ItcmVzaXplci1ib3R0b20tcmlnaHRcIixcbiAgICAgIGJvdHRvbU1pZGRsZTogXCJwZGZqcy1lZGl0b3ItcmVzaXplci1ib3R0b20tbWlkZGxlXCIsXG4gICAgICBib3R0b21MZWZ0OiBcInBkZmpzLWVkaXRvci1yZXNpemVyLWJvdHRvbS1sZWZ0XCIsXG4gICAgICBtaWRkbGVMZWZ0OiBcInBkZmpzLWVkaXRvci1yZXNpemVyLW1pZGRsZS1sZWZ0XCJcbiAgICB9KTtcbiAgICBpZiAoQW5ub3RhdGlvbkVkaXRvci5fYm9yZGVyTGluZVdpZHRoICE9PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLl9ib3JkZXJMaW5lV2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCItLW91dGxpbmUtd2lkdGhcIikpIHx8IDA7XG4gIH1cbiAgc3RhdGljIHVwZGF0ZURlZmF1bHRQYXJhbXMoX3R5cGUsIF92YWx1ZSkge31cbiAgc3RhdGljIGdldCBkZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBzdGF0aWMgaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nKG1pbWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIHBhc3RlKGl0ZW0sIHBhcmVudCkge1xuICAgIHVucmVhY2hhYmxlKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIGdldCBwcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGdldCBfaXNEcmFnZ2FibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lzRHJhZ2dhYmxlO1xuICB9XG4gIHNldCBfaXNEcmFnZ2FibGUodmFsdWUpIHtcbiAgICB0aGlzLiNpc0RyYWdnYWJsZSA9IHZhbHVlO1xuICAgIHRoaXMuZGl2Py5jbGFzc0xpc3QudG9nZ2xlKFwiZHJhZ2dhYmxlXCIsIHZhbHVlKTtcbiAgfVxuICBnZXQgaXNFbnRlckhhbmRsZWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY2VudGVyKCkge1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50Um90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHRoaXMueCAtPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQgLyAocGFnZVdpZHRoICogMik7XG4gICAgICAgIHRoaXMueSArPSB0aGlzLndpZHRoICogcGFnZVdpZHRoIC8gKHBhZ2VIZWlnaHQgKiAyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgdGhpcy54ICs9IHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnkgKz0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICB0aGlzLnggKz0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0IC8gKHBhZ2VXaWR0aCAqIDIpO1xuICAgICAgICB0aGlzLnkgLT0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aCAvIChwYWdlSGVpZ2h0ICogMik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy54IC09IHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnkgLT0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gIGFkZENvbW1hbmRzKHBhcmFtcykge1xuICAgIHRoaXMuX3VpTWFuYWdlci5hZGRDb21tYW5kcyhwYXJhbXMpO1xuICB9XG4gIGdldCBjdXJyZW50TGF5ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VpTWFuYWdlci5jdXJyZW50TGF5ZXI7XG4gIH1cbiAgc2V0SW5CYWNrZ3JvdW5kKCkge1xuICAgIHRoaXMuZGl2LnN0eWxlLnpJbmRleCA9IDA7XG4gIH1cbiAgc2V0SW5Gb3JlZ3JvdW5kKCkge1xuICAgIHRoaXMuZGl2LnN0eWxlLnpJbmRleCA9IHRoaXMuI3pJbmRleDtcbiAgfVxuICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5wYWdlSW5kZXggPSBwYXJlbnQucGFnZUluZGV4O1xuICAgICAgdGhpcy5wYWdlRGltZW5zaW9ucyA9IHBhcmVudC5wYWdlRGltZW5zaW9ucztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jc3RvcFJlc2l6aW5nKCk7XG4gICAgfVxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB9XG4gIGZvY3VzaW4oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2ZvY3VzRXZlbnRzQWxsb3dlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2hhc0JlZW5DbGlja2VkKSB7XG4gICAgICB0aGlzLnBhcmVudC5zZXRTZWxlY3RlZCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jaGFzQmVlbkNsaWNrZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9jdXNvdXQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2ZvY3VzRXZlbnRzQWxsb3dlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgaWYgKHRhcmdldD8uY2xvc2VzdChgIyR7dGhpcy5pZH1gKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICghdGhpcy5wYXJlbnQ/LmlzTXVsdGlwbGVTZWxlY3Rpb24pIHtcbiAgICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB9XG4gIH1cbiAgY29tbWl0T3JSZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICB0aGlzLnJlbW92ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbW1pdCgpO1xuICAgIH1cbiAgfVxuICBjb21taXQoKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5FZGl0TW9kZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSgpO1xuICB9XG4gIGFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoKSB7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UodGhpcyk7XG4gIH1cbiAgc2V0QXQoeCwgeSwgdHgsIHR5KSB7XG4gICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIFt0eCwgdHldID0gdGhpcy5zY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbih0eCwgdHkpO1xuICAgIHRoaXMueCA9ICh4ICsgdHgpIC8gd2lkdGg7XG4gICAgdGhpcy55ID0gKHkgKyB0eSkgLyBoZWlnaHQ7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gIF9tb3ZlQWZ0ZXJQYXN0ZShiYXNlWCwgYmFzZVkpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy5zZXRBdChiYXNlWCAqIHBhcmVudFdpZHRoLCBiYXNlWSAqIHBhcmVudEhlaWdodCwgdGhpcy53aWR0aCAqIHBhcmVudFdpZHRoLCB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gICAgdGhpcy5fb25UcmFuc2xhdGVkKCk7XG4gIH1cbiAgI3RyYW5zbGF0ZShbd2lkdGgsIGhlaWdodF0sIHgsIHkpIHtcbiAgICBbeCwgeV0gPSB0aGlzLnNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKHgsIHkpO1xuICAgIHRoaXMueCArPSB4IC8gd2lkdGg7XG4gICAgdGhpcy55ICs9IHkgLyBoZWlnaHQ7XG4gICAgdGhpcy5fb25UcmFuc2xhdGluZyh0aGlzLngsIHRoaXMueSk7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gIHRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgdGhpcy4jdHJhbnNsYXRlKHRoaXMucGFyZW50RGltZW5zaW9ucywgeCwgeSk7XG4gIH1cbiAgdHJhbnNsYXRlSW5QYWdlKHgsIHkpIHtcbiAgICB0aGlzLiNpbml0aWFsUmVjdCB8fD0gW3RoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodF07XG4gICAgdGhpcy4jdHJhbnNsYXRlKHRoaXMucGFnZURpbWVuc2lvbnMsIHgsIHkpO1xuICAgIHRoaXMuZGl2LnNjcm9sbEludG9WaWV3KHtcbiAgICAgIGJsb2NrOiBcIm5lYXJlc3RcIlxuICAgIH0pO1xuICB9XG4gIHRyYW5zbGF0aW9uRG9uZSgpIHtcbiAgICB0aGlzLl9vblRyYW5zbGF0ZWQodGhpcy54LCB0aGlzLnkpO1xuICB9XG4gIGRyYWcodHgsIHR5KSB7XG4gICAgdGhpcy4jaW5pdGlhbFJlY3QgfHw9IFt0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdO1xuICAgIGNvbnN0IHtcbiAgICAgIGRpdixcbiAgICAgIHBhcmVudERpbWVuc2lvbnM6IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XVxuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMueCArPSB0eCAvIHBhcmVudFdpZHRoO1xuICAgIHRoaXMueSArPSB0eSAvIHBhcmVudEhlaWdodDtcbiAgICBpZiAodGhpcy5wYXJlbnQgJiYgKHRoaXMueCA8IDAgfHwgdGhpcy54ID4gMSB8fCB0aGlzLnkgPCAwIHx8IHRoaXMueSA+IDEpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmICh0aGlzLnBhcmVudC5maW5kTmV3UGFyZW50KHRoaXMsIHgsIHkpKSB7XG4gICAgICAgIHRoaXMueCAtPSBNYXRoLmZsb29yKHRoaXMueCk7XG4gICAgICAgIHRoaXMueSAtPSBNYXRoLmZsb29yKHRoaXMueSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IFtieCwgYnldID0gdGhpcy5nZXRCYXNlVHJhbnNsYXRpb24oKTtcbiAgICB4ICs9IGJ4O1xuICAgIHkgKz0gYnk7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gZGl2O1xuICAgIHN0eWxlLmxlZnQgPSBgJHsoMTAwICogeCkudG9GaXhlZCgyKX0lYDtcbiAgICBzdHlsZS50b3AgPSBgJHsoMTAwICogeSkudG9GaXhlZCgyKX0lYDtcbiAgICB0aGlzLl9vblRyYW5zbGF0aW5nKHgsIHkpO1xuICAgIGRpdi5zY3JvbGxJbnRvVmlldyh7XG4gICAgICBibG9jazogXCJuZWFyZXN0XCJcbiAgICB9KTtcbiAgfVxuICBfb25UcmFuc2xhdGluZyh4LCB5KSB7fVxuICBfb25UcmFuc2xhdGVkKHgsIHkpIHt9XG4gIGdldCBfaGFzQmVlbk1vdmVkKCkge1xuICAgIHJldHVybiAhIXRoaXMuI2luaXRpYWxSZWN0ICYmICh0aGlzLiNpbml0aWFsUmVjdFswXSAhPT0gdGhpcy54IHx8IHRoaXMuI2luaXRpYWxSZWN0WzFdICE9PSB0aGlzLnkpO1xuICB9XG4gIGdldCBfaGFzQmVlblJlc2l6ZWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy4jaW5pdGlhbFJlY3QgJiYgKHRoaXMuI2luaXRpYWxSZWN0WzJdICE9PSB0aGlzLndpZHRoIHx8IHRoaXMuI2luaXRpYWxSZWN0WzNdICE9PSB0aGlzLmhlaWdodCk7XG4gIH1cbiAgZ2V0QmFzZVRyYW5zbGF0aW9uKCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCB7XG4gICAgICBfYm9yZGVyTGluZVdpZHRoXG4gICAgfSA9IEFubm90YXRpb25FZGl0b3I7XG4gICAgY29uc3QgeCA9IF9ib3JkZXJMaW5lV2lkdGggLyBwYXJlbnRXaWR0aDtcbiAgICBjb25zdCB5ID0gX2JvcmRlckxpbmVXaWR0aCAvIHBhcmVudEhlaWdodDtcbiAgICBzd2l0Y2ggKHRoaXMucm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbLXgsIHldO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFt4LCAteV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWy14LCAteV07XG4gICAgfVxuICB9XG4gIGdldCBfbXVzdEZpeFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZpeEFuZFNldFBvc2l0aW9uKHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpdjoge1xuICAgICAgICBzdHlsZVxuICAgICAgfSxcbiAgICAgIHBhZ2VEaW1lbnNpb25zOiBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXM7XG4gICAgd2lkdGggKj0gcGFnZVdpZHRoO1xuICAgIGhlaWdodCAqPSBwYWdlSGVpZ2h0O1xuICAgIHggKj0gcGFnZVdpZHRoO1xuICAgIHkgKj0gcGFnZUhlaWdodDtcbiAgICBpZiAodGhpcy5fbXVzdEZpeFBvc2l0aW9uKSB7XG4gICAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICB4ID0gTWF0aENsYW1wKHgsIDAsIHBhZ2VXaWR0aCAtIHdpZHRoKTtcbiAgICAgICAgICB5ID0gTWF0aENsYW1wKHksIDAsIHBhZ2VIZWlnaHQgLSBoZWlnaHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDkwOlxuICAgICAgICAgIHggPSBNYXRoQ2xhbXAoeCwgMCwgcGFnZVdpZHRoIC0gaGVpZ2h0KTtcbiAgICAgICAgICB5ID0gTWF0aENsYW1wKHksIHdpZHRoLCBwYWdlSGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxODA6XG4gICAgICAgICAgeCA9IE1hdGhDbGFtcCh4LCB3aWR0aCwgcGFnZVdpZHRoKTtcbiAgICAgICAgICB5ID0gTWF0aENsYW1wKHksIGhlaWdodCwgcGFnZUhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjcwOlxuICAgICAgICAgIHggPSBNYXRoQ2xhbXAoeCwgaGVpZ2h0LCBwYWdlV2lkdGgpO1xuICAgICAgICAgIHkgPSBNYXRoQ2xhbXAoeSwgMCwgcGFnZUhlaWdodCAtIHdpZHRoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy54ID0geCAvPSBwYWdlV2lkdGg7XG4gICAgdGhpcy55ID0geSAvPSBwYWdlSGVpZ2h0O1xuICAgIGNvbnN0IFtieCwgYnldID0gdGhpcy5nZXRCYXNlVHJhbnNsYXRpb24oKTtcbiAgICB4ICs9IGJ4O1xuICAgIHkgKz0gYnk7XG4gICAgc3R5bGUubGVmdCA9IGAkeygxMDAgKiB4KS50b0ZpeGVkKDIpfSVgO1xuICAgIHN0eWxlLnRvcCA9IGAkeygxMDAgKiB5KS50b0ZpeGVkKDIpfSVgO1xuICAgIHRoaXMubW92ZUluRE9NKCk7XG4gIH1cbiAgc3RhdGljICNyb3RhdGVQb2ludCh4LCB5LCBhbmdsZSkge1xuICAgIHN3aXRjaCAoYW5nbGUpIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbeSwgLXhdO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbLXgsIC15XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gWy15LCB4XTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuICB9XG4gIHNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gQW5ub3RhdGlvbkVkaXRvci4jcm90YXRlUG9pbnQoeCwgeSwgdGhpcy5wYXJlbnRSb3RhdGlvbik7XG4gIH1cbiAgcGFnZVRyYW5zbGF0aW9uVG9TY3JlZW4oeCwgeSkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWRpdG9yLiNyb3RhdGVQb2ludCh4LCB5LCAzNjAgLSB0aGlzLnBhcmVudFJvdGF0aW9uKTtcbiAgfVxuICAjZ2V0Um90YXRpb25NYXRyaXgocm90YXRpb24pIHtcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgICAgIHJldHVybiBbMCwgLXBhZ2VXaWR0aCAvIHBhZ2VIZWlnaHQsIHBhZ2VIZWlnaHQgLyBwYWdlV2lkdGgsIDBdO1xuICAgICAgICB9XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFstMSwgMCwgMCwgLTFdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgICAgICAgcmV0dXJuIFswLCBwYWdlV2lkdGggLyBwYWdlSGVpZ2h0LCAtcGFnZUhlaWdodCAvIHBhZ2VXaWR0aCwgMF07XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbMSwgMCwgMCwgMV07XG4gICAgfVxuICB9XG4gIGdldCBwYXJlbnRTY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzLnJlYWxTY2FsZTtcbiAgfVxuICBnZXQgcGFyZW50Um90YXRpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLl91aU1hbmFnZXIudmlld1BhcmFtZXRlcnMucm90YXRpb24gKyB0aGlzLnBhZ2VSb3RhdGlvbikgJSAzNjA7XG4gIH1cbiAgZ2V0IHBhcmVudERpbWVuc2lvbnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFyZW50U2NhbGUsXG4gICAgICBwYWdlRGltZW5zaW9uczogW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF1cbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4gW3BhZ2VXaWR0aCAqIHBhcmVudFNjYWxlLCBwYWdlSGVpZ2h0ICogcGFyZW50U2NhbGVdO1xuICB9XG4gIHNldERpbXMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmRpdjtcbiAgICBzdHlsZS53aWR0aCA9IGAkeygxMDAgKiB3aWR0aCAvIHBhcmVudFdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgIGlmICghdGhpcy4ja2VlcEFzcGVjdFJhdGlvKSB7XG4gICAgICBzdHlsZS5oZWlnaHQgPSBgJHsoMTAwICogaGVpZ2h0IC8gcGFyZW50SGVpZ2h0KS50b0ZpeGVkKDIpfSVgO1xuICAgIH1cbiAgfVxuICBmaXhEaW1zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuZGl2O1xuICAgIGNvbnN0IHtcbiAgICAgIGhlaWdodCxcbiAgICAgIHdpZHRoXG4gICAgfSA9IHN0eWxlO1xuICAgIGNvbnN0IHdpZHRoUGVyY2VudCA9IHdpZHRoLmVuZHNXaXRoKFwiJVwiKTtcbiAgICBjb25zdCBoZWlnaHRQZXJjZW50ID0gIXRoaXMuI2tlZXBBc3BlY3RSYXRpbyAmJiBoZWlnaHQuZW5kc1dpdGgoXCIlXCIpO1xuICAgIGlmICh3aWR0aFBlcmNlbnQgJiYgaGVpZ2h0UGVyY2VudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgaWYgKCF3aWR0aFBlcmNlbnQpIHtcbiAgICAgIHN0eWxlLndpZHRoID0gYCR7KDEwMCAqIHBhcnNlRmxvYXQod2lkdGgpIC8gcGFyZW50V2lkdGgpLnRvRml4ZWQoMil9JWA7XG4gICAgfVxuICAgIGlmICghdGhpcy4ja2VlcEFzcGVjdFJhdGlvICYmICFoZWlnaHRQZXJjZW50KSB7XG4gICAgICBzdHlsZS5oZWlnaHQgPSBgJHsoMTAwICogcGFyc2VGbG9hdChoZWlnaHQpIC8gcGFyZW50SGVpZ2h0KS50b0ZpeGVkKDIpfSVgO1xuICAgIH1cbiAgfVxuICBnZXRJbml0aWFsVHJhbnNsYXRpb24oKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfVxuICAjY3JlYXRlUmVzaXplcnMoKSB7XG4gICAgaWYgKHRoaXMuI3Jlc2l6ZXJzRGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3Jlc2l6ZXJzRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLiNyZXNpemVyc0Rpdi5jbGFzc0xpc3QuYWRkKFwicmVzaXplcnNcIik7XG4gICAgY29uc3QgY2xhc3NlcyA9IHRoaXMuX3dpbGxLZWVwQXNwZWN0UmF0aW8gPyBbXCJ0b3BMZWZ0XCIsIFwidG9wUmlnaHRcIiwgXCJib3R0b21SaWdodFwiLCBcImJvdHRvbUxlZnRcIl0gOiBbXCJ0b3BMZWZ0XCIsIFwidG9wTWlkZGxlXCIsIFwidG9wUmlnaHRcIiwgXCJtaWRkbGVSaWdodFwiLCBcImJvdHRvbVJpZ2h0XCIsIFwiYm90dG9tTWlkZGxlXCIsIFwiYm90dG9tTGVmdFwiLCBcIm1pZGRsZUxlZnRcIl07XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGNsYXNzZXMpIHtcbiAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLiNyZXNpemVyc0Rpdi5hcHBlbmQoZGl2KTtcbiAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwicmVzaXplclwiLCBuYW1lKTtcbiAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLXJlc2l6ZXItbmFtZVwiLCBuYW1lKTtcbiAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jcmVzaXplclBvaW50ZXJkb3duLmJpbmQodGhpcywgbmFtZSksIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgZGl2LnRhYkluZGV4ID0gLTE7XG4gICAgfVxuICAgIHRoaXMuZGl2LnByZXBlbmQodGhpcy4jcmVzaXplcnNEaXYpO1xuICB9XG4gICNyZXNpemVyUG9pbnRlcmRvd24obmFtZSwgZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FsdFRleHQ/LnRvZ2dsZShmYWxzZSk7XG4gICAgY29uc3Qgc2F2ZWREcmFnZ2FibGUgPSB0aGlzLl9pc0RyYWdnYWJsZTtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuI2xhc3RQb2ludGVyQ29vcmRzID0gW2V2ZW50LnNjcmVlblgsIGV2ZW50LnNjcmVlblldO1xuICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbChhYyk7XG4gICAgdGhpcy5wYXJlbnQudG9nZ2xlUG9pbnRlckV2ZW50cyhmYWxzZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLiNyZXNpemVyUG9pbnRlcm1vdmUuYmluZCh0aGlzLCBuYW1lKSwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBzdG9wRXZlbnQsIHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLiNzYXZlZERpbWVuc2lvbnMgPSB7XG4gICAgICBzYXZlZFg6IHRoaXMueCxcbiAgICAgIHNhdmVkWTogdGhpcy55LFxuICAgICAgc2F2ZWRXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgIHNhdmVkSGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gICAgY29uc3Qgc2F2ZWRQYXJlbnRDdXJzb3IgPSB0aGlzLnBhcmVudC5kaXYuc3R5bGUuY3Vyc29yO1xuICAgIGNvbnN0IHNhdmVkQ3Vyc29yID0gdGhpcy5kaXYuc3R5bGUuY3Vyc29yO1xuICAgIHRoaXMuZGl2LnN0eWxlLmN1cnNvciA9IHRoaXMucGFyZW50LmRpdi5zdHlsZS5jdXJzb3IgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShldmVudC50YXJnZXQpLmN1cnNvcjtcbiAgICBjb25zdCBwb2ludGVyVXBDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIGFjLmFib3J0KCk7XG4gICAgICB0aGlzLnBhcmVudC50b2dnbGVQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgICAgdGhpcy4jYWx0VGV4dD8udG9nZ2xlKHRydWUpO1xuICAgICAgdGhpcy5faXNEcmFnZ2FibGUgPSBzYXZlZERyYWdnYWJsZTtcbiAgICAgIHRoaXMucGFyZW50LmRpdi5zdHlsZS5jdXJzb3IgPSBzYXZlZFBhcmVudEN1cnNvcjtcbiAgICAgIHRoaXMuZGl2LnN0eWxlLmN1cnNvciA9IHNhdmVkQ3Vyc29yO1xuICAgICAgdGhpcy4jYWRkUmVzaXplVG9VbmRvU3RhY2soKTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJVcENhbGxiYWNrLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gICNyZXNpemUoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMuc2V0RGltcyhwYXJlbnRXaWR0aCAqIHdpZHRoLCBwYXJlbnRIZWlnaHQgKiBoZWlnaHQpO1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB0aGlzLl9vblJlc2l6ZWQoKTtcbiAgfVxuICBfb25SZXNpemVkKCkge31cbiAgI2FkZFJlc2l6ZVRvVW5kb1N0YWNrKCkge1xuICAgIGlmICghdGhpcy4jc2F2ZWREaW1lbnNpb25zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHNhdmVkWCxcbiAgICAgIHNhdmVkWSxcbiAgICAgIHNhdmVkV2lkdGgsXG4gICAgICBzYXZlZEhlaWdodFxuICAgIH0gPSB0aGlzLiNzYXZlZERpbWVuc2lvbnM7XG4gICAgdGhpcy4jc2F2ZWREaW1lbnNpb25zID0gbnVsbDtcbiAgICBjb25zdCBuZXdYID0gdGhpcy54O1xuICAgIGNvbnN0IG5ld1kgPSB0aGlzLnk7XG4gICAgY29uc3QgbmV3V2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIGlmIChuZXdYID09PSBzYXZlZFggJiYgbmV3WSA9PT0gc2F2ZWRZICYmIG5ld1dpZHRoID09PSBzYXZlZFdpZHRoICYmIG5ld0hlaWdodCA9PT0gc2F2ZWRIZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6IHRoaXMuI3Jlc2l6ZS5iaW5kKHRoaXMsIG5ld1gsIG5ld1ksIG5ld1dpZHRoLCBuZXdIZWlnaHQpLFxuICAgICAgdW5kbzogdGhpcy4jcmVzaXplLmJpbmQodGhpcywgc2F2ZWRYLCBzYXZlZFksIHNhdmVkV2lkdGgsIHNhdmVkSGVpZ2h0KSxcbiAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIF9yb3VuZCh4KSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoeCAqIDEwMDAwKSAvIDEwMDAwO1xuICB9XG4gICNyZXNpemVyUG9pbnRlcm1vdmUobmFtZSwgZXZlbnQpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgY29uc3Qgc2F2ZWRYID0gdGhpcy54O1xuICAgIGNvbnN0IHNhdmVkWSA9IHRoaXMueTtcbiAgICBjb25zdCBzYXZlZFdpZHRoID0gdGhpcy53aWR0aDtcbiAgICBjb25zdCBzYXZlZEhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIGNvbnN0IG1pbldpZHRoID0gQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSAvIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IG1pbkhlaWdodCA9IEFubm90YXRpb25FZGl0b3IuTUlOX1NJWkUgLyBwYXJlbnRIZWlnaHQ7XG4gICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSB0aGlzLiNnZXRSb3RhdGlvbk1hdHJpeCh0aGlzLnJvdGF0aW9uKTtcbiAgICBjb25zdCB0cmFuc2YgPSAoeCwgeSkgPT4gW3JvdGF0aW9uTWF0cml4WzBdICogeCArIHJvdGF0aW9uTWF0cml4WzJdICogeSwgcm90YXRpb25NYXRyaXhbMV0gKiB4ICsgcm90YXRpb25NYXRyaXhbM10gKiB5XTtcbiAgICBjb25zdCBpbnZSb3RhdGlvbk1hdHJpeCA9IHRoaXMuI2dldFJvdGF0aW9uTWF0cml4KDM2MCAtIHRoaXMucm90YXRpb24pO1xuICAgIGNvbnN0IGludlRyYW5zZiA9ICh4LCB5KSA9PiBbaW52Um90YXRpb25NYXRyaXhbMF0gKiB4ICsgaW52Um90YXRpb25NYXRyaXhbMl0gKiB5LCBpbnZSb3RhdGlvbk1hdHJpeFsxXSAqIHggKyBpbnZSb3RhdGlvbk1hdHJpeFszXSAqIHldO1xuICAgIGxldCBnZXRQb2ludDtcbiAgICBsZXQgZ2V0T3Bwb3NpdGU7XG4gICAgbGV0IGlzRGlhZ29uYWwgPSBmYWxzZTtcbiAgICBsZXQgaXNIb3Jpem9udGFsID0gZmFsc2U7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwidG9wTGVmdFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gWzAsIDBdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdywgaF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRvcE1pZGRsZVwiOlxuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdyAvIDIsIDBdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdyAvIDIsIGhdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0b3BSaWdodFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3csIDBdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbMCwgaF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1pZGRsZVJpZ2h0XCI6XG4gICAgICAgIGlzSG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3LCBoIC8gMl07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFswLCBoIC8gMl07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJvdHRvbVJpZ2h0XCI6XG4gICAgICAgIGlzRGlhZ29uYWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdywgaF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFswLCAwXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYm90dG9tTWlkZGxlXCI6XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3IC8gMiwgaF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3IC8gMiwgMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJvdHRvbUxlZnRcIjpcbiAgICAgICAgaXNEaWFnb25hbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFswLCBoXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3csIDBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtaWRkbGVMZWZ0XCI6XG4gICAgICAgIGlzSG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFswLCBoIC8gMl07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3LCBoIC8gMl07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBwb2ludCA9IGdldFBvaW50KHNhdmVkV2lkdGgsIHNhdmVkSGVpZ2h0KTtcbiAgICBjb25zdCBvcHBvc2l0ZVBvaW50ID0gZ2V0T3Bwb3NpdGUoc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpO1xuICAgIGxldCB0cmFuc2ZPcHBvc2l0ZVBvaW50ID0gdHJhbnNmKC4uLm9wcG9zaXRlUG9pbnQpO1xuICAgIGNvbnN0IG9wcG9zaXRlWCA9IEFubm90YXRpb25FZGl0b3IuX3JvdW5kKHNhdmVkWCArIHRyYW5zZk9wcG9zaXRlUG9pbnRbMF0pO1xuICAgIGNvbnN0IG9wcG9zaXRlWSA9IEFubm90YXRpb25FZGl0b3IuX3JvdW5kKHNhdmVkWSArIHRyYW5zZk9wcG9zaXRlUG9pbnRbMV0pO1xuICAgIGxldCByYXRpb1ggPSAxO1xuICAgIGxldCByYXRpb1kgPSAxO1xuICAgIGxldCBkZWx0YVgsIGRlbHRhWTtcbiAgICBpZiAoIWV2ZW50LmZyb21LZXlib2FyZCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzY3JlZW5YLFxuICAgICAgICBzY3JlZW5ZXG4gICAgICB9ID0gZXZlbnQ7XG4gICAgICBjb25zdCBbbGFzdFNjcmVlblgsIGxhc3RTY3JlZW5ZXSA9IHRoaXMuI2xhc3RQb2ludGVyQ29vcmRzO1xuICAgICAgW2RlbHRhWCwgZGVsdGFZXSA9IHRoaXMuc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24oc2NyZWVuWCAtIGxhc3RTY3JlZW5YLCBzY3JlZW5ZIC0gbGFzdFNjcmVlblkpO1xuICAgICAgdGhpcy4jbGFzdFBvaW50ZXJDb29yZHNbMF0gPSBzY3JlZW5YO1xuICAgICAgdGhpcy4jbGFzdFBvaW50ZXJDb29yZHNbMV0gPSBzY3JlZW5ZO1xuICAgIH0gZWxzZSB7XG4gICAgICAoe1xuICAgICAgICBkZWx0YVgsXG4gICAgICAgIGRlbHRhWVxuICAgICAgfSA9IGV2ZW50KTtcbiAgICB9XG4gICAgW2RlbHRhWCwgZGVsdGFZXSA9IGludlRyYW5zZihkZWx0YVggLyBwYXJlbnRXaWR0aCwgZGVsdGFZIC8gcGFyZW50SGVpZ2h0KTtcbiAgICBpZiAoaXNEaWFnb25hbCkge1xuICAgICAgY29uc3Qgb2xkRGlhZyA9IE1hdGguaHlwb3Qoc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpO1xuICAgICAgcmF0aW9YID0gcmF0aW9ZID0gTWF0aC5tYXgoTWF0aC5taW4oTWF0aC5oeXBvdChvcHBvc2l0ZVBvaW50WzBdIC0gcG9pbnRbMF0gLSBkZWx0YVgsIG9wcG9zaXRlUG9pbnRbMV0gLSBwb2ludFsxXSAtIGRlbHRhWSkgLyBvbGREaWFnLCAxIC8gc2F2ZWRXaWR0aCwgMSAvIHNhdmVkSGVpZ2h0KSwgbWluV2lkdGggLyBzYXZlZFdpZHRoLCBtaW5IZWlnaHQgLyBzYXZlZEhlaWdodCk7XG4gICAgfSBlbHNlIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIHJhdGlvWCA9IE1hdGhDbGFtcChNYXRoLmFicyhvcHBvc2l0ZVBvaW50WzBdIC0gcG9pbnRbMF0gLSBkZWx0YVgpLCBtaW5XaWR0aCwgMSkgLyBzYXZlZFdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICByYXRpb1kgPSBNYXRoQ2xhbXAoTWF0aC5hYnMob3Bwb3NpdGVQb2ludFsxXSAtIHBvaW50WzFdIC0gZGVsdGFZKSwgbWluSGVpZ2h0LCAxKSAvIHNhdmVkSGVpZ2h0O1xuICAgIH1cbiAgICBjb25zdCBuZXdXaWR0aCA9IEFubm90YXRpb25FZGl0b3IuX3JvdW5kKHNhdmVkV2lkdGggKiByYXRpb1gpO1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IEFubm90YXRpb25FZGl0b3IuX3JvdW5kKHNhdmVkSGVpZ2h0ICogcmF0aW9ZKTtcbiAgICB0cmFuc2ZPcHBvc2l0ZVBvaW50ID0gdHJhbnNmKC4uLmdldE9wcG9zaXRlKG5ld1dpZHRoLCBuZXdIZWlnaHQpKTtcbiAgICBjb25zdCBuZXdYID0gb3Bwb3NpdGVYIC0gdHJhbnNmT3Bwb3NpdGVQb2ludFswXTtcbiAgICBjb25zdCBuZXdZID0gb3Bwb3NpdGVZIC0gdHJhbnNmT3Bwb3NpdGVQb2ludFsxXTtcbiAgICB0aGlzLiNpbml0aWFsUmVjdCB8fD0gW3RoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodF07XG4gICAgdGhpcy53aWR0aCA9IG5ld1dpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgIHRoaXMueCA9IG5ld1g7XG4gICAgdGhpcy55ID0gbmV3WTtcbiAgICB0aGlzLnNldERpbXMocGFyZW50V2lkdGggKiBuZXdXaWR0aCwgcGFyZW50SGVpZ2h0ICogbmV3SGVpZ2h0KTtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgdGhpcy5fb25SZXNpemluZygpO1xuICB9XG4gIF9vblJlc2l6aW5nKCkge31cbiAgYWx0VGV4dEZpbmlzaCgpIHtcbiAgICB0aGlzLiNhbHRUZXh0Py5maW5pc2goKTtcbiAgfVxuICBnZXQgdG9vbGJhckJ1dHRvbnMoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgYXN5bmMgYWRkRWRpdFRvb2xiYXIoKSB7XG4gICAgaWYgKHRoaXMuX2VkaXRUb29sYmFyIHx8IHRoaXMuI2lzSW5FZGl0TW9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VkaXRUb29sYmFyO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0VG9vbGJhciA9IG5ldyBFZGl0b3JUb29sYmFyKHRoaXMpO1xuICAgIHRoaXMuZGl2LmFwcGVuZCh0aGlzLl9lZGl0VG9vbGJhci5yZW5kZXIoKSk7XG4gICAgY29uc3Qge1xuICAgICAgdG9vbGJhckJ1dHRvbnNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAodG9vbGJhckJ1dHRvbnMpIHtcbiAgICAgIGZvciAoY29uc3QgW25hbWUsIHRvb2xdIG9mIHRvb2xiYXJCdXR0b25zKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VkaXRUb29sYmFyLmFkZEJ1dHRvbihuYW1lLCB0b29sKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZWRpdFRvb2xiYXIuYWRkQnV0dG9uKFwiY29tbWVudFwiLCB0aGlzLmFkZENvbW1lbnRCdXR0b24oKSk7XG4gICAgdGhpcy5fZWRpdFRvb2xiYXIuYWRkQnV0dG9uKFwiZGVsZXRlXCIpO1xuICAgIHJldHVybiB0aGlzLl9lZGl0VG9vbGJhcjtcbiAgfVxuICByZW1vdmVFZGl0VG9vbGJhcigpIHtcbiAgICBpZiAoIXRoaXMuX2VkaXRUb29sYmFyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2VkaXRUb29sYmFyLnJlbW92ZSgpO1xuICAgIHRoaXMuX2VkaXRUb29sYmFyID0gbnVsbDtcbiAgICB0aGlzLiNhbHRUZXh0Py5kZXN0cm95KCk7XG4gIH1cbiAgYWRkQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgIGNvbnN0IGVkaXRUb29sYmFyRGl2ID0gdGhpcy5fZWRpdFRvb2xiYXI/LmRpdjtcbiAgICBpZiAoZWRpdFRvb2xiYXJEaXYpIHtcbiAgICAgIGVkaXRUb29sYmFyRGl2LmJlZm9yZShjb250YWluZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpdi5hcHBlbmQoY29udGFpbmVyKTtcbiAgICB9XG4gIH1cbiAgZ2V0Q2xpZW50RGltZW5zaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cbiAgY3JlYXRlQWx0VGV4dCgpIHtcbiAgICBpZiAoIXRoaXMuI2FsdFRleHQpIHtcbiAgICAgIEFsdFRleHQuaW5pdGlhbGl6ZShBbm5vdGF0aW9uRWRpdG9yLl9sMTBuKTtcbiAgICAgIHRoaXMuI2FsdFRleHQgPSBuZXcgQWx0VGV4dCh0aGlzKTtcbiAgICAgIGlmICh0aGlzLiNhY2Nlc3NpYmlsaXR5RGF0YSkge1xuICAgICAgICB0aGlzLiNhbHRUZXh0LmRhdGEgPSB0aGlzLiNhY2Nlc3NpYmlsaXR5RGF0YTtcbiAgICAgICAgdGhpcy4jYWNjZXNzaWJpbGl0eURhdGEgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jYWx0VGV4dDtcbiAgfVxuICBnZXQgYWx0VGV4dERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsdFRleHQ/LmRhdGE7XG4gIH1cbiAgc2V0IGFsdFRleHREYXRhKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuI2FsdFRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWx0VGV4dC5kYXRhID0gZGF0YTtcbiAgfVxuICBnZXQgZ3Vlc3NlZEFsdFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsdFRleHQ/Lmd1ZXNzZWRUZXh0O1xuICB9XG4gIGFzeW5jIHNldEd1ZXNzZWRBbHRUZXh0KHRleHQpIHtcbiAgICBhd2FpdCB0aGlzLiNhbHRUZXh0Py5zZXRHdWVzc2VkVGV4dCh0ZXh0KTtcbiAgfVxuICBzZXJpYWxpemVBbHRUZXh0KGlzRm9yQ29weWluZykge1xuICAgIHJldHVybiB0aGlzLiNhbHRUZXh0Py5zZXJpYWxpemUoaXNGb3JDb3B5aW5nKTtcbiAgfVxuICBoYXNBbHRUZXh0KCkge1xuICAgIHJldHVybiAhIXRoaXMuI2FsdFRleHQgJiYgIXRoaXMuI2FsdFRleHQuaXNFbXB0eSgpO1xuICB9XG4gIGhhc0FsdFRleHREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLiNhbHRUZXh0Py5oYXNEYXRhKCkgPz8gZmFsc2U7XG4gIH1cbiAgYWRkQ29tbWVudEJ1dHRvbigpIHtcbiAgICBpZiAodGhpcy4jY29tbWVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuI2NvbW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNjb21tZW50ID0gbmV3IENvbW1lbnQodGhpcyk7XG4gIH1cbiAgZ2V0IGNvbW1lbnRDb2xvcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgY29tbWVudCgpIHtcbiAgICBjb25zdCBjb21tZW50ID0gdGhpcy4jY29tbWVudDtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogY29tbWVudC5kYXRhLnRleHQsXG4gICAgICBkYXRlOiBjb21tZW50LmRhdGEuZGF0ZSxcbiAgICAgIGRlbGV0ZWQ6IGNvbW1lbnQuaXNEZWxldGVkKCksXG4gICAgICBjb2xvcjogdGhpcy5jb21tZW50Q29sb3JcbiAgICB9O1xuICB9XG4gIHNldCBjb21tZW50KHRleHQpIHtcbiAgICBpZiAoIXRoaXMuI2NvbW1lbnQpIHtcbiAgICAgIHRoaXMuI2NvbW1lbnQgPSBuZXcgQ29tbWVudCh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy4jY29tbWVudC5kYXRhID0gdGV4dDtcbiAgfVxuICBzZXRDb21tZW50RGF0YSh0ZXh0KSB7XG4gICAgaWYgKCF0aGlzLiNjb21tZW50KSB7XG4gICAgICB0aGlzLiNjb21tZW50ID0gbmV3IENvbW1lbnQodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuI2NvbW1lbnQuc2V0SW5pdGlhbFRleHQodGV4dCk7XG4gIH1cbiAgZ2V0IGhhc0VkaXRlZENvbW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbW1lbnQ/Lmhhc0JlZW5FZGl0ZWQoKTtcbiAgfVxuICBhc3luYyBlZGl0Q29tbWVudCgpIHtcbiAgICBpZiAoIXRoaXMuI2NvbW1lbnQpIHtcbiAgICAgIHRoaXMuI2NvbW1lbnQgPSBuZXcgQ29tbWVudCh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy4jY29tbWVudC5lZGl0KCk7XG4gIH1cbiAgYWRkQ29tbWVudChzZXJpYWxpemVkKSB7XG4gICAgaWYgKHRoaXMuaGFzRWRpdGVkQ29tbWVudCkge1xuICAgICAgY29uc3QgREVGQVVMVF9QT1BVUF9XSURUSCA9IDE4MDtcbiAgICAgIGNvbnN0IERFRkFVTFRfUE9QVVBfSEVJR0hUID0gMTAwO1xuICAgICAgY29uc3QgWywsLCB0clldID0gc2VyaWFsaXplZC5yZWN0O1xuICAgICAgY29uc3QgW3BhZ2VXaWR0aF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgY29uc3QgW3BhZ2VYXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgICAgY29uc3QgYmxYID0gcGFnZVggKyBwYWdlV2lkdGggKyAxO1xuICAgICAgY29uc3QgYmxZID0gdHJZIC0gREVGQVVMVF9QT1BVUF9IRUlHSFQ7XG4gICAgICBjb25zdCB0clggPSBibFggKyBERUZBVUxUX1BPUFVQX1dJRFRIO1xuICAgICAgc2VyaWFsaXplZC5wb3B1cCA9IHtcbiAgICAgICAgY29udGVudHM6IHRoaXMuY29tbWVudC50ZXh0LFxuICAgICAgICBkZWxldGVkOiB0aGlzLmNvbW1lbnQuZGVsZXRlZCxcbiAgICAgICAgcmVjdDogW2JsWCwgYmxZLCB0clgsIHRyWV1cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBkaXYgPSB0aGlzLmRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtZWRpdG9yLXJvdGF0aW9uXCIsICgzNjAgLSB0aGlzLnJvdGF0aW9uKSAlIDM2MCk7XG4gICAgZGl2LmNsYXNzTmFtZSA9IHRoaXMubmFtZTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiaWRcIiwgdGhpcy5pZCk7XG4gICAgZGl2LnRhYkluZGV4ID0gdGhpcy4jZGlzYWJsZWQgPyAtMSA6IDA7XG4gICAgZGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJhcHBsaWNhdGlvblwiKTtcbiAgICBpZiAodGhpcy5kZWZhdWx0TDEwbklkKSB7XG4gICAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIHRoaXMuZGVmYXVsdEwxMG5JZCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKSB7XG4gICAgICBkaXYuY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcbiAgICB9XG4gICAgdGhpcy5zZXRJbkZvcmVncm91bmQoKTtcbiAgICB0aGlzLiNhZGRGb2N1c0xpc3RlbmVycygpO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBpZiAodGhpcy5wYXJlbnRSb3RhdGlvbiAlIDE4MCAhPT0gMCkge1xuICAgICAgZGl2LnN0eWxlLm1heFdpZHRoID0gYCR7KDEwMCAqIHBhcmVudEhlaWdodCAvIHBhcmVudFdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgICAgZGl2LnN0eWxlLm1heEhlaWdodCA9IGAkeygxMDAgKiBwYXJlbnRXaWR0aCAvIHBhcmVudEhlaWdodCkudG9GaXhlZCgyKX0lYDtcbiAgICB9XG4gICAgY29uc3QgW3R4LCB0eV0gPSB0aGlzLmdldEluaXRpYWxUcmFuc2xhdGlvbigpO1xuICAgIHRoaXMudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgYmluZEV2ZW50cyh0aGlzLCBkaXYsIFtcImtleWRvd25cIiwgXCJwb2ludGVyZG93blwiLCBcImRibGNsaWNrXCJdKTtcbiAgICBpZiAodGhpcy5pc1Jlc2l6YWJsZSAmJiB0aGlzLl91aU1hbmFnZXIuX3N1cHBvcnRzUGluY2hUb1pvb20pIHtcbiAgICAgIHRoaXMuI3RvdWNoTWFuYWdlciB8fD0gbmV3IFRvdWNoTWFuYWdlcih7XG4gICAgICAgIGNvbnRhaW5lcjogZGl2LFxuICAgICAgICBpc1BpbmNoaW5nRGlzYWJsZWQ6ICgpID0+ICF0aGlzLmlzU2VsZWN0ZWQsXG4gICAgICAgIG9uUGluY2hTdGFydDogdGhpcy4jdG91Y2hQaW5jaFN0YXJ0Q2FsbGJhY2suYmluZCh0aGlzKSxcbiAgICAgICAgb25QaW5jaGluZzogdGhpcy4jdG91Y2hQaW5jaENhbGxiYWNrLmJpbmQodGhpcyksXG4gICAgICAgIG9uUGluY2hFbmQ6IHRoaXMuI3RvdWNoUGluY2hFbmRDYWxsYmFjay5iaW5kKHRoaXMpLFxuICAgICAgICBzaWduYWw6IHRoaXMuX3VpTWFuYWdlci5fc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fdWlNYW5hZ2VyLl9lZGl0b3JVbmRvQmFyPy5oaWRlKCk7XG4gICAgcmV0dXJuIGRpdjtcbiAgfVxuICAjdG91Y2hQaW5jaFN0YXJ0Q2FsbGJhY2soKSB7XG4gICAgdGhpcy4jc2F2ZWREaW1lbnNpb25zID0ge1xuICAgICAgc2F2ZWRYOiB0aGlzLngsXG4gICAgICBzYXZlZFk6IHRoaXMueSxcbiAgICAgIHNhdmVkV2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBzYXZlZEhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9O1xuICAgIHRoaXMuI2FsdFRleHQ/LnRvZ2dsZShmYWxzZSk7XG4gICAgdGhpcy5wYXJlbnQudG9nZ2xlUG9pbnRlckV2ZW50cyhmYWxzZSk7XG4gIH1cbiAgI3RvdWNoUGluY2hDYWxsYmFjayhfb3JpZ2luLCBwcmV2RGlzdGFuY2UsIGRpc3RhbmNlKSB7XG4gICAgY29uc3Qgc2xvd0Rvd25GYWN0b3IgPSAwLjc7XG4gICAgbGV0IGZhY3RvciA9IHNsb3dEb3duRmFjdG9yICogKGRpc3RhbmNlIC8gcHJldkRpc3RhbmNlKSArIDEgLSBzbG93RG93bkZhY3RvcjtcbiAgICBpZiAoZmFjdG9yID09PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJvdGF0aW9uTWF0cml4ID0gdGhpcy4jZ2V0Um90YXRpb25NYXRyaXgodGhpcy5yb3RhdGlvbik7XG4gICAgY29uc3QgdHJhbnNmID0gKHgsIHkpID0+IFtyb3RhdGlvbk1hdHJpeFswXSAqIHggKyByb3RhdGlvbk1hdHJpeFsyXSAqIHksIHJvdGF0aW9uTWF0cml4WzFdICogeCArIHJvdGF0aW9uTWF0cml4WzNdICogeV07XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IHNhdmVkWCA9IHRoaXMueDtcbiAgICBjb25zdCBzYXZlZFkgPSB0aGlzLnk7XG4gICAgY29uc3Qgc2F2ZWRXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgY29uc3Qgc2F2ZWRIZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICBjb25zdCBtaW5XaWR0aCA9IEFubm90YXRpb25FZGl0b3IuTUlOX1NJWkUgLyBwYXJlbnRXaWR0aDtcbiAgICBjb25zdCBtaW5IZWlnaHQgPSBBbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFIC8gcGFyZW50SGVpZ2h0O1xuICAgIGZhY3RvciA9IE1hdGgubWF4KE1hdGgubWluKGZhY3RvciwgMSAvIHNhdmVkV2lkdGgsIDEgLyBzYXZlZEhlaWdodCksIG1pbldpZHRoIC8gc2F2ZWRXaWR0aCwgbWluSGVpZ2h0IC8gc2F2ZWRIZWlnaHQpO1xuICAgIGNvbnN0IG5ld1dpZHRoID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRXaWR0aCAqIGZhY3Rvcik7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRIZWlnaHQgKiBmYWN0b3IpO1xuICAgIGlmIChuZXdXaWR0aCA9PT0gc2F2ZWRXaWR0aCAmJiBuZXdIZWlnaHQgPT09IHNhdmVkSGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2luaXRpYWxSZWN0IHx8PSBbc2F2ZWRYLCBzYXZlZFksIHNhdmVkV2lkdGgsIHNhdmVkSGVpZ2h0XTtcbiAgICBjb25zdCB0cmFuc2ZDZW50ZXJQb2ludCA9IHRyYW5zZihzYXZlZFdpZHRoIC8gMiwgc2F2ZWRIZWlnaHQgLyAyKTtcbiAgICBjb25zdCBjZW50ZXJYID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRYICsgdHJhbnNmQ2VudGVyUG9pbnRbMF0pO1xuICAgIGNvbnN0IGNlbnRlclkgPSBBbm5vdGF0aW9uRWRpdG9yLl9yb3VuZChzYXZlZFkgKyB0cmFuc2ZDZW50ZXJQb2ludFsxXSk7XG4gICAgY29uc3QgbmV3VHJhbnNmQ2VudGVyUG9pbnQgPSB0cmFuc2YobmV3V2lkdGggLyAyLCBuZXdIZWlnaHQgLyAyKTtcbiAgICB0aGlzLnggPSBjZW50ZXJYIC0gbmV3VHJhbnNmQ2VudGVyUG9pbnRbMF07XG4gICAgdGhpcy55ID0gY2VudGVyWSAtIG5ld1RyYW5zZkNlbnRlclBvaW50WzFdO1xuICAgIHRoaXMud2lkdGggPSBuZXdXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICB0aGlzLnNldERpbXMocGFyZW50V2lkdGggKiBuZXdXaWR0aCwgcGFyZW50SGVpZ2h0ICogbmV3SGVpZ2h0KTtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgdGhpcy5fb25SZXNpemluZygpO1xuICB9XG4gICN0b3VjaFBpbmNoRW5kQ2FsbGJhY2soKSB7XG4gICAgdGhpcy4jYWx0VGV4dD8udG9nZ2xlKHRydWUpO1xuICAgIHRoaXMucGFyZW50LnRvZ2dsZVBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgdGhpcy4jYWRkUmVzaXplVG9VbmRvU3RhY2soKTtcbiAgfVxuICBwb2ludGVyZG93bihldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNoYXNCZWVuQ2xpY2tlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuX2lzRHJhZ2dhYmxlKSB7XG4gICAgICB0aGlzLiNzZXRVcERyYWdTZXNzaW9uKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0T25Qb2ludGVyRXZlbnQoZXZlbnQpO1xuICB9XG4gICNzZWxlY3RPblBvaW50ZXJFdmVudChldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkgJiYgIWlzTWFjIHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50Lm1ldGFLZXkgJiYgaXNNYWMpIHtcbiAgICAgIHRoaXMucGFyZW50LnRvZ2dsZVNlbGVjdGVkKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhcmVudC5zZXRTZWxlY3RlZCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgI3NldFVwRHJhZ1Nlc3Npb24oZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc1NlbGVjdGVkXG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLnNldFVwRHJhZ1Nlc3Npb24oKTtcbiAgICBsZXQgaGFzRHJhZ2dpbmdTdGFydGVkID0gZmFsc2U7XG4gICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKGFjKTtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgc2lnbmFsXG4gICAgfTtcbiAgICBjb25zdCBjYW5jZWxEcmFnID0gZSA9PiB7XG4gICAgICBhYy5hYm9ydCgpO1xuICAgICAgdGhpcy4jZHJhZ1BvaW50ZXJJZCA9IG51bGw7XG4gICAgICB0aGlzLiNoYXNCZWVuQ2xpY2tlZCA9IGZhbHNlO1xuICAgICAgaWYgKCF0aGlzLl91aU1hbmFnZXIuZW5kRHJhZ1Nlc3Npb24oKSkge1xuICAgICAgICB0aGlzLiNzZWxlY3RPblBvaW50ZXJFdmVudChlKTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNEcmFnZ2luZ1N0YXJ0ZWQpIHtcbiAgICAgICAgdGhpcy5fb25TdG9wRHJhZ2dpbmcoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICB0aGlzLiNwcmV2RHJhZ1ggPSBldmVudC5jbGllbnRYO1xuICAgICAgdGhpcy4jcHJldkRyYWdZID0gZXZlbnQuY2xpZW50WTtcbiAgICAgIHRoaXMuI2RyYWdQb2ludGVySWQgPSBldmVudC5wb2ludGVySWQ7XG4gICAgICB0aGlzLiNkcmFnUG9pbnRlclR5cGUgPSBldmVudC5wb2ludGVyVHlwZTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgZSA9PiB7XG4gICAgICAgIGlmICghaGFzRHJhZ2dpbmdTdGFydGVkKSB7XG4gICAgICAgICAgaGFzRHJhZ2dpbmdTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLl9vblN0YXJ0RHJhZ2dpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY2xpZW50WDogeCxcbiAgICAgICAgICBjbGllbnRZOiB5LFxuICAgICAgICAgIHBvaW50ZXJJZFxuICAgICAgICB9ID0gZTtcbiAgICAgICAgaWYgKHBvaW50ZXJJZCAhPT0gdGhpcy4jZHJhZ1BvaW50ZXJJZCkge1xuICAgICAgICAgIHN0b3BFdmVudChlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3R4LCB0eV0gPSB0aGlzLnNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKHggLSB0aGlzLiNwcmV2RHJhZ1gsIHkgLSB0aGlzLiNwcmV2RHJhZ1kpO1xuICAgICAgICB0aGlzLiNwcmV2RHJhZ1ggPSB4O1xuICAgICAgICB0aGlzLiNwcmV2RHJhZ1kgPSB5O1xuICAgICAgICB0aGlzLl91aU1hbmFnZXIuZHJhZ1NlbGVjdGVkRWRpdG9ycyh0eCwgdHkpO1xuICAgICAgfSwgb3B0cyk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBzdG9wRXZlbnQsIG9wdHMpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBlID0+IHtcbiAgICAgICAgaWYgKGUucG9pbnRlclR5cGUgPT09IHRoaXMuI2RyYWdQb2ludGVyVHlwZSkge1xuICAgICAgICAgIGlmICh0aGlzLiN0b3VjaE1hbmFnZXIgfHwgZS5pc1ByaW1hcnkpIHtcbiAgICAgICAgICAgIGNhbmNlbERyYWcoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0b3BFdmVudChlKTtcbiAgICAgIH0sIG9wdHMpO1xuICAgIH1cbiAgICBjb25zdCBwb2ludGVyVXBDYWxsYmFjayA9IGUgPT4ge1xuICAgICAgaWYgKCF0aGlzLiNkcmFnUG9pbnRlcklkIHx8IHRoaXMuI2RyYWdQb2ludGVySWQgPT09IGUucG9pbnRlcklkKSB7XG4gICAgICAgIGNhbmNlbERyYWcoZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0b3BFdmVudChlKTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJVcENhbGxiYWNrLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gIF9vblN0YXJ0RHJhZ2dpbmcoKSB7fVxuICBfb25TdG9wRHJhZ2dpbmcoKSB7fVxuICBtb3ZlSW5ET00oKSB7XG4gICAgaWYgKHRoaXMuI21vdmVJbkRPTVRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNtb3ZlSW5ET01UaW1lb3V0KTtcbiAgICB9XG4gICAgdGhpcy4jbW92ZUluRE9NVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy4jbW92ZUluRE9NVGltZW91dCA9IG51bGw7XG4gICAgICB0aGlzLnBhcmVudD8ubW92ZUVkaXRvckluRE9NKHRoaXMpO1xuICAgIH0sIDApO1xuICB9XG4gIF9zZXRQYXJlbnRBbmRQb3NpdGlvbihwYXJlbnQsIHgsIHkpIHtcbiAgICBwYXJlbnQuY2hhbmdlUGFyZW50KHRoaXMpO1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgdGhpcy5fb25UcmFuc2xhdGVkKCk7XG4gIH1cbiAgZ2V0UmVjdCh0eCwgdHksIHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbikge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5wYXJlbnRTY2FsZTtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgW3BhZ2VYLCBwYWdlWV0gPSB0aGlzLnBhZ2VUcmFuc2xhdGlvbjtcbiAgICBjb25zdCBzaGlmdFggPSB0eCAvIHNjYWxlO1xuICAgIGNvbnN0IHNoaWZ0WSA9IHR5IC8gc2NhbGU7XG4gICAgY29uc3QgeCA9IHRoaXMueCAqIHBhZ2VXaWR0aDtcbiAgICBjb25zdCB5ID0gdGhpcy55ICogcGFnZUhlaWdodDtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMud2lkdGggKiBwYWdlV2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0O1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIFt4ICsgc2hpZnRYICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5IC0gc2hpZnRZIC0gaGVpZ2h0ICsgcGFnZVksIHggKyBzaGlmdFggKyB3aWR0aCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WSArIHBhZ2VZXTtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbeCArIHNoaWZ0WSArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSArIHNoaWZ0WCArIHBhZ2VZLCB4ICsgc2hpZnRZICsgaGVpZ2h0ICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRYICsgd2lkdGggKyBwYWdlWV07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFt4IC0gc2hpZnRYIC0gd2lkdGggKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgKyBzaGlmdFkgKyBwYWdlWSwgeCAtIHNoaWZ0WCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSArIHNoaWZ0WSArIGhlaWdodCArIHBhZ2VZXTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3ggLSBzaGlmdFkgLSBoZWlnaHQgKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgLSBzaGlmdFggLSB3aWR0aCArIHBhZ2VZLCB4IC0gc2hpZnRZICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5IC0gc2hpZnRYICsgcGFnZVldO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb3RhdGlvblwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0UmVjdEluQ3VycmVudENvb3JkcyhyZWN0LCBwYWdlSGVpZ2h0KSB7XG4gICAgY29uc3QgW3gxLCB5MSwgeDIsIHkyXSA9IHJlY3Q7XG4gICAgY29uc3Qgd2lkdGggPSB4MiAtIHgxO1xuICAgIGNvbnN0IGhlaWdodCA9IHkyIC0geTE7XG4gICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBbeDEsIHBhZ2VIZWlnaHQgLSB5Miwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gW3gxLCBwYWdlSGVpZ2h0IC0geTEsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbeDIsIHBhZ2VIZWlnaHQgLSB5MSwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFt4MiwgcGFnZUhlaWdodCAtIHkyLCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcm90YXRpb25cIik7XG4gICAgfVxuICB9XG4gIGdldFBERlJlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmVjdCgwLCAwKTtcbiAgfVxuICBvbmNlQWRkZWQoZm9jdXMpIHt9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGVuYWJsZUVkaXRNb2RlKCkge1xuICAgIGlmICh0aGlzLmlzSW5FZGl0TW9kZSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMucGFyZW50LnNldEVkaXRpbmdTdGF0ZShmYWxzZSk7XG4gICAgdGhpcy4jaXNJbkVkaXRNb2RlID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkaXNhYmxlRWRpdE1vZGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5FZGl0TW9kZSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMucGFyZW50LnNldEVkaXRpbmdTdGF0ZSh0cnVlKTtcbiAgICB0aGlzLiNpc0luRWRpdE1vZGUgPSBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpc0luRWRpdE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lzSW5FZGl0TW9kZTtcbiAgfVxuICBzaG91bGRHZXRLZXlib2FyZEV2ZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkO1xuICB9XG4gIG5lZWRzVG9CZVJlYnVpbHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2ICYmICF0aGlzLmlzQXR0YWNoZWRUb0RPTTtcbiAgfVxuICBnZXQgaXNPblNjcmVlbigpIHtcbiAgICBjb25zdCB7XG4gICAgICB0b3AsXG4gICAgICBsZWZ0LFxuICAgICAgYm90dG9tLFxuICAgICAgcmlnaHRcbiAgICB9ID0gdGhpcy5nZXRDbGllbnREaW1lbnNpb25zKCk7XG4gICAgY29uc3Qge1xuICAgICAgaW5uZXJIZWlnaHQsXG4gICAgICBpbm5lcldpZHRoXG4gICAgfSA9IHdpbmRvdztcbiAgICByZXR1cm4gbGVmdCA8IGlubmVyV2lkdGggJiYgcmlnaHQgPiAwICYmIHRvcCA8IGlubmVySGVpZ2h0ICYmIGJvdHRvbSA+IDA7XG4gIH1cbiAgI2FkZEZvY3VzTGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLiNmb2N1c0FDIHx8ICF0aGlzLmRpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNmb2N1c0FDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiNmb2N1c0FDKTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCB0aGlzLmZvY3VzaW4uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuZm9jdXNvdXQuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICB0aGlzLiNhZGRGb2N1c0xpc3RlbmVycygpO1xuICB9XG4gIHJvdGF0ZShfYW5nbGUpIHt9XG4gIHJlc2l6ZSgpIHt9XG4gIHNlcmlhbGl6ZURlbGV0ZWQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmFubm90YXRpb25FbGVtZW50SWQsXG4gICAgICBkZWxldGVkOiB0cnVlLFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgIHBvcHVwUmVmOiB0aGlzLl9pbml0aWFsRGF0YT8ucG9wdXBSZWYgfHwgXCJcIlxuICAgIH07XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlLCBjb250ZXh0ID0gbnVsbCkge1xuICAgIHVucmVhY2hhYmxlKFwiQW4gZWRpdG9yIG11c3QgYmUgc2VyaWFsaXphYmxlXCIpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGNvbnN0IGVkaXRvciA9IG5ldyB0aGlzLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcih7XG4gICAgICBwYXJlbnQsXG4gICAgICBpZDogcGFyZW50LmdldE5leHRJZCgpLFxuICAgICAgdWlNYW5hZ2VyLFxuICAgICAgYW5ub3RhdGlvbkVsZW1lbnRJZDogZGF0YS5hbm5vdGF0aW9uRWxlbWVudElkXG4gICAgfSk7XG4gICAgZWRpdG9yLnJvdGF0aW9uID0gZGF0YS5yb3RhdGlvbjtcbiAgICBlZGl0b3IuI2FjY2Vzc2liaWxpdHlEYXRhID0gZGF0YS5hY2Nlc3NpYmlsaXR5RGF0YTtcbiAgICBlZGl0b3IuX2lzQ29weSA9IGRhdGEuaXNDb3B5IHx8IGZhbHNlO1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gZWRpdG9yLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IGVkaXRvci5nZXRSZWN0SW5DdXJyZW50Q29vcmRzKGRhdGEucmVjdCwgcGFnZUhlaWdodCk7XG4gICAgZWRpdG9yLnggPSB4IC8gcGFnZVdpZHRoO1xuICAgIGVkaXRvci55ID0geSAvIHBhZ2VIZWlnaHQ7XG4gICAgZWRpdG9yLndpZHRoID0gd2lkdGggLyBwYWdlV2lkdGg7XG4gICAgZWRpdG9yLmhlaWdodCA9IGhlaWdodCAvIHBhZ2VIZWlnaHQ7XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBnZXQgaGFzQmVlbk1vZGlmaWVkKCkge1xuICAgIHJldHVybiAhIXRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiAodGhpcy5kZWxldGVkIHx8IHRoaXMuc2VyaWFsaXplKCkgIT09IG51bGwpO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLiNmb2N1c0FDPy5hYm9ydCgpO1xuICAgIHRoaXMuI2ZvY3VzQUMgPSBudWxsO1xuICAgIGlmICghdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMuY29tbWl0KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIucmVtb3ZlRWRpdG9yKHRoaXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jbW92ZUluRE9NVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI21vdmVJbkRPTVRpbWVvdXQpO1xuICAgICAgdGhpcy4jbW92ZUluRE9NVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuI3N0b3BSZXNpemluZygpO1xuICAgIHRoaXMucmVtb3ZlRWRpdFRvb2xiYXIoKTtcbiAgICBpZiAodGhpcy4jdGVsZW1ldHJ5VGltZW91dHMpIHtcbiAgICAgIGZvciAoY29uc3QgdGltZW91dCBvZiB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cy52YWx1ZXMoKSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB9XG4gICAgICB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLiN0b3VjaE1hbmFnZXI/LmRlc3Ryb3koKTtcbiAgICB0aGlzLiN0b3VjaE1hbmFnZXIgPSBudWxsO1xuICB9XG4gIGdldCBpc1Jlc2l6YWJsZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWFrZVJlc2l6YWJsZSgpIHtcbiAgICBpZiAodGhpcy5pc1Jlc2l6YWJsZSkge1xuICAgICAgdGhpcy4jY3JlYXRlUmVzaXplcnMoKTtcbiAgICAgIHRoaXMuI3Jlc2l6ZXJzRGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XG4gICAgfVxuICB9XG4gIGdldCB0b29sYmFyUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAga2V5ZG93bihldmVudCkge1xuICAgIGlmICghdGhpcy5pc1Jlc2l6YWJsZSB8fCBldmVudC50YXJnZXQgIT09IHRoaXMuZGl2IHx8IGV2ZW50LmtleSAhPT0gXCJFbnRlclwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3VpTWFuYWdlci5zZXRTZWxlY3RlZCh0aGlzKTtcbiAgICB0aGlzLiNzYXZlZERpbWVuc2lvbnMgPSB7XG4gICAgICBzYXZlZFg6IHRoaXMueCxcbiAgICAgIHNhdmVkWTogdGhpcy55LFxuICAgICAgc2F2ZWRXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgIHNhdmVkSGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLiNyZXNpemVyc0Rpdi5jaGlsZHJlbjtcbiAgICBpZiAoIXRoaXMuI2FsbFJlc2l6ZXJEaXZzKSB7XG4gICAgICB0aGlzLiNhbGxSZXNpemVyRGl2cyA9IEFycmF5LmZyb20oY2hpbGRyZW4pO1xuICAgICAgY29uc3QgYm91bmRSZXNpemVyS2V5ZG93biA9IHRoaXMuI3Jlc2l6ZXJLZXlkb3duLmJpbmQodGhpcyk7XG4gICAgICBjb25zdCBib3VuZFJlc2l6ZXJCbHVyID0gdGhpcy4jcmVzaXplckJsdXIuYmluZCh0aGlzKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgICAgZm9yIChjb25zdCBkaXYgb2YgdGhpcy4jYWxsUmVzaXplckRpdnMpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGRpdi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlc2l6ZXItbmFtZVwiKTtcbiAgICAgICAgZGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJzcGluYnV0dG9uXCIpO1xuICAgICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgYm91bmRSZXNpemVyS2V5ZG93biwge1xuICAgICAgICAgIHNpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGJvdW5kUmVzaXplckJsdXIsIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy4jcmVzaXplckZvY3VzLmJpbmQodGhpcywgbmFtZSksIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQW5ub3RhdGlvbkVkaXRvci5fbDEwblJlc2l6ZXJbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmaXJzdCA9IHRoaXMuI2FsbFJlc2l6ZXJEaXZzWzBdO1xuICAgIGxldCBmaXJzdFBvc2l0aW9uID0gMDtcbiAgICBmb3IgKGNvbnN0IGRpdiBvZiBjaGlsZHJlbikge1xuICAgICAgaWYgKGRpdiA9PT0gZmlyc3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBmaXJzdFBvc2l0aW9uKys7XG4gICAgfVxuICAgIGNvbnN0IG5leHRGaXJzdFBvc2l0aW9uID0gKDM2MCAtIHRoaXMucm90YXRpb24gKyB0aGlzLnBhcmVudFJvdGF0aW9uKSAlIDM2MCAvIDkwICogKHRoaXMuI2FsbFJlc2l6ZXJEaXZzLmxlbmd0aCAvIDQpO1xuICAgIGlmIChuZXh0Rmlyc3RQb3NpdGlvbiAhPT0gZmlyc3RQb3NpdGlvbikge1xuICAgICAgaWYgKG5leHRGaXJzdFBvc2l0aW9uIDwgZmlyc3RQb3NpdGlvbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpcnN0UG9zaXRpb24gLSBuZXh0Rmlyc3RQb3NpdGlvbjsgaSsrKSB7XG4gICAgICAgICAgdGhpcy4jcmVzaXplcnNEaXYuYXBwZW5kKHRoaXMuI3Jlc2l6ZXJzRGl2LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5leHRGaXJzdFBvc2l0aW9uID4gZmlyc3RQb3NpdGlvbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRGaXJzdFBvc2l0aW9uIC0gZmlyc3RQb3NpdGlvbjsgaSsrKSB7XG4gICAgICAgICAgdGhpcy4jcmVzaXplcnNEaXYuZmlyc3RDaGlsZC5iZWZvcmUodGhpcy4jcmVzaXplcnNEaXYubGFzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgICBjb25zdCBkaXYgPSB0aGlzLiNhbGxSZXNpemVyRGl2c1tpKytdO1xuICAgICAgICBjb25zdCBuYW1lID0gZGl2LmdldEF0dHJpYnV0ZShcImRhdGEtcmVzaXplci1uYW1lXCIpO1xuICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQW5ub3RhdGlvbkVkaXRvci5fbDEwblJlc2l6ZXJbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNzZXRSZXNpemVyVGFiSW5kZXgoMCk7XG4gICAgdGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkID0gdHJ1ZTtcbiAgICB0aGlzLiNyZXNpemVyc0Rpdi5maXJzdENoaWxkLmZvY3VzKHtcbiAgICAgIGZvY3VzVmlzaWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgI3Jlc2l6ZXJLZXlkb3duKGV2ZW50KSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5fcmVzaXplcktleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgfVxuICAjcmVzaXplckJsdXIoZXZlbnQpIHtcbiAgICBpZiAodGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkICYmIGV2ZW50LnJlbGF0ZWRUYXJnZXQ/LnBhcmVudE5vZGUgIT09IHRoaXMuI3Jlc2l6ZXJzRGl2KSB7XG4gICAgICB0aGlzLiNzdG9wUmVzaXppbmcoKTtcbiAgICB9XG4gIH1cbiAgI3Jlc2l6ZXJGb2N1cyhuYW1lKSB7XG4gICAgdGhpcy4jZm9jdXNlZFJlc2l6ZXJOYW1lID0gdGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkID8gbmFtZSA6IFwiXCI7XG4gIH1cbiAgI3NldFJlc2l6ZXJUYWJJbmRleCh2YWx1ZSkge1xuICAgIGlmICghdGhpcy4jYWxsUmVzaXplckRpdnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBkaXYgb2YgdGhpcy4jYWxsUmVzaXplckRpdnMpIHtcbiAgICAgIGRpdi50YWJJbmRleCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICBfcmVzaXplV2l0aEtleWJvYXJkKHgsIHkpIHtcbiAgICBpZiAoIXRoaXMuI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNyZXNpemVyUG9pbnRlcm1vdmUodGhpcy4jZm9jdXNlZFJlc2l6ZXJOYW1lLCB7XG4gICAgICBkZWx0YVg6IHgsXG4gICAgICBkZWx0YVk6IHksXG4gICAgICBmcm9tS2V5Ym9hcmQ6IHRydWVcbiAgICB9KTtcbiAgfVxuICAjc3RvcFJlc2l6aW5nKCkge1xuICAgIHRoaXMuI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCA9IGZhbHNlO1xuICAgIHRoaXMuI3NldFJlc2l6ZXJUYWJJbmRleCgtMSk7XG4gICAgdGhpcy4jYWRkUmVzaXplVG9VbmRvU3RhY2soKTtcbiAgfVxuICBfc3RvcFJlc2l6aW5nV2l0aEtleWJvYXJkKCkge1xuICAgIHRoaXMuI3N0b3BSZXNpemluZygpO1xuICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gIH1cbiAgc2VsZWN0KCkge1xuICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQgJiYgdGhpcy5fZWRpdFRvb2xiYXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICB0aGlzLm1ha2VSZXNpemFibGUoKTtcbiAgICB0aGlzLmRpdj8uY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkRWRpdG9yXCIpO1xuICAgIGlmICghdGhpcy5fZWRpdFRvb2xiYXIpIHtcbiAgICAgIHRoaXMuYWRkRWRpdFRvb2xiYXIoKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZGl2Py5jbGFzc0xpc3QuY29udGFpbnMoXCJzZWxlY3RlZEVkaXRvclwiKSkge1xuICAgICAgICAgIHRoaXMuX2VkaXRUb29sYmFyPy5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0VG9vbGJhcj8uc2hvdygpO1xuICAgIHRoaXMuI2FsdFRleHQ/LnRvZ2dsZUFsdFRleHRCYWRnZShmYWxzZSk7XG4gIH1cbiAgdW5zZWxlY3QoKSB7XG4gICAgaWYgKCF0aGlzLmlzU2VsZWN0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy4jcmVzaXplcnNEaXY/LmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gICAgdGhpcy5kaXY/LmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZEVkaXRvclwiKTtcbiAgICBpZiAodGhpcy5kaXY/LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuY3VycmVudExheWVyLmRpdi5mb2N1cyh7XG4gICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0VG9vbGJhcj8uaGlkZSgpO1xuICAgIHRoaXMuI2FsdFRleHQ/LnRvZ2dsZUFsdFRleHRCYWRnZSh0cnVlKTtcbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHt9XG4gIGRpc2FibGVFZGl0aW5nKCkge31cbiAgZW5hYmxlRWRpdGluZygpIHt9XG4gIGdldCBjYW5DaGFuZ2VDb250ZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBlbnRlckluRWRpdE1vZGUoKSB7XG4gICAgaWYgKCF0aGlzLmNhbkNoYW5nZUNvbnRlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gIH1cbiAgZGJsY2xpY2soZXZlbnQpIHtcbiAgICB0aGlzLmVudGVySW5FZGl0TW9kZSgpO1xuICAgIHRoaXMucGFyZW50LnVwZGF0ZVRvb2xiYXIoe1xuICAgICAgbW9kZTogdGhpcy5jb25zdHJ1Y3Rvci5fZWRpdG9yVHlwZSxcbiAgICAgIGVkaXRJZDogdGhpcy5pZFxuICAgIH0pO1xuICB9XG4gIGdldEVsZW1lbnRGb3JBbHRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICBnZXQgY29udGVudERpdigpIHtcbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgZ2V0IGlzRWRpdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNFZGl0aW5nO1xuICB9XG4gIHNldCBpc0VkaXRpbmcodmFsdWUpIHtcbiAgICB0aGlzLiNpc0VkaXRpbmcgPSB2YWx1ZTtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0U2VsZWN0ZWQodGhpcyk7XG4gICAgICB0aGlzLnBhcmVudC5zZXRBY3RpdmVFZGl0b3IodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyZW50LnNldEFjdGl2ZUVkaXRvcihudWxsKTtcbiAgICB9XG4gIH1cbiAgc2V0QXNwZWN0UmF0aW8od2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMuI2tlZXBBc3BlY3RSYXRpbyA9IHRydWU7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSB3aWR0aCAvIGhlaWdodDtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmRpdjtcbiAgICBzdHlsZS5hc3BlY3RSYXRpbyA9IGFzcGVjdFJhdGlvO1xuICAgIHN0eWxlLmhlaWdodCA9IFwiYXV0b1wiO1xuICB9XG4gIHN0YXRpYyBnZXQgTUlOX1NJWkUoKSB7XG4gICAgcmV0dXJuIDE2O1xuICB9XG4gIHN0YXRpYyBjYW5DcmVhdGVOZXdFbXB0eUVkaXRvcigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXQgdGVsZW1ldHJ5SW5pdGlhbERhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGlvbjogXCJhZGRlZFwiXG4gICAgfTtcbiAgfVxuICBnZXQgdGVsZW1ldHJ5RmluYWxEYXRhKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIF9yZXBvcnRUZWxlbWV0cnkoZGF0YSwgbXVzdFdhaXQgPSBmYWxzZSkge1xuICAgIGlmIChtdXN0V2FpdCkge1xuICAgICAgdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMgfHw9IG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWN0aW9uXG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGxldCB0aW1lb3V0ID0gdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMuZ2V0KGFjdGlvbik7XG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB9XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeShkYXRhKTtcbiAgICAgICAgdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMuZGVsZXRlKGFjdGlvbik7XG4gICAgICAgIGlmICh0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9LCBBbm5vdGF0aW9uRWRpdG9yLl90ZWxlbWV0cnlUaW1lb3V0KTtcbiAgICAgIHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzLnNldChhY3Rpb24sIHRpbWVvdXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkYXRhLnR5cGUgfHw9IHRoaXMuZWRpdG9yVHlwZTtcbiAgICB0aGlzLl91aU1hbmFnZXIuX2V2ZW50QnVzLmRpc3BhdGNoKFwicmVwb3J0dGVsZW1ldHJ5XCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgdHlwZTogXCJlZGl0aW5nXCIsXG4gICAgICAgIGRhdGFcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzaG93KHZpc2libGUgPSB0aGlzLl9pc1Zpc2libGUpIHtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiaGlkZGVuXCIsICF2aXNpYmxlKTtcbiAgICB0aGlzLl9pc1Zpc2libGUgPSB2aXNpYmxlO1xuICB9XG4gIGVuYWJsZSgpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHRoaXMuZGl2LnRhYkluZGV4ID0gMDtcbiAgICB9XG4gICAgdGhpcy4jZGlzYWJsZWQgPSBmYWxzZTtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgdGhpcy5kaXYudGFiSW5kZXggPSAtMTtcbiAgICB9XG4gICAgdGhpcy4jZGlzYWJsZWQgPSB0cnVlO1xuICB9XG4gIHJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBpZiAodGhpcy5kZWxldGVkKSB7XG4gICAgICBhbm5vdGF0aW9uLmhpZGUoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgY29udGVudCA9IGFubm90YXRpb24uY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIuYW5ub3RhdGlvbkNvbnRlbnRcIik7XG4gICAgaWYgKCFjb250ZW50KSB7XG4gICAgICBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZChcImFubm90YXRpb25Db250ZW50XCIsIHRoaXMuZWRpdG9yVHlwZSk7XG4gICAgICBhbm5vdGF0aW9uLmNvbnRhaW5lci5wcmVwZW5kKGNvbnRlbnQpO1xuICAgIH0gZWxzZSBpZiAoY29udGVudC5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIikge1xuICAgICAgY29uc3QgY2FudmFzID0gY29udGVudDtcbiAgICAgIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKFwiYW5ub3RhdGlvbkNvbnRlbnRcIiwgdGhpcy5lZGl0b3JUeXBlKTtcbiAgICAgIGNhbnZhcy5iZWZvcmUoY29udGVudCk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIHJlc2V0QW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIGZpcnN0Q2hpbGRcbiAgICB9ID0gYW5ub3RhdGlvbi5jb250YWluZXI7XG4gICAgaWYgKGZpcnN0Q2hpbGQ/Lm5vZGVOYW1lID09PSBcIkRJVlwiICYmIGZpcnN0Q2hpbGQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYW5ub3RhdGlvbkNvbnRlbnRcIikpIHtcbiAgICAgIGZpcnN0Q2hpbGQucmVtb3ZlKCk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBGYWtlRWRpdG9yIGV4dGVuZHMgQW5ub3RhdGlvbkVkaXRvciB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHBhcmFtcyk7XG4gICAgdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkID0gcGFyYW1zLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgdGhpcy5kZWxldGVkID0gdHJ1ZTtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplRGVsZXRlZCgpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9zaGFyZWQvbXVybXVyaGFzaDMuanNcbmNvbnN0IFNFRUQgPSAweGMzZDJlMWYwO1xuY29uc3QgTUFTS19ISUdIID0gMHhmZmZmMDAwMDtcbmNvbnN0IE1BU0tfTE9XID0gMHhmZmZmO1xuY2xhc3MgTXVybXVySGFzaDNfNjQge1xuICBjb25zdHJ1Y3RvcihzZWVkKSB7XG4gICAgdGhpcy5oMSA9IHNlZWQgPyBzZWVkICYgMHhmZmZmZmZmZiA6IFNFRUQ7XG4gICAgdGhpcy5oMiA9IHNlZWQgPyBzZWVkICYgMHhmZmZmZmZmZiA6IFNFRUQ7XG4gIH1cbiAgdXBkYXRlKGlucHV0KSB7XG4gICAgbGV0IGRhdGEsIGxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQubGVuZ3RoICogMik7XG4gICAgICBsZW5ndGggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gaW5wdXQubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBjb25zdCBjb2RlID0gaW5wdXQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGUgPD0gMHhmZikge1xuICAgICAgICAgIGRhdGFbbGVuZ3RoKytdID0gY29kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhW2xlbmd0aCsrXSA9IGNvZGUgPj4+IDg7XG4gICAgICAgICAgZGF0YVtsZW5ndGgrK10gPSBjb2RlICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGlucHV0KSkge1xuICAgICAgZGF0YSA9IGlucHV0LnNsaWNlKCk7XG4gICAgICBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSBmb3JtYXQsIG11c3QgYmUgYSBzdHJpbmcgb3IgVHlwZWRBcnJheS5cIik7XG4gICAgfVxuICAgIGNvbnN0IGJsb2NrQ291bnRzID0gbGVuZ3RoID4+IDI7XG4gICAgY29uc3QgdGFpbExlbmd0aCA9IGxlbmd0aCAtIGJsb2NrQ291bnRzICogNDtcbiAgICBjb25zdCBkYXRhVWludDMyID0gbmV3IFVpbnQzMkFycmF5KGRhdGEuYnVmZmVyLCAwLCBibG9ja0NvdW50cyk7XG4gICAgbGV0IGsxID0gMCxcbiAgICAgIGsyID0gMDtcbiAgICBsZXQgaDEgPSB0aGlzLmgxLFxuICAgICAgaDIgPSB0aGlzLmgyO1xuICAgIGNvbnN0IEMxID0gMHhjYzllMmQ1MSxcbiAgICAgIEMyID0gMHgxYjg3MzU5MztcbiAgICBjb25zdCBDMV9MT1cgPSBDMSAmIE1BU0tfTE9XLFxuICAgICAgQzJfTE9XID0gQzIgJiBNQVNLX0xPVztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrQ291bnRzOyBpKyspIHtcbiAgICAgIGlmIChpICYgMSkge1xuICAgICAgICBrMSA9IGRhdGFVaW50MzJbaV07XG4gICAgICAgIGsxID0gazEgKiBDMSAmIE1BU0tfSElHSCB8IGsxICogQzFfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGsxID0gazEgPDwgMTUgfCBrMSA+Pj4gMTc7XG4gICAgICAgIGsxID0gazEgKiBDMiAmIE1BU0tfSElHSCB8IGsxICogQzJfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGgxIF49IGsxO1xuICAgICAgICBoMSA9IGgxIDw8IDEzIHwgaDEgPj4+IDE5O1xuICAgICAgICBoMSA9IGgxICogNSArIDB4ZTY1NDZiNjQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrMiA9IGRhdGFVaW50MzJbaV07XG4gICAgICAgIGsyID0gazIgKiBDMSAmIE1BU0tfSElHSCB8IGsyICogQzFfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGsyID0gazIgPDwgMTUgfCBrMiA+Pj4gMTc7XG4gICAgICAgIGsyID0gazIgKiBDMiAmIE1BU0tfSElHSCB8IGsyICogQzJfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGgyIF49IGsyO1xuICAgICAgICBoMiA9IGgyIDw8IDEzIHwgaDIgPj4+IDE5O1xuICAgICAgICBoMiA9IGgyICogNSArIDB4ZTY1NDZiNjQ7XG4gICAgICB9XG4gICAgfVxuICAgIGsxID0gMDtcbiAgICBzd2l0Y2ggKHRhaWxMZW5ndGgpIHtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgazEgXj0gZGF0YVtibG9ja0NvdW50cyAqIDQgKyAyXSA8PCAxNjtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgazEgXj0gZGF0YVtibG9ja0NvdW50cyAqIDQgKyAxXSA8PCA4O1xuICAgICAgY2FzZSAxOlxuICAgICAgICBrMSBePSBkYXRhW2Jsb2NrQ291bnRzICogNF07XG4gICAgICAgIGsxID0gazEgKiBDMSAmIE1BU0tfSElHSCB8IGsxICogQzFfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGsxID0gazEgPDwgMTUgfCBrMSA+Pj4gMTc7XG4gICAgICAgIGsxID0gazEgKiBDMiAmIE1BU0tfSElHSCB8IGsxICogQzJfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGlmIChibG9ja0NvdW50cyAmIDEpIHtcbiAgICAgICAgICBoMSBePSBrMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoMiBePSBrMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmgxID0gaDE7XG4gICAgdGhpcy5oMiA9IGgyO1xuICB9XG4gIGhleGRpZ2VzdCgpIHtcbiAgICBsZXQgaDEgPSB0aGlzLmgxLFxuICAgICAgaDIgPSB0aGlzLmgyO1xuICAgIGgxIF49IGgyID4+PiAxO1xuICAgIGgxID0gaDEgKiAweGVkNTU4Y2NkICYgTUFTS19ISUdIIHwgaDEgKiAweDhjY2QgJiBNQVNLX0xPVztcbiAgICBoMiA9IGgyICogMHhmZjUxYWZkNyAmIE1BU0tfSElHSCB8ICgoaDIgPDwgMTYgfCBoMSA+Pj4gMTYpICogMHhhZmQ3ZWQ1NSAmIE1BU0tfSElHSCkgPj4+IDE2O1xuICAgIGgxIF49IGgyID4+PiAxO1xuICAgIGgxID0gaDEgKiAweDFhODVlYzUzICYgTUFTS19ISUdIIHwgaDEgKiAweGVjNTMgJiBNQVNLX0xPVztcbiAgICBoMiA9IGgyICogMHhjNGNlYjlmZSAmIE1BU0tfSElHSCB8ICgoaDIgPDwgMTYgfCBoMSA+Pj4gMTYpICogMHhiOWZlMWE4NSAmIE1BU0tfSElHSCkgPj4+IDE2O1xuICAgIGgxIF49IGgyID4+PiAxO1xuICAgIHJldHVybiAoaDEgPj4+IDApLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LCBcIjBcIikgKyAoaDIgPj4+IDApLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LCBcIjBcIik7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvYW5ub3RhdGlvbl9zdG9yYWdlLmpzXG5cblxuXG5jb25zdCBTZXJpYWxpemFibGVFbXB0eSA9IE9iamVjdC5mcmVlemUoe1xuICBtYXA6IG51bGwsXG4gIGhhc2g6IFwiXCIsXG4gIHRyYW5zZmVyOiB1bmRlZmluZWRcbn0pO1xuY2xhc3MgQW5ub3RhdGlvblN0b3JhZ2Uge1xuICAjbW9kaWZpZWQgPSBmYWxzZTtcbiAgI21vZGlmaWVkSWRzID0gbnVsbDtcbiAgI3N0b3JhZ2UgPSBuZXcgTWFwKCk7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMub25TZXRNb2RpZmllZCA9IG51bGw7XG4gICAgdGhpcy5vblJlc2V0TW9kaWZpZWQgPSBudWxsO1xuICAgIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yID0gbnVsbDtcbiAgfVxuICBnZXRWYWx1ZShrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jc3RvcmFnZS5nZXQoa2V5KTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGVmYXVsdFZhbHVlLCB2YWx1ZSk7XG4gIH1cbiAgZ2V0UmF3VmFsdWUoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuI3N0b3JhZ2UuZ2V0KGtleSk7XG4gIH1cbiAgcmVtb3ZlKGtleSkge1xuICAgIHRoaXMuI3N0b3JhZ2UuZGVsZXRlKGtleSk7XG4gICAgaWYgKHRoaXMuI3N0b3JhZ2Uuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5yZXNldE1vZGlmaWVkKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5vbkFubm90YXRpb25FZGl0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLiNzdG9yYWdlLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFubm90YXRpb25FZGl0b3IpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yKG51bGwpO1xuICAgIH1cbiAgfVxuICBzZXRWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jc3RvcmFnZS5nZXQoa2V5KTtcbiAgICBsZXQgbW9kaWZpZWQgPSBmYWxzZTtcbiAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAoY29uc3QgW2VudHJ5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICBpZiAob2JqW2VudHJ5XSAhPT0gdmFsKSB7XG4gICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgIG9ialtlbnRyeV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgdGhpcy4jc3RvcmFnZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgdGhpcy4jc2V0TW9kaWZpZWQoKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQW5ub3RhdGlvbkVkaXRvciAmJiB0eXBlb2YgdGhpcy5vbkFubm90YXRpb25FZGl0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhpcy5vbkFubm90YXRpb25FZGl0b3IodmFsdWUuY29uc3RydWN0b3IuX3R5cGUpO1xuICAgIH1cbiAgfVxuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuI3N0b3JhZ2UuaGFzKGtleSk7XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3N0b3JhZ2Uuc2l6ZTtcbiAgfVxuICAjc2V0TW9kaWZpZWQoKSB7XG4gICAgaWYgKCF0aGlzLiNtb2RpZmllZCkge1xuICAgICAgdGhpcy4jbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uU2V0TW9kaWZpZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9uU2V0TW9kaWZpZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVzZXRNb2RpZmllZCgpIHtcbiAgICBpZiAodGhpcy4jbW9kaWZpZWQpIHtcbiAgICAgIHRoaXMuI21vZGlmaWVkID0gZmFsc2U7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub25SZXNldE1vZGlmaWVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5vblJlc2V0TW9kaWZpZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IHByaW50KCkge1xuICAgIHJldHVybiBuZXcgUHJpbnRBbm5vdGF0aW9uU3RvcmFnZSh0aGlzKTtcbiAgfVxuICBnZXQgc2VyaWFsaXphYmxlKCkge1xuICAgIGlmICh0aGlzLiNzdG9yYWdlLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBTZXJpYWxpemFibGVFbXB0eTtcbiAgICB9XG4gICAgY29uc3QgbWFwID0gbmV3IE1hcCgpLFxuICAgICAgaGFzaCA9IG5ldyBNdXJtdXJIYXNoM182NCgpLFxuICAgICAgdHJhbnNmZXIgPSBbXTtcbiAgICBjb25zdCBjb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgaGFzQml0bWFwID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIHRoaXMuI3N0b3JhZ2UpIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB2YWwgaW5zdGFuY2VvZiBBbm5vdGF0aW9uRWRpdG9yID8gdmFsLnNlcmlhbGl6ZShmYWxzZSwgY29udGV4dCkgOiB2YWw7XG4gICAgICBpZiAoc2VyaWFsaXplZCkge1xuICAgICAgICBtYXAuc2V0KGtleSwgc2VyaWFsaXplZCk7XG4gICAgICAgIGhhc2gudXBkYXRlKGAke2tleX06JHtKU09OLnN0cmluZ2lmeShzZXJpYWxpemVkKX1gKTtcbiAgICAgICAgaGFzQml0bWFwIHx8PSAhIXNlcmlhbGl6ZWQuYml0bWFwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFzQml0bWFwKSB7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIG1hcC52YWx1ZXMoKSkge1xuICAgICAgICBpZiAodmFsdWUuYml0bWFwKSB7XG4gICAgICAgICAgdHJhbnNmZXIucHVzaCh2YWx1ZS5iaXRtYXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXAuc2l6ZSA+IDAgPyB7XG4gICAgICBtYXAsXG4gICAgICBoYXNoOiBoYXNoLmhleGRpZ2VzdCgpLFxuICAgICAgdHJhbnNmZXJcbiAgICB9IDogU2VyaWFsaXphYmxlRW1wdHk7XG4gIH1cbiAgZ2V0IGVkaXRvclN0YXRzKCkge1xuICAgIGxldCBzdGF0cyA9IG51bGw7XG4gICAgY29uc3QgdHlwZVRvRWRpdG9yID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy4jc3RvcmFnZS52YWx1ZXMoKSkge1xuICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBBbm5vdGF0aW9uRWRpdG9yKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVkaXRvclN0YXRzID0gdmFsdWUudGVsZW1ldHJ5RmluYWxEYXRhO1xuICAgICAgaWYgKCFlZGl0b3JTdGF0cykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHlwZVxuICAgICAgfSA9IGVkaXRvclN0YXRzO1xuICAgICAgaWYgKCF0eXBlVG9FZGl0b3IuaGFzKHR5cGUpKSB7XG4gICAgICAgIHR5cGVUb0VkaXRvci5zZXQodHlwZSwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKS5jb25zdHJ1Y3Rvcik7XG4gICAgICB9XG4gICAgICBzdGF0cyB8fD0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIGNvbnN0IG1hcCA9IHN0YXRzW3R5cGVdIHx8PSBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXMoZWRpdG9yU3RhdHMpKSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwidHlwZVwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvdW50ZXJzID0gbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoIWNvdW50ZXJzKSB7XG4gICAgICAgICAgY291bnRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgbWFwLnNldChrZXksIGNvdW50ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb3VudCA9IGNvdW50ZXJzLmdldCh2YWwpID8/IDA7XG4gICAgICAgIGNvdW50ZXJzLnNldCh2YWwsIGNvdW50ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgW3R5cGUsIGVkaXRvcl0gb2YgdHlwZVRvRWRpdG9yKSB7XG4gICAgICBzdGF0c1t0eXBlXSA9IGVkaXRvci5jb21wdXRlVGVsZW1ldHJ5RmluYWxEYXRhKHN0YXRzW3R5cGVdKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRzO1xuICB9XG4gIHJlc2V0TW9kaWZpZWRJZHMoKSB7XG4gICAgdGhpcy4jbW9kaWZpZWRJZHMgPSBudWxsO1xuICB9XG4gIGdldCBtb2RpZmllZElkcygpIHtcbiAgICBpZiAodGhpcy4jbW9kaWZpZWRJZHMpIHtcbiAgICAgIHJldHVybiB0aGlzLiNtb2RpZmllZElkcztcbiAgICB9XG4gICAgY29uc3QgaWRzID0gW107XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLiNzdG9yYWdlLnZhbHVlcygpKSB7XG4gICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFubm90YXRpb25FZGl0b3IpIHx8ICF2YWx1ZS5hbm5vdGF0aW9uRWxlbWVudElkIHx8ICF2YWx1ZS5zZXJpYWxpemUoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlkcy5wdXNoKHZhbHVlLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jbW9kaWZpZWRJZHMgPSB7XG4gICAgICBpZHM6IG5ldyBTZXQoaWRzKSxcbiAgICAgIGhhc2g6IGlkcy5qb2luKFwiLFwiKVxuICAgIH07XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuI3N0b3JhZ2UuZW50cmllcygpO1xuICB9XG59XG5jbGFzcyBQcmludEFubm90YXRpb25TdG9yYWdlIGV4dGVuZHMgQW5ub3RhdGlvblN0b3JhZ2Uge1xuICAjc2VyaWFsaXphYmxlO1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHtcbiAgICAgIG1hcCxcbiAgICAgIGhhc2gsXG4gICAgICB0cmFuc2ZlclxuICAgIH0gPSBwYXJlbnQuc2VyaWFsaXphYmxlO1xuICAgIGNvbnN0IGNsb25lID0gc3RydWN0dXJlZENsb25lKG1hcCwgdHJhbnNmZXIgPyB7XG4gICAgICB0cmFuc2ZlclxuICAgIH0gOiBudWxsKTtcbiAgICB0aGlzLiNzZXJpYWxpemFibGUgPSB7XG4gICAgICBtYXA6IGNsb25lLFxuICAgICAgaGFzaCxcbiAgICAgIHRyYW5zZmVyXG4gICAgfTtcbiAgfVxuICBnZXQgcHJpbnQoKSB7XG4gICAgdW5yZWFjaGFibGUoXCJTaG91bGQgbm90IGNhbGwgUHJpbnRBbm5vdGF0aW9uU3RvcmFnZS5wcmludFwiKTtcbiAgfVxuICBnZXQgc2VyaWFsaXphYmxlKCkge1xuICAgIHJldHVybiB0aGlzLiNzZXJpYWxpemFibGU7XG4gIH1cbiAgZ2V0IG1vZGlmaWVkSWRzKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJtb2RpZmllZElkc1wiLCB7XG4gICAgICBpZHM6IG5ldyBTZXQoKSxcbiAgICAgIGhhc2g6IFwiXCJcbiAgICB9KTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9mb250X2xvYWRlci5qc1xuXG5jbGFzcyBGb250TG9hZGVyIHtcbiAgI3N5c3RlbUZvbnRzID0gbmV3IFNldCgpO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgb3duZXJEb2N1bWVudCA9IGdsb2JhbFRoaXMuZG9jdW1lbnQsXG4gICAgc3R5bGVFbGVtZW50ID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5fZG9jdW1lbnQgPSBvd25lckRvY3VtZW50O1xuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmxvYWRpbmdSZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMubG9hZFRlc3RGb250SWQgPSAwO1xuICB9XG4gIGFkZE5hdGl2ZUZvbnRGYWNlKG5hdGl2ZUZvbnRGYWNlKSB7XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMuYWRkKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICB0aGlzLl9kb2N1bWVudC5mb250cy5hZGQobmF0aXZlRm9udEZhY2UpO1xuICB9XG4gIHJlbW92ZU5hdGl2ZUZvbnRGYWNlKG5hdGl2ZUZvbnRGYWNlKSB7XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMuZGVsZXRlKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICB0aGlzLl9kb2N1bWVudC5mb250cy5kZWxldGUobmF0aXZlRm9udEZhY2UpO1xuICB9XG4gIGluc2VydFJ1bGUocnVsZSkge1xuICAgIGlmICghdGhpcy5zdHlsZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgdGhpcy5fZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXS5hcHBlbmQodGhpcy5zdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBzdHlsZVNoZWV0ID0gdGhpcy5zdHlsZUVsZW1lbnQuc2hlZXQ7XG4gICAgc3R5bGVTaGVldC5pbnNlcnRSdWxlKHJ1bGUsIHN0eWxlU2hlZXQuY3NzUnVsZXMubGVuZ3RoKTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IG5hdGl2ZUZvbnRGYWNlIG9mIHRoaXMubmF0aXZlRm9udEZhY2VzKSB7XG4gICAgICB0aGlzLl9kb2N1bWVudC5mb250cy5kZWxldGUobmF0aXZlRm9udEZhY2UpO1xuICAgIH1cbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcy5jbGVhcigpO1xuICAgIHRoaXMuI3N5c3RlbUZvbnRzLmNsZWFyKCk7XG4gICAgaWYgKHRoaXMuc3R5bGVFbGVtZW50KSB7XG4gICAgICB0aGlzLnN0eWxlRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgYXN5bmMgbG9hZFN5c3RlbUZvbnQoe1xuICAgIHN5c3RlbUZvbnRJbmZvOiBpbmZvLFxuICAgIGRpc2FibGVGb250RmFjZSxcbiAgICBfaW5zcGVjdEZvbnRcbiAgfSkge1xuICAgIGlmICghaW5mbyB8fCB0aGlzLiNzeXN0ZW1Gb250cy5oYXMoaW5mby5sb2FkZWROYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhc3NlcnQoIWRpc2FibGVGb250RmFjZSwgXCJsb2FkU3lzdGVtRm9udCBzaG91bGRuJ3QgYmUgY2FsbGVkIHdoZW4gYGRpc2FibGVGb250RmFjZWAgaXMgc2V0LlwiKTtcbiAgICBpZiAodGhpcy5pc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxvYWRlZE5hbWUsXG4gICAgICAgIHNyYyxcbiAgICAgICAgc3R5bGVcbiAgICAgIH0gPSBpbmZvO1xuICAgICAgY29uc3QgZm9udEZhY2UgPSBuZXcgRm9udEZhY2UobG9hZGVkTmFtZSwgc3JjLCBzdHlsZSk7XG4gICAgICB0aGlzLmFkZE5hdGl2ZUZvbnRGYWNlKGZvbnRGYWNlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGZvbnRGYWNlLmxvYWQoKTtcbiAgICAgICAgdGhpcy4jc3lzdGVtRm9udHMuYWRkKGxvYWRlZE5hbWUpO1xuICAgICAgICBfaW5zcGVjdEZvbnQ/LihpbmZvKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICB3YXJuKGBDYW5ub3QgbG9hZCBzeXN0ZW0gZm9udDogJHtpbmZvLmJhc2VGb250TmFtZX0sIGluc3RhbGxpbmcgaXQgY291bGQgaGVscCB0byBpbXByb3ZlIFBERiByZW5kZXJpbmcuYCk7XG4gICAgICAgIHRoaXMucmVtb3ZlTmF0aXZlRm9udEZhY2UoZm9udEZhY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1bnJlYWNoYWJsZShcIk5vdCBpbXBsZW1lbnRlZDogbG9hZFN5c3RlbUZvbnQgd2l0aG91dCB0aGUgRm9udCBMb2FkaW5nIEFQSS5cIik7XG4gIH1cbiAgYXN5bmMgYmluZChmb250KSB7XG4gICAgaWYgKGZvbnQuYXR0YWNoZWQgfHwgZm9udC5taXNzaW5nRmlsZSAmJiAhZm9udC5zeXN0ZW1Gb250SW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb250LmF0dGFjaGVkID0gdHJ1ZTtcbiAgICBpZiAoZm9udC5zeXN0ZW1Gb250SW5mbykge1xuICAgICAgYXdhaXQgdGhpcy5sb2FkU3lzdGVtRm9udChmb250KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZCkge1xuICAgICAgY29uc3QgbmF0aXZlRm9udEZhY2UgPSBmb250LmNyZWF0ZU5hdGl2ZUZvbnRGYWNlKCk7XG4gICAgICBpZiAobmF0aXZlRm9udEZhY2UpIHtcbiAgICAgICAgdGhpcy5hZGROYXRpdmVGb250RmFjZShuYXRpdmVGb250RmFjZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgbmF0aXZlRm9udEZhY2UubG9hZGVkO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIHdhcm4oYEZhaWxlZCB0byBsb2FkIGZvbnQgJyR7bmF0aXZlRm9udEZhY2UuZmFtaWx5fSc6ICcke2V4fScuYCk7XG4gICAgICAgICAgZm9udC5kaXNhYmxlRm9udEZhY2UgPSB0cnVlO1xuICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJ1bGUgPSBmb250LmNyZWF0ZUZvbnRGYWNlUnVsZSgpO1xuICAgIGlmIChydWxlKSB7XG4gICAgICB0aGlzLmluc2VydFJ1bGUocnVsZSk7XG4gICAgICBpZiAodGhpcy5pc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuX3F1ZXVlTG9hZGluZ0NhbGxiYWNrKHJlc29sdmUpO1xuICAgICAgICB0aGlzLl9wcmVwYXJlRm9udExvYWRFdmVudChmb250LCByZXF1ZXN0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQgaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZCgpIHtcbiAgICBjb25zdCBoYXNGb250cyA9ICEhdGhpcy5fZG9jdW1lbnQ/LmZvbnRzO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkXCIsIGhhc0ZvbnRzKTtcbiAgfVxuICBnZXQgaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzU3luY0ZvbnRMb2FkaW5nU3VwcG9ydGVkXCIsIGlzTm9kZUpTIHx8IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm0uaXNGaXJlZm94KTtcbiAgfVxuICBfcXVldWVMb2FkaW5nQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICBmdW5jdGlvbiBjb21wbGV0ZVJlcXVlc3QoKSB7XG4gICAgICBhc3NlcnQoIXJlcXVlc3QuZG9uZSwgXCJjb21wbGV0ZVJlcXVlc3QoKSBjYW5ub3QgYmUgY2FsbGVkIHR3aWNlLlwiKTtcbiAgICAgIHJlcXVlc3QuZG9uZSA9IHRydWU7XG4gICAgICB3aGlsZSAobG9hZGluZ1JlcXVlc3RzLmxlbmd0aCA+IDAgJiYgbG9hZGluZ1JlcXVlc3RzWzBdLmRvbmUpIHtcbiAgICAgICAgY29uc3Qgb3RoZXJSZXF1ZXN0ID0gbG9hZGluZ1JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICAgIHNldFRpbWVvdXQob3RoZXJSZXF1ZXN0LmNhbGxiYWNrLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbG9hZGluZ1JlcXVlc3RzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgY29tcGxldGU6IGNvbXBsZXRlUmVxdWVzdCxcbiAgICAgIGNhbGxiYWNrXG4gICAgfTtcbiAgICBsb2FkaW5nUmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfVxuICBnZXQgX2xvYWRUZXN0Rm9udCgpIHtcbiAgICBjb25zdCB0ZXN0Rm9udCA9IGF0b2IoXCJUMVJVVHdBTEFJQUFBd0F3UTBaR0lESHRaZzRBQUFPWUFBQUFnVVpHVkUxbGt6WndBQUFFSEFBQUFCeEhSRVZHQUJRQVwiICsgXCJGUUFBQkRnQUFBQWVUMU12TWxZTll3a0FBQUVnQUFBQVlHTnRZWEFCRFFMVUFBQUNOQUFBQVVKb1pXRmsveFZGRFFBQVwiICsgXCJBTHdBQUFBMmFHaGxZUWRrQStvQUFBRDBBQUFBSkdodGRIZ0Q2QUFBQUFBRVdBQUFBQVp0WVhod0FBSlFBQUFBQVJnQVwiICsgXCJBQUFHYm1GdFpWam1kSDRBQUFHQUFBQUFzWEJ2YzNUL2hnQXpBQUFEZUFBQUFDQUFBUUFBQUFFQUFMWlJGc1JmRHp6MVwiICsgXCJBQXNENkFBQUFBRE9CT1RMQUFBQUFNNEtIRHdBQUFBQUErZ0RJUUFBQUFnQUFnQUFBQUFBQUFBQkFBQURJUUFBQUZvRFwiICsgXCI2QUFBQUFBRDZBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUFVQUFBQWdBQUFBUUQ2QUgwQUFVQUFBS0tBcndBQUFDTVwiICsgXCJBb29DdkFBQUFlQUFNUUVDQUFBQ0FBWUpBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUZCbVJXUUF3QUF1QUM0RFwiICsgXCJJUDg0QUZvRElRQUFBQUFBQVFBQUFBQUFBQUFBQUNBQUlBQUJBQUFBRGdDdUFBRUFBQUFBQUFBQUFRQUFBQUVBQUFBQVwiICsgXCJBQUVBQVFBQUFBRUFBQUFBQUFJQUFRQUFBQUVBQUFBQUFBTUFBUUFBQUFFQUFBQUFBQVFBQVFBQUFBRUFBQUFBQUFVQVwiICsgXCJBUUFBQUFFQUFBQUFBQVlBQVFBQUFBTUFBUVFKQUFBQUFnQUJBQU1BQVFRSkFBRUFBZ0FCQUFNQUFRUUpBQUlBQWdBQlwiICsgXCJBQU1BQVFRSkFBTUFBZ0FCQUFNQUFRUUpBQVFBQWdBQkFBTUFBUVFKQUFVQUFnQUJBQU1BQVFRSkFBWUFBZ0FCV0FCWVwiICsgXCJBQUFBQUFBQUF3QUFBQU1BQUFBY0FBRUFBQUFBQUR3QUF3QUJBQUFBSEFBRUFDQUFBQUFFQUFRQUFRQUFBQzcvL3dBQVwiICsgXCJBQzcvLy8vVEFBRUFBQUFBQUFBQkJnQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFNQUFBQUFBQUQvZ3dBeUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFCQUFRRUFBRUJBUUpZQUFFQkFTSDREd0Q0R3dIRUF2Z2NBL2dYQkl3TUFZdUwrbno1dFFYa0Q1ajNDQkxuRVFBQ1wiICsgXCJBUUVCSVZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlBQUFCQVFBQUR3QUNBUUVFRS90M1wiICsgXCJEb3Y2ZkFINmZBVCtmUHA4K253SERvc01Ddm0xQ3ZtMURBejZmQlFBQUFBQUFBQUJBQUFBQU1tSmJ6RUFBQUFBemdUalwiICsgXCJGUUFBQUFET0JPUXBBQUVBQUFBQUFBQUFEQUFVQUFRQUFBQUJBQUFBQWdBQkFBQUFBQUFBQUFBRDZBQUFBQUFBQUE9PVwiKTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2xvYWRUZXN0Rm9udFwiLCB0ZXN0Rm9udCk7XG4gIH1cbiAgX3ByZXBhcmVGb250TG9hZEV2ZW50KGZvbnQsIHJlcXVlc3QpIHtcbiAgICBmdW5jdGlvbiBpbnQzMihkYXRhLCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0KSA8PCAyNCB8IGRhdGEuY2hhckNvZGVBdChvZmZzZXQgKyAxKSA8PCAxNiB8IGRhdGEuY2hhckNvZGVBdChvZmZzZXQgKyAyKSA8PCA4IHwgZGF0YS5jaGFyQ29kZUF0KG9mZnNldCArIDMpICYgMHhmZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3BsaWNlU3RyaW5nKHMsIG9mZnNldCwgcmVtb3ZlLCBpbnNlcnQpIHtcbiAgICAgIGNvbnN0IGNodW5rMSA9IHMuc3Vic3RyaW5nKDAsIG9mZnNldCk7XG4gICAgICBjb25zdCBjaHVuazIgPSBzLnN1YnN0cmluZyhvZmZzZXQgKyByZW1vdmUpO1xuICAgICAgcmV0dXJuIGNodW5rMSArIGluc2VydCArIGNodW5rMjtcbiAgICB9XG4gICAgbGV0IGksIGlpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gMTtcbiAgICBjYW52YXMuaGVpZ2h0ID0gMTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGxldCBjYWxsZWQgPSAwO1xuICAgIGZ1bmN0aW9uIGlzRm9udFJlYWR5KG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoKytjYWxsZWQgPiAzMCkge1xuICAgICAgICB3YXJuKFwiTG9hZCB0ZXN0IGZvbnQgbmV2ZXIgbG9hZGVkLlwiKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LmZvbnQgPSBcIjMwcHggXCIgKyBuYW1lO1xuICAgICAgY3R4LmZpbGxUZXh0KFwiLlwiLCAwLCAyMCk7XG4gICAgICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpO1xuICAgICAgaWYgKGltYWdlRGF0YS5kYXRhWzNdID4gMCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KGlzRm9udFJlYWR5LmJpbmQobnVsbCwgbmFtZSwgY2FsbGJhY2spKTtcbiAgICB9XG4gICAgY29uc3QgbG9hZFRlc3RGb250SWQgPSBgbHQke0RhdGUubm93KCl9JHt0aGlzLmxvYWRUZXN0Rm9udElkKyt9YDtcbiAgICBsZXQgZGF0YSA9IHRoaXMuX2xvYWRUZXN0Rm9udDtcbiAgICBjb25zdCBDT01NRU5UX09GRlNFVCA9IDk3NjtcbiAgICBkYXRhID0gc3BsaWNlU3RyaW5nKGRhdGEsIENPTU1FTlRfT0ZGU0VULCBsb2FkVGVzdEZvbnRJZC5sZW5ndGgsIGxvYWRUZXN0Rm9udElkKTtcbiAgICBjb25zdCBDRkZfQ0hFQ0tTVU1fT0ZGU0VUID0gMTY7XG4gICAgY29uc3QgWFhYWF9WQUxVRSA9IDB4NTg1ODU4NTg7XG4gICAgbGV0IGNoZWNrc3VtID0gaW50MzIoZGF0YSwgQ0ZGX0NIRUNLU1VNX09GRlNFVCk7XG4gICAgZm9yIChpID0gMCwgaWkgPSBsb2FkVGVzdEZvbnRJZC5sZW5ndGggLSAzOyBpIDwgaWk7IGkgKz0gNCkge1xuICAgICAgY2hlY2tzdW0gPSBjaGVja3N1bSAtIFhYWFhfVkFMVUUgKyBpbnQzMihsb2FkVGVzdEZvbnRJZCwgaSkgfCAwO1xuICAgIH1cbiAgICBpZiAoaSA8IGxvYWRUZXN0Rm9udElkLmxlbmd0aCkge1xuICAgICAgY2hlY2tzdW0gPSBjaGVja3N1bSAtIFhYWFhfVkFMVUUgKyBpbnQzMihsb2FkVGVzdEZvbnRJZCArIFwiWFhYXCIsIGkpIHwgMDtcbiAgICB9XG4gICAgZGF0YSA9IHNwbGljZVN0cmluZyhkYXRhLCBDRkZfQ0hFQ0tTVU1fT0ZGU0VULCA0LCBzdHJpbmczMihjaGVja3N1bSkpO1xuICAgIGNvbnN0IHVybCA9IGB1cmwoZGF0YTpmb250L29wZW50eXBlO2Jhc2U2NCwke2J0b2EoZGF0YSl9KTtgO1xuICAgIGNvbnN0IHJ1bGUgPSBgQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6XCIke2xvYWRUZXN0Rm9udElkfVwiO3NyYzoke3VybH19YDtcbiAgICB0aGlzLmluc2VydFJ1bGUocnVsZSk7XG4gICAgY29uc3QgZGl2ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgZGl2LnN0eWxlLndpZHRoID0gZGl2LnN0eWxlLmhlaWdodCA9IFwiMTBweFwiO1xuICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBkaXYuc3R5bGUudG9wID0gZGl2LnN0eWxlLmxlZnQgPSBcIjBweFwiO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBbZm9udC5sb2FkZWROYW1lLCBsb2FkVGVzdEZvbnRJZF0pIHtcbiAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBcIkhpXCI7XG4gICAgICBzcGFuLnN0eWxlLmZvbnRGYW1pbHkgPSBuYW1lO1xuICAgICAgZGl2LmFwcGVuZChzcGFuKTtcbiAgICB9XG4gICAgdGhpcy5fZG9jdW1lbnQuYm9keS5hcHBlbmQoZGl2KTtcbiAgICBpc0ZvbnRSZWFkeShsb2FkVGVzdEZvbnRJZCwgKCkgPT4ge1xuICAgICAgZGl2LnJlbW92ZSgpO1xuICAgICAgcmVxdWVzdC5jb21wbGV0ZSgpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBGb250RmFjZU9iamVjdCB7XG4gIGNvbnN0cnVjdG9yKHRyYW5zbGF0ZWREYXRhLCBpbnNwZWN0Rm9udCA9IG51bGwpIHtcbiAgICB0aGlzLmNvbXBpbGVkR2x5cGhzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdHJhbnNsYXRlZERhdGEpIHtcbiAgICAgIHRoaXNbaV0gPSB0cmFuc2xhdGVkRGF0YVtpXTtcbiAgICB9XG4gICAgdGhpcy5faW5zcGVjdEZvbnQgPSBpbnNwZWN0Rm9udDtcbiAgfVxuICBjcmVhdGVOYXRpdmVGb250RmFjZSgpIHtcbiAgICBpZiAoIXRoaXMuZGF0YSB8fCB0aGlzLmRpc2FibGVGb250RmFjZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBuYXRpdmVGb250RmFjZTtcbiAgICBpZiAoIXRoaXMuY3NzRm9udEluZm8pIHtcbiAgICAgIG5hdGl2ZUZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKHRoaXMubG9hZGVkTmFtZSwgdGhpcy5kYXRhLCB7fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNzcyA9IHtcbiAgICAgICAgd2VpZ2h0OiB0aGlzLmNzc0ZvbnRJbmZvLmZvbnRXZWlnaHRcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jc3NGb250SW5mby5pdGFsaWNBbmdsZSkge1xuICAgICAgICBjc3Muc3R5bGUgPSBgb2JsaXF1ZSAke3RoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGV9ZGVnYDtcbiAgICAgIH1cbiAgICAgIG5hdGl2ZUZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKHRoaXMuY3NzRm9udEluZm8uZm9udEZhbWlseSwgdGhpcy5kYXRhLCBjc3MpO1xuICAgIH1cbiAgICB0aGlzLl9pbnNwZWN0Rm9udD8uKHRoaXMpO1xuICAgIHJldHVybiBuYXRpdmVGb250RmFjZTtcbiAgfVxuICBjcmVhdGVGb250RmFjZVJ1bGUoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kaXNhYmxlRm9udEZhY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBgdXJsKGRhdGE6JHt0aGlzLm1pbWV0eXBlfTtiYXNlNjQsJHt0b0Jhc2U2NFV0aWwodGhpcy5kYXRhKX0pO2A7XG4gICAgbGV0IHJ1bGU7XG4gICAgaWYgKCF0aGlzLmNzc0ZvbnRJbmZvKSB7XG4gICAgICBydWxlID0gYEBmb250LWZhY2Uge2ZvbnQtZmFtaWx5OlwiJHt0aGlzLmxvYWRlZE5hbWV9XCI7c3JjOiR7dXJsfX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY3NzID0gYGZvbnQtd2VpZ2h0OiAke3RoaXMuY3NzRm9udEluZm8uZm9udFdlaWdodH07YDtcbiAgICAgIGlmICh0aGlzLmNzc0ZvbnRJbmZvLml0YWxpY0FuZ2xlKSB7XG4gICAgICAgIGNzcyArPSBgZm9udC1zdHlsZTogb2JsaXF1ZSAke3RoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGV9ZGVnO2A7XG4gICAgICB9XG4gICAgICBydWxlID0gYEBmb250LWZhY2Uge2ZvbnQtZmFtaWx5OlwiJHt0aGlzLmNzc0ZvbnRJbmZvLmZvbnRGYW1pbHl9XCI7JHtjc3N9c3JjOiR7dXJsfX1gO1xuICAgIH1cbiAgICB0aGlzLl9pbnNwZWN0Rm9udD8uKHRoaXMsIHVybCk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgZ2V0UGF0aEdlbmVyYXRvcihvYmpzLCBjaGFyYWN0ZXIpIHtcbiAgICBpZiAodGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl07XG4gICAgfVxuICAgIGNvbnN0IG9iaklkID0gdGhpcy5sb2FkZWROYW1lICsgXCJfcGF0aF9cIiArIGNoYXJhY3RlcjtcbiAgICBsZXQgY21kcztcbiAgICB0cnkge1xuICAgICAgY21kcyA9IG9ianMuZ2V0KG9iaklkKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgd2FybihgZ2V0UGF0aEdlbmVyYXRvciAtIGlnbm9yaW5nIGNoYXJhY3RlcjogXCIke2V4fVwiLmApO1xuICAgIH1cbiAgICBjb25zdCBwYXRoID0gbmV3IFBhdGgyRChjbWRzIHx8IFwiXCIpO1xuICAgIGlmICghdGhpcy5mb250RXh0cmFQcm9wZXJ0aWVzKSB7XG4gICAgICBvYmpzLmRlbGV0ZShvYmpJZCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl0gPSBwYXRoO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2FwaV91dGlscy5qc1xuXG5mdW5jdGlvbiBnZXRVcmxQcm9wKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgcmV0dXJuIHZhbC5ocmVmO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGlzTm9kZUpTKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBVUkwucGFyc2UodmFsLCB3aW5kb3cubG9jYXRpb24pO1xuICAgIGlmICh1cmwpIHtcbiAgICAgIHJldHVybiB1cmwuaHJlZjtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBQREYgdXJsIGRhdGE6IFwiICsgXCJlaXRoZXIgc3RyaW5nIG9yIFVSTC1vYmplY3QgaXMgZXhwZWN0ZWQgaW4gdGhlIHVybCBwcm9wZXJ0eS5cIik7XG59XG5mdW5jdGlvbiBnZXREYXRhUHJvcCh2YWwpIHtcbiAgaWYgKGlzTm9kZUpTICYmIHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgdmFsIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHByb3ZpZGUgYmluYXJ5IGRhdGEgYXMgYFVpbnQ4QXJyYXlgLCByYXRoZXIgdGhhbiBgQnVmZmVyYC5cIik7XG4gIH1cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgdmFsLmJ5dGVMZW5ndGggPT09IHZhbC5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gc3RyaW5nVG9CeXRlcyh2YWwpO1xuICB9XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKSB8fCB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmICFpc05hTih2YWw/Lmxlbmd0aCkpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFBERiBiaW5hcnkgZGF0YTogZWl0aGVyIFR5cGVkQXJyYXksIFwiICsgXCJzdHJpbmcsIG9yIGFycmF5LWxpa2Ugb2JqZWN0IGlzIGV4cGVjdGVkIGluIHRoZSBkYXRhIHByb3BlcnR5LlwiKTtcbn1cbmZ1bmN0aW9uIGdldEZhY3RvcnlVcmxQcm9wKHZhbCkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh2YWwuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmFjdG9yeSB1cmw6IFwiJHt2YWx9XCIgbXVzdCBpbmNsdWRlIHRyYWlsaW5nIHNsYXNoLmApO1xufVxuY29uc3QgaXNSZWZQcm94eSA9IHYgPT4gdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgTnVtYmVyLmlzSW50ZWdlcih2Py5udW0pICYmIHYubnVtID49IDAgJiYgTnVtYmVyLmlzSW50ZWdlcih2Py5nZW4pICYmIHYuZ2VuID49IDA7XG5jb25zdCBpc05hbWVQcm94eSA9IHYgPT4gdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHY/Lm5hbWUgPT09IFwic3RyaW5nXCI7XG5jb25zdCBpc1ZhbGlkRXhwbGljaXREZXN0ID0gX2lzVmFsaWRFeHBsaWNpdERlc3QuYmluZChudWxsLCBpc1JlZlByb3h5LCBpc05hbWVQcm94eSk7XG5jbGFzcyBMb29wYmFja1BvcnQge1xuICAjbGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAjZGVmZXJyZWQgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgcG9zdE1lc3NhZ2Uob2JqLCB0cmFuc2Zlcikge1xuICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgZGF0YTogc3RydWN0dXJlZENsb25lKG9iaiwgdHJhbnNmZXIgPyB7XG4gICAgICAgIHRyYW5zZmVyXG4gICAgICB9IDogbnVsbClcbiAgICB9O1xuICAgIHRoaXMuI2RlZmVycmVkLnRoZW4oKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBbbGlzdGVuZXJdIG9mIHRoaXMuI2xpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyLCBvcHRpb25zID0gbnVsbCkge1xuICAgIGxldCBybUFib3J0ID0gbnVsbDtcbiAgICBpZiAob3B0aW9ucz8uc2lnbmFsIGluc3RhbmNlb2YgQWJvcnRTaWduYWwpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICB3YXJuKFwiTG9vcGJhY2tQb3J0IC0gY2Fubm90IHVzZSBhbiBgYWJvcnRlZGAgc2lnbmFsLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb25BYm9ydCA9ICgpID0+IHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcik7XG4gICAgICBybUFib3J0ID0gKCkgPT4gc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgfVxuICAgIHRoaXMuI2xpc3RlbmVycy5zZXQobGlzdGVuZXIsIHJtQWJvcnQpO1xuICB9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBybUFib3J0ID0gdGhpcy4jbGlzdGVuZXJzLmdldChsaXN0ZW5lcik7XG4gICAgcm1BYm9ydD8uKCk7XG4gICAgdGhpcy4jbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gIH1cbiAgdGVybWluYXRlKCkge1xuICAgIGZvciAoY29uc3QgWywgcm1BYm9ydF0gb2YgdGhpcy4jbGlzdGVuZXJzKSB7XG4gICAgICBybUFib3J0Py4oKTtcbiAgICB9XG4gICAgdGhpcy4jbGlzdGVuZXJzLmNsZWFyKCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL3NoYXJlZC9tZXNzYWdlX2hhbmRsZXIuanNcblxuY29uc3QgQ2FsbGJhY2tLaW5kID0ge1xuICBEQVRBOiAxLFxuICBFUlJPUjogMlxufTtcbmNvbnN0IFN0cmVhbUtpbmQgPSB7XG4gIENBTkNFTDogMSxcbiAgQ0FOQ0VMX0NPTVBMRVRFOiAyLFxuICBDTE9TRTogMyxcbiAgRU5RVUVVRTogNCxcbiAgRVJST1I6IDUsXG4gIFBVTEw6IDYsXG4gIFBVTExfQ09NUExFVEU6IDcsXG4gIFNUQVJUX0NPTVBMRVRFOiA4XG59O1xuZnVuY3Rpb24gb25GbigpIHt9XG5mdW5jdGlvbiB3cmFwUmVhc29uKGV4KSB7XG4gIGlmIChleCBpbnN0YW5jZW9mIEFib3J0RXhjZXB0aW9uIHx8IGV4IGluc3RhbmNlb2YgSW52YWxpZFBERkV4Y2VwdGlvbiB8fCBleCBpbnN0YW5jZW9mIFBhc3N3b3JkRXhjZXB0aW9uIHx8IGV4IGluc3RhbmNlb2YgUmVzcG9uc2VFeGNlcHRpb24gfHwgZXggaW5zdGFuY2VvZiBVbmtub3duRXJyb3JFeGNlcHRpb24pIHtcbiAgICByZXR1cm4gZXg7XG4gIH1cbiAgaWYgKCEoZXggaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgZXggPT09IFwib2JqZWN0XCIgJiYgZXggIT09IG51bGwpKSB7XG4gICAgdW5yZWFjaGFibGUoJ3dyYXBSZWFzb246IEV4cGVjdGVkIFwicmVhc29uXCIgdG8gYmUgYSAocG9zc2libHkgY2xvbmVkKSBFcnJvci4nKTtcbiAgfVxuICBzd2l0Y2ggKGV4Lm5hbWUpIHtcbiAgICBjYXNlIFwiQWJvcnRFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgQWJvcnRFeGNlcHRpb24oZXgubWVzc2FnZSk7XG4gICAgY2FzZSBcIkludmFsaWRQREZFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgSW52YWxpZFBERkV4Y2VwdGlvbihleC5tZXNzYWdlKTtcbiAgICBjYXNlIFwiUGFzc3dvcmRFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgUGFzc3dvcmRFeGNlcHRpb24oZXgubWVzc2FnZSwgZXguY29kZSk7XG4gICAgY2FzZSBcIlJlc3BvbnNlRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlRXhjZXB0aW9uKGV4Lm1lc3NhZ2UsIGV4LnN0YXR1cywgZXgubWlzc2luZyk7XG4gICAgY2FzZSBcIlVua25vd25FcnJvckV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBVbmtub3duRXJyb3JFeGNlcHRpb24oZXgubWVzc2FnZSwgZXguZGV0YWlscyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBVbmtub3duRXJyb3JFeGNlcHRpb24oZXgubWVzc2FnZSwgZXgudG9TdHJpbmcoKSk7XG59XG5jbGFzcyBNZXNzYWdlSGFuZGxlciB7XG4gICNtZXNzYWdlQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZU5hbWUsIHRhcmdldE5hbWUsIGNvbU9iaikge1xuICAgIHRoaXMuc291cmNlTmFtZSA9IHNvdXJjZU5hbWU7XG4gICAgdGhpcy50YXJnZXROYW1lID0gdGFyZ2V0TmFtZTtcbiAgICB0aGlzLmNvbU9iaiA9IGNvbU9iajtcbiAgICB0aGlzLmNhbGxiYWNrSWQgPSAxO1xuICAgIHRoaXMuc3RyZWFtSWQgPSAxO1xuICAgIHRoaXMuc3RyZWFtU2lua3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYWN0aW9uSGFuZGxlciA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29tT2JqLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuI29uTWVzc2FnZS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWw6IHRoaXMuI21lc3NhZ2VBQy5zaWduYWxcbiAgICB9KTtcbiAgfVxuICAjb25NZXNzYWdlKHtcbiAgICBkYXRhXG4gIH0pIHtcbiAgICBpZiAoZGF0YS50YXJnZXROYW1lICE9PSB0aGlzLnNvdXJjZU5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEuc3RyZWFtKSB7XG4gICAgICB0aGlzLiNwcm9jZXNzU3RyZWFtTWVzc2FnZShkYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEuY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrSWQgPSBkYXRhLmNhbGxiYWNrSWQ7XG4gICAgICBjb25zdCBjYXBhYmlsaXR5ID0gdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllc1tjYWxsYmFja0lkXTtcbiAgICAgIGlmICghY2FwYWJpbGl0eSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZXNvbHZlIGNhbGxiYWNrICR7Y2FsbGJhY2tJZH1gKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdO1xuICAgICAgaWYgKGRhdGEuY2FsbGJhY2sgPT09IENhbGxiYWNrS2luZC5EQVRBKSB7XG4gICAgICAgIGNhcGFiaWxpdHkucmVzb2x2ZShkYXRhLmRhdGEpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLmNhbGxiYWNrID09PSBDYWxsYmFja0tpbmQuRVJST1IpIHtcbiAgICAgICAgY2FwYWJpbGl0eS5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBjYWxsYmFjayBjYXNlXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhY3Rpb24gPSB0aGlzLmFjdGlvbkhhbmRsZXJbZGF0YS5hY3Rpb25dO1xuICAgIGlmICghYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYWN0aW9uIGZyb20gd29ya2VyOiAke2RhdGEuYWN0aW9ufWApO1xuICAgIH1cbiAgICBpZiAoZGF0YS5jYWxsYmFja0lkKSB7XG4gICAgICBjb25zdCBzb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgICB0YXJnZXROYW1lID0gZGF0YS5zb3VyY2VOYW1lLFxuICAgICAgICBjb21PYmogPSB0aGlzLmNvbU9iajtcbiAgICAgIFByb21pc2UudHJ5KGFjdGlvbiwgZGF0YS5kYXRhKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgY2FsbGJhY2s6IENhbGxiYWNrS2luZC5EQVRBLFxuICAgICAgICAgIGNhbGxiYWNrSWQ6IGRhdGEuY2FsbGJhY2tJZCxcbiAgICAgICAgICBkYXRhOiByZXN1bHRcbiAgICAgICAgfSk7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIGNhbGxiYWNrOiBDYWxsYmFja0tpbmQuRVJST1IsXG4gICAgICAgICAgY2FsbGJhY2tJZDogZGF0YS5jYWxsYmFja0lkLFxuICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhLnN0cmVhbUlkKSB7XG4gICAgICB0aGlzLiNjcmVhdGVTdHJlYW1TaW5rKGRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhY3Rpb24oZGF0YS5kYXRhKTtcbiAgfVxuICBvbihhY3Rpb25OYW1lLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgYWggPSB0aGlzLmFjdGlvbkhhbmRsZXI7XG4gICAgaWYgKGFoW2FjdGlvbk5hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIGlzIGFscmVhZHkgYW4gYWN0aW9uTmFtZSBjYWxsZWQgXCIke2FjdGlvbk5hbWV9XCJgKTtcbiAgICB9XG4gICAgYWhbYWN0aW9uTmFtZV0gPSBoYW5kbGVyO1xuICB9XG4gIHNlbmQoYWN0aW9uTmFtZSwgZGF0YSwgdHJhbnNmZXJzKSB7XG4gICAgdGhpcy5jb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgc291cmNlTmFtZTogdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgdGFyZ2V0TmFtZTogdGhpcy50YXJnZXROYW1lLFxuICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgZGF0YVxuICAgIH0sIHRyYW5zZmVycyk7XG4gIH1cbiAgc2VuZFdpdGhQcm9taXNlKGFjdGlvbk5hbWUsIGRhdGEsIHRyYW5zZmVycykge1xuICAgIGNvbnN0IGNhbGxiYWNrSWQgPSB0aGlzLmNhbGxiYWNrSWQrKztcbiAgICBjb25zdCBjYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllc1tjYWxsYmFja0lkXSA9IGNhcGFiaWxpdHk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgc291cmNlTmFtZTogdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgICB0YXJnZXROYW1lOiB0aGlzLnRhcmdldE5hbWUsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uTmFtZSxcbiAgICAgICAgY2FsbGJhY2tJZCxcbiAgICAgICAgZGF0YVxuICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgY2FwYWJpbGl0eS5yZWplY3QoZXgpO1xuICAgIH1cbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIHNlbmRXaXRoU3RyZWFtKGFjdGlvbk5hbWUsIGRhdGEsIHF1ZXVlaW5nU3RyYXRlZ3ksIHRyYW5zZmVycykge1xuICAgIGNvbnN0IHN0cmVhbUlkID0gdGhpcy5zdHJlYW1JZCsrLFxuICAgICAgc291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZSxcbiAgICAgIHRhcmdldE5hbWUgPSB0aGlzLnRhcmdldE5hbWUsXG4gICAgICBjb21PYmogPSB0aGlzLmNvbU9iajtcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIHN0YXJ0OiBjb250cm9sbGVyID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdID0ge1xuICAgICAgICAgIGNvbnRyb2xsZXIsXG4gICAgICAgICAgc3RhcnRDYWxsOiBzdGFydENhcGFiaWxpdHksXG4gICAgICAgICAgcHVsbENhbGw6IG51bGwsXG4gICAgICAgICAgY2FuY2VsQ2FsbDogbnVsbCxcbiAgICAgICAgICBpc0Nsb3NlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgZGVzaXJlZFNpemU6IGNvbnRyb2xsZXIuZGVzaXJlZFNpemVcbiAgICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgfSxcbiAgICAgIHB1bGw6IGNvbnRyb2xsZXIgPT4ge1xuICAgICAgICBjb25zdCBwdWxsQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5wdWxsQ2FsbCA9IHB1bGxDYXBhYmlsaXR5O1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTCxcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICBkZXNpcmVkU2l6ZTogY29udHJvbGxlci5kZXNpcmVkU2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHB1bGxDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9LFxuICAgICAgY2FuY2VsOiByZWFzb24gPT4ge1xuICAgICAgICBhc3NlcnQocmVhc29uIGluc3RhbmNlb2YgRXJyb3IsIFwiY2FuY2VsIG11c3QgaGF2ZSBhIHZhbGlkIHJlYXNvblwiKTtcbiAgICAgICAgY29uc3QgY2FuY2VsQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5jYW5jZWxDYWxsID0gY2FuY2VsQ2FwYWJpbGl0eTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0FOQ0VMLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2FuY2VsQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgfVxuICAgIH0sIHF1ZXVlaW5nU3RyYXRlZ3kpO1xuICB9XG4gICNjcmVhdGVTdHJlYW1TaW5rKGRhdGEpIHtcbiAgICBjb25zdCBzdHJlYW1JZCA9IGRhdGEuc3RyZWFtSWQsXG4gICAgICBzb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgdGFyZ2V0TmFtZSA9IGRhdGEuc291cmNlTmFtZSxcbiAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLFxuICAgICAgYWN0aW9uID0gdGhpcy5hY3Rpb25IYW5kbGVyW2RhdGEuYWN0aW9uXTtcbiAgICBjb25zdCBzdHJlYW1TaW5rID0ge1xuICAgICAgZW5xdWV1ZShjaHVuaywgc2l6ZSA9IDEsIHRyYW5zZmVycykge1xuICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0RGVzaXJlZFNpemUgPSB0aGlzLmRlc2lyZWRTaXplO1xuICAgICAgICB0aGlzLmRlc2lyZWRTaXplIC09IHNpemU7XG4gICAgICAgIGlmIChsYXN0RGVzaXJlZFNpemUgPiAwICYmIHRoaXMuZGVzaXJlZFNpemUgPD0gMCkge1xuICAgICAgICAgIHRoaXMuc2lua0NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgICAgICB0aGlzLnJlYWR5ID0gdGhpcy5zaW5rQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5FTlFVRVVFLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIGNodW5rXG4gICAgICAgIH0sIHRyYW5zZmVycyk7XG4gICAgICB9LFxuICAgICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0xPU0UsXG4gICAgICAgICAgc3RyZWFtSWRcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZSBzZWxmLnN0cmVhbVNpbmtzW3N0cmVhbUlkXTtcbiAgICAgIH0sXG4gICAgICBlcnJvcihyZWFzb24pIHtcbiAgICAgICAgYXNzZXJ0KHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yLCBcImVycm9yIG11c3QgaGF2ZSBhIHZhbGlkIHJlYXNvblwiKTtcbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5FUlJPUixcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBzaW5rQ2FwYWJpbGl0eTogUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCksXG4gICAgICBvblB1bGw6IG51bGwsXG4gICAgICBvbkNhbmNlbDogbnVsbCxcbiAgICAgIGlzQ2FuY2VsbGVkOiBmYWxzZSxcbiAgICAgIGRlc2lyZWRTaXplOiBkYXRhLmRlc2lyZWRTaXplLFxuICAgICAgcmVhZHk6IG51bGxcbiAgICB9O1xuICAgIHN0cmVhbVNpbmsuc2lua0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIHN0cmVhbVNpbmsucmVhZHkgPSBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF0gPSBzdHJlYW1TaW5rO1xuICAgIFByb21pc2UudHJ5KGFjdGlvbiwgZGF0YS5kYXRhLCBzdHJlYW1TaW5rKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5TVEFSVF9DT01QTEVURSxcbiAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5TVEFSVF9DT01QTEVURSxcbiAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAjcHJvY2Vzc1N0cmVhbU1lc3NhZ2UoZGF0YSkge1xuICAgIGNvbnN0IHN0cmVhbUlkID0gZGF0YS5zdHJlYW1JZCxcbiAgICAgIHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICB0YXJnZXROYW1lID0gZGF0YS5zb3VyY2VOYW1lLFxuICAgICAgY29tT2JqID0gdGhpcy5jb21PYmo7XG4gICAgY29uc3Qgc3RyZWFtQ29udHJvbGxlciA9IHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLFxuICAgICAgc3RyZWFtU2luayA9IHRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdO1xuICAgIHN3aXRjaCAoZGF0YS5zdHJlYW0pIHtcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5TVEFSVF9DT01QTEVURTpcbiAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuc3RhcnRDYWxsLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnN0YXJ0Q2FsbC5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEU6XG4gICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnB1bGxDYWxsLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnB1bGxDYWxsLnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuUFVMTDpcbiAgICAgICAgaWYgKCFzdHJlYW1TaW5rKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtU2luay5kZXNpcmVkU2l6ZSA8PSAwICYmIGRhdGEuZGVzaXJlZFNpemUgPiAwKSB7XG4gICAgICAgICAgc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtU2luay5kZXNpcmVkU2l6ZSA9IGRhdGEuZGVzaXJlZFNpemU7XG4gICAgICAgIFByb21pc2UudHJ5KHN0cmVhbVNpbmsub25QdWxsIHx8IG9uRm4pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkVOUVVFVUU6XG4gICAgICAgIGFzc2VydChzdHJlYW1Db250cm9sbGVyLCBcImVucXVldWUgc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXJcIik7XG4gICAgICAgIGlmIChzdHJlYW1Db250cm9sbGVyLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jb250cm9sbGVyLmVucXVldWUoZGF0YS5jaHVuayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkNMT1NFOlxuICAgICAgICBhc3NlcnQoc3RyZWFtQ29udHJvbGxlciwgXCJjbG9zZSBzaG91bGQgaGF2ZSBzdHJlYW0gY29udHJvbGxlclwiKTtcbiAgICAgICAgaWYgKHN0cmVhbUNvbnRyb2xsZXIuaXNDbG9zZWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuI2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlciwgc3RyZWFtSWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5FUlJPUjpcbiAgICAgICAgYXNzZXJ0KHN0cmVhbUNvbnRyb2xsZXIsIFwiZXJyb3Igc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXJcIik7XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY29udHJvbGxlci5lcnJvcih3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIHRoaXMuI2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlciwgc3RyZWFtSWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5DQU5DRUxfQ09NUExFVEU6XG4gICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNhbmNlbENhbGwucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY2FuY2VsQ2FsbC5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlciwgc3RyZWFtSWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5DQU5DRUw6XG4gICAgICAgIGlmICghc3RyZWFtU2luaykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFSZWFzb24gPSB3cmFwUmVhc29uKGRhdGEucmVhc29uKTtcbiAgICAgICAgUHJvbWlzZS50cnkoc3RyZWFtU2luay5vbkNhbmNlbCB8fCBvbkZuLCBkYXRhUmVhc29uKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0FOQ0VMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0FOQ0VMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5yZWplY3QoZGF0YVJlYXNvbik7XG4gICAgICAgIHN0cmVhbVNpbmsuaXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICBkZWxldGUgdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBzdHJlYW0gY2FzZVwiKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgI2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlciwgc3RyZWFtSWQpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoW3N0cmVhbUNvbnRyb2xsZXIuc3RhcnRDYWxsPy5wcm9taXNlLCBzdHJlYW1Db250cm9sbGVyLnB1bGxDYWxsPy5wcm9taXNlLCBzdHJlYW1Db250cm9sbGVyLmNhbmNlbENhbGw/LnByb21pc2VdKTtcbiAgICBkZWxldGUgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF07XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNtZXNzYWdlQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jbWVzc2FnZUFDID0gbnVsbDtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9jYW52YXNfZmFjdG9yeS5qc1xuXG5jbGFzcyBCYXNlQ2FudmFzRmFjdG9yeSB7XG4gICNlbmFibGVIV0EgPSBmYWxzZTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGVuYWJsZUhXQSA9IGZhbHNlXG4gIH0pIHtcbiAgICB0aGlzLiNlbmFibGVIV0EgPSBlbmFibGVIV0E7XG4gIH1cbiAgY3JlYXRlKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjYW52YXMgc2l6ZVwiKTtcbiAgICB9XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5fY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgIHJldHVybiB7XG4gICAgICBjYW52YXMsXG4gICAgICBjb250ZXh0OiBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiAhdGhpcy4jZW5hYmxlSFdBXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgcmVzZXQoY2FudmFzQW5kQ29udGV4dCwgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghY2FudmFzQW5kQ29udGV4dC5jYW52YXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBpcyBub3Qgc3BlY2lmaWVkXCIpO1xuICAgIH1cbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjYW52YXMgc2l6ZVwiKTtcbiAgICB9XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgZGVzdHJveShjYW52YXNBbmRDb250ZXh0KSB7XG4gICAgaWYgKCFjYW52YXNBbmRDb250ZXh0LmNhbnZhcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIG5vdCBzcGVjaWZpZWRcIik7XG4gICAgfVxuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLndpZHRoID0gMDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzID0gbnVsbDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNvbnRleHQgPSBudWxsO1xuICB9XG4gIF9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBfY3JlYXRlQ2FudmFzYCBjYWxsZWQuXCIpO1xuICB9XG59XG5jbGFzcyBET01DYW52YXNGYWN0b3J5IGV4dGVuZHMgQmFzZUNhbnZhc0ZhY3Rvcnkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgb3duZXJEb2N1bWVudCA9IGdsb2JhbFRoaXMuZG9jdW1lbnQsXG4gICAgZW5hYmxlSFdBID0gZmFsc2VcbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGVuYWJsZUhXQVxuICAgIH0pO1xuICAgIHRoaXMuX2RvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgfVxuICBfY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9jbWFwX3JlYWRlcl9mYWN0b3J5LmpzXG5cblxuY2xhc3MgQmFzZUNNYXBSZWFkZXJGYWN0b3J5IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGJhc2VVcmwgPSBudWxsLFxuICAgIGlzQ29tcHJlc3NlZCA9IHRydWVcbiAgfSkge1xuICAgIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gICAgdGhpcy5pc0NvbXByZXNzZWQgPSBpc0NvbXByZXNzZWQ7XG4gIH1cbiAgYXN5bmMgZmV0Y2goe1xuICAgIG5hbWVcbiAgfSkge1xuICAgIGlmICghdGhpcy5iYXNlVXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhhdCB0aGUgYGNNYXBVcmxgIGFuZCBgY01hcFBhY2tlZGAgQVBJIHBhcmFtZXRlcnMgYXJlIHByb3ZpZGVkLlwiKTtcbiAgICB9XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDTWFwIG5hbWUgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSB0aGlzLmJhc2VVcmwgKyBuYW1lICsgKHRoaXMuaXNDb21wcmVzc2VkID8gXCIuYmNtYXBcIiA6IFwiXCIpO1xuICAgIHJldHVybiB0aGlzLl9mZXRjaCh1cmwpLnRoZW4oY01hcERhdGEgPT4gKHtcbiAgICAgIGNNYXBEYXRhLFxuICAgICAgaXNDb21wcmVzc2VkOiB0aGlzLmlzQ29tcHJlc3NlZFxuICAgIH0pKS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbG9hZCAke3RoaXMuaXNDb21wcmVzc2VkID8gXCJiaW5hcnkgXCIgOiBcIlwifUNNYXAgYXQ6ICR7dXJsfWApO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgX2ZldGNoYCBjYWxsZWQuXCIpO1xuICB9XG59XG5jbGFzcyBET01DTWFwUmVhZGVyRmFjdG9yeSBleHRlbmRzIEJhc2VDTWFwUmVhZGVyRmFjdG9yeSB7XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgZmV0Y2hEYXRhKHVybCwgdGhpcy5pc0NvbXByZXNzZWQgPyBcImFycmF5YnVmZmVyXCIgOiBcInRleHRcIik7XG4gICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IG5ldyBVaW50OEFycmF5KGRhdGEpIDogc3RyaW5nVG9CeXRlcyhkYXRhKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9maWx0ZXJfZmFjdG9yeS5qc1xuXG5cbmNsYXNzIEJhc2VGaWx0ZXJGYWN0b3J5IHtcbiAgYWRkRmlsdGVyKG1hcHMpIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgYWRkSENNRmlsdGVyKGZnQ29sb3IsIGJnQ29sb3IpIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgYWRkQWxwaGFGaWx0ZXIobWFwKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGFkZEx1bWlub3NpdHlGaWx0ZXIobWFwKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGFkZEhpZ2hsaWdodEhDTUZpbHRlcihmaWx0ZXJOYW1lLCBmZ0NvbG9yLCBiZ0NvbG9yLCBuZXdGZ0NvbG9yLCBuZXdCZ0NvbG9yKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGRlc3Ryb3koa2VlcEhDTSA9IGZhbHNlKSB7fVxufVxuY2xhc3MgRE9NRmlsdGVyRmFjdG9yeSBleHRlbmRzIEJhc2VGaWx0ZXJGYWN0b3J5IHtcbiAgI2Jhc2VVcmw7XG4gICNfY2FjaGU7XG4gICNfZGVmcztcbiAgI2RvY0lkO1xuICAjZG9jdW1lbnQ7XG4gICNfaGNtQ2FjaGU7XG4gICNpZCA9IDA7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkb2NJZCxcbiAgICBvd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcy5kb2N1bWVudFxuICB9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNkb2NJZCA9IGRvY0lkO1xuICAgIHRoaXMuI2RvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgfVxuICBnZXQgI2NhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLiNfY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXQgI2hjbUNhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLiNfaGNtQ2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXQgI2RlZnMoKSB7XG4gICAgaWYgKCF0aGlzLiNfZGVmcykge1xuICAgICAgY29uc3QgZGl2ID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3R5bGVcbiAgICAgIH0gPSBkaXY7XG4gICAgICBzdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgIHN0eWxlLmNvbnRhaW4gPSBcInN0cmljdFwiO1xuICAgICAgc3R5bGUud2lkdGggPSBzdHlsZS5oZWlnaHQgPSAwO1xuICAgICAgc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICBzdHlsZS50b3AgPSBzdHlsZS5sZWZ0ID0gMDtcbiAgICAgIHN0eWxlLnpJbmRleCA9IC0xO1xuICAgICAgY29uc3Qgc3ZnID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJzdmdcIik7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgMCk7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIDApO1xuICAgICAgdGhpcy4jX2RlZnMgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImRlZnNcIik7XG4gICAgICBkaXYuYXBwZW5kKHN2Zyk7XG4gICAgICBzdmcuYXBwZW5kKHRoaXMuI19kZWZzKTtcbiAgICAgIHRoaXMuI2RvY3VtZW50LmJvZHkuYXBwZW5kKGRpdik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNfZGVmcztcbiAgfVxuICAjY3JlYXRlVGFibGVzKG1hcHMpIHtcbiAgICBpZiAobWFwcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IG1hcFIgPSBtYXBzWzBdO1xuICAgICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5KDI1Nik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIGJ1ZmZlcltpXSA9IG1hcFJbaV0gLyAyNTU7XG4gICAgICB9XG4gICAgICBjb25zdCB0YWJsZSA9IGJ1ZmZlci5qb2luKFwiLFwiKTtcbiAgICAgIHJldHVybiBbdGFibGUsIHRhYmxlLCB0YWJsZV07XG4gICAgfVxuICAgIGNvbnN0IFttYXBSLCBtYXBHLCBtYXBCXSA9IG1hcHM7XG4gICAgY29uc3QgYnVmZmVyUiA9IG5ldyBBcnJheSgyNTYpO1xuICAgIGNvbnN0IGJ1ZmZlckcgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICBjb25zdCBidWZmZXJCID0gbmV3IEFycmF5KDI1Nik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgYnVmZmVyUltpXSA9IG1hcFJbaV0gLyAyNTU7XG4gICAgICBidWZmZXJHW2ldID0gbWFwR1tpXSAvIDI1NTtcbiAgICAgIGJ1ZmZlckJbaV0gPSBtYXBCW2ldIC8gMjU1O1xuICAgIH1cbiAgICByZXR1cm4gW2J1ZmZlclIuam9pbihcIixcIiksIGJ1ZmZlckcuam9pbihcIixcIiksIGJ1ZmZlckIuam9pbihcIixcIildO1xuICB9XG4gICNjcmVhdGVVcmwoaWQpIHtcbiAgICBpZiAodGhpcy4jYmFzZVVybCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLiNiYXNlVXJsID0gXCJcIjtcbiAgICAgIGNvbnN0IHVybCA9IHRoaXMuI2RvY3VtZW50LlVSTDtcbiAgICAgIGlmICh1cmwgIT09IHRoaXMuI2RvY3VtZW50LmJhc2VVUkkpIHtcbiAgICAgICAgaWYgKGlzRGF0YVNjaGVtZSh1cmwpKSB7XG4gICAgICAgICAgd2FybignI2NyZWF0ZVVybDogaWdub3JlIFwiZGF0YTpcIi1VUkwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4jYmFzZVVybCA9IHVwZGF0ZVVybEhhc2godXJsLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYHVybCgke3RoaXMuI2Jhc2VVcmx9IyR7aWR9KWA7XG4gIH1cbiAgYWRkRmlsdGVyKG1hcHMpIHtcbiAgICBpZiAoIW1hcHMpIHtcbiAgICAgIHJldHVybiBcIm5vbmVcIjtcbiAgICB9XG4gICAgbGV0IHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KG1hcHMpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBbdGFibGVSLCB0YWJsZUcsIHRhYmxlQl0gPSB0aGlzLiNjcmVhdGVUYWJsZXMobWFwcyk7XG4gICAgY29uc3Qga2V5ID0gbWFwcy5sZW5ndGggPT09IDEgPyB0YWJsZVIgOiBgJHt0YWJsZVJ9JHt0YWJsZUd9JHt0YWJsZUJ9YDtcbiAgICB2YWx1ZSA9IHRoaXMuI2NhY2hlLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy4jY2FjaGUuc2V0KG1hcHMsIHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV90cmFuc2Zlcl9tYXBfJHt0aGlzLiNpZCsrfWA7XG4gICAgY29uc3QgdXJsID0gdGhpcy4jY3JlYXRlVXJsKGlkKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQobWFwcywgdXJsKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQoa2V5LCB1cmwpO1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKHRhYmxlUiwgdGFibGVHLCB0YWJsZUIsIGZpbHRlcik7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBhZGRIQ01GaWx0ZXIoZmdDb2xvciwgYmdDb2xvcikge1xuICAgIGNvbnN0IGtleSA9IGAke2ZnQ29sb3J9LSR7YmdDb2xvcn1gO1xuICAgIGNvbnN0IGZpbHRlck5hbWUgPSBcImJhc2VcIjtcbiAgICBsZXQgaW5mbyA9IHRoaXMuI2hjbUNhY2hlLmdldChmaWx0ZXJOYW1lKTtcbiAgICBpZiAoaW5mbz8ua2V5ID09PSBrZXkpIHtcbiAgICAgIHJldHVybiBpbmZvLnVybDtcbiAgICB9XG4gICAgaWYgKGluZm8pIHtcbiAgICAgIGluZm8uZmlsdGVyPy5yZW1vdmUoKTtcbiAgICAgIGluZm8ua2V5ID0ga2V5O1xuICAgICAgaW5mby51cmwgPSBcIm5vbmVcIjtcbiAgICAgIGluZm8uZmlsdGVyID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyA9IHtcbiAgICAgICAga2V5LFxuICAgICAgICB1cmw6IFwibm9uZVwiLFxuICAgICAgICBmaWx0ZXI6IG51bGxcbiAgICAgIH07XG4gICAgICB0aGlzLiNoY21DYWNoZS5zZXQoZmlsdGVyTmFtZSwgaW5mbyk7XG4gICAgfVxuICAgIGlmICghZmdDb2xvciB8fCAhYmdDb2xvcikge1xuICAgICAgcmV0dXJuIGluZm8udXJsO1xuICAgIH1cbiAgICBjb25zdCBmZ1JHQiA9IHRoaXMuI2dldFJHQihmZ0NvbG9yKTtcbiAgICBmZ0NvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4uZmdSR0IpO1xuICAgIGNvbnN0IGJnUkdCID0gdGhpcy4jZ2V0UkdCKGJnQ29sb3IpO1xuICAgIGJnQ29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvciguLi5iZ1JHQik7XG4gICAgdGhpcy4jZGVmcy5zdHlsZS5jb2xvciA9IFwiXCI7XG4gICAgaWYgKGZnQ29sb3IgPT09IFwiIzAwMDAwMFwiICYmIGJnQ29sb3IgPT09IFwiI2ZmZmZmZlwiIHx8IGZnQ29sb3IgPT09IGJnQ29sb3IpIHtcbiAgICAgIHJldHVybiBpbmZvLnVybDtcbiAgICB9XG4gICAgY29uc3QgbWFwID0gbmV3IEFycmF5KDI1Nik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMjU1OyBpKyspIHtcbiAgICAgIGNvbnN0IHggPSBpIC8gMjU1O1xuICAgICAgbWFwW2ldID0geCA8PSAwLjAzOTI4ID8geCAvIDEyLjkyIDogKCh4ICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNDtcbiAgICB9XG4gICAgY29uc3QgdGFibGUgPSBtYXAuam9pbihcIixcIik7XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV9oY21fZmlsdGVyYDtcbiAgICBjb25zdCBmaWx0ZXIgPSBpbmZvLmZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKHRhYmxlLCB0YWJsZSwgdGFibGUsIGZpbHRlcik7XG4gICAgdGhpcy4jYWRkR3JheUNvbnZlcnNpb24oZmlsdGVyKTtcbiAgICBjb25zdCBnZXRTdGVwcyA9IChjLCBuKSA9PiB7XG4gICAgICBjb25zdCBzdGFydCA9IGZnUkdCW2NdIC8gMjU1O1xuICAgICAgY29uc3QgZW5kID0gYmdSR0JbY10gLyAyNTU7XG4gICAgICBjb25zdCBhcnIgPSBuZXcgQXJyYXkobiArIDEpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbjsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IHN0YXJ0ICsgaSAvIG4gKiAoZW5kIC0gc3RhcnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyci5qb2luKFwiLFwiKTtcbiAgICB9O1xuICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQ29udmVyc2lvbihnZXRTdGVwcygwLCA1KSwgZ2V0U3RlcHMoMSwgNSksIGdldFN0ZXBzKDIsIDUpLCBmaWx0ZXIpO1xuICAgIGluZm8udXJsID0gdGhpcy4jY3JlYXRlVXJsKGlkKTtcbiAgICByZXR1cm4gaW5mby51cmw7XG4gIH1cbiAgYWRkQWxwaGFGaWx0ZXIobWFwKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KG1hcCk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IFt0YWJsZUFdID0gdGhpcy4jY3JlYXRlVGFibGVzKFttYXBdKTtcbiAgICBjb25zdCBrZXkgPSBgYWxwaGFfJHt0YWJsZUF9YDtcbiAgICB2YWx1ZSA9IHRoaXMuI2NhY2hlLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy4jY2FjaGUuc2V0KG1hcCwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X2FscGhhX21hcF8ke3RoaXMuI2lkKyt9YDtcbiAgICBjb25zdCB1cmwgPSB0aGlzLiNjcmVhdGVVcmwoaWQpO1xuICAgIHRoaXMuI2NhY2hlLnNldChtYXAsIHVybCk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KGtleSwgdXJsKTtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLiNjcmVhdGVGaWx0ZXIoaWQpO1xuICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQWxwaGFDb252ZXJzaW9uKHRhYmxlQSwgZmlsdGVyKTtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGFkZEx1bWlub3NpdHlGaWx0ZXIobWFwKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KG1hcCB8fCBcImx1bWlub3NpdHlcIik7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGxldCB0YWJsZUEsIGtleTtcbiAgICBpZiAobWFwKSB7XG4gICAgICBbdGFibGVBXSA9IHRoaXMuI2NyZWF0ZVRhYmxlcyhbbWFwXSk7XG4gICAgICBrZXkgPSBgbHVtaW5vc2l0eV8ke3RhYmxlQX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBcImx1bWlub3NpdHlcIjtcbiAgICB9XG4gICAgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuI2NhY2hlLnNldChtYXAsIHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV9sdW1pbm9zaXR5X21hcF8ke3RoaXMuI2lkKyt9YDtcbiAgICBjb25zdCB1cmwgPSB0aGlzLiNjcmVhdGVVcmwoaWQpO1xuICAgIHRoaXMuI2NhY2hlLnNldChtYXAsIHVybCk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KGtleSwgdXJsKTtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLiNjcmVhdGVGaWx0ZXIoaWQpO1xuICAgIHRoaXMuI2FkZEx1bWlub3NpdHlDb252ZXJzaW9uKGZpbHRlcik7XG4gICAgaWYgKG1hcCkge1xuICAgICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBBbHBoYUNvbnZlcnNpb24odGFibGVBLCBmaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGFkZEhpZ2hsaWdodEhDTUZpbHRlcihmaWx0ZXJOYW1lLCBmZ0NvbG9yLCBiZ0NvbG9yLCBuZXdGZ0NvbG9yLCBuZXdCZ0NvbG9yKSB7XG4gICAgY29uc3Qga2V5ID0gYCR7ZmdDb2xvcn0tJHtiZ0NvbG9yfS0ke25ld0ZnQ29sb3J9LSR7bmV3QmdDb2xvcn1gO1xuICAgIGxldCBpbmZvID0gdGhpcy4jaGNtQ2FjaGUuZ2V0KGZpbHRlck5hbWUpO1xuICAgIGlmIChpbmZvPy5rZXkgPT09IGtleSkge1xuICAgICAgcmV0dXJuIGluZm8udXJsO1xuICAgIH1cbiAgICBpZiAoaW5mbykge1xuICAgICAgaW5mby5maWx0ZXI/LnJlbW92ZSgpO1xuICAgICAgaW5mby5rZXkgPSBrZXk7XG4gICAgICBpbmZvLnVybCA9IFwibm9uZVwiO1xuICAgICAgaW5mby5maWx0ZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvID0ge1xuICAgICAgICBrZXksXG4gICAgICAgIHVybDogXCJub25lXCIsXG4gICAgICAgIGZpbHRlcjogbnVsbFxuICAgICAgfTtcbiAgICAgIHRoaXMuI2hjbUNhY2hlLnNldChmaWx0ZXJOYW1lLCBpbmZvKTtcbiAgICB9XG4gICAgaWYgKCFmZ0NvbG9yIHx8ICFiZ0NvbG9yKSB7XG4gICAgICByZXR1cm4gaW5mby51cmw7XG4gICAgfVxuICAgIGNvbnN0IFtmZ1JHQiwgYmdSR0JdID0gW2ZnQ29sb3IsIGJnQ29sb3JdLm1hcCh0aGlzLiNnZXRSR0IuYmluZCh0aGlzKSk7XG4gICAgbGV0IGZnR3JheSA9IE1hdGgucm91bmQoMC4yMTI2ICogZmdSR0JbMF0gKyAwLjcxNTIgKiBmZ1JHQlsxXSArIDAuMDcyMiAqIGZnUkdCWzJdKTtcbiAgICBsZXQgYmdHcmF5ID0gTWF0aC5yb3VuZCgwLjIxMjYgKiBiZ1JHQlswXSArIDAuNzE1MiAqIGJnUkdCWzFdICsgMC4wNzIyICogYmdSR0JbMl0pO1xuICAgIGxldCBbbmV3RmdSR0IsIG5ld0JnUkdCXSA9IFtuZXdGZ0NvbG9yLCBuZXdCZ0NvbG9yXS5tYXAodGhpcy4jZ2V0UkdCLmJpbmQodGhpcykpO1xuICAgIGlmIChiZ0dyYXkgPCBmZ0dyYXkpIHtcbiAgICAgIFtmZ0dyYXksIGJnR3JheSwgbmV3RmdSR0IsIG5ld0JnUkdCXSA9IFtiZ0dyYXksIGZnR3JheSwgbmV3QmdSR0IsIG5ld0ZnUkdCXTtcbiAgICB9XG4gICAgdGhpcy4jZGVmcy5zdHlsZS5jb2xvciA9IFwiXCI7XG4gICAgY29uc3QgZ2V0U3RlcHMgPSAoZmcsIGJnLCBuKSA9PiB7XG4gICAgICBjb25zdCBhcnIgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICAgIGNvbnN0IHN0ZXAgPSAoYmdHcmF5IC0gZmdHcmF5KSAvIG47XG4gICAgICBjb25zdCBuZXdTdGFydCA9IGZnIC8gMjU1O1xuICAgICAgY29uc3QgbmV3U3RlcCA9IChiZyAtIGZnKSAvICgyNTUgKiBuKTtcbiAgICAgIGxldCBwcmV2ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG47IGkrKykge1xuICAgICAgICBjb25zdCBrID0gTWF0aC5yb3VuZChmZ0dyYXkgKyBpICogc3RlcCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbmV3U3RhcnQgKyBpICogbmV3U3RlcDtcbiAgICAgICAgZm9yIChsZXQgaiA9IHByZXY7IGogPD0gazsgaisrKSB7XG4gICAgICAgICAgYXJyW2pdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcHJldiA9IGsgKyAxO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IHByZXY7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBhcnJbcHJldiAtIDFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyci5qb2luKFwiLFwiKTtcbiAgICB9O1xuICAgIGNvbnN0IGlkID0gYGdfJHt0aGlzLiNkb2NJZH1faGNtXyR7ZmlsdGVyTmFtZX1fZmlsdGVyYDtcbiAgICBjb25zdCBmaWx0ZXIgPSBpbmZvLmZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkR3JheUNvbnZlcnNpb24oZmlsdGVyKTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24oZ2V0U3RlcHMobmV3RmdSR0JbMF0sIG5ld0JnUkdCWzBdLCA1KSwgZ2V0U3RlcHMobmV3RmdSR0JbMV0sIG5ld0JnUkdCWzFdLCA1KSwgZ2V0U3RlcHMobmV3RmdSR0JbMl0sIG5ld0JnUkdCWzJdLCA1KSwgZmlsdGVyKTtcbiAgICBpbmZvLnVybCA9IHRoaXMuI2NyZWF0ZVVybChpZCk7XG4gICAgcmV0dXJuIGluZm8udXJsO1xuICB9XG4gIGRlc3Ryb3koa2VlcEhDTSA9IGZhbHNlKSB7XG4gICAgaWYgKGtlZXBIQ00gJiYgdGhpcy4jX2hjbUNhY2hlPy5zaXplKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI19kZWZzPy5wYXJlbnROb2RlLnBhcmVudE5vZGUucmVtb3ZlKCk7XG4gICAgdGhpcy4jX2RlZnMgPSBudWxsO1xuICAgIHRoaXMuI19jYWNoZT8uY2xlYXIoKTtcbiAgICB0aGlzLiNfY2FjaGUgPSBudWxsO1xuICAgIHRoaXMuI19oY21DYWNoZT8uY2xlYXIoKTtcbiAgICB0aGlzLiNfaGNtQ2FjaGUgPSBudWxsO1xuICAgIHRoaXMuI2lkID0gMDtcbiAgfVxuICAjYWRkTHVtaW5vc2l0eUNvbnZlcnNpb24oZmlsdGVyKSB7XG4gICAgY29uc3QgZmVDb2xvck1hdHJpeCA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZmVDb2xvck1hdHJpeFwiKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJtYXRyaXhcIik7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZXNcIiwgXCIwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwLjMgMC41OSAwLjExIDAgMFwiKTtcbiAgICBmaWx0ZXIuYXBwZW5kKGZlQ29sb3JNYXRyaXgpO1xuICB9XG4gICNhZGRHcmF5Q29udmVyc2lvbihmaWx0ZXIpIHtcbiAgICBjb25zdCBmZUNvbG9yTWF0cml4ID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmZUNvbG9yTWF0cml4XCIpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcIm1hdHJpeFwiKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZShcInZhbHVlc1wiLCBcIjAuMjEyNiAwLjcxNTIgMC4wNzIyIDAgMCAwLjIxMjYgMC43MTUyIDAuMDcyMiAwIDAgMC4yMTI2IDAuNzE1MiAwLjA3MjIgMCAwIDAgMCAwIDEgMFwiKTtcbiAgICBmaWx0ZXIuYXBwZW5kKGZlQ29sb3JNYXRyaXgpO1xuICB9XG4gICNjcmVhdGVGaWx0ZXIoaWQpIHtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImZpbHRlclwiKTtcbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKFwiY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzXCIsIFwic1JHQlwiKTtcbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKFwiaWRcIiwgaWQpO1xuICAgIHRoaXMuI2RlZnMuYXBwZW5kKGZpbHRlcik7XG4gICAgcmV0dXJuIGZpbHRlcjtcbiAgfVxuICAjYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIGZ1bmMsIHRhYmxlKSB7XG4gICAgY29uc3QgZmVGdW5jID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgZnVuYyk7XG4gICAgZmVGdW5jLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJkaXNjcmV0ZVwiKTtcbiAgICBmZUZ1bmMuc2V0QXR0cmlidXRlKFwidGFibGVWYWx1ZXNcIiwgdGFibGUpO1xuICAgIGZlQ29tcG9uZW50VHJhbnNmZXIuYXBwZW5kKGZlRnVuYyk7XG4gIH1cbiAgI2FkZFRyYW5zZmVyTWFwQ29udmVyc2lvbihyVGFibGUsIGdUYWJsZSwgYlRhYmxlLCBmaWx0ZXIpIHtcbiAgICBjb25zdCBmZUNvbXBvbmVudFRyYW5zZmVyID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmZUNvbXBvbmVudFRyYW5zZmVyXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gICAgdGhpcy4jYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIFwiZmVGdW5jUlwiLCByVGFibGUpO1xuICAgIHRoaXMuI2FwcGVuZEZlRnVuYyhmZUNvbXBvbmVudFRyYW5zZmVyLCBcImZlRnVuY0dcIiwgZ1RhYmxlKTtcbiAgICB0aGlzLiNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgXCJmZUZ1bmNCXCIsIGJUYWJsZSk7XG4gIH1cbiAgI2FkZFRyYW5zZmVyTWFwQWxwaGFDb252ZXJzaW9uKGFUYWJsZSwgZmlsdGVyKSB7XG4gICAgY29uc3QgZmVDb21wb25lbnRUcmFuc2ZlciA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZmVDb21wb25lbnRUcmFuc2ZlclwiKTtcbiAgICBmaWx0ZXIuYXBwZW5kKGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgIHRoaXMuI2FwcGVuZEZlRnVuYyhmZUNvbXBvbmVudFRyYW5zZmVyLCBcImZlRnVuY0FcIiwgYVRhYmxlKTtcbiAgfVxuICAjZ2V0UkdCKGNvbG9yKSB7XG4gICAgdGhpcy4jZGVmcy5zdHlsZS5jb2xvciA9IGNvbG9yO1xuICAgIHJldHVybiBnZXRSR0IoZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiNkZWZzKS5nZXRQcm9wZXJ0eVZhbHVlKFwiY29sb3JcIikpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3N0YW5kYXJkX2ZvbnRkYXRhX2ZhY3RvcnkuanNcblxuXG5jbGFzcyBCYXNlU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmFzZVVybCA9IG51bGxcbiAgfSkge1xuICAgIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gIH1cbiAgYXN5bmMgZmV0Y2goe1xuICAgIGZpbGVuYW1lXG4gIH0pIHtcbiAgICBpZiAoIXRoaXMuYmFzZVVybCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoYXQgdGhlIGBzdGFuZGFyZEZvbnREYXRhVXJsYCBBUEkgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLlwiKTtcbiAgICB9XG4gICAgaWYgKCFmaWxlbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRm9udCBmaWxlbmFtZSBtdXN0IGJlIHNwZWNpZmllZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYmFzZVVybH0ke2ZpbGVuYW1lfWA7XG4gICAgcmV0dXJuIHRoaXMuX2ZldGNoKHVybCkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGxvYWQgZm9udCBkYXRhIGF0OiAke3VybH1gKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBfZmV0Y2godXJsKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYF9mZXRjaGAgY2FsbGVkLlwiKTtcbiAgfVxufVxuY2xhc3MgRE9NU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgZXh0ZW5kcyBCYXNlU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkge1xuICBhc3luYyBfZmV0Y2godXJsKSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGZldGNoRGF0YSh1cmwsIFwiYXJyYXlidWZmZXJcIik7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3dhc21fZmFjdG9yeS5qc1xuXG5cbmNsYXNzIEJhc2VXYXNtRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBiYXNlVXJsID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgfVxuICBhc3luYyBmZXRjaCh7XG4gICAgZmlsZW5hbWVcbiAgfSkge1xuICAgIGlmICghdGhpcy5iYXNlVXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhhdCB0aGUgYHdhc21VcmxgIEFQSSBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIWZpbGVuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXYXNtIGZpbGVuYW1lIG11c3QgYmUgc3BlY2lmaWVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gYCR7dGhpcy5iYXNlVXJsfSR7ZmlsZW5hbWV9YDtcbiAgICByZXR1cm4gdGhpcy5fZmV0Y2godXJsKS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbG9hZCB3YXNtIGRhdGEgYXQ6ICR7dXJsfWApO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgX2ZldGNoYCBjYWxsZWQuXCIpO1xuICB9XG59XG5jbGFzcyBET01XYXNtRmFjdG9yeSBleHRlbmRzIEJhc2VXYXNtRmFjdG9yeSB7XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgZmV0Y2hEYXRhKHVybCwgXCJhcnJheWJ1ZmZlclwiKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvbm9kZV91dGlscy5qc1xuXG5cblxuXG5cblxuaWYgKGlzTm9kZUpTKSB7XG4gIHdhcm4oXCJQbGVhc2UgdXNlIHRoZSBgbGVnYWN5YCBidWlsZCBpbiBOb2RlLmpzIGVudmlyb25tZW50cy5cIik7XG59XG5hc3luYyBmdW5jdGlvbiBub2RlX3V0aWxzX2ZldGNoRGF0YSh1cmwpIHtcbiAgY29uc3QgZnMgPSBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGUoXCJmc1wiKTtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IGZzLnByb21pc2VzLnJlYWRGaWxlKHVybCk7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhKTtcbn1cbmNsYXNzIE5vZGVGaWx0ZXJGYWN0b3J5IGV4dGVuZHMgQmFzZUZpbHRlckZhY3Rvcnkge31cbmNsYXNzIE5vZGVDYW52YXNGYWN0b3J5IGV4dGVuZHMgQmFzZUNhbnZhc0ZhY3Rvcnkge1xuICBfY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByZXF1aXJlID0gcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlKFwibW9kdWxlXCIpLmNyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKTtcbiAgICBjb25zdCBjYW52YXMgPSByZXF1aXJlKFwiQG5hcGktcnMvY2FudmFzXCIpO1xuICAgIHJldHVybiBjYW52YXMuY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICB9XG59XG5jbGFzcyBOb2RlQ01hcFJlYWRlckZhY3RvcnkgZXh0ZW5kcyBCYXNlQ01hcFJlYWRlckZhY3Rvcnkge1xuICBhc3luYyBfZmV0Y2godXJsKSB7XG4gICAgcmV0dXJuIG5vZGVfdXRpbHNfZmV0Y2hEYXRhKHVybCk7XG4gIH1cbn1cbmNsYXNzIE5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSBleHRlbmRzIEJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB7XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICByZXR1cm4gbm9kZV91dGlsc19mZXRjaERhdGEodXJsKTtcbiAgfVxufVxuY2xhc3MgTm9kZVdhc21GYWN0b3J5IGV4dGVuZHMgQmFzZVdhc21GYWN0b3J5IHtcbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIHJldHVybiBub2RlX3V0aWxzX2ZldGNoRGF0YSh1cmwpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2NhbnZhc19kZXBlbmRlbmN5X3RyYWNrZXIuanNcblxuY29uc3QgRk9SQ0VEX0RFUEVOREVOQ1lfTEFCRUwgPSBcIl9fZm9yY2VkRGVwZW5kZW5jeVwiO1xuY2xhc3MgQ2FudmFzRGVwZW5kZW5jeVRyYWNrZXIge1xuICAjc2ltcGxlID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbFxuICB9O1xuICAjaW5jcmVtZW50YWwgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHRyYW5zZm9ybTogW10sXG4gICAgbW92ZVRleHQ6IFtdLFxuICAgIHNhbWVMaW5lVGV4dDogW10sXG4gICAgW0ZPUkNFRF9ERVBFTkRFTkNZX0xBQkVMXTogW11cbiAgfTtcbiAgI25hbWVkRGVwZW5kZW5jaWVzID0gbmV3IE1hcCgpO1xuICAjc2F2ZXNTdGFjayA9IFtdO1xuICAjbWFya2VkQ29udGVudFN0YWNrID0gW107XG4gICNiYXNlVHJhbnNmb3JtU3RhY2sgPSBbWzEsIDAsIDAsIDEsIDAsIDBdXTtcbiAgI2NsaXBCb3ggPSBbLUluZmluaXR5LCAtSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eV07XG4gICNwZW5kaW5nQkJveCA9IG5ldyBGbG9hdDY0QXJyYXkoW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldKTtcbiAgI3BlbmRpbmdCQm94SWR4ID0gLTE7XG4gICNwZW5kaW5nRGVwZW5kZW5jaWVzID0gbmV3IFNldCgpO1xuICAjb3BlcmF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgI2ZvbnRCQm94VHJ1c3R3b3J0aHkgPSBuZXcgTWFwKCk7XG4gICNjYW52YXNXaWR0aDtcbiAgI2NhbnZhc0hlaWdodDtcbiAgY29uc3RydWN0b3IoY2FudmFzKSB7XG4gICAgdGhpcy4jY2FudmFzV2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgdGhpcy4jY2FudmFzSGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgfVxuICBzYXZlKG9wSWR4KSB7XG4gICAgdGhpcy4jc2ltcGxlID0ge1xuICAgICAgX19wcm90b19fOiB0aGlzLiNzaW1wbGVcbiAgICB9O1xuICAgIHRoaXMuI2luY3JlbWVudGFsID0ge1xuICAgICAgX19wcm90b19fOiB0aGlzLiNpbmNyZW1lbnRhbCxcbiAgICAgIHRyYW5zZm9ybToge1xuICAgICAgICBfX3Byb3RvX186IHRoaXMuI2luY3JlbWVudGFsLnRyYW5zZm9ybVxuICAgICAgfSxcbiAgICAgIG1vdmVUZXh0OiB7XG4gICAgICAgIF9fcHJvdG9fXzogdGhpcy4jaW5jcmVtZW50YWwubW92ZVRleHRcbiAgICAgIH0sXG4gICAgICBzYW1lTGluZVRleHQ6IHtcbiAgICAgICAgX19wcm90b19fOiB0aGlzLiNpbmNyZW1lbnRhbC5zYW1lTGluZVRleHRcbiAgICAgIH0sXG4gICAgICBbRk9SQ0VEX0RFUEVOREVOQ1lfTEFCRUxdOiB7XG4gICAgICAgIF9fcHJvdG9fXzogdGhpcy4jaW5jcmVtZW50YWxbRk9SQ0VEX0RFUEVOREVOQ1lfTEFCRUxdXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLiNjbGlwQm94ID0ge1xuICAgICAgX19wcm90b19fOiB0aGlzLiNjbGlwQm94XG4gICAgfTtcbiAgICB0aGlzLiNzYXZlc1N0YWNrLnB1c2goW29wSWR4LCBudWxsXSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVzdG9yZShvcElkeCkge1xuICAgIGNvbnN0IHByZXZpb3VzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMuI3NpbXBsZSk7XG4gICAgaWYgKHByZXZpb3VzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy4jc2ltcGxlID0gcHJldmlvdXM7XG4gICAgdGhpcy4jaW5jcmVtZW50YWwgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcy4jaW5jcmVtZW50YWwpO1xuICAgIHRoaXMuI2NsaXBCb3ggPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcy4jY2xpcEJveCk7XG4gICAgY29uc3QgbGFzdFBhaXIgPSB0aGlzLiNzYXZlc1N0YWNrLnBvcCgpO1xuICAgIGlmIChsYXN0UGFpciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsYXN0UGFpclsxXSA9IG9wSWR4O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRPcGVuTWFya2VyKGlkeCkge1xuICAgIHRoaXMuI3NhdmVzU3RhY2sucHVzaChbaWR4LCBudWxsXSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0T3Blbk1hcmtlcigpIHtcbiAgICBpZiAodGhpcy4jc2F2ZXNTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jc2F2ZXNTdGFjay5hdCgtMSlbMF07XG4gIH1cbiAgcmVjb3JkQ2xvc2VNYXJrZXIoaWR4KSB7XG4gICAgY29uc3QgbGFzdFBhaXIgPSB0aGlzLiNzYXZlc1N0YWNrLnBvcCgpO1xuICAgIGlmIChsYXN0UGFpciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsYXN0UGFpclsxXSA9IGlkeDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYmVnaW5NYXJrZWRDb250ZW50KG9wSWR4KSB7XG4gICAgdGhpcy4jbWFya2VkQ29udGVudFN0YWNrLnB1c2goW29wSWR4LCBudWxsXSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZW5kTWFya2VkQ29udGVudChvcElkeCkge1xuICAgIGNvbnN0IGxhc3RQYWlyID0gdGhpcy4jbWFya2VkQ29udGVudFN0YWNrLnBvcCgpO1xuICAgIGlmIChsYXN0UGFpciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsYXN0UGFpclsxXSA9IG9wSWR4O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwdXNoQmFzZVRyYW5zZm9ybShjdHgpIHtcbiAgICB0aGlzLiNiYXNlVHJhbnNmb3JtU3RhY2sucHVzaChVdGlsLm11bHRpcGx5QnlET01NYXRyaXgodGhpcy4jYmFzZVRyYW5zZm9ybVN0YWNrLmF0KC0xKSwgY3R4LmdldFRyYW5zZm9ybSgpKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcG9wQmFzZVRyYW5zZm9ybSgpIHtcbiAgICBpZiAodGhpcy4jYmFzZVRyYW5zZm9ybVN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMuI2Jhc2VUcmFuc2Zvcm1TdGFjay5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkU2ltcGxlRGF0YShuYW1lLCBpZHgpIHtcbiAgICB0aGlzLiNzaW1wbGVbbmFtZV0gPSBpZHg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkSW5jcmVtZW50YWxEYXRhKG5hbWUsIGlkeCkge1xuICAgIHRoaXMuI2luY3JlbWVudGFsW25hbWVdLnB1c2goaWR4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXNldEluY3JlbWVudGFsRGF0YShuYW1lLCBpZHgpIHtcbiAgICB0aGlzLiNpbmNyZW1lbnRhbFtuYW1lXS5sZW5ndGggPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZE5hbWVkRGF0YShuYW1lLCBpZHgpIHtcbiAgICB0aGlzLiNuYW1lZERlcGVuZGVuY2llcy5zZXQobmFtZSwgaWR4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KG5hbWUsIGlkeCkge1xuICAgIHRoaXMucmVjb3JkSW5jcmVtZW50YWxEYXRhKEZPUkNFRF9ERVBFTkRFTkNZX0xBQkVMLCBpZHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGluaGVyaXRTaW1wbGVEYXRhQXNGdXR1cmVGb3JjZWREZXBlbmRlbmNpZXMobmFtZXMpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbmFtZXMpIHtcbiAgICAgIGlmIChuYW1lIGluIHRoaXMuI3NpbXBsZSkge1xuICAgICAgICB0aGlzLnJlY29yZEZ1dHVyZUZvcmNlZERlcGVuZGVuY3kobmFtZSwgdGhpcy4jc2ltcGxlW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaW5oZXJpdFBlbmRpbmdEZXBlbmRlbmNpZXNBc0Z1dHVyZUZvcmNlZERlcGVuZGVuY2llcygpIHtcbiAgICBmb3IgKGNvbnN0IGRlcCBvZiB0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzKSB7XG4gICAgICB0aGlzLnJlY29yZEZ1dHVyZUZvcmNlZERlcGVuZGVuY3koRk9SQ0VEX0RFUEVOREVOQ1lfTEFCRUwsIGRlcCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlc2V0QkJveChpZHgpIHtcbiAgICB0aGlzLiNwZW5kaW5nQkJveElkeCA9IGlkeDtcbiAgICB0aGlzLiNwZW5kaW5nQkJveFswXSA9IEluZmluaXR5O1xuICAgIHRoaXMuI3BlbmRpbmdCQm94WzFdID0gSW5maW5pdHk7XG4gICAgdGhpcy4jcGVuZGluZ0JCb3hbMl0gPSAtSW5maW5pdHk7XG4gICAgdGhpcy4jcGVuZGluZ0JCb3hbM10gPSAtSW5maW5pdHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0IGhhc1BlbmRpbmdCQm94KCkge1xuICAgIHJldHVybiB0aGlzLiNwZW5kaW5nQkJveElkeCAhPT0gLTE7XG4gIH1cbiAgcmVjb3JkQ2xpcEJveChpZHgsIGN0eCwgbWluWCwgbWF4WCwgbWluWSwgbWF4WSkge1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IFV0aWwubXVsdGlwbHlCeURPTU1hdHJpeCh0aGlzLiNiYXNlVHJhbnNmb3JtU3RhY2suYXQoLTEpLCBjdHguZ2V0VHJhbnNmb3JtKCkpO1xuICAgIGNvbnN0IGNsaXBCb3ggPSBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0sIHRyYW5zZm9ybSwgY2xpcEJveCk7XG4gICAgY29uc3QgaW50ZXJzZWN0aW9uID0gVXRpbC5pbnRlcnNlY3QodGhpcy4jY2xpcEJveCwgY2xpcEJveCk7XG4gICAgaWYgKGludGVyc2VjdGlvbikge1xuICAgICAgdGhpcy4jY2xpcEJveFswXSA9IGludGVyc2VjdGlvblswXTtcbiAgICAgIHRoaXMuI2NsaXBCb3hbMV0gPSBpbnRlcnNlY3Rpb25bMV07XG4gICAgICB0aGlzLiNjbGlwQm94WzJdID0gaW50ZXJzZWN0aW9uWzJdO1xuICAgICAgdGhpcy4jY2xpcEJveFszXSA9IGludGVyc2VjdGlvblszXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jY2xpcEJveFswXSA9IHRoaXMuI2NsaXBCb3hbMV0gPSBJbmZpbml0eTtcbiAgICAgIHRoaXMuI2NsaXBCb3hbMl0gPSB0aGlzLiNjbGlwQm94WzNdID0gLUluZmluaXR5O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRCQm94KGlkeCwgY3R4LCBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZKSB7XG4gICAgY29uc3QgY2xpcEJveCA9IHRoaXMuI2NsaXBCb3g7XG4gICAgaWYgKGNsaXBCb3hbMF0gPT09IEluZmluaXR5KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3QgdHJhbnNmb3JtID0gVXRpbC5tdWx0aXBseUJ5RE9NTWF0cml4KHRoaXMuI2Jhc2VUcmFuc2Zvcm1TdGFjay5hdCgtMSksIGN0eC5nZXRUcmFuc2Zvcm0oKSk7XG4gICAgaWYgKGNsaXBCb3hbMF0gPT09IC1JbmZpbml0eSkge1xuICAgICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0sIHRyYW5zZm9ybSwgdGhpcy4jcGVuZGluZ0JCb3gpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IGJib3ggPSBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0sIHRyYW5zZm9ybSwgYmJveCk7XG4gICAgdGhpcy4jcGVuZGluZ0JCb3hbMF0gPSBNYXRoLm1pbih0aGlzLiNwZW5kaW5nQkJveFswXSwgTWF0aC5tYXgoYmJveFswXSwgY2xpcEJveFswXSkpO1xuICAgIHRoaXMuI3BlbmRpbmdCQm94WzFdID0gTWF0aC5taW4odGhpcy4jcGVuZGluZ0JCb3hbMV0sIE1hdGgubWF4KGJib3hbMV0sIGNsaXBCb3hbMV0pKTtcbiAgICB0aGlzLiNwZW5kaW5nQkJveFsyXSA9IE1hdGgubWF4KHRoaXMuI3BlbmRpbmdCQm94WzJdLCBNYXRoLm1pbihiYm94WzJdLCBjbGlwQm94WzJdKSk7XG4gICAgdGhpcy4jcGVuZGluZ0JCb3hbM10gPSBNYXRoLm1heCh0aGlzLiNwZW5kaW5nQkJveFszXSwgTWF0aC5taW4oYmJveFszXSwgY2xpcEJveFszXSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZENoYXJhY3RlckJCb3goaWR4LCBjdHgsIGZvbnQsIHNjYWxlID0gMSwgeCA9IDAsIHkgPSAwLCBnZXRNZWFzdXJlKSB7XG4gICAgY29uc3QgZm9udEJCb3ggPSBmb250LmJib3g7XG4gICAgbGV0IGlzQkJveFRydXN0d29ydGh5O1xuICAgIGxldCBjb21wdXRlZEJCb3g7XG4gICAgaWYgKGZvbnRCQm94KSB7XG4gICAgICBpc0JCb3hUcnVzdHdvcnRoeSA9IGZvbnRCQm94WzJdICE9PSBmb250QkJveFswXSAmJiBmb250QkJveFszXSAhPT0gZm9udEJCb3hbMV0gJiYgdGhpcy4jZm9udEJCb3hUcnVzdHdvcnRoeS5nZXQoZm9udCk7XG4gICAgICBpZiAoaXNCQm94VHJ1c3R3b3J0aHkgIT09IGZhbHNlKSB7XG4gICAgICAgIGNvbXB1dGVkQkJveCA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChmb250QkJveCwgZm9udC5mb250TWF0cml4LCBjb21wdXRlZEJCb3gpO1xuICAgICAgICBpZiAoc2NhbGUgIT09IDEgfHwgeCAhPT0gMCB8fCB5ICE9PSAwKSB7XG4gICAgICAgICAgVXRpbC5zY2FsZU1pbk1heChbc2NhbGUsIDAsIDAsIC1zY2FsZSwgeCwgeV0sIGNvbXB1dGVkQkJveCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQkJveFRydXN0d29ydGh5KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVjb3JkQkJveChpZHgsIGN0eCwgY29tcHV0ZWRCQm94WzBdLCBjb21wdXRlZEJCb3hbMl0sIGNvbXB1dGVkQkJveFsxXSwgY29tcHV0ZWRCQm94WzNdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWdldE1lYXN1cmUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlY29yZEZ1bGxQYWdlQkJveChpZHgpO1xuICAgIH1cbiAgICBjb25zdCBtZWFzdXJlID0gZ2V0TWVhc3VyZSgpO1xuICAgIGlmIChmb250QkJveCAmJiBjb21wdXRlZEJCb3ggJiYgaXNCQm94VHJ1c3R3b3J0aHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaXNCQm94VHJ1c3R3b3J0aHkgPSBjb21wdXRlZEJCb3hbMF0gPD0geCAtIG1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hMZWZ0ICYmIGNvbXB1dGVkQkJveFsyXSA+PSB4ICsgbWVhc3VyZS5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0ICYmIGNvbXB1dGVkQkJveFsxXSA8PSB5IC0gbWVhc3VyZS5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCAmJiBjb21wdXRlZEJCb3hbM10gPj0geSArIG1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50O1xuICAgICAgdGhpcy4jZm9udEJCb3hUcnVzdHdvcnRoeS5zZXQoZm9udCwgaXNCQm94VHJ1c3R3b3J0aHkpO1xuICAgICAgaWYgKGlzQkJveFRydXN0d29ydGh5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY29yZEJCb3goaWR4LCBjdHgsIGNvbXB1dGVkQkJveFswXSwgY29tcHV0ZWRCQm94WzJdLCBjb21wdXRlZEJCb3hbMV0sIGNvbXB1dGVkQkJveFszXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlY29yZEJCb3goaWR4LCBjdHgsIHggLSBtZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94TGVmdCwgeCArIG1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hSaWdodCwgeSAtIG1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQsIHkgKyBtZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCk7XG4gIH1cbiAgcmVjb3JkRnVsbFBhZ2VCQm94KGlkeCkge1xuICAgIHRoaXMuI3BlbmRpbmdCQm94WzBdID0gTWF0aC5tYXgoMCwgdGhpcy4jY2xpcEJveFswXSk7XG4gICAgdGhpcy4jcGVuZGluZ0JCb3hbMV0gPSBNYXRoLm1heCgwLCB0aGlzLiNjbGlwQm94WzFdKTtcbiAgICB0aGlzLiNwZW5kaW5nQkJveFsyXSA9IE1hdGgubWluKHRoaXMuI2NhbnZhc1dpZHRoLCB0aGlzLiNjbGlwQm94WzJdKTtcbiAgICB0aGlzLiNwZW5kaW5nQkJveFszXSA9IE1hdGgubWluKHRoaXMuI2NhbnZhc0hlaWdodCwgdGhpcy4jY2xpcEJveFszXSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0U2ltcGxlSW5kZXgoZGVwZW5kZW5jeU5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy4jc2ltcGxlW2RlcGVuZGVuY3lOYW1lXTtcbiAgfVxuICByZWNvcmREZXBlbmRlbmNpZXMoaWR4LCBkZXBlbmRlbmN5TmFtZXMpIHtcbiAgICBjb25zdCBwZW5kaW5nRGVwZW5kZW5jaWVzID0gdGhpcy4jcGVuZGluZ0RlcGVuZGVuY2llcztcbiAgICBjb25zdCBzaW1wbGUgPSB0aGlzLiNzaW1wbGU7XG4gICAgY29uc3QgaW5jcmVtZW50YWwgPSB0aGlzLiNpbmNyZW1lbnRhbDtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgZGVwZW5kZW5jeU5hbWVzKSB7XG4gICAgICBpZiAobmFtZSBpbiB0aGlzLiNzaW1wbGUpIHtcbiAgICAgICAgcGVuZGluZ0RlcGVuZGVuY2llcy5hZGQoc2ltcGxlW25hbWVdKTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSBpbiBpbmNyZW1lbnRhbCkge1xuICAgICAgICBpbmNyZW1lbnRhbFtuYW1lXS5mb3JFYWNoKHBlbmRpbmdEZXBlbmRlbmNpZXMuYWRkLCBwZW5kaW5nRGVwZW5kZW5jaWVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY29weURlcGVuZGVuY2llc0Zyb21JbmNyZW1lbnRhbE9wZXJhdGlvbihpZHgsIG5hbWUpIHtcbiAgICBjb25zdCBvcGVyYXRpb25zID0gdGhpcy4jb3BlcmF0aW9ucztcbiAgICBjb25zdCBwZW5kaW5nRGVwZW5kZW5jaWVzID0gdGhpcy4jcGVuZGluZ0RlcGVuZGVuY2llcztcbiAgICBmb3IgKGNvbnN0IGRlcElkeCBvZiB0aGlzLiNpbmNyZW1lbnRhbFtuYW1lXSkge1xuICAgICAgb3BlcmF0aW9ucy5nZXQoZGVwSWR4KS5kZXBlbmRlbmNpZXMuZm9yRWFjaChwZW5kaW5nRGVwZW5kZW5jaWVzLmFkZCwgcGVuZGluZ0RlcGVuZGVuY2llcy5hZGQoZGVwSWR4KSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZE5hbWVkRGVwZW5kZW5jeShpZHgsIG5hbWUpIHtcbiAgICBpZiAodGhpcy4jbmFtZWREZXBlbmRlbmNpZXMuaGFzKG5hbWUpKSB7XG4gICAgICB0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzLmFkZCh0aGlzLiNuYW1lZERlcGVuZGVuY2llcy5nZXQobmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRPcGVyYXRpb24oaWR4LCBwcmVzZXJ2ZUJib3ggPSBmYWxzZSkge1xuICAgIHRoaXMucmVjb3JkRGVwZW5kZW5jaWVzKGlkeCwgW0ZPUkNFRF9ERVBFTkRFTkNZX0xBQkVMXSk7XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gbmV3IFNldCh0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzKTtcbiAgICBjb25zdCBwYWlycyA9IHRoaXMuI3NhdmVzU3RhY2suY29uY2F0KHRoaXMuI21hcmtlZENvbnRlbnRTdGFjayk7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuI3BlbmRpbmdCQm94SWR4ID09PSBpZHggPyB7XG4gICAgICBtaW5YOiB0aGlzLiNwZW5kaW5nQkJveFswXSxcbiAgICAgIG1pblk6IHRoaXMuI3BlbmRpbmdCQm94WzFdLFxuICAgICAgbWF4WDogdGhpcy4jcGVuZGluZ0JCb3hbMl0sXG4gICAgICBtYXhZOiB0aGlzLiNwZW5kaW5nQkJveFszXVxuICAgIH0gOiBudWxsO1xuICAgIHRoaXMuI29wZXJhdGlvbnMuc2V0KGlkeCwge1xuICAgICAgYmJveCxcbiAgICAgIHBhaXJzLFxuICAgICAgZGVwZW5kZW5jaWVzXG4gICAgfSk7XG4gICAgaWYgKCFwcmVzZXJ2ZUJib3gpIHtcbiAgICAgIHRoaXMuI3BlbmRpbmdCQm94SWR4ID0gLTE7XG4gICAgfVxuICAgIHRoaXMuI3BlbmRpbmdEZXBlbmRlbmNpZXMuY2xlYXIoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBiYm94VG9DbGlwQm94RHJvcE9wZXJhdGlvbihpZHgpIHtcbiAgICBpZiAodGhpcy4jcGVuZGluZ0JCb3hJZHggIT09IC0xKSB7XG4gICAgICB0aGlzLiNwZW5kaW5nQkJveElkeCA9IC0xO1xuICAgICAgdGhpcy4jY2xpcEJveFswXSA9IE1hdGgubWF4KHRoaXMuI2NsaXBCb3hbMF0sIHRoaXMuI3BlbmRpbmdCQm94WzBdKTtcbiAgICAgIHRoaXMuI2NsaXBCb3hbMV0gPSBNYXRoLm1heCh0aGlzLiNjbGlwQm94WzFdLCB0aGlzLiNwZW5kaW5nQkJveFsxXSk7XG4gICAgICB0aGlzLiNjbGlwQm94WzJdID0gTWF0aC5taW4odGhpcy4jY2xpcEJveFsyXSwgdGhpcy4jcGVuZGluZ0JCb3hbMl0pO1xuICAgICAgdGhpcy4jY2xpcEJveFszXSA9IE1hdGgubWluKHRoaXMuI2NsaXBCb3hbM10sIHRoaXMuI3BlbmRpbmdCQm94WzNdKTtcbiAgICB9XG4gICAgdGhpcy4jcGVuZGluZ0RlcGVuZGVuY2llcy5jbGVhcigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF90YWtlUGVuZGluZ0RlcGVuZGVuY2llcygpIHtcbiAgICBjb25zdCBwZW5kaW5nRGVwZW5kZW5jaWVzID0gdGhpcy4jcGVuZGluZ0RlcGVuZGVuY2llcztcbiAgICB0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzID0gbmV3IFNldCgpO1xuICAgIHJldHVybiBwZW5kaW5nRGVwZW5kZW5jaWVzO1xuICB9XG4gIF9leHRyYWN0T3BlcmF0aW9uKGlkeCkge1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXMuI29wZXJhdGlvbnMuZ2V0KGlkeCk7XG4gICAgdGhpcy4jb3BlcmF0aW9ucy5kZWxldGUoaWR4KTtcbiAgICByZXR1cm4gb3BlcmF0aW9uO1xuICB9XG4gIF9wdXNoUGVuZGluZ0RlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpIHtcbiAgICBmb3IgKGNvbnN0IGRlcCBvZiBkZXBlbmRlbmNpZXMpIHtcbiAgICAgIHRoaXMuI3BlbmRpbmdEZXBlbmRlbmNpZXMuYWRkKGRlcCk7XG4gICAgfVxuICB9XG4gIHRha2UoKSB7XG4gICAgdGhpcy4jZm9udEJCb3hUcnVzdHdvcnRoeS5jbGVhcigpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuI29wZXJhdGlvbnMsIChbaWR4LCB7XG4gICAgICBiYm94LFxuICAgICAgcGFpcnMsXG4gICAgICBkZXBlbmRlbmNpZXNcbiAgICB9XSkgPT4ge1xuICAgICAgcGFpcnMuZm9yRWFjaChwYWlyID0+IHBhaXIuZm9yRWFjaChkZXBlbmRlbmNpZXMuYWRkLCBkZXBlbmRlbmNpZXMpKTtcbiAgICAgIGRlcGVuZGVuY2llcy5kZWxldGUoaWR4KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pblg6IChiYm94Py5taW5YID8/IDApIC8gdGhpcy4jY2FudmFzV2lkdGgsXG4gICAgICAgIG1heFg6IChiYm94Py5tYXhYID8/IHRoaXMuI2NhbnZhc1dpZHRoKSAvIHRoaXMuI2NhbnZhc1dpZHRoLFxuICAgICAgICBtaW5ZOiAoYmJveD8ubWluWSA/PyAwKSAvIHRoaXMuI2NhbnZhc0hlaWdodCxcbiAgICAgICAgbWF4WTogKGJib3g/Lm1heFkgPz8gdGhpcy4jY2FudmFzSGVpZ2h0KSAvIHRoaXMuI2NhbnZhc0hlaWdodCxcbiAgICAgICAgZGVwZW5kZW5jaWVzOiBBcnJheS5mcm9tKGRlcGVuZGVuY2llcykuc29ydCgoYSwgYikgPT4gYSAtIGIpLFxuICAgICAgICBpZHhcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIENhbnZhc05lc3RlZERlcGVuZGVuY3lUcmFja2VyIHtcbiAgI2RlcGVuZGVuY3lUcmFja2VyO1xuICAjb3BJZHg7XG4gICNuZXN0aW5nTGV2ZWwgPSAwO1xuICAjb3V0ZXJEZXBlbmRlbmNpZXM7XG4gICNzYXZlc0xldmVsID0gMDtcbiAgY29uc3RydWN0b3IoZGVwZW5kZW5jeVRyYWNrZXIsIG9wSWR4KSB7XG4gICAgaWYgKGRlcGVuZGVuY3lUcmFja2VyIGluc3RhbmNlb2YgQ2FudmFzTmVzdGVkRGVwZW5kZW5jeVRyYWNrZXIpIHtcbiAgICAgIHJldHVybiBkZXBlbmRlbmN5VHJhY2tlcjtcbiAgICB9XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIgPSBkZXBlbmRlbmN5VHJhY2tlcjtcbiAgICB0aGlzLiNvdXRlckRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY3lUcmFja2VyLl90YWtlUGVuZGluZ0RlcGVuZGVuY2llcygpO1xuICAgIHRoaXMuI29wSWR4ID0gb3BJZHg7XG4gIH1cbiAgc2F2ZShvcElkeCkge1xuICAgIHRoaXMuI3NhdmVzTGV2ZWwrKztcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5zYXZlKHRoaXMuI29wSWR4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXN0b3JlKG9wSWR4KSB7XG4gICAgaWYgKHRoaXMuI3NhdmVzTGV2ZWwgPiAwKSB7XG4gICAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZXN0b3JlKHRoaXMuI29wSWR4KTtcbiAgICAgIHRoaXMuI3NhdmVzTGV2ZWwtLTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkT3Blbk1hcmtlcihpZHgpIHtcbiAgICB0aGlzLiNuZXN0aW5nTGV2ZWwrKztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXRPcGVuTWFya2VyKCkge1xuICAgIHJldHVybiB0aGlzLiNuZXN0aW5nTGV2ZWwgPiAwID8gdGhpcy4jb3BJZHggOiB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5nZXRPcGVuTWFya2VyKCk7XG4gIH1cbiAgcmVjb3JkQ2xvc2VNYXJrZXIoaWR4KSB7XG4gICAgdGhpcy4jbmVzdGluZ0xldmVsLS07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYmVnaW5NYXJrZWRDb250ZW50KG9wSWR4KSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZW5kTWFya2VkQ29udGVudChvcElkeCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHB1c2hCYXNlVHJhbnNmb3JtKGN0eCkge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnB1c2hCYXNlVHJhbnNmb3JtKGN0eCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcG9wQmFzZVRyYW5zZm9ybSgpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5wb3BCYXNlVHJhbnNmb3JtKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkU2ltcGxlRGF0YShuYW1lLCBpZHgpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRTaW1wbGVEYXRhKG5hbWUsIHRoaXMuI29wSWR4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRJbmNyZW1lbnRhbERhdGEobmFtZSwgaWR4KSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkSW5jcmVtZW50YWxEYXRhKG5hbWUsIHRoaXMuI29wSWR4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXNldEluY3JlbWVudGFsRGF0YShuYW1lLCBpZHgpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZXNldEluY3JlbWVudGFsRGF0YShuYW1lLCB0aGlzLiNvcElkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkTmFtZWREYXRhKG5hbWUsIGlkeCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZEZ1dHVyZUZvcmNlZERlcGVuZGVuY3kobmFtZSwgaWR4KSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkRnV0dXJlRm9yY2VkRGVwZW5kZW5jeShuYW1lLCB0aGlzLiNvcElkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaW5oZXJpdFNpbXBsZURhdGFBc0Z1dHVyZUZvcmNlZERlcGVuZGVuY2llcyhuYW1lcykge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLmluaGVyaXRTaW1wbGVEYXRhQXNGdXR1cmVGb3JjZWREZXBlbmRlbmNpZXMobmFtZXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGluaGVyaXRQZW5kaW5nRGVwZW5kZW5jaWVzQXNGdXR1cmVGb3JjZWREZXBlbmRlbmNpZXMoKSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIuaW5oZXJpdFBlbmRpbmdEZXBlbmRlbmNpZXNBc0Z1dHVyZUZvcmNlZERlcGVuZGVuY2llcygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlc2V0QkJveChpZHgpIHtcbiAgICBpZiAoIXRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLmhhc1BlbmRpbmdCQm94KSB7XG4gICAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZXNldEJCb3godGhpcy4jb3BJZHgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXQgaGFzUGVuZGluZ0JCb3goKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLmhhc1BlbmRpbmdCQm94O1xuICB9XG4gIHJlY29yZENsaXBCb3goaWR4LCBjdHgsIG1pblgsIG1heFgsIG1pblksIG1heFkpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRDbGlwQm94KHRoaXMuI29wSWR4LCBjdHgsIG1pblgsIG1heFgsIG1pblksIG1heFkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZEJCb3goaWR4LCBjdHgsIG1pblgsIG1heFgsIG1pblksIG1heFkpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRCQm94KHRoaXMuI29wSWR4LCBjdHgsIG1pblgsIG1heFgsIG1pblksIG1heFkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZENoYXJhY3RlckJCb3goaWR4LCBjdHgsIGZvbnQsIHNjYWxlLCB4LCB5LCBnZXRNZWFzdXJlKSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkQ2hhcmFjdGVyQkJveCh0aGlzLiNvcElkeCwgY3R4LCBmb250LCBzY2FsZSwgeCwgeSwgZ2V0TWVhc3VyZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkRnVsbFBhZ2VCQm94KGlkeCkge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlY29yZEZ1bGxQYWdlQkJveCh0aGlzLiNvcElkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0U2ltcGxlSW5kZXgoZGVwZW5kZW5jeU5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIuZ2V0U2ltcGxlSW5kZXgoZGVwZW5kZW5jeU5hbWUpO1xuICB9XG4gIHJlY29yZERlcGVuZGVuY2llcyhpZHgsIGRlcGVuZGVuY3lOYW1lcykge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlY29yZERlcGVuZGVuY2llcyh0aGlzLiNvcElkeCwgZGVwZW5kZW5jeU5hbWVzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb3B5RGVwZW5kZW5jaWVzRnJvbUluY3JlbWVudGFsT3BlcmF0aW9uKGlkeCwgbmFtZSkge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLmNvcHlEZXBlbmRlbmNpZXNGcm9tSW5jcmVtZW50YWxPcGVyYXRpb24odGhpcy4jb3BJZHgsIG5hbWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZE5hbWVkRGVwZW5kZW5jeShpZHgsIG5hbWUpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmROYW1lZERlcGVuZGVuY3kodGhpcy4jb3BJZHgsIG5hbWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZE9wZXJhdGlvbihpZHgpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRPcGVyYXRpb24odGhpcy4jb3BJZHgsIHRydWUpO1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLl9leHRyYWN0T3BlcmF0aW9uKHRoaXMuI29wSWR4KTtcbiAgICBmb3IgKGNvbnN0IGRlcElkeCBvZiBvcGVyYXRpb24uZGVwZW5kZW5jaWVzKSB7XG4gICAgICB0aGlzLiNvdXRlckRlcGVuZGVuY2llcy5hZGQoZGVwSWR4KTtcbiAgICB9XG4gICAgdGhpcy4jb3V0ZXJEZXBlbmRlbmNpZXMuZGVsZXRlKHRoaXMuI29wSWR4KTtcbiAgICB0aGlzLiNvdXRlckRlcGVuZGVuY2llcy5kZWxldGUobnVsbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYmJveFRvQ2xpcEJveERyb3BPcGVyYXRpb24oaWR4KSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIuYmJveFRvQ2xpcEJveERyb3BPcGVyYXRpb24odGhpcy4jb3BJZHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZE5lc3RlZERlcGVuZGVuY2llcygpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5fcHVzaFBlbmRpbmdEZXBlbmRlbmNpZXModGhpcy4jb3V0ZXJEZXBlbmRlbmNpZXMpO1xuICB9XG4gIHRha2UoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWFjaGFibGVcIik7XG4gIH1cbn1cbmNvbnN0IERlcGVuZGVuY2llcyA9IHtcbiAgc3Ryb2tlOiBbXCJwYXRoXCIsIFwidHJhbnNmb3JtXCIsIFwiZmlsdGVyXCIsIFwic3Ryb2tlQ29sb3JcIiwgXCJzdHJva2VBbHBoYVwiLCBcImxpbmVXaWR0aFwiLCBcImxpbmVDYXBcIiwgXCJsaW5lSm9pblwiLCBcIm1pdGVyTGltaXRcIiwgXCJkYXNoXCJdLFxuICBmaWxsOiBbXCJwYXRoXCIsIFwidHJhbnNmb3JtXCIsIFwiZmlsdGVyXCIsIFwiZmlsbENvbG9yXCIsIFwiZmlsbEFscGhhXCIsIFwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXCIsIFwiU01hc2tcIl0sXG4gIGltYWdlWE9iamVjdDogW1widHJhbnNmb3JtXCIsIFwiU01hc2tcIiwgXCJmaWx0ZXJcIiwgXCJmaWxsQWxwaGFcIiwgXCJzdHJva2VBbHBoYVwiLCBcImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblwiXSxcbiAgcmF3RmlsbFBhdGg6IFtcImZpbHRlclwiLCBcImZpbGxDb2xvclwiLCBcImZpbGxBbHBoYVwiXSxcbiAgc2hvd1RleHQ6IFtcInRyYW5zZm9ybVwiLCBcImxlYWRpbmdcIiwgXCJjaGFyU3BhY2luZ1wiLCBcIndvcmRTcGFjaW5nXCIsIFwiaFNjYWxlXCIsIFwidGV4dFJpc2VcIiwgXCJtb3ZlVGV4dFwiLCBcInRleHRNYXRyaXhcIiwgXCJmb250XCIsIFwiZmlsdGVyXCIsIFwiZmlsbENvbG9yXCIsIFwidGV4dFJlbmRlcmluZ01vZGVcIiwgXCJTTWFza1wiLCBcImZpbGxBbHBoYVwiLCBcInN0cm9rZUFscGhhXCIsIFwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXCJdLFxuICB0cmFuc2Zvcm06IFtcInRyYW5zZm9ybVwiXSxcbiAgdHJhbnNmb3JtQW5kRmlsbDogW1widHJhbnNmb3JtXCIsIFwiZmlsbENvbG9yXCJdXG59O1xuXG47Ly8gLi9zcmMvZGlzcGxheS9wYXR0ZXJuX2hlbHBlci5qc1xuXG5cbmNvbnN0IFBhdGhUeXBlID0ge1xuICBGSUxMOiBcIkZpbGxcIixcbiAgU1RST0tFOiBcIlN0cm9rZVwiLFxuICBTSEFESU5HOiBcIlNoYWRpbmdcIlxufTtcbmZ1bmN0aW9uIGFwcGx5Qm91bmRpbmdCb3goY3R4LCBiYm94KSB7XG4gIGlmICghYmJveCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB3aWR0aCA9IGJib3hbMl0gLSBiYm94WzBdO1xuICBjb25zdCBoZWlnaHQgPSBiYm94WzNdIC0gYmJveFsxXTtcbiAgY29uc3QgcmVnaW9uID0gbmV3IFBhdGgyRCgpO1xuICByZWdpb24ucmVjdChiYm94WzBdLCBiYm94WzFdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgY3R4LmNsaXAocmVnaW9uKTtcbn1cbmNsYXNzIEJhc2VTaGFkaW5nUGF0dGVybiB7XG4gIGlzTW9kaWZ5aW5nQ3VycmVudFRyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0UGF0dGVybigpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgZ2V0UGF0dGVybmAgY2FsbGVkLlwiKTtcbiAgfVxufVxuY2xhc3MgUmFkaWFsQXhpYWxTaGFkaW5nUGF0dGVybiBleHRlbmRzIEJhc2VTaGFkaW5nUGF0dGVybiB7XG4gIGNvbnN0cnVjdG9yKElSKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl90eXBlID0gSVJbMV07XG4gICAgdGhpcy5fYmJveCA9IElSWzJdO1xuICAgIHRoaXMuX2NvbG9yU3RvcHMgPSBJUlszXTtcbiAgICB0aGlzLl9wMCA9IElSWzRdO1xuICAgIHRoaXMuX3AxID0gSVJbNV07XG4gICAgdGhpcy5fcjAgPSBJUls2XTtcbiAgICB0aGlzLl9yMSA9IElSWzddO1xuICAgIHRoaXMubWF0cml4ID0gbnVsbDtcbiAgfVxuICBfY3JlYXRlR3JhZGllbnQoY3R4KSB7XG4gICAgbGV0IGdyYWQ7XG4gICAgaWYgKHRoaXMuX3R5cGUgPT09IFwiYXhpYWxcIikge1xuICAgICAgZ3JhZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh0aGlzLl9wMFswXSwgdGhpcy5fcDBbMV0sIHRoaXMuX3AxWzBdLCB0aGlzLl9wMVsxXSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl90eXBlID09PSBcInJhZGlhbFwiKSB7XG4gICAgICBncmFkID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHRoaXMuX3AwWzBdLCB0aGlzLl9wMFsxXSwgdGhpcy5fcjAsIHRoaXMuX3AxWzBdLCB0aGlzLl9wMVsxXSwgdGhpcy5fcjEpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNvbG9yU3RvcCBvZiB0aGlzLl9jb2xvclN0b3BzKSB7XG4gICAgICBncmFkLmFkZENvbG9yU3RvcChjb2xvclN0b3BbMF0sIGNvbG9yU3RvcFsxXSk7XG4gICAgfVxuICAgIHJldHVybiBncmFkO1xuICB9XG4gIGdldFBhdHRlcm4oY3R4LCBvd25lciwgaW52ZXJzZSwgcGF0aFR5cGUpIHtcbiAgICBsZXQgcGF0dGVybjtcbiAgICBpZiAocGF0aFR5cGUgPT09IFBhdGhUeXBlLlNUUk9LRSB8fCBwYXRoVHlwZSA9PT0gUGF0aFR5cGUuRklMTCkge1xuICAgICAgY29uc3Qgb3duZXJCQm94ID0gb3duZXIuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KHBhdGhUeXBlLCBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCkpIHx8IFswLCAwLCAwLCAwXTtcbiAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5jZWlsKG93bmVyQkJveFsyXSAtIG93bmVyQkJveFswXSkgfHwgMTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguY2VpbChvd25lckJCb3hbM10gLSBvd25lckJCb3hbMV0pIHx8IDE7XG4gICAgICBjb25zdCB0bXBDYW52YXMgPSBvd25lci5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJwYXR0ZXJuXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICB0bXBDdHguY2xlYXJSZWN0KDAsIDAsIHRtcEN0eC5jYW52YXMud2lkdGgsIHRtcEN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgIHRtcEN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHRtcEN0eC5yZWN0KDAsIDAsIHRtcEN0eC5jYW52YXMud2lkdGgsIHRtcEN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgIHRtcEN0eC50cmFuc2xhdGUoLW93bmVyQkJveFswXSwgLW93bmVyQkJveFsxXSk7XG4gICAgICBpbnZlcnNlID0gVXRpbC50cmFuc2Zvcm0oaW52ZXJzZSwgWzEsIDAsIDAsIDEsIG93bmVyQkJveFswXSwgb3duZXJCQm94WzFdXSk7XG4gICAgICB0bXBDdHgudHJhbnNmb3JtKC4uLm93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICAgIHRtcEN0eC50cmFuc2Zvcm0oLi4udGhpcy5tYXRyaXgpO1xuICAgICAgfVxuICAgICAgYXBwbHlCb3VuZGluZ0JveCh0bXBDdHgsIHRoaXMuX2Jib3gpO1xuICAgICAgdG1wQ3R4LmZpbGxTdHlsZSA9IHRoaXMuX2NyZWF0ZUdyYWRpZW50KHRtcEN0eCk7XG4gICAgICB0bXBDdHguZmlsbCgpO1xuICAgICAgcGF0dGVybiA9IGN0eC5jcmVhdGVQYXR0ZXJuKHRtcENhbnZhcy5jYW52YXMsIFwibm8tcmVwZWF0XCIpO1xuICAgICAgY29uc3QgZG9tTWF0cml4ID0gbmV3IERPTU1hdHJpeChpbnZlcnNlKTtcbiAgICAgIHBhdHRlcm4uc2V0VHJhbnNmb3JtKGRvbU1hdHJpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwcGx5Qm91bmRpbmdCb3goY3R4LCB0aGlzLl9iYm94KTtcbiAgICAgIHBhdHRlcm4gPSB0aGlzLl9jcmVhdGVHcmFkaWVudChjdHgpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxufVxuZnVuY3Rpb24gZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHAxLCBwMiwgcDMsIGMxLCBjMiwgYzMpIHtcbiAgY29uc3QgY29vcmRzID0gY29udGV4dC5jb29yZHMsXG4gICAgY29sb3JzID0gY29udGV4dC5jb2xvcnM7XG4gIGNvbnN0IGJ5dGVzID0gZGF0YS5kYXRhLFxuICAgIHJvd1NpemUgPSBkYXRhLndpZHRoICogNDtcbiAgbGV0IHRtcDtcbiAgaWYgKGNvb3Jkc1twMSArIDFdID4gY29vcmRzW3AyICsgMV0pIHtcbiAgICB0bXAgPSBwMTtcbiAgICBwMSA9IHAyO1xuICAgIHAyID0gdG1wO1xuICAgIHRtcCA9IGMxO1xuICAgIGMxID0gYzI7XG4gICAgYzIgPSB0bXA7XG4gIH1cbiAgaWYgKGNvb3Jkc1twMiArIDFdID4gY29vcmRzW3AzICsgMV0pIHtcbiAgICB0bXAgPSBwMjtcbiAgICBwMiA9IHAzO1xuICAgIHAzID0gdG1wO1xuICAgIHRtcCA9IGMyO1xuICAgIGMyID0gYzM7XG4gICAgYzMgPSB0bXA7XG4gIH1cbiAgaWYgKGNvb3Jkc1twMSArIDFdID4gY29vcmRzW3AyICsgMV0pIHtcbiAgICB0bXAgPSBwMTtcbiAgICBwMSA9IHAyO1xuICAgIHAyID0gdG1wO1xuICAgIHRtcCA9IGMxO1xuICAgIGMxID0gYzI7XG4gICAgYzIgPSB0bXA7XG4gIH1cbiAgY29uc3QgeDEgPSAoY29vcmRzW3AxXSArIGNvbnRleHQub2Zmc2V0WCkgKiBjb250ZXh0LnNjYWxlWDtcbiAgY29uc3QgeTEgPSAoY29vcmRzW3AxICsgMV0gKyBjb250ZXh0Lm9mZnNldFkpICogY29udGV4dC5zY2FsZVk7XG4gIGNvbnN0IHgyID0gKGNvb3Jkc1twMl0gKyBjb250ZXh0Lm9mZnNldFgpICogY29udGV4dC5zY2FsZVg7XG4gIGNvbnN0IHkyID0gKGNvb3Jkc1twMiArIDFdICsgY29udGV4dC5vZmZzZXRZKSAqIGNvbnRleHQuc2NhbGVZO1xuICBjb25zdCB4MyA9IChjb29yZHNbcDNdICsgY29udGV4dC5vZmZzZXRYKSAqIGNvbnRleHQuc2NhbGVYO1xuICBjb25zdCB5MyA9IChjb29yZHNbcDMgKyAxXSArIGNvbnRleHQub2Zmc2V0WSkgKiBjb250ZXh0LnNjYWxlWTtcbiAgaWYgKHkxID49IHkzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGMxciA9IGNvbG9yc1tjMV0sXG4gICAgYzFnID0gY29sb3JzW2MxICsgMV0sXG4gICAgYzFiID0gY29sb3JzW2MxICsgMl07XG4gIGNvbnN0IGMyciA9IGNvbG9yc1tjMl0sXG4gICAgYzJnID0gY29sb3JzW2MyICsgMV0sXG4gICAgYzJiID0gY29sb3JzW2MyICsgMl07XG4gIGNvbnN0IGMzciA9IGNvbG9yc1tjM10sXG4gICAgYzNnID0gY29sb3JzW2MzICsgMV0sXG4gICAgYzNiID0gY29sb3JzW2MzICsgMl07XG4gIGNvbnN0IG1pblkgPSBNYXRoLnJvdW5kKHkxKSxcbiAgICBtYXhZID0gTWF0aC5yb3VuZCh5Myk7XG4gIGxldCB4YSwgY2FyLCBjYWcsIGNhYjtcbiAgbGV0IHhiLCBjYnIsIGNiZywgY2JiO1xuICBmb3IgKGxldCB5ID0gbWluWTsgeSA8PSBtYXhZOyB5KyspIHtcbiAgICBpZiAoeSA8IHkyKSB7XG4gICAgICBjb25zdCBrID0geSA8IHkxID8gMCA6ICh5MSAtIHkpIC8gKHkxIC0geTIpO1xuICAgICAgeGEgPSB4MSAtICh4MSAtIHgyKSAqIGs7XG4gICAgICBjYXIgPSBjMXIgLSAoYzFyIC0gYzJyKSAqIGs7XG4gICAgICBjYWcgPSBjMWcgLSAoYzFnIC0gYzJnKSAqIGs7XG4gICAgICBjYWIgPSBjMWIgLSAoYzFiIC0gYzJiKSAqIGs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBrO1xuICAgICAgaWYgKHkgPiB5Mykge1xuICAgICAgICBrID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoeTIgPT09IHkzKSB7XG4gICAgICAgIGsgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgayA9ICh5MiAtIHkpIC8gKHkyIC0geTMpO1xuICAgICAgfVxuICAgICAgeGEgPSB4MiAtICh4MiAtIHgzKSAqIGs7XG4gICAgICBjYXIgPSBjMnIgLSAoYzJyIC0gYzNyKSAqIGs7XG4gICAgICBjYWcgPSBjMmcgLSAoYzJnIC0gYzNnKSAqIGs7XG4gICAgICBjYWIgPSBjMmIgLSAoYzJiIC0gYzNiKSAqIGs7XG4gICAgfVxuICAgIGxldCBrO1xuICAgIGlmICh5IDwgeTEpIHtcbiAgICAgIGsgPSAwO1xuICAgIH0gZWxzZSBpZiAoeSA+IHkzKSB7XG4gICAgICBrID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgayA9ICh5MSAtIHkpIC8gKHkxIC0geTMpO1xuICAgIH1cbiAgICB4YiA9IHgxIC0gKHgxIC0geDMpICogaztcbiAgICBjYnIgPSBjMXIgLSAoYzFyIC0gYzNyKSAqIGs7XG4gICAgY2JnID0gYzFnIC0gKGMxZyAtIGMzZykgKiBrO1xuICAgIGNiYiA9IGMxYiAtIChjMWIgLSBjM2IpICogaztcbiAgICBjb25zdCB4MV8gPSBNYXRoLnJvdW5kKE1hdGgubWluKHhhLCB4YikpO1xuICAgIGNvbnN0IHgyXyA9IE1hdGgucm91bmQoTWF0aC5tYXgoeGEsIHhiKSk7XG4gICAgbGV0IGogPSByb3dTaXplICogeSArIHgxXyAqIDQ7XG4gICAgZm9yIChsZXQgeCA9IHgxXzsgeCA8PSB4Ml87IHgrKykge1xuICAgICAgayA9ICh4YSAtIHgpIC8gKHhhIC0geGIpO1xuICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgIGsgPSAwO1xuICAgICAgfSBlbHNlIGlmIChrID4gMSkge1xuICAgICAgICBrID0gMTtcbiAgICAgIH1cbiAgICAgIGJ5dGVzW2orK10gPSBjYXIgLSAoY2FyIC0gY2JyKSAqIGsgfCAwO1xuICAgICAgYnl0ZXNbaisrXSA9IGNhZyAtIChjYWcgLSBjYmcpICogayB8IDA7XG4gICAgICBieXRlc1tqKytdID0gY2FiIC0gKGNhYiAtIGNiYikgKiBrIHwgMDtcbiAgICAgIGJ5dGVzW2orK10gPSAyNTU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkcmF3RmlndXJlKGRhdGEsIGZpZ3VyZSwgY29udGV4dCkge1xuICBjb25zdCBwcyA9IGZpZ3VyZS5jb29yZHM7XG4gIGNvbnN0IGNzID0gZmlndXJlLmNvbG9ycztcbiAgbGV0IGksIGlpO1xuICBzd2l0Y2ggKGZpZ3VyZS50eXBlKSB7XG4gICAgY2FzZSBcImxhdHRpY2VcIjpcbiAgICAgIGNvbnN0IHZlcnRpY2VzUGVyUm93ID0gZmlndXJlLnZlcnRpY2VzUGVyUm93O1xuICAgICAgY29uc3Qgcm93cyA9IE1hdGguZmxvb3IocHMubGVuZ3RoIC8gdmVydGljZXNQZXJSb3cpIC0gMTtcbiAgICAgIGNvbnN0IGNvbHMgPSB2ZXJ0aWNlc1BlclJvdyAtIDE7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgIGxldCBxID0gaSAqIHZlcnRpY2VzUGVyUm93O1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHM7IGorKywgcSsrKSB7XG4gICAgICAgICAgZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHBzW3FdLCBwc1txICsgMV0sIHBzW3EgKyB2ZXJ0aWNlc1BlclJvd10sIGNzW3FdLCBjc1txICsgMV0sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvd10pO1xuICAgICAgICAgIGRyYXdUcmlhbmdsZShkYXRhLCBjb250ZXh0LCBwc1txICsgdmVydGljZXNQZXJSb3cgKyAxXSwgcHNbcSArIDFdLCBwc1txICsgdmVydGljZXNQZXJSb3ddLCBjc1txICsgdmVydGljZXNQZXJSb3cgKyAxXSwgY3NbcSArIDFdLCBjc1txICsgdmVydGljZXNQZXJSb3ddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInRyaWFuZ2xlc1wiOlxuICAgICAgZm9yIChpID0gMCwgaWkgPSBwcy5sZW5ndGg7IGkgPCBpaTsgaSArPSAzKSB7XG4gICAgICAgIGRyYXdUcmlhbmdsZShkYXRhLCBjb250ZXh0LCBwc1tpXSwgcHNbaSArIDFdLCBwc1tpICsgMl0sIGNzW2ldLCBjc1tpICsgMV0sIGNzW2kgKyAyXSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBmaWd1cmVcIik7XG4gIH1cbn1cbmNsYXNzIE1lc2hTaGFkaW5nUGF0dGVybiBleHRlbmRzIEJhc2VTaGFkaW5nUGF0dGVybiB7XG4gIGNvbnN0cnVjdG9yKElSKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9jb29yZHMgPSBJUlsyXTtcbiAgICB0aGlzLl9jb2xvcnMgPSBJUlszXTtcbiAgICB0aGlzLl9maWd1cmVzID0gSVJbNF07XG4gICAgdGhpcy5fYm91bmRzID0gSVJbNV07XG4gICAgdGhpcy5fYmJveCA9IElSWzZdO1xuICAgIHRoaXMuX2JhY2tncm91bmQgPSBJUls3XTtcbiAgICB0aGlzLm1hdHJpeCA9IG51bGw7XG4gIH1cbiAgX2NyZWF0ZU1lc2hDYW52YXMoY29tYmluZWRTY2FsZSwgYmFja2dyb3VuZENvbG9yLCBjYWNoZWRDYW52YXNlcykge1xuICAgIGNvbnN0IEVYUEVDVEVEX1NDQUxFID0gMS4xO1xuICAgIGNvbnN0IE1BWF9QQVRURVJOX1NJWkUgPSAzMDAwO1xuICAgIGNvbnN0IEJPUkRFUl9TSVpFID0gMjtcbiAgICBjb25zdCBvZmZzZXRYID0gTWF0aC5mbG9vcih0aGlzLl9ib3VuZHNbMF0pO1xuICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLmZsb29yKHRoaXMuX2JvdW5kc1sxXSk7XG4gICAgY29uc3QgYm91bmRzV2lkdGggPSBNYXRoLmNlaWwodGhpcy5fYm91bmRzWzJdKSAtIG9mZnNldFg7XG4gICAgY29uc3QgYm91bmRzSGVpZ2h0ID0gTWF0aC5jZWlsKHRoaXMuX2JvdW5kc1szXSkgLSBvZmZzZXRZO1xuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5taW4oTWF0aC5jZWlsKE1hdGguYWJzKGJvdW5kc1dpZHRoICogY29tYmluZWRTY2FsZVswXSAqIEVYUEVDVEVEX1NDQUxFKSksIE1BWF9QQVRURVJOX1NJWkUpO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWluKE1hdGguY2VpbChNYXRoLmFicyhib3VuZHNIZWlnaHQgKiBjb21iaW5lZFNjYWxlWzFdICogRVhQRUNURURfU0NBTEUpKSwgTUFYX1BBVFRFUk5fU0laRSk7XG4gICAgY29uc3Qgc2NhbGVYID0gYm91bmRzV2lkdGggLyB3aWR0aDtcbiAgICBjb25zdCBzY2FsZVkgPSBib3VuZHNIZWlnaHQgLyBoZWlnaHQ7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIGNvb3JkczogdGhpcy5fY29vcmRzLFxuICAgICAgY29sb3JzOiB0aGlzLl9jb2xvcnMsXG4gICAgICBvZmZzZXRYOiAtb2Zmc2V0WCxcbiAgICAgIG9mZnNldFk6IC1vZmZzZXRZLFxuICAgICAgc2NhbGVYOiAxIC8gc2NhbGVYLFxuICAgICAgc2NhbGVZOiAxIC8gc2NhbGVZXG4gICAgfTtcbiAgICBjb25zdCBwYWRkZWRXaWR0aCA9IHdpZHRoICsgQk9SREVSX1NJWkUgKiAyO1xuICAgIGNvbnN0IHBhZGRlZEhlaWdodCA9IGhlaWdodCArIEJPUkRFUl9TSVpFICogMjtcbiAgICBjb25zdCB0bXBDYW52YXMgPSBjYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtZXNoXCIsIHBhZGRlZFdpZHRoLCBwYWRkZWRIZWlnaHQpO1xuICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IGRhdGEgPSB0bXBDdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gZGF0YS5kYXRhO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gYnl0ZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNCkge1xuICAgICAgICBieXRlc1tpXSA9IGJhY2tncm91bmRDb2xvclswXTtcbiAgICAgICAgYnl0ZXNbaSArIDFdID0gYmFja2dyb3VuZENvbG9yWzFdO1xuICAgICAgICBieXRlc1tpICsgMl0gPSBiYWNrZ3JvdW5kQ29sb3JbMl07XG4gICAgICAgIGJ5dGVzW2kgKyAzXSA9IDI1NTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBmaWd1cmUgb2YgdGhpcy5fZmlndXJlcykge1xuICAgICAgZHJhd0ZpZ3VyZShkYXRhLCBmaWd1cmUsIGNvbnRleHQpO1xuICAgIH1cbiAgICB0bXBDdHgucHV0SW1hZ2VEYXRhKGRhdGEsIEJPUkRFUl9TSVpFLCBCT1JERVJfU0laRSk7XG4gICAgY29uc3QgY2FudmFzID0gdG1wQ2FudmFzLmNhbnZhcztcbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzLFxuICAgICAgb2Zmc2V0WDogb2Zmc2V0WCAtIEJPUkRFUl9TSVpFICogc2NhbGVYLFxuICAgICAgb2Zmc2V0WTogb2Zmc2V0WSAtIEJPUkRFUl9TSVpFICogc2NhbGVZLFxuICAgICAgc2NhbGVYLFxuICAgICAgc2NhbGVZXG4gICAgfTtcbiAgfVxuICBpc01vZGlmeWluZ0N1cnJlbnRUcmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0UGF0dGVybihjdHgsIG93bmVyLCBpbnZlcnNlLCBwYXRoVHlwZSkge1xuICAgIGFwcGx5Qm91bmRpbmdCb3goY3R4LCB0aGlzLl9iYm94KTtcbiAgICBjb25zdCBzY2FsZSA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG4gICAgaWYgKHBhdGhUeXBlID09PSBQYXRoVHlwZS5TSEFESU5HKSB7XG4gICAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KSwgc2NhbGUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgIFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodGhpcy5tYXRyaXgsIHNjYWxlKTtcbiAgICAgIGNvbnN0IFttYXRyaXhTY2FsZVgsIG1hdHJpeFNjYWxlWV0gPSBzY2FsZTtcbiAgICAgIFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUob3duZXIuYmFzZVRyYW5zZm9ybSwgc2NhbGUpO1xuICAgICAgc2NhbGVbMF0gKj0gbWF0cml4U2NhbGVYO1xuICAgICAgc2NhbGVbMV0gKj0gbWF0cml4U2NhbGVZO1xuICAgIH0gZWxzZSB7XG4gICAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKG93bmVyLmJhc2VUcmFuc2Zvcm0sIHNjYWxlKTtcbiAgICB9XG4gICAgY29uc3QgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcyA9IHRoaXMuX2NyZWF0ZU1lc2hDYW52YXMoc2NhbGUsIHBhdGhUeXBlID09PSBQYXRoVHlwZS5TSEFESU5HID8gbnVsbCA6IHRoaXMuX2JhY2tncm91bmQsIG93bmVyLmNhY2hlZENhbnZhc2VzKTtcbiAgICBpZiAocGF0aFR5cGUgIT09IFBhdGhUeXBlLlNIQURJTkcpIHtcbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4ub3duZXIuYmFzZVRyYW5zZm9ybSk7XG4gICAgICBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSguLi50aGlzLm1hdHJpeCk7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC50cmFuc2xhdGUodGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRYLCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFkpO1xuICAgIGN0eC5zY2FsZSh0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWCwgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVkpO1xuICAgIHJldHVybiBjdHguY3JlYXRlUGF0dGVybih0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLmNhbnZhcywgXCJuby1yZXBlYXRcIik7XG4gIH1cbn1cbmNsYXNzIER1bW15U2hhZGluZ1BhdHRlcm4gZXh0ZW5kcyBCYXNlU2hhZGluZ1BhdHRlcm4ge1xuICBnZXRQYXR0ZXJuKCkge1xuICAgIHJldHVybiBcImhvdHBpbmtcIjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U2hhZGluZ1BhdHRlcm4oSVIpIHtcbiAgc3dpdGNoIChJUlswXSkge1xuICAgIGNhc2UgXCJSYWRpYWxBeGlhbFwiOlxuICAgICAgcmV0dXJuIG5ldyBSYWRpYWxBeGlhbFNoYWRpbmdQYXR0ZXJuKElSKTtcbiAgICBjYXNlIFwiTWVzaFwiOlxuICAgICAgcmV0dXJuIG5ldyBNZXNoU2hhZGluZ1BhdHRlcm4oSVIpO1xuICAgIGNhc2UgXCJEdW1teVwiOlxuICAgICAgcmV0dXJuIG5ldyBEdW1teVNoYWRpbmdQYXR0ZXJuKCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIElSIHR5cGU6ICR7SVJbMF19YCk7XG59XG5jb25zdCBQYWludFR5cGUgPSB7XG4gIENPTE9SRUQ6IDEsXG4gIFVOQ09MT1JFRDogMlxufTtcbmNsYXNzIFRpbGluZ1BhdHRlcm4ge1xuICBzdGF0aWMgTUFYX1BBVFRFUk5fU0laRSA9IDMwMDA7XG4gIGNvbnN0cnVjdG9yKElSLCBjdHgsIGNhbnZhc0dyYXBoaWNzRmFjdG9yeSwgYmFzZVRyYW5zZm9ybSkge1xuICAgIHRoaXMuY29sb3IgPSBJUlsxXTtcbiAgICB0aGlzLm9wZXJhdG9yTGlzdCA9IElSWzJdO1xuICAgIHRoaXMubWF0cml4ID0gSVJbM107XG4gICAgdGhpcy5iYm94ID0gSVJbNF07XG4gICAgdGhpcy54c3RlcCA9IElSWzVdO1xuICAgIHRoaXMueXN0ZXAgPSBJUls2XTtcbiAgICB0aGlzLnBhaW50VHlwZSA9IElSWzddO1xuICAgIHRoaXMudGlsaW5nVHlwZSA9IElSWzhdO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuY2FudmFzR3JhcGhpY3NGYWN0b3J5ID0gY2FudmFzR3JhcGhpY3NGYWN0b3J5O1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IGJhc2VUcmFuc2Zvcm07XG4gIH1cbiAgY3JlYXRlUGF0dGVybkNhbnZhcyhvd25lcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGJib3gsXG4gICAgICBvcGVyYXRvckxpc3QsXG4gICAgICBwYWludFR5cGUsXG4gICAgICB0aWxpbmdUeXBlLFxuICAgICAgY29sb3IsXG4gICAgICBjYW52YXNHcmFwaGljc0ZhY3RvcnlcbiAgICB9ID0gdGhpcztcbiAgICBsZXQge1xuICAgICAgeHN0ZXAsXG4gICAgICB5c3RlcFxuICAgIH0gPSB0aGlzO1xuICAgIHhzdGVwID0gTWF0aC5hYnMoeHN0ZXApO1xuICAgIHlzdGVwID0gTWF0aC5hYnMoeXN0ZXApO1xuICAgIGluZm8oXCJUaWxpbmdUeXBlOiBcIiArIHRpbGluZ1R5cGUpO1xuICAgIGNvbnN0IHgwID0gYmJveFswXSxcbiAgICAgIHkwID0gYmJveFsxXSxcbiAgICAgIHgxID0gYmJveFsyXSxcbiAgICAgIHkxID0gYmJveFszXTtcbiAgICBjb25zdCB3aWR0aCA9IHgxIC0geDA7XG4gICAgY29uc3QgaGVpZ2h0ID0geTEgLSB5MDtcbiAgICBjb25zdCBzY2FsZSA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG4gICAgVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0aGlzLm1hdHJpeCwgc2NhbGUpO1xuICAgIGNvbnN0IFttYXRyaXhTY2FsZVgsIG1hdHJpeFNjYWxlWV0gPSBzY2FsZTtcbiAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRoaXMuYmFzZVRyYW5zZm9ybSwgc2NhbGUpO1xuICAgIGNvbnN0IGNvbWJpbmVkU2NhbGVYID0gbWF0cml4U2NhbGVYICogc2NhbGVbMF07XG4gICAgY29uc3QgY29tYmluZWRTY2FsZVkgPSBtYXRyaXhTY2FsZVkgKiBzY2FsZVsxXTtcbiAgICBsZXQgY2FudmFzV2lkdGggPSB3aWR0aCxcbiAgICAgIGNhbnZhc0hlaWdodCA9IGhlaWdodCxcbiAgICAgIHJlZHJhd0hvcml6b250YWxseSA9IGZhbHNlLFxuICAgICAgcmVkcmF3VmVydGljYWxseSA9IGZhbHNlO1xuICAgIGNvbnN0IHhTY2FsZWRTdGVwID0gTWF0aC5jZWlsKHhzdGVwICogY29tYmluZWRTY2FsZVgpO1xuICAgIGNvbnN0IHlTY2FsZWRTdGVwID0gTWF0aC5jZWlsKHlzdGVwICogY29tYmluZWRTY2FsZVkpO1xuICAgIGNvbnN0IHhTY2FsZWRXaWR0aCA9IE1hdGguY2VpbCh3aWR0aCAqIGNvbWJpbmVkU2NhbGVYKTtcbiAgICBjb25zdCB5U2NhbGVkSGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCAqIGNvbWJpbmVkU2NhbGVZKTtcbiAgICBpZiAoeFNjYWxlZFN0ZXAgPj0geFNjYWxlZFdpZHRoKSB7XG4gICAgICBjYW52YXNXaWR0aCA9IHhzdGVwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWRyYXdIb3Jpem9udGFsbHkgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoeVNjYWxlZFN0ZXAgPj0geVNjYWxlZEhlaWdodCkge1xuICAgICAgY2FudmFzSGVpZ2h0ID0geXN0ZXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZHJhd1ZlcnRpY2FsbHkgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBkaW14ID0gdGhpcy5nZXRTaXplQW5kU2NhbGUoY2FudmFzV2lkdGgsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgY29tYmluZWRTY2FsZVgpO1xuICAgIGNvbnN0IGRpbXkgPSB0aGlzLmdldFNpemVBbmRTY2FsZShjYW52YXNIZWlnaHQsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQsIGNvbWJpbmVkU2NhbGVZKTtcbiAgICBjb25zdCB0bXBDYW52YXMgPSBvd25lci5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJwYXR0ZXJuXCIsIGRpbXguc2l6ZSwgZGlteS5zaXplKTtcbiAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICBjb25zdCBncmFwaGljcyA9IGNhbnZhc0dyYXBoaWNzRmFjdG9yeS5jcmVhdGVDYW52YXNHcmFwaGljcyh0bXBDdHgpO1xuICAgIGdyYXBoaWNzLmdyb3VwTGV2ZWwgPSBvd25lci5ncm91cExldmVsO1xuICAgIHRoaXMuc2V0RmlsbEFuZFN0cm9rZVN0eWxlVG9Db250ZXh0KGdyYXBoaWNzLCBwYWludFR5cGUsIGNvbG9yKTtcbiAgICB0bXBDdHgudHJhbnNsYXRlKC1kaW14LnNjYWxlICogeDAsIC1kaW15LnNjYWxlICogeTApO1xuICAgIGdyYXBoaWNzLnRyYW5zZm9ybSgwLCBkaW14LnNjYWxlLCAwLCAwLCBkaW15LnNjYWxlLCAwLCAwKTtcbiAgICB0bXBDdHguc2F2ZSgpO1xuICAgIGdyYXBoaWNzLmRlcGVuZGVuY3lUcmFja2VyPy5zYXZlKCk7XG4gICAgdGhpcy5jbGlwQmJveChncmFwaGljcywgeDAsIHkwLCB4MSwgeTEpO1xuICAgIGdyYXBoaWNzLmJhc2VUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGdyYXBoaWNzLmN0eCk7XG4gICAgZ3JhcGhpY3MuZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QpO1xuICAgIGdyYXBoaWNzLmVuZERyYXdpbmcoKTtcbiAgICBncmFwaGljcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVzdG9yZSgpLnJlY29yZE5lc3RlZERlcGVuZGVuY2llcz8uKCk7XG4gICAgdG1wQ3R4LnJlc3RvcmUoKTtcbiAgICBpZiAocmVkcmF3SG9yaXpvbnRhbGx5IHx8IHJlZHJhd1ZlcnRpY2FsbHkpIHtcbiAgICAgIGNvbnN0IGltYWdlID0gdG1wQ2FudmFzLmNhbnZhcztcbiAgICAgIGlmIChyZWRyYXdIb3Jpem9udGFsbHkpIHtcbiAgICAgICAgY2FudmFzV2lkdGggPSB4c3RlcDtcbiAgICAgIH1cbiAgICAgIGlmIChyZWRyYXdWZXJ0aWNhbGx5KSB7XG4gICAgICAgIGNhbnZhc0hlaWdodCA9IHlzdGVwO1xuICAgICAgfVxuICAgICAgY29uc3QgZGlteDIgPSB0aGlzLmdldFNpemVBbmRTY2FsZShjYW52YXNXaWR0aCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCBjb21iaW5lZFNjYWxlWCk7XG4gICAgICBjb25zdCBkaW15MiA9IHRoaXMuZ2V0U2l6ZUFuZFNjYWxlKGNhbnZhc0hlaWdodCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCwgY29tYmluZWRTY2FsZVkpO1xuICAgICAgY29uc3QgeFNpemUgPSBkaW14Mi5zaXplO1xuICAgICAgY29uc3QgeVNpemUgPSBkaW15Mi5zaXplO1xuICAgICAgY29uc3QgdG1wQ2FudmFzMiA9IG93bmVyLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcInBhdHRlcm4td29ya2Fyb3VuZFwiLCB4U2l6ZSwgeVNpemUpO1xuICAgICAgY29uc3QgdG1wQ3R4MiA9IHRtcENhbnZhczIuY29udGV4dDtcbiAgICAgIGNvbnN0IGlpID0gcmVkcmF3SG9yaXpvbnRhbGx5ID8gTWF0aC5mbG9vcih3aWR0aCAvIHhzdGVwKSA6IDA7XG4gICAgICBjb25zdCBqaiA9IHJlZHJhd1ZlcnRpY2FsbHkgPyBNYXRoLmZsb29yKGhlaWdodCAvIHlzdGVwKSA6IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBpaTsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDw9IGpqOyBqKyspIHtcbiAgICAgICAgICB0bXBDdHgyLmRyYXdJbWFnZShpbWFnZSwgeFNpemUgKiBpLCB5U2l6ZSAqIGosIHhTaXplLCB5U2l6ZSwgMCwgMCwgeFNpemUsIHlTaXplKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FudmFzOiB0bXBDYW52YXMyLmNhbnZhcyxcbiAgICAgICAgc2NhbGVYOiBkaW14Mi5zY2FsZSxcbiAgICAgICAgc2NhbGVZOiBkaW15Mi5zY2FsZSxcbiAgICAgICAgb2Zmc2V0WDogeDAsXG4gICAgICAgIG9mZnNldFk6IHkwXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzOiB0bXBDYW52YXMuY2FudmFzLFxuICAgICAgc2NhbGVYOiBkaW14LnNjYWxlLFxuICAgICAgc2NhbGVZOiBkaW15LnNjYWxlLFxuICAgICAgb2Zmc2V0WDogeDAsXG4gICAgICBvZmZzZXRZOiB5MFxuICAgIH07XG4gIH1cbiAgZ2V0U2l6ZUFuZFNjYWxlKHN0ZXAsIHJlYWxPdXRwdXRTaXplLCBzY2FsZSkge1xuICAgIGNvbnN0IG1heFNpemUgPSBNYXRoLm1heChUaWxpbmdQYXR0ZXJuLk1BWF9QQVRURVJOX1NJWkUsIHJlYWxPdXRwdXRTaXplKTtcbiAgICBsZXQgc2l6ZSA9IE1hdGguY2VpbChzdGVwICogc2NhbGUpO1xuICAgIGlmIChzaXplID49IG1heFNpemUpIHtcbiAgICAgIHNpemUgPSBtYXhTaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2FsZSA9IHNpemUgLyBzdGVwO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2NhbGUsXG4gICAgICBzaXplXG4gICAgfTtcbiAgfVxuICBjbGlwQmJveChncmFwaGljcywgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICBjb25zdCBiYm94V2lkdGggPSB4MSAtIHgwO1xuICAgIGNvbnN0IGJib3hIZWlnaHQgPSB5MSAtIHkwO1xuICAgIGdyYXBoaWNzLmN0eC5yZWN0KHgwLCB5MCwgYmJveFdpZHRoLCBiYm94SGVpZ2h0KTtcbiAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFt4MCwgeTAsIHgxLCB5MV0sIGdldEN1cnJlbnRUcmFuc2Zvcm0oZ3JhcGhpY3MuY3R4KSwgZ3JhcGhpY3MuY3VycmVudC5taW5NYXgpO1xuICAgIGdyYXBoaWNzLmNsaXAoKTtcbiAgICBncmFwaGljcy5lbmRQYXRoKCk7XG4gIH1cbiAgc2V0RmlsbEFuZFN0cm9rZVN0eWxlVG9Db250ZXh0KGdyYXBoaWNzLCBwYWludFR5cGUsIGNvbG9yKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGdyYXBoaWNzLmN0eCxcbiAgICAgIGN1cnJlbnQgPSBncmFwaGljcy5jdXJyZW50O1xuICAgIHN3aXRjaCAocGFpbnRUeXBlKSB7XG4gICAgICBjYXNlIFBhaW50VHlwZS5DT0xPUkVEOlxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZmlsbFN0eWxlLFxuICAgICAgICAgIHN0cm9rZVN0eWxlXG4gICAgICAgIH0gPSB0aGlzLmN0eDtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjdXJyZW50LmZpbGxDb2xvciA9IGZpbGxTdHlsZTtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBzdHJva2VTdHlsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBhaW50VHlwZS5VTkNPTE9SRUQ6XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICBjdXJyZW50LmZpbGxDb2xvciA9IGN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBjb2xvcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYFVuc3VwcG9ydGVkIHBhaW50IHR5cGU6ICR7cGFpbnRUeXBlfWApO1xuICAgIH1cbiAgfVxuICBpc01vZGlmeWluZ0N1cnJlbnRUcmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldFBhdHRlcm4oY3R4LCBvd25lciwgaW52ZXJzZSwgcGF0aFR5cGUpIHtcbiAgICBsZXQgbWF0cml4ID0gaW52ZXJzZTtcbiAgICBpZiAocGF0aFR5cGUgIT09IFBhdGhUeXBlLlNIQURJTkcpIHtcbiAgICAgIG1hdHJpeCA9IFV0aWwudHJhbnNmb3JtKG1hdHJpeCwgb3duZXIuYmFzZVRyYW5zZm9ybSk7XG4gICAgICBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgICAgbWF0cml4ID0gVXRpbC50cmFuc2Zvcm0obWF0cml4LCB0aGlzLm1hdHJpeCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRlbXBvcmFyeVBhdHRlcm5DYW52YXMgPSB0aGlzLmNyZWF0ZVBhdHRlcm5DYW52YXMob3duZXIpO1xuICAgIGxldCBkb21NYXRyaXggPSBuZXcgRE9NTWF0cml4KG1hdHJpeCk7XG4gICAgZG9tTWF0cml4ID0gZG9tTWF0cml4LnRyYW5zbGF0ZSh0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFgsIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WSk7XG4gICAgZG9tTWF0cml4ID0gZG9tTWF0cml4LnNjYWxlKDEgLyB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWCwgMSAvIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVZKTtcbiAgICBjb25zdCBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4odGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5jYW52YXMsIFwicmVwZWF0XCIpO1xuICAgIHBhdHRlcm4uc2V0VHJhbnNmb3JtKGRvbU1hdHJpeCk7XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbn1cblxuOy8vIC4vc3JjL3NoYXJlZC9pbWFnZV91dGlscy5qc1xuXG5mdW5jdGlvbiBjb252ZXJ0VG9SR0JBKHBhcmFtcykge1xuICBzd2l0Y2ggKHBhcmFtcy5raW5kKSB7XG4gICAgY2FzZSBJbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFA6XG4gICAgICByZXR1cm4gY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEocGFyYW1zKTtcbiAgICBjYXNlIEltYWdlS2luZC5SR0JfMjRCUFA6XG4gICAgICByZXR1cm4gY29udmVydFJHQlRvUkdCQShwYXJhbXMpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEoe1xuICBzcmMsXG4gIHNyY1BvcyA9IDAsXG4gIGRlc3QsXG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIG5vbkJsYWNrQ29sb3IgPSAweGZmZmZmZmZmLFxuICBpbnZlcnNlRGVjb2RlID0gZmFsc2Vcbn0pIHtcbiAgY29uc3QgYmxhY2sgPSB1dGlsX0ZlYXR1cmVUZXN0LmlzTGl0dGxlRW5kaWFuID8gMHhmZjAwMDAwMCA6IDB4MDAwMDAwZmY7XG4gIGNvbnN0IFt6ZXJvTWFwcGluZywgb25lTWFwcGluZ10gPSBpbnZlcnNlRGVjb2RlID8gW25vbkJsYWNrQ29sb3IsIGJsYWNrXSA6IFtibGFjaywgbm9uQmxhY2tDb2xvcl07XG4gIGNvbnN0IHdpZHRoSW5Tb3VyY2UgPSB3aWR0aCA+PiAzO1xuICBjb25zdCB3aWR0aFJlbWFpbmRlciA9IHdpZHRoICYgNztcbiAgY29uc3Qgc3JjTGVuZ3RoID0gc3JjLmxlbmd0aDtcbiAgZGVzdCA9IG5ldyBVaW50MzJBcnJheShkZXN0LmJ1ZmZlcik7XG4gIGxldCBkZXN0UG9zID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgIGZvciAoY29uc3QgbWF4ID0gc3JjUG9zICsgd2lkdGhJblNvdXJjZTsgc3JjUG9zIDwgbWF4OyBzcmNQb3MrKykge1xuICAgICAgY29uc3QgZWxlbSA9IHNyY1BvcyA8IHNyY0xlbmd0aCA/IHNyY1tzcmNQb3NdIDogMjU1O1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMDAwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgIH1cbiAgICBpZiAod2lkdGhSZW1haW5kZXIgPT09IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBlbGVtID0gc3JjUG9zIDwgc3JjTGVuZ3RoID8gc3JjW3NyY1BvcysrXSA6IDI1NTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpZHRoUmVtYWluZGVyOyBqKyspIHtcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAxIDw8IDcgLSBqID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHNyY1BvcyxcbiAgICBkZXN0UG9zXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0UkdCVG9SR0JBKHtcbiAgc3JjLFxuICBzcmNQb3MgPSAwLFxuICBkZXN0LFxuICBkZXN0UG9zID0gMCxcbiAgd2lkdGgsXG4gIGhlaWdodFxufSkge1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IGxlbiA9IHdpZHRoICogaGVpZ2h0ICogMztcbiAgY29uc3QgbGVuMzIgPSBsZW4gPj4gMjtcbiAgY29uc3Qgc3JjMzIgPSBuZXcgVWludDMyQXJyYXkoc3JjLmJ1ZmZlciwgc3JjUG9zLCBsZW4zMik7XG4gIGlmIChGZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbikge1xuICAgIGZvciAoOyBpIDwgbGVuMzIgLSAyOyBpICs9IDMsIGRlc3RQb3MgKz0gNCkge1xuICAgICAgY29uc3QgczEgPSBzcmMzMltpXTtcbiAgICAgIGNvbnN0IHMyID0gc3JjMzJbaSArIDFdO1xuICAgICAgY29uc3QgczMgPSBzcmMzMltpICsgMl07XG4gICAgICBkZXN0W2Rlc3RQb3NdID0gczEgfCAweGZmMDAwMDAwO1xuICAgICAgZGVzdFtkZXN0UG9zICsgMV0gPSBzMSA+Pj4gMjQgfCBzMiA8PCA4IHwgMHhmZjAwMDAwMDtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDJdID0gczIgPj4+IDE2IHwgczMgPDwgMTYgfCAweGZmMDAwMDAwO1xuICAgICAgZGVzdFtkZXN0UG9zICsgM10gPSBzMyA+Pj4gOCB8IDB4ZmYwMDAwMDA7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSBpICogNCwgamogPSBzcmNQb3MgKyBsZW47IGogPCBqajsgaiArPSAzKSB7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbal0gfCBzcmNbaiArIDFdIDw8IDggfCBzcmNbaiArIDJdIDw8IDE2IHwgMHhmZjAwMDAwMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICg7IGkgPCBsZW4zMiAtIDI7IGkgKz0gMywgZGVzdFBvcyArPSA0KSB7XG4gICAgICBjb25zdCBzMSA9IHNyYzMyW2ldO1xuICAgICAgY29uc3QgczIgPSBzcmMzMltpICsgMV07XG4gICAgICBjb25zdCBzMyA9IHNyYzMyW2kgKyAyXTtcbiAgICAgIGRlc3RbZGVzdFBvc10gPSBzMSB8IDB4ZmY7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAxXSA9IHMxIDw8IDI0IHwgczIgPj4+IDggfCAweGZmO1xuICAgICAgZGVzdFtkZXN0UG9zICsgMl0gPSBzMiA8PCAxNiB8IHMzID4+PiAxNiB8IDB4ZmY7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAzXSA9IHMzIDw8IDggfCAweGZmO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaSAqIDQsIGpqID0gc3JjUG9zICsgbGVuOyBqIDwgamo7IGogKz0gMykge1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW2pdIDw8IDI0IHwgc3JjW2ogKyAxXSA8PCAxNiB8IHNyY1tqICsgMl0gPDwgOCB8IDB4ZmY7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgc3JjUG9zOiBzcmNQb3MgKyBsZW4sXG4gICAgZGVzdFBvc1xuICB9O1xufVxuZnVuY3Rpb24gZ3JheVRvUkdCQShzcmMsIGRlc3QpIHtcbiAgaWYgKEZlYXR1cmVUZXN0LmlzTGl0dGxlRW5kaWFuKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3JjLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGRlc3RbaV0gPSBzcmNbaV0gKiAweDEwMTAxIHwgMHhmZjAwMDAwMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3JjLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGRlc3RbaV0gPSBzcmNbaV0gKiAweDEwMTAxMDAgfCAweDAwMDAwMGZmO1xuICAgIH1cbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9jYW52YXMuanNcblxuXG5cblxuXG5jb25zdCBNSU5fRk9OVF9TSVpFID0gMTY7XG5jb25zdCBNQVhfRk9OVF9TSVpFID0gMTAwO1xuY29uc3QgRVhFQ1VUSU9OX1RJTUUgPSAxNTtcbmNvbnN0IEVYRUNVVElPTl9TVEVQUyA9IDEwO1xuY29uc3QgRlVMTF9DSFVOS19IRUlHSFQgPSAxNjtcbmNvbnN0IFNDQUxFX01BVFJJWCA9IG5ldyBET01NYXRyaXgoKTtcbmNvbnN0IFhZID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbmNvbnN0IE1JTl9NQVhfSU5JVCA9IG5ldyBGbG9hdDMyQXJyYXkoW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldKTtcbmZ1bmN0aW9uIG1pcnJvckNvbnRleHRPcGVyYXRpb25zKGN0eCwgZGVzdEN0eCkge1xuICBpZiAoY3R4Ll9yZW1vdmVNaXJyb3JpbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250ZXh0IGlzIGFscmVhZHkgZm9yd2FyZGluZyBvcGVyYXRpb25zLlwiKTtcbiAgfVxuICBjdHguX19vcmlnaW5hbFNhdmUgPSBjdHguc2F2ZTtcbiAgY3R4Ll9fb3JpZ2luYWxSZXN0b3JlID0gY3R4LnJlc3RvcmU7XG4gIGN0eC5fX29yaWdpbmFsUm90YXRlID0gY3R4LnJvdGF0ZTtcbiAgY3R4Ll9fb3JpZ2luYWxTY2FsZSA9IGN0eC5zY2FsZTtcbiAgY3R4Ll9fb3JpZ2luYWxUcmFuc2xhdGUgPSBjdHgudHJhbnNsYXRlO1xuICBjdHguX19vcmlnaW5hbFRyYW5zZm9ybSA9IGN0eC50cmFuc2Zvcm07XG4gIGN0eC5fX29yaWdpbmFsU2V0VHJhbnNmb3JtID0gY3R4LnNldFRyYW5zZm9ybTtcbiAgY3R4Ll9fb3JpZ2luYWxSZXNldFRyYW5zZm9ybSA9IGN0eC5yZXNldFRyYW5zZm9ybTtcbiAgY3R4Ll9fb3JpZ2luYWxDbGlwID0gY3R4LmNsaXA7XG4gIGN0eC5fX29yaWdpbmFsTW92ZVRvID0gY3R4Lm1vdmVUbztcbiAgY3R4Ll9fb3JpZ2luYWxMaW5lVG8gPSBjdHgubGluZVRvO1xuICBjdHguX19vcmlnaW5hbEJlemllckN1cnZlVG8gPSBjdHguYmV6aWVyQ3VydmVUbztcbiAgY3R4Ll9fb3JpZ2luYWxSZWN0ID0gY3R4LnJlY3Q7XG4gIGN0eC5fX29yaWdpbmFsQ2xvc2VQYXRoID0gY3R4LmNsb3NlUGF0aDtcbiAgY3R4Ll9fb3JpZ2luYWxCZWdpblBhdGggPSBjdHguYmVnaW5QYXRoO1xuICBjdHguX3JlbW92ZU1pcnJvcmluZyA9ICgpID0+IHtcbiAgICBjdHguc2F2ZSA9IGN0eC5fX29yaWdpbmFsU2F2ZTtcbiAgICBjdHgucmVzdG9yZSA9IGN0eC5fX29yaWdpbmFsUmVzdG9yZTtcbiAgICBjdHgucm90YXRlID0gY3R4Ll9fb3JpZ2luYWxSb3RhdGU7XG4gICAgY3R4LnNjYWxlID0gY3R4Ll9fb3JpZ2luYWxTY2FsZTtcbiAgICBjdHgudHJhbnNsYXRlID0gY3R4Ll9fb3JpZ2luYWxUcmFuc2xhdGU7XG4gICAgY3R4LnRyYW5zZm9ybSA9IGN0eC5fX29yaWdpbmFsVHJhbnNmb3JtO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0gPSBjdHguX19vcmlnaW5hbFNldFRyYW5zZm9ybTtcbiAgICBjdHgucmVzZXRUcmFuc2Zvcm0gPSBjdHguX19vcmlnaW5hbFJlc2V0VHJhbnNmb3JtO1xuICAgIGN0eC5jbGlwID0gY3R4Ll9fb3JpZ2luYWxDbGlwO1xuICAgIGN0eC5tb3ZlVG8gPSBjdHguX19vcmlnaW5hbE1vdmVUbztcbiAgICBjdHgubGluZVRvID0gY3R4Ll9fb3JpZ2luYWxMaW5lVG87XG4gICAgY3R4LmJlemllckN1cnZlVG8gPSBjdHguX19vcmlnaW5hbEJlemllckN1cnZlVG87XG4gICAgY3R4LnJlY3QgPSBjdHguX19vcmlnaW5hbFJlY3Q7XG4gICAgY3R4LmNsb3NlUGF0aCA9IGN0eC5fX29yaWdpbmFsQ2xvc2VQYXRoO1xuICAgIGN0eC5iZWdpblBhdGggPSBjdHguX19vcmlnaW5hbEJlZ2luUGF0aDtcbiAgICBkZWxldGUgY3R4Ll9yZW1vdmVNaXJyb3Jpbmc7XG4gIH07XG4gIGN0eC5zYXZlID0gZnVuY3Rpb24gKCkge1xuICAgIGRlc3RDdHguc2F2ZSgpO1xuICAgIHRoaXMuX19vcmlnaW5hbFNhdmUoKTtcbiAgfTtcbiAgY3R4LnJlc3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVzdEN0eC5yZXN0b3JlKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsUmVzdG9yZSgpO1xuICB9O1xuICBjdHgudHJhbnNsYXRlID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBkZXN0Q3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxUcmFuc2xhdGUoeCwgeSk7XG4gIH07XG4gIGN0eC5zY2FsZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgZGVzdEN0eC5zY2FsZSh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxTY2FsZSh4LCB5KTtcbiAgfTtcbiAgY3R4LnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgZGVzdEN0eC50cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gICAgdGhpcy5fX29yaWdpbmFsVHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICB9O1xuICBjdHguc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBkZXN0Q3R4LnNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxTZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gIH07XG4gIGN0eC5yZXNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICBkZXN0Q3R4LnJlc2V0VHJhbnNmb3JtKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsUmVzZXRUcmFuc2Zvcm0oKTtcbiAgfTtcbiAgY3R4LnJvdGF0ZSA9IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgIGRlc3RDdHgucm90YXRlKGFuZ2xlKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSb3RhdGUoYW5nbGUpO1xuICB9O1xuICBjdHguY2xpcCA9IGZ1bmN0aW9uIChydWxlKSB7XG4gICAgZGVzdEN0eC5jbGlwKHJ1bGUpO1xuICAgIHRoaXMuX19vcmlnaW5hbENsaXAocnVsZSk7XG4gIH07XG4gIGN0eC5tb3ZlVG8gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGRlc3RDdHgubW92ZVRvKHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbE1vdmVUbyh4LCB5KTtcbiAgfTtcbiAgY3R4LmxpbmVUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgZGVzdEN0eC5saW5lVG8oeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsTGluZVRvKHgsIHkpO1xuICB9O1xuICBjdHguYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uIChjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KSB7XG4gICAgZGVzdEN0eC5iZXppZXJDdXJ2ZVRvKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbEJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSk7XG4gIH07XG4gIGN0eC5yZWN0ID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBkZXN0Q3R4LnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5fX29yaWdpbmFsUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgfTtcbiAgY3R4LmNsb3NlUGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICBkZXN0Q3R4LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX19vcmlnaW5hbENsb3NlUGF0aCgpO1xuICB9O1xuICBjdHguYmVnaW5QYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIGRlc3RDdHguYmVnaW5QYXRoKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsQmVnaW5QYXRoKCk7XG4gIH07XG59XG5jbGFzcyBDYWNoZWRDYW52YXNlcyB7XG4gIGNvbnN0cnVjdG9yKGNhbnZhc0ZhY3RvcnkpIHtcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBjYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGdldENhbnZhcyhpZCwgd2lkdGgsIGhlaWdodCkge1xuICAgIGxldCBjYW52YXNFbnRyeTtcbiAgICBpZiAodGhpcy5jYWNoZVtpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2FudmFzRW50cnkgPSB0aGlzLmNhY2hlW2lkXTtcbiAgICAgIHRoaXMuY2FudmFzRmFjdG9yeS5yZXNldChjYW52YXNFbnRyeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbnZhc0VudHJ5ID0gdGhpcy5jYW52YXNGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuY2FjaGVbaWRdID0gY2FudmFzRW50cnk7XG4gICAgfVxuICAgIHJldHVybiBjYW52YXNFbnRyeTtcbiAgfVxuICBkZWxldGUoaWQpIHtcbiAgICBkZWxldGUgdGhpcy5jYWNoZVtpZF07XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLmNhY2hlKSB7XG4gICAgICBjb25zdCBjYW52YXNFbnRyeSA9IHRoaXMuY2FjaGVbaWRdO1xuICAgICAgdGhpcy5jYW52YXNGYWN0b3J5LmRlc3Ryb3koY2FudmFzRW50cnkpO1xuICAgICAgZGVsZXRlIHRoaXMuY2FjaGVbaWRdO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGN0eCwgc3JjSW1nLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCBkZXN0WCwgZGVzdFksIGRlc3RXLCBkZXN0SCkge1xuICBjb25zdCBbYSwgYiwgYywgZCwgdHgsIHR5XSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KTtcbiAgaWYgKGIgPT09IDAgJiYgYyA9PT0gMCkge1xuICAgIGNvbnN0IHRsWCA9IGRlc3RYICogYSArIHR4O1xuICAgIGNvbnN0IHJUbFggPSBNYXRoLnJvdW5kKHRsWCk7XG4gICAgY29uc3QgdGxZID0gZGVzdFkgKiBkICsgdHk7XG4gICAgY29uc3QgclRsWSA9IE1hdGgucm91bmQodGxZKTtcbiAgICBjb25zdCBiclggPSAoZGVzdFggKyBkZXN0VykgKiBhICsgdHg7XG4gICAgY29uc3QgcldpZHRoID0gTWF0aC5hYnMoTWF0aC5yb3VuZChiclgpIC0gclRsWCkgfHwgMTtcbiAgICBjb25zdCBiclkgPSAoZGVzdFkgKyBkZXN0SCkgKiBkICsgdHk7XG4gICAgY29uc3QgckhlaWdodCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJZKSAtIHJUbFkpIHx8IDE7XG4gICAgY3R4LnNldFRyYW5zZm9ybShNYXRoLnNpZ24oYSksIDAsIDAsIE1hdGguc2lnbihkKSwgclRsWCwgclRsWSk7XG4gICAgY3R4LmRyYXdJbWFnZShzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIDAsIDAsIHJXaWR0aCwgckhlaWdodCk7XG4gICAgY3R4LnNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCB0eCwgdHkpO1xuICAgIHJldHVybiBbcldpZHRoLCBySGVpZ2h0XTtcbiAgfVxuICBpZiAoYSA9PT0gMCAmJiBkID09PSAwKSB7XG4gICAgY29uc3QgdGxYID0gZGVzdFkgKiBjICsgdHg7XG4gICAgY29uc3QgclRsWCA9IE1hdGgucm91bmQodGxYKTtcbiAgICBjb25zdCB0bFkgPSBkZXN0WCAqIGIgKyB0eTtcbiAgICBjb25zdCByVGxZID0gTWF0aC5yb3VuZCh0bFkpO1xuICAgIGNvbnN0IGJyWCA9IChkZXN0WSArIGRlc3RIKSAqIGMgKyB0eDtcbiAgICBjb25zdCByV2lkdGggPSBNYXRoLmFicyhNYXRoLnJvdW5kKGJyWCkgLSByVGxYKSB8fCAxO1xuICAgIGNvbnN0IGJyWSA9IChkZXN0WCArIGRlc3RXKSAqIGIgKyB0eTtcbiAgICBjb25zdCBySGVpZ2h0ID0gTWF0aC5hYnMoTWF0aC5yb3VuZChiclkpIC0gclRsWSkgfHwgMTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKDAsIE1hdGguc2lnbihiKSwgTWF0aC5zaWduKGMpLCAwLCByVGxYLCByVGxZKTtcbiAgICBjdHguZHJhd0ltYWdlKHNyY0ltZywgc3JjWCwgc3JjWSwgc3JjVywgc3JjSCwgMCwgMCwgckhlaWdodCwgcldpZHRoKTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIHR4LCB0eSk7XG4gICAgcmV0dXJuIFtySGVpZ2h0LCByV2lkdGhdO1xuICB9XG4gIGN0eC5kcmF3SW1hZ2Uoc3JjSW1nLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCBkZXN0WCwgZGVzdFksIGRlc3RXLCBkZXN0SCk7XG4gIGNvbnN0IHNjYWxlWCA9IE1hdGguaHlwb3QoYSwgYik7XG4gIGNvbnN0IHNjYWxlWSA9IE1hdGguaHlwb3QoYywgZCk7XG4gIHJldHVybiBbc2NhbGVYICogZGVzdFcsIHNjYWxlWSAqIGRlc3RIXTtcbn1cbmNsYXNzIENhbnZhc0V4dHJhU3RhdGUge1xuICBhbHBoYUlzU2hhcGUgPSBmYWxzZTtcbiAgZm9udFNpemUgPSAwO1xuICBmb250U2l6ZVNjYWxlID0gMTtcbiAgdGV4dE1hdHJpeCA9IG51bGw7XG4gIHRleHRNYXRyaXhTY2FsZSA9IDE7XG4gIGZvbnRNYXRyaXggPSBGT05UX0lERU5USVRZX01BVFJJWDtcbiAgbGVhZGluZyA9IDA7XG4gIHggPSAwO1xuICB5ID0gMDtcbiAgbGluZVggPSAwO1xuICBsaW5lWSA9IDA7XG4gIGNoYXJTcGFjaW5nID0gMDtcbiAgd29yZFNwYWNpbmcgPSAwO1xuICB0ZXh0SFNjYWxlID0gMTtcbiAgdGV4dFJlbmRlcmluZ01vZGUgPSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMO1xuICB0ZXh0UmlzZSA9IDA7XG4gIGZpbGxDb2xvciA9IFwiIzAwMDAwMFwiO1xuICBzdHJva2VDb2xvciA9IFwiIzAwMDAwMFwiO1xuICBwYXR0ZXJuRmlsbCA9IGZhbHNlO1xuICBwYXR0ZXJuU3Ryb2tlID0gZmFsc2U7XG4gIGZpbGxBbHBoYSA9IDE7XG4gIHN0cm9rZUFscGhhID0gMTtcbiAgbGluZVdpZHRoID0gMTtcbiAgYWN0aXZlU01hc2sgPSBudWxsO1xuICB0cmFuc2Zlck1hcHMgPSBcIm5vbmVcIjtcbiAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCwgcHJlSW5pdCkge1xuICAgIHByZUluaXQ/Lih0aGlzKTtcbiAgICB0aGlzLmNsaXBCb3ggPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCB3aWR0aCwgaGVpZ2h0XSk7XG4gICAgdGhpcy5taW5NYXggPSBNSU5fTUFYX0lOSVQuc2xpY2UoKTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgY2xvbmUuY2xpcEJveCA9IHRoaXMuY2xpcEJveC5zbGljZSgpO1xuICAgIGNsb25lLm1pbk1heCA9IHRoaXMubWluTWF4LnNsaWNlKCk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIGdldFBhdGhCb3VuZGluZ0JveChwYXRoVHlwZSA9IFBhdGhUeXBlLkZJTEwsIHRyYW5zZm9ybSA9IG51bGwpIHtcbiAgICBjb25zdCBib3ggPSB0aGlzLm1pbk1heC5zbGljZSgpO1xuICAgIGlmIChwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU1RST0tFKSB7XG4gICAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgICB1bnJlYWNoYWJsZShcIlN0cm9rZSBib3VuZGluZyBib3ggbXVzdCBpbmNsdWRlIHRyYW5zZm9ybS5cIik7XG4gICAgICB9XG4gICAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRyYW5zZm9ybSwgWFkpO1xuICAgICAgY29uc3QgeFN0cm9rZVBhZCA9IFhZWzBdICogdGhpcy5saW5lV2lkdGggLyAyO1xuICAgICAgY29uc3QgeVN0cm9rZVBhZCA9IFhZWzFdICogdGhpcy5saW5lV2lkdGggLyAyO1xuICAgICAgYm94WzBdIC09IHhTdHJva2VQYWQ7XG4gICAgICBib3hbMV0gLT0geVN0cm9rZVBhZDtcbiAgICAgIGJveFsyXSArPSB4U3Ryb2tlUGFkO1xuICAgICAgYm94WzNdICs9IHlTdHJva2VQYWQ7XG4gICAgfVxuICAgIHJldHVybiBib3g7XG4gIH1cbiAgdXBkYXRlQ2xpcEZyb21QYXRoKCkge1xuICAgIGNvbnN0IGludGVyc2VjdCA9IFV0aWwuaW50ZXJzZWN0KHRoaXMuY2xpcEJveCwgdGhpcy5nZXRQYXRoQm91bmRpbmdCb3goKSk7XG4gICAgdGhpcy5zdGFydE5ld1BhdGhBbmRDbGlwQm94KGludGVyc2VjdCB8fCBbMCwgMCwgMCwgMF0pO1xuICB9XG4gIGlzRW1wdHlDbGlwKCkge1xuICAgIHJldHVybiB0aGlzLm1pbk1heFswXSA9PT0gSW5maW5pdHk7XG4gIH1cbiAgc3RhcnROZXdQYXRoQW5kQ2xpcEJveChib3gpIHtcbiAgICB0aGlzLmNsaXBCb3guc2V0KGJveCwgMCk7XG4gICAgdGhpcy5taW5NYXguc2V0KE1JTl9NQVhfSU5JVCwgMCk7XG4gIH1cbiAgZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveChwYXRoVHlwZSA9IFBhdGhUeXBlLkZJTEwsIHRyYW5zZm9ybSA9IG51bGwpIHtcbiAgICByZXR1cm4gVXRpbC5pbnRlcnNlY3QodGhpcy5jbGlwQm94LCB0aGlzLmdldFBhdGhCb3VuZGluZ0JveChwYXRoVHlwZSwgdHJhbnNmb3JtKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1dEJpbmFyeUltYWdlRGF0YShjdHgsIGltZ0RhdGEpIHtcbiAgaWYgKGltZ0RhdGEgaW5zdGFuY2VvZiBJbWFnZURhdGEpIHtcbiAgICBjdHgucHV0SW1hZ2VEYXRhKGltZ0RhdGEsIDAsIDApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodCxcbiAgICB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gIGNvbnN0IHBhcnRpYWxDaHVua0hlaWdodCA9IGhlaWdodCAlIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCBmdWxsQ2h1bmtzID0gKGhlaWdodCAtIHBhcnRpYWxDaHVua0hlaWdodCkgLyBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgY29uc3QgdG90YWxDaHVua3MgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQgPT09IDAgPyBmdWxsQ2h1bmtzIDogZnVsbENodW5rcyArIDE7XG4gIGNvbnN0IGNodW5rSW1nRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgbGV0IHNyY1BvcyA9IDAsXG4gICAgZGVzdFBvcztcbiAgY29uc3Qgc3JjID0gaW1nRGF0YS5kYXRhO1xuICBjb25zdCBkZXN0ID0gY2h1bmtJbWdEYXRhLmRhdGE7XG4gIGxldCBpLCBqLCB0aGlzQ2h1bmtIZWlnaHQsIGVsZW1zSW5UaGlzQ2h1bms7XG4gIGlmIChpbWdEYXRhLmtpbmQgPT09IHV0aWxfSW1hZ2VLaW5kLkdSQVlTQ0FMRV8xQlBQKSB7XG4gICAgY29uc3Qgc3JjTGVuZ3RoID0gc3JjLmJ5dGVMZW5ndGg7XG4gICAgY29uc3QgZGVzdDMyID0gbmV3IFVpbnQzMkFycmF5KGRlc3QuYnVmZmVyLCAwLCBkZXN0LmJ5dGVMZW5ndGggPj4gMik7XG4gICAgY29uc3QgZGVzdDMyRGF0YUxlbmd0aCA9IGRlc3QzMi5sZW5ndGg7XG4gICAgY29uc3QgZnVsbFNyY0RpZmYgPSB3aWR0aCArIDcgPj4gMztcbiAgICBjb25zdCB3aGl0ZSA9IDB4ZmZmZmZmZmY7XG4gICAgY29uc3QgYmxhY2sgPSB1dGlsX0ZlYXR1cmVUZXN0LmlzTGl0dGxlRW5kaWFuID8gMHhmZjAwMDAwMCA6IDB4MDAwMDAwZmY7XG4gICAgZm9yIChpID0gMDsgaSA8IHRvdGFsQ2h1bmtzOyBpKyspIHtcbiAgICAgIHRoaXNDaHVua0hlaWdodCA9IGkgPCBmdWxsQ2h1bmtzID8gRlVMTF9DSFVOS19IRUlHSFQgOiBwYXJ0aWFsQ2h1bmtIZWlnaHQ7XG4gICAgICBkZXN0UG9zID0gMDtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzQ2h1bmtIZWlnaHQ7IGorKykge1xuICAgICAgICBjb25zdCBzcmNEaWZmID0gc3JjTGVuZ3RoIC0gc3JjUG9zO1xuICAgICAgICBsZXQgayA9IDA7XG4gICAgICAgIGNvbnN0IGtFbmQgPSBzcmNEaWZmID4gZnVsbFNyY0RpZmYgPyB3aWR0aCA6IHNyY0RpZmYgKiA4IC0gNztcbiAgICAgICAgY29uc3Qga0VuZFVucm9sbGVkID0ga0VuZCAmIH43O1xuICAgICAgICBsZXQgbWFzayA9IDA7XG4gICAgICAgIGxldCBzcmNCeXRlID0gMDtcbiAgICAgICAgZm9yICg7IGsgPCBrRW5kVW5yb2xsZWQ7IGsgKz0gOCkge1xuICAgICAgICAgIHNyY0J5dGUgPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDEyOCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgNjQgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDMyID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAxNiA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgOCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgNCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMiA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMSA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGsgPCBrRW5kOyBrKyspIHtcbiAgICAgICAgICBpZiAobWFzayA9PT0gMCkge1xuICAgICAgICAgICAgc3JjQnl0ZSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgICAgICBtYXNrID0gMTI4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiBtYXNrID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBtYXNrID4+PSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoZGVzdFBvcyA8IGRlc3QzMkRhdGFMZW5ndGgpIHtcbiAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSAwO1xuICAgICAgfVxuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGkgKiBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGltZ0RhdGEua2luZCA9PT0gdXRpbF9JbWFnZUtpbmQuUkdCQV8zMkJQUCkge1xuICAgIGogPSAwO1xuICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIEZVTExfQ0hVTktfSEVJR0hUICogNDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZnVsbENodW5rczsgaSsrKSB7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjUG9zLCBzcmNQb3MgKyBlbGVtc0luVGhpc0NodW5rKSk7XG4gICAgICBzcmNQb3MgKz0gZWxlbXNJblRoaXNDaHVuaztcbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBqKTtcbiAgICAgIGogKz0gRlVMTF9DSFVOS19IRUlHSFQ7XG4gICAgfVxuICAgIGlmIChpIDwgdG90YWxDaHVua3MpIHtcbiAgICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIHBhcnRpYWxDaHVua0hlaWdodCAqIDQ7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjUG9zLCBzcmNQb3MgKyBlbGVtc0luVGhpc0NodW5rKSk7XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGltZ0RhdGEua2luZCA9PT0gdXRpbF9JbWFnZUtpbmQuUkdCXzI0QlBQKSB7XG4gICAgdGhpc0NodW5rSGVpZ2h0ID0gRlVMTF9DSFVOS19IRUlHSFQ7XG4gICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogdGhpc0NodW5rSGVpZ2h0O1xuICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbENodW5rczsgaSsrKSB7XG4gICAgICBpZiAoaSA+PSBmdWxsQ2h1bmtzKSB7XG4gICAgICAgIHRoaXNDaHVua0hlaWdodCA9IHBhcnRpYWxDaHVua0hlaWdodDtcbiAgICAgICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogdGhpc0NodW5rSGVpZ2h0O1xuICAgICAgfVxuICAgICAgZGVzdFBvcyA9IDA7XG4gICAgICBmb3IgKGogPSBlbGVtc0luVGhpc0NodW5rOyBqLS07KSB7XG4gICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IDI1NTtcbiAgICAgIH1cbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBpICogRlVMTF9DSFVOS19IRUlHSFQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGJhZCBpbWFnZSBraW5kOiAke2ltZ0RhdGEua2luZH1gKTtcbiAgfVxufVxuZnVuY3Rpb24gcHV0QmluYXJ5SW1hZ2VNYXNrKGN0eCwgaW1nRGF0YSkge1xuICBpZiAoaW1nRGF0YS5iaXRtYXApIHtcbiAgICBjdHguZHJhd0ltYWdlKGltZ0RhdGEuYml0bWFwLCAwLCAwKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQsXG4gICAgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICBjb25zdCBwYXJ0aWFsQ2h1bmtIZWlnaHQgPSBoZWlnaHQgJSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgY29uc3QgZnVsbENodW5rcyA9IChoZWlnaHQgLSBwYXJ0aWFsQ2h1bmtIZWlnaHQpIC8gRlVMTF9DSFVOS19IRUlHSFQ7XG4gIGNvbnN0IHRvdGFsQ2h1bmtzID0gcGFydGlhbENodW5rSGVpZ2h0ID09PSAwID8gZnVsbENodW5rcyA6IGZ1bGxDaHVua3MgKyAxO1xuICBjb25zdCBjaHVua0ltZ0RhdGEgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gIGxldCBzcmNQb3MgPSAwO1xuICBjb25zdCBzcmMgPSBpbWdEYXRhLmRhdGE7XG4gIGNvbnN0IGRlc3QgPSBjaHVua0ltZ0RhdGEuZGF0YTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbENodW5rczsgaSsrKSB7XG4gICAgY29uc3QgdGhpc0NodW5rSGVpZ2h0ID0gaSA8IGZ1bGxDaHVua3MgPyBGVUxMX0NIVU5LX0hFSUdIVCA6IHBhcnRpYWxDaHVua0hlaWdodDtcbiAgICAoe1xuICAgICAgc3JjUG9zXG4gICAgfSA9IGNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBKHtcbiAgICAgIHNyYyxcbiAgICAgIHNyY1BvcyxcbiAgICAgIGRlc3QsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodDogdGhpc0NodW5rSGVpZ2h0LFxuICAgICAgbm9uQmxhY2tDb2xvcjogMFxuICAgIH0pKTtcbiAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaSAqIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgfVxufVxuZnVuY3Rpb24gY29weUN0eFN0YXRlKHNvdXJjZUN0eCwgZGVzdEN0eCkge1xuICBjb25zdCBwcm9wZXJ0aWVzID0gW1wic3Ryb2tlU3R5bGVcIiwgXCJmaWxsU3R5bGVcIiwgXCJmaWxsUnVsZVwiLCBcImdsb2JhbEFscGhhXCIsIFwibGluZVdpZHRoXCIsIFwibGluZUNhcFwiLCBcImxpbmVKb2luXCIsIFwibWl0ZXJMaW1pdFwiLCBcImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblwiLCBcImZvbnRcIiwgXCJmaWx0ZXJcIl07XG4gIGZvciAoY29uc3QgcHJvcGVydHkgb2YgcHJvcGVydGllcykge1xuICAgIGlmIChzb3VyY2VDdHhbcHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlc3RDdHhbcHJvcGVydHldID0gc291cmNlQ3R4W3Byb3BlcnR5XTtcbiAgICB9XG4gIH1cbiAgaWYgKHNvdXJjZUN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVzdEN0eC5zZXRMaW5lRGFzaChzb3VyY2VDdHguZ2V0TGluZURhc2goKSk7XG4gICAgZGVzdEN0eC5saW5lRGFzaE9mZnNldCA9IHNvdXJjZUN0eC5saW5lRGFzaE9mZnNldDtcbiAgfVxufVxuZnVuY3Rpb24gcmVzZXRDdHhUb0RlZmF1bHQoY3R4KSB7XG4gIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGUgPSBcIiMwMDAwMDBcIjtcbiAgY3R4LmZpbGxSdWxlID0gXCJub256ZXJvXCI7XG4gIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gIGN0eC5saW5lV2lkdGggPSAxO1xuICBjdHgubGluZUNhcCA9IFwiYnV0dFwiO1xuICBjdHgubGluZUpvaW4gPSBcIm1pdGVyXCI7XG4gIGN0eC5taXRlckxpbWl0ID0gMTA7XG4gIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1vdmVyXCI7XG4gIGN0eC5mb250ID0gXCIxMHB4IHNhbnMtc2VyaWZcIjtcbiAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICBjdHgubGluZURhc2hPZmZzZXQgPSAwO1xuICB9XG4gIGNvbnN0IHtcbiAgICBmaWx0ZXJcbiAgfSA9IGN0eDtcbiAgaWYgKGZpbHRlciAhPT0gXCJub25lXCIgJiYgZmlsdGVyICE9PSBcIlwiKSB7XG4gICAgY3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICB9XG59XG5mdW5jdGlvbiBnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQodHJhbnNmb3JtLCBpbnRlcnBvbGF0ZSkge1xuICBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRyYW5zZm9ybSwgWFkpO1xuICBjb25zdCBhY3R1YWxTY2FsZSA9IE1hdGguZnJvdW5kKE91dHB1dFNjYWxlLnBpeGVsUmF0aW8gKiBQaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMpO1xuICByZXR1cm4gWFlbMF0gPD0gYWN0dWFsU2NhbGUgJiYgWFlbMV0gPD0gYWN0dWFsU2NhbGU7XG59XG5jb25zdCBMSU5FX0NBUF9TVFlMRVMgPSBbXCJidXR0XCIsIFwicm91bmRcIiwgXCJzcXVhcmVcIl07XG5jb25zdCBMSU5FX0pPSU5fU1RZTEVTID0gW1wibWl0ZXJcIiwgXCJyb3VuZFwiLCBcImJldmVsXCJdO1xuY29uc3QgTk9STUFMX0NMSVAgPSB7fTtcbmNvbnN0IEVPX0NMSVAgPSB7fTtcbmNsYXNzIENhbnZhc0dyYXBoaWNzIHtcbiAgY29uc3RydWN0b3IoY2FudmFzQ3R4LCBjb21tb25PYmpzLCBvYmpzLCBjYW52YXNGYWN0b3J5LCBmaWx0ZXJGYWN0b3J5LCB7XG4gICAgb3B0aW9uYWxDb250ZW50Q29uZmlnLFxuICAgIG1hcmtlZENvbnRlbnRTdGFjayA9IG51bGxcbiAgfSwgYW5ub3RhdGlvbkNhbnZhc01hcCwgcGFnZUNvbG9ycywgZGVwZW5kZW5jeVRyYWNrZXIpIHtcbiAgICB0aGlzLmN0eCA9IGNhbnZhc0N0eDtcbiAgICB0aGlzLmN1cnJlbnQgPSBuZXcgQ2FudmFzRXh0cmFTdGF0ZSh0aGlzLmN0eC5jYW52YXMud2lkdGgsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgIHRoaXMuc3RhdGVTdGFjayA9IFtdO1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IGZhbHNlO1xuICAgIHRoaXMucmVzID0gbnVsbDtcbiAgICB0aGlzLnhvYmpzID0gbnVsbDtcbiAgICB0aGlzLmNvbW1vbk9ianMgPSBjb21tb25PYmpzO1xuICAgIHRoaXMub2JqcyA9IG9ianM7XG4gICAgdGhpcy5jYW52YXNGYWN0b3J5ID0gY2FudmFzRmFjdG9yeTtcbiAgICB0aGlzLmZpbHRlckZhY3RvcnkgPSBmaWx0ZXJGYWN0b3J5O1xuICAgIHRoaXMuZ3JvdXBTdGFjayA9IFtdO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IG51bGw7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtU3RhY2sgPSBbXTtcbiAgICB0aGlzLmdyb3VwTGV2ZWwgPSAwO1xuICAgIHRoaXMuc21hc2tTdGFjayA9IFtdO1xuICAgIHRoaXMuc21hc2tDb3VudGVyID0gMDtcbiAgICB0aGlzLnRlbXBTTWFzayA9IG51bGw7XG4gICAgdGhpcy5zdXNwZW5kZWRDdHggPSBudWxsO1xuICAgIHRoaXMuY29udGVudFZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrID0gbWFya2VkQ29udGVudFN0YWNrIHx8IFtdO1xuICAgIHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnID0gb3B0aW9uYWxDb250ZW50Q29uZmlnO1xuICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMgPSBuZXcgQ2FjaGVkQ2FudmFzZXModGhpcy5jYW52YXNGYWN0b3J5KTtcbiAgICB0aGlzLmNhY2hlZFBhdHRlcm5zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCA9IGFubm90YXRpb25DYW52YXNNYXA7XG4gICAgdGhpcy52aWV3cG9ydFNjYWxlID0gMTtcbiAgICB0aGlzLm91dHB1dFNjYWxlWCA9IDE7XG4gICAgdGhpcy5vdXRwdXRTY2FsZVkgPSAxO1xuICAgIHRoaXMucGFnZUNvbG9ycyA9IHBhZ2VDb2xvcnM7XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZyA9IFstMSwgMF07XG4gICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gICAgdGhpcy5fY2FjaGVkQml0bWFwc01hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyID0gZGVwZW5kZW5jeVRyYWNrZXIgPz8gbnVsbDtcbiAgfVxuICBnZXRPYmplY3Qob3BJZHgsIGRhdGEsIGZhbGxiYWNrID0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkTmFtZWREZXBlbmRlbmN5KG9wSWR4LCBkYXRhKTtcbiAgICAgIHJldHVybiBkYXRhLnN0YXJ0c1dpdGgoXCJnX1wiKSA/IHRoaXMuY29tbW9uT2Jqcy5nZXQoZGF0YSkgOiB0aGlzLm9ianMuZ2V0KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsbGJhY2s7XG4gIH1cbiAgYmVnaW5EcmF3aW5nKHtcbiAgICB0cmFuc2Zvcm0sXG4gICAgdmlld3BvcnQsXG4gICAgdHJhbnNwYXJlbmN5ID0gZmFsc2UsXG4gICAgYmFja2dyb3VuZCA9IG51bGxcbiAgfSkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5jdHguY2FudmFzLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3Qgc2F2ZWRGaWxsU3R5bGUgPSB0aGlzLmN0eC5maWxsU3R5bGU7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZCB8fCBcIiNmZmZmZmZcIjtcbiAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBzYXZlZEZpbGxTdHlsZTtcbiAgICBpZiAodHJhbnNwYXJlbmN5KSB7XG4gICAgICBjb25zdCB0cmFuc3BhcmVudENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwidHJhbnNwYXJlbnRcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLmNvbXBvc2l0ZUN0eCA9IHRoaXMuY3R4O1xuICAgICAgdGhpcy50cmFuc3BhcmVudENhbnZhcyA9IHRyYW5zcGFyZW50Q2FudmFzLmNhbnZhcztcbiAgICAgIHRoaXMuY3R4ID0gdHJhbnNwYXJlbnRDYW52YXMuY29udGV4dDtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuY3R4LnRyYW5zZm9ybSguLi5nZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY29tcG9zaXRlQ3R4KSk7XG4gICAgfVxuICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgdGhpcy5jdHgudHJhbnNmb3JtKC4uLnRyYW5zZm9ybSk7XG4gICAgICB0aGlzLm91dHB1dFNjYWxlWCA9IHRyYW5zZm9ybVswXTtcbiAgICAgIHRoaXMub3V0cHV0U2NhbGVZID0gdHJhbnNmb3JtWzBdO1xuICAgIH1cbiAgICB0aGlzLmN0eC50cmFuc2Zvcm0oLi4udmlld3BvcnQudHJhbnNmb3JtKTtcbiAgICB0aGlzLnZpZXdwb3J0U2NhbGUgPSB2aWV3cG9ydC5zY2FsZTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KTtcbiAgfVxuICBleGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCwgZXhlY3V0aW9uU3RhcnRJZHgsIGNvbnRpbnVlQ2FsbGJhY2ssIHN0ZXBwZXIsIGZpbHRlcmVkT3BlcmF0aW9uSW5kZXhlcykge1xuICAgIGNvbnN0IGFyZ3NBcnJheSA9IG9wZXJhdG9yTGlzdC5hcmdzQXJyYXk7XG4gICAgY29uc3QgZm5BcnJheSA9IG9wZXJhdG9yTGlzdC5mbkFycmF5O1xuICAgIGxldCBpID0gZXhlY3V0aW9uU3RhcnRJZHggfHwgMDtcbiAgICBjb25zdCBhcmdzQXJyYXlMZW4gPSBhcmdzQXJyYXkubGVuZ3RoO1xuICAgIGlmIChhcmdzQXJyYXlMZW4gPT09IGkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICBjb25zdCBjaHVua09wZXJhdGlvbnMgPSBhcmdzQXJyYXlMZW4gLSBpID4gRVhFQ1VUSU9OX1NURVBTICYmIHR5cGVvZiBjb250aW51ZUNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCI7XG4gICAgY29uc3QgZW5kVGltZSA9IGNodW5rT3BlcmF0aW9ucyA/IERhdGUubm93KCkgKyBFWEVDVVRJT05fVElNRSA6IDA7XG4gICAgbGV0IHN0ZXBzID0gMDtcbiAgICBjb25zdCBjb21tb25PYmpzID0gdGhpcy5jb21tb25PYmpzO1xuICAgIGNvbnN0IG9ianMgPSB0aGlzLm9ianM7XG4gICAgbGV0IGZuSWQsIGZuQXJncztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKHN0ZXBwZXIgIT09IHVuZGVmaW5lZCAmJiBpID09PSBzdGVwcGVyLm5leHRCcmVha1BvaW50KSB7XG4gICAgICAgIHN0ZXBwZXIuYnJlYWtJdChpLCBjb250aW51ZUNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICBpZiAoIWZpbHRlcmVkT3BlcmF0aW9uSW5kZXhlcyB8fCBmaWx0ZXJlZE9wZXJhdGlvbkluZGV4ZXMuaGFzKGkpKSB7XG4gICAgICAgIGZuSWQgPSBmbkFycmF5W2ldO1xuICAgICAgICBmbkFyZ3MgPSBhcmdzQXJyYXlbaV0gPz8gbnVsbDtcbiAgICAgICAgaWYgKGZuSWQgIT09IE9QUy5kZXBlbmRlbmN5KSB7XG4gICAgICAgICAgaWYgKGZuQXJncyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpc1tmbklkXShpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc1tmbklkXShpLCAuLi5mbkFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGRlcE9iaklkIG9mIGZuQXJncykge1xuICAgICAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkTmFtZWREYXRhKGRlcE9iaklkLCBpKTtcbiAgICAgICAgICAgIGNvbnN0IG9ianNQb29sID0gZGVwT2JqSWQuc3RhcnRzV2l0aChcImdfXCIpID8gY29tbW9uT2JqcyA6IG9ianM7XG4gICAgICAgICAgICBpZiAoIW9ianNQb29sLmhhcyhkZXBPYmpJZCkpIHtcbiAgICAgICAgICAgICAgb2Jqc1Bvb2wuZ2V0KGRlcE9iaklkLCBjb250aW51ZUNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgICBpZiAoaSA9PT0gYXJnc0FycmF5TGVuKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgICAgaWYgKGNodW5rT3BlcmF0aW9ucyAmJiArK3N0ZXBzID4gRVhFQ1VUSU9OX1NURVBTKSB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpID4gZW5kVGltZSkge1xuICAgICAgICAgIGNvbnRpbnVlQ2FsbGJhY2soKTtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICBzdGVwcyA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNyZXN0b3JlSW5pdGlhbFN0YXRlKCkge1xuICAgIHdoaWxlICh0aGlzLnN0YXRlU3RhY2subGVuZ3RoIHx8IHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgPSBudWxsO1xuICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICBpZiAodGhpcy50cmFuc3BhcmVudENhbnZhcykge1xuICAgICAgdGhpcy5jdHggPSB0aGlzLmNvbXBvc2l0ZUN0eDtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZSh0aGlzLnRyYW5zcGFyZW50Q2FudmFzLCAwLCAwKTtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMudHJhbnNwYXJlbnRDYW52YXMgPSBudWxsO1xuICAgIH1cbiAgfVxuICBlbmREcmF3aW5nKCkge1xuICAgIHRoaXMuI3Jlc3RvcmVJbml0aWFsU3RhdGUoKTtcbiAgICB0aGlzLmNhY2hlZENhbnZhc2VzLmNsZWFyKCk7XG4gICAgdGhpcy5jYWNoZWRQYXR0ZXJucy5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgY2FjaGUgb2YgdGhpcy5fY2FjaGVkQml0bWFwc01hcC52YWx1ZXMoKSkge1xuICAgICAgZm9yIChjb25zdCBjYW52YXMgb2YgY2FjaGUudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLmNsZWFyKCk7XG4gICAgdGhpcy4jZHJhd0ZpbHRlcigpO1xuICB9XG4gICNkcmF3RmlsdGVyKCkge1xuICAgIGlmICh0aGlzLnBhZ2VDb2xvcnMpIHtcbiAgICAgIGNvbnN0IGhjbUZpbHRlcklkID0gdGhpcy5maWx0ZXJGYWN0b3J5LmFkZEhDTUZpbHRlcih0aGlzLnBhZ2VDb2xvcnMuZm9yZWdyb3VuZCwgdGhpcy5wYWdlQ29sb3JzLmJhY2tncm91bmQpO1xuICAgICAgaWYgKGhjbUZpbHRlcklkICE9PSBcIm5vbmVcIikge1xuICAgICAgICBjb25zdCBzYXZlZEZpbHRlciA9IHRoaXMuY3R4LmZpbHRlcjtcbiAgICAgICAgdGhpcy5jdHguZmlsdGVyID0gaGNtRmlsdGVySWQ7XG4gICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZSh0aGlzLmN0eC5jYW52YXMsIDAsIDApO1xuICAgICAgICB0aGlzLmN0eC5maWx0ZXIgPSBzYXZlZEZpbHRlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3NjYWxlSW1hZ2UoaW1nLCBpbnZlcnNlVHJhbnNmb3JtKSB7XG4gICAgY29uc3Qgd2lkdGggPSBpbWcud2lkdGggPz8gaW1nLmRpc3BsYXlXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWcuaGVpZ2h0ID8/IGltZy5kaXNwbGF5SGVpZ2h0O1xuICAgIGxldCB3aWR0aFNjYWxlID0gTWF0aC5tYXgoTWF0aC5oeXBvdChpbnZlcnNlVHJhbnNmb3JtWzBdLCBpbnZlcnNlVHJhbnNmb3JtWzFdKSwgMSk7XG4gICAgbGV0IGhlaWdodFNjYWxlID0gTWF0aC5tYXgoTWF0aC5oeXBvdChpbnZlcnNlVHJhbnNmb3JtWzJdLCBpbnZlcnNlVHJhbnNmb3JtWzNdKSwgMSk7XG4gICAgbGV0IHBhaW50V2lkdGggPSB3aWR0aCxcbiAgICAgIHBhaW50SGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGxldCB0bXBDYW52YXNJZCA9IFwicHJlc2NhbGUxXCI7XG4gICAgbGV0IHRtcENhbnZhcywgdG1wQ3R4O1xuICAgIHdoaWxlICh3aWR0aFNjYWxlID4gMiAmJiBwYWludFdpZHRoID4gMSB8fCBoZWlnaHRTY2FsZSA+IDIgJiYgcGFpbnRIZWlnaHQgPiAxKSB7XG4gICAgICBsZXQgbmV3V2lkdGggPSBwYWludFdpZHRoLFxuICAgICAgICBuZXdIZWlnaHQgPSBwYWludEhlaWdodDtcbiAgICAgIGlmICh3aWR0aFNjYWxlID4gMiAmJiBwYWludFdpZHRoID4gMSkge1xuICAgICAgICBuZXdXaWR0aCA9IHBhaW50V2lkdGggPj0gMTYzODQgPyBNYXRoLmZsb29yKHBhaW50V2lkdGggLyAyKSAtIDEgfHwgMSA6IE1hdGguY2VpbChwYWludFdpZHRoIC8gMik7XG4gICAgICAgIHdpZHRoU2NhbGUgLz0gcGFpbnRXaWR0aCAvIG5ld1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodFNjYWxlID4gMiAmJiBwYWludEhlaWdodCA+IDEpIHtcbiAgICAgICAgbmV3SGVpZ2h0ID0gcGFpbnRIZWlnaHQgPj0gMTYzODQgPyBNYXRoLmZsb29yKHBhaW50SGVpZ2h0IC8gMikgLSAxIHx8IDEgOiBNYXRoLmNlaWwocGFpbnRIZWlnaHQpIC8gMjtcbiAgICAgICAgaGVpZ2h0U2NhbGUgLz0gcGFpbnRIZWlnaHQgLyBuZXdIZWlnaHQ7XG4gICAgICB9XG4gICAgICB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyh0bXBDYW52YXNJZCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHRtcEN0eC5jbGVhclJlY3QoMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICB0bXBDdHguZHJhd0ltYWdlKGltZywgMCwgMCwgcGFpbnRXaWR0aCwgcGFpbnRIZWlnaHQsIDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgaW1nID0gdG1wQ2FudmFzLmNhbnZhcztcbiAgICAgIHBhaW50V2lkdGggPSBuZXdXaWR0aDtcbiAgICAgIHBhaW50SGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgdG1wQ2FudmFzSWQgPSB0bXBDYW52YXNJZCA9PT0gXCJwcmVzY2FsZTFcIiA/IFwicHJlc2NhbGUyXCIgOiBcInByZXNjYWxlMVwiO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaW1nLFxuICAgICAgcGFpbnRXaWR0aCxcbiAgICAgIHBhaW50SGVpZ2h0XG4gICAgfTtcbiAgfVxuICBfY3JlYXRlTWFza0NhbnZhcyhvcElkeCwgaW1nKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gaW1nO1xuICAgIGNvbnN0IGZpbGxDb2xvciA9IHRoaXMuY3VycmVudC5maWxsQ29sb3I7XG4gICAgY29uc3QgaXNQYXR0ZXJuRmlsbCA9IHRoaXMuY3VycmVudC5wYXR0ZXJuRmlsbDtcbiAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpO1xuICAgIGxldCBjYWNoZSwgY2FjaGVLZXksIHNjYWxlZCwgbWFza0NhbnZhcztcbiAgICBpZiAoKGltZy5iaXRtYXAgfHwgaW1nLmRhdGEpICYmIGltZy5jb3VudCA+IDEpIHtcbiAgICAgIGNvbnN0IG1haW5LZXkgPSBpbWcuYml0bWFwIHx8IGltZy5kYXRhLmJ1ZmZlcjtcbiAgICAgIGNhY2hlS2V5ID0gSlNPTi5zdHJpbmdpZnkoaXNQYXR0ZXJuRmlsbCA/IGN1cnJlbnRUcmFuc2Zvcm0gOiBbY3VycmVudFRyYW5zZm9ybS5zbGljZSgwLCA0KSwgZmlsbENvbG9yXSk7XG4gICAgICBjYWNoZSA9IHRoaXMuX2NhY2hlZEJpdG1hcHNNYXAuZ2V0KG1haW5LZXkpO1xuICAgICAgaWYgKCFjYWNoZSkge1xuICAgICAgICBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkQml0bWFwc01hcC5zZXQobWFpbktleSwgY2FjaGUpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FjaGVkSW1hZ2UgPSBjYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgaWYgKGNhY2hlZEltYWdlICYmICFpc1BhdHRlcm5GaWxsKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLnJvdW5kKE1hdGgubWluKGN1cnJlbnRUcmFuc2Zvcm1bMF0sIGN1cnJlbnRUcmFuc2Zvcm1bMl0pICsgY3VycmVudFRyYW5zZm9ybVs0XSk7XG4gICAgICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLnJvdW5kKE1hdGgubWluKGN1cnJlbnRUcmFuc2Zvcm1bMV0sIGN1cnJlbnRUcmFuc2Zvcm1bM10pICsgY3VycmVudFRyYW5zZm9ybVs1XSk7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLnRyYW5zZm9ybUFuZEZpbGwpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNhbnZhczogY2FjaGVkSW1hZ2UsXG4gICAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgICBvZmZzZXRZXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBzY2FsZWQgPSBjYWNoZWRJbWFnZTtcbiAgICB9XG4gICAgaWYgKCFzY2FsZWQpIHtcbiAgICAgIG1hc2tDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1hc2tDYW52YXNcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBwdXRCaW5hcnlJbWFnZU1hc2sobWFza0NhbnZhcy5jb250ZXh0LCBpbWcpO1xuICAgIH1cbiAgICBsZXQgbWFza1RvQ2FudmFzID0gVXRpbC50cmFuc2Zvcm0oY3VycmVudFRyYW5zZm9ybSwgWzEgLyB3aWR0aCwgMCwgMCwgLTEgLyBoZWlnaHQsIDAsIDBdKTtcbiAgICBtYXNrVG9DYW52YXMgPSBVdGlsLnRyYW5zZm9ybShtYXNrVG9DYW52YXMsIFsxLCAwLCAwLCAxLCAwLCAtaGVpZ2h0XSk7XG4gICAgY29uc3QgbWluTWF4ID0gTUlOX01BWF9JTklULnNsaWNlKCk7XG4gICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChbMCwgMCwgd2lkdGgsIGhlaWdodF0sIG1hc2tUb0NhbnZhcywgbWluTWF4KTtcbiAgICBjb25zdCBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gPSBtaW5NYXg7XG4gICAgY29uc3QgZHJhd25XaWR0aCA9IE1hdGgucm91bmQobWF4WCAtIG1pblgpIHx8IDE7XG4gICAgY29uc3QgZHJhd25IZWlnaHQgPSBNYXRoLnJvdW5kKG1heFkgLSBtaW5ZKSB8fCAxO1xuICAgIGNvbnN0IGZpbGxDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImZpbGxDYW52YXNcIiwgZHJhd25XaWR0aCwgZHJhd25IZWlnaHQpO1xuICAgIGNvbnN0IGZpbGxDdHggPSBmaWxsQ2FudmFzLmNvbnRleHQ7XG4gICAgY29uc3Qgb2Zmc2V0WCA9IG1pblg7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IG1pblk7XG4gICAgZmlsbEN0eC50cmFuc2xhdGUoLW9mZnNldFgsIC1vZmZzZXRZKTtcbiAgICBmaWxsQ3R4LnRyYW5zZm9ybSguLi5tYXNrVG9DYW52YXMpO1xuICAgIGlmICghc2NhbGVkKSB7XG4gICAgICBzY2FsZWQgPSB0aGlzLl9zY2FsZUltYWdlKG1hc2tDYW52YXMuY2FudmFzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShmaWxsQ3R4KSk7XG4gICAgICBzY2FsZWQgPSBzY2FsZWQuaW1nO1xuICAgICAgaWYgKGNhY2hlICYmIGlzUGF0dGVybkZpbGwpIHtcbiAgICAgICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBzY2FsZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmaWxsQ3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGdldEltYWdlU21vb3RoaW5nRW5hYmxlZChnZXRDdXJyZW50VHJhbnNmb3JtKGZpbGxDdHgpLCBpbWcuaW50ZXJwb2xhdGUpO1xuICAgIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhmaWxsQ3R4LCBzY2FsZWQsIDAsIDAsIHNjYWxlZC53aWR0aCwgc2NhbGVkLmhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgZmlsbEN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1pblwiO1xuICAgIGNvbnN0IGludmVyc2UgPSBVdGlsLnRyYW5zZm9ybShnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShmaWxsQ3R4KSwgWzEsIDAsIDAsIDEsIC1vZmZzZXRYLCAtb2Zmc2V0WV0pO1xuICAgIGZpbGxDdHguZmlsbFN0eWxlID0gaXNQYXR0ZXJuRmlsbCA/IGZpbGxDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgaW52ZXJzZSwgUGF0aFR5cGUuRklMTCkgOiBmaWxsQ29sb3I7XG4gICAgZmlsbEN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAoY2FjaGUgJiYgIWlzUGF0dGVybkZpbGwpIHtcbiAgICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMuZGVsZXRlKFwiZmlsbENhbnZhc1wiKTtcbiAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgZmlsbENhbnZhcy5jYW52YXMpO1xuICAgIH1cbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmREZXBlbmRlbmNpZXMob3BJZHgsIERlcGVuZGVuY2llcy50cmFuc2Zvcm1BbmRGaWxsKTtcbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzOiBmaWxsQ2FudmFzLmNhbnZhcyxcbiAgICAgIG9mZnNldFg6IE1hdGgucm91bmQob2Zmc2V0WCksXG4gICAgICBvZmZzZXRZOiBNYXRoLnJvdW5kKG9mZnNldFkpXG4gICAgfTtcbiAgfVxuICBzZXRMaW5lV2lkdGgob3BJZHgsIHdpZHRoKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImxpbmVXaWR0aFwiLCBvcElkeCk7XG4gICAgaWYgKHdpZHRoICE9PSB0aGlzLmN1cnJlbnQubGluZVdpZHRoKSB7XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5saW5lV2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmN0eC5saW5lV2lkdGggPSB3aWR0aDtcbiAgfVxuICBzZXRMaW5lQ2FwKG9wSWR4LCBzdHlsZSkge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJsaW5lQ2FwXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN0eC5saW5lQ2FwID0gTElORV9DQVBfU1RZTEVTW3N0eWxlXTtcbiAgfVxuICBzZXRMaW5lSm9pbihvcElkeCwgc3R5bGUpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwibGluZUpvaW5cIiwgb3BJZHgpO1xuICAgIHRoaXMuY3R4LmxpbmVKb2luID0gTElORV9KT0lOX1NUWUxFU1tzdHlsZV07XG4gIH1cbiAgc2V0TWl0ZXJMaW1pdChvcElkeCwgbGltaXQpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwibWl0ZXJMaW1pdFwiLCBvcElkeCk7XG4gICAgdGhpcy5jdHgubWl0ZXJMaW1pdCA9IGxpbWl0O1xuICB9XG4gIHNldERhc2gob3BJZHgsIGRhc2hBcnJheSwgZGFzaFBoYXNlKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImRhc2hcIiwgb3BJZHgpO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hBcnJheSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoUGhhc2U7XG4gICAgfVxuICB9XG4gIHNldFJlbmRlcmluZ0ludGVudChvcElkeCwgaW50ZW50KSB7fVxuICBzZXRGbGF0bmVzcyhvcElkeCwgZmxhdG5lc3MpIHt9XG4gIHNldEdTdGF0ZShvcElkeCwgc3RhdGVzKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3RhdGVzKSB7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlIFwiTFdcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVXaWR0aChvcElkeCwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTENcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVDYXAob3BJZHgsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkxKXCI6XG4gICAgICAgICAgdGhpcy5zZXRMaW5lSm9pbihvcElkeCwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTUxcIjpcbiAgICAgICAgICB0aGlzLnNldE1pdGVyTGltaXQob3BJZHgsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkRcIjpcbiAgICAgICAgICB0aGlzLnNldERhc2gob3BJZHgsIHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJSSVwiOlxuICAgICAgICAgIHRoaXMuc2V0UmVuZGVyaW5nSW50ZW50KG9wSWR4LCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJGTFwiOlxuICAgICAgICAgIHRoaXMuc2V0RmxhdG5lc3Mob3BJZHgsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkZvbnRcIjpcbiAgICAgICAgICB0aGlzLnNldEZvbnQob3BJZHgsIHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJDQVwiOlxuICAgICAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJzdHJva2VBbHBoYVwiLCBvcElkeCk7XG4gICAgICAgICAgdGhpcy5jdXJyZW50LnN0cm9rZUFscGhhID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjYVwiOlxuICAgICAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJmaWxsQWxwaGFcIiwgb3BJZHgpO1xuICAgICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5jdXJyZW50LmZpbGxBbHBoYSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQk1cIjpcbiAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXCIsIG9wSWR4KTtcbiAgICAgICAgICB0aGlzLmN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlNNYXNrXCI6XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcIlNNYXNrXCIsIG9wSWR4KTtcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgPSB2YWx1ZSA/IHRoaXMudGVtcFNNYXNrIDogbnVsbDtcbiAgICAgICAgICB0aGlzLnRlbXBTTWFzayA9IG51bGw7XG4gICAgICAgICAgdGhpcy5jaGVja1NNYXNrU3RhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlRSXCI6XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImZpbHRlclwiLCBvcElkeCk7XG4gICAgICAgICAgdGhpcy5jdHguZmlsdGVyID0gdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyA9IHRoaXMuZmlsdGVyRmFjdG9yeS5hZGRGaWx0ZXIodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgaW5TTWFza01vZGUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5zdXNwZW5kZWRDdHg7XG4gIH1cbiAgY2hlY2tTTWFza1N0YXRlKCkge1xuICAgIGNvbnN0IGluU01hc2tNb2RlID0gdGhpcy5pblNNYXNrTW9kZTtcbiAgICBpZiAodGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrICYmICFpblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5iZWdpblNNYXNrTW9kZSgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuY3VycmVudC5hY3RpdmVTTWFzayAmJiBpblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5lbmRTTWFza01vZGUoKTtcbiAgICB9XG4gIH1cbiAgYmVnaW5TTWFza01vZGUob3BJZHgpIHtcbiAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmVnaW5TTWFza01vZGUgY2FsbGVkIHdoaWxlIGFscmVhZHkgaW4gc21hc2sgbW9kZVwiKTtcbiAgICB9XG4gICAgY29uc3QgZHJhd25XaWR0aCA9IHRoaXMuY3R4LmNhbnZhcy53aWR0aDtcbiAgICBjb25zdCBkcmF3bkhlaWdodCA9IHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3QgY2FjaGVJZCA9IFwic21hc2tHcm91cEF0XCIgKyB0aGlzLmdyb3VwTGV2ZWw7XG4gICAgY29uc3Qgc2NyYXRjaENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKGNhY2hlSWQsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0KTtcbiAgICB0aGlzLnN1c3BlbmRlZEN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4ID0gc2NyYXRjaENhbnZhcy5jb250ZXh0O1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0odGhpcy5zdXNwZW5kZWRDdHguZ2V0VHJhbnNmb3JtKCkpO1xuICAgIGNvcHlDdHhTdGF0ZSh0aGlzLnN1c3BlbmRlZEN0eCwgY3R4KTtcbiAgICBtaXJyb3JDb250ZXh0T3BlcmF0aW9ucyhjdHgsIHRoaXMuc3VzcGVuZGVkQ3R4KTtcbiAgICB0aGlzLnNldEdTdGF0ZShvcElkeCwgW1tcIkJNXCIsIFwic291cmNlLW92ZXJcIl1dKTtcbiAgfVxuICBlbmRTTWFza01vZGUoKSB7XG4gICAgaWYgKCF0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbmRTTWFza01vZGUgY2FsbGVkIHdoaWxlIG5vdCBpbiBzbWFzayBtb2RlXCIpO1xuICAgIH1cbiAgICB0aGlzLmN0eC5fcmVtb3ZlTWlycm9yaW5nKCk7XG4gICAgY29weUN0eFN0YXRlKHRoaXMuY3R4LCB0aGlzLnN1c3BlbmRlZEN0eCk7XG4gICAgdGhpcy5jdHggPSB0aGlzLnN1c3BlbmRlZEN0eDtcbiAgICB0aGlzLnN1c3BlbmRlZEN0eCA9IG51bGw7XG4gIH1cbiAgY29tcG9zZShkaXJ0eUJveCkge1xuICAgIGlmICghdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghZGlydHlCb3gpIHtcbiAgICAgIGRpcnR5Qm94ID0gWzAsIDAsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcnR5Qm94WzBdID0gTWF0aC5mbG9vcihkaXJ0eUJveFswXSk7XG4gICAgICBkaXJ0eUJveFsxXSA9IE1hdGguZmxvb3IoZGlydHlCb3hbMV0pO1xuICAgICAgZGlydHlCb3hbMl0gPSBNYXRoLmNlaWwoZGlydHlCb3hbMl0pO1xuICAgICAgZGlydHlCb3hbM10gPSBNYXRoLmNlaWwoZGlydHlCb3hbM10pO1xuICAgIH1cbiAgICBjb25zdCBzbWFzayA9IHRoaXMuY3VycmVudC5hY3RpdmVTTWFzaztcbiAgICBjb25zdCBzdXNwZW5kZWRDdHggPSB0aGlzLnN1c3BlbmRlZEN0eDtcbiAgICB0aGlzLmNvbXBvc2VTTWFzayhzdXNwZW5kZWRDdHgsIHNtYXNrLCB0aGlzLmN0eCwgZGlydHlCb3gpO1xuICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCk7XG4gICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICB9XG4gIGNvbXBvc2VTTWFzayhjdHgsIHNtYXNrLCBsYXllckN0eCwgbGF5ZXJCb3gpIHtcbiAgICBjb25zdCBsYXllck9mZnNldFggPSBsYXllckJveFswXTtcbiAgICBjb25zdCBsYXllck9mZnNldFkgPSBsYXllckJveFsxXTtcbiAgICBjb25zdCBsYXllcldpZHRoID0gbGF5ZXJCb3hbMl0gLSBsYXllck9mZnNldFg7XG4gICAgY29uc3QgbGF5ZXJIZWlnaHQgPSBsYXllckJveFszXSAtIGxheWVyT2Zmc2V0WTtcbiAgICBpZiAobGF5ZXJXaWR0aCA9PT0gMCB8fCBsYXllckhlaWdodCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmdlbmVyaWNDb21wb3NlU01hc2soc21hc2suY29udGV4dCwgbGF5ZXJDdHgsIGxheWVyV2lkdGgsIGxheWVySGVpZ2h0LCBzbWFzay5zdWJ0eXBlLCBzbWFzay5iYWNrZHJvcCwgc21hc2sudHJhbnNmZXJNYXAsIGxheWVyT2Zmc2V0WCwgbGF5ZXJPZmZzZXRZLCBzbWFzay5vZmZzZXRYLCBzbWFzay5vZmZzZXRZKTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLW92ZXJcIjtcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIGN0eC5kcmF3SW1hZ2UobGF5ZXJDdHguY2FudmFzLCAwLCAwKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG4gIGdlbmVyaWNDb21wb3NlU01hc2sobWFza0N0eCwgbGF5ZXJDdHgsIHdpZHRoLCBoZWlnaHQsIHN1YnR5cGUsIGJhY2tkcm9wLCB0cmFuc2Zlck1hcCwgbGF5ZXJPZmZzZXRYLCBsYXllck9mZnNldFksIG1hc2tPZmZzZXRYLCBtYXNrT2Zmc2V0WSkge1xuICAgIGxldCBtYXNrQ2FudmFzID0gbWFza0N0eC5jYW52YXM7XG4gICAgbGV0IG1hc2tYID0gbGF5ZXJPZmZzZXRYIC0gbWFza09mZnNldFg7XG4gICAgbGV0IG1hc2tZID0gbGF5ZXJPZmZzZXRZIC0gbWFza09mZnNldFk7XG4gICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICBpZiAobWFza1ggPCAwIHx8IG1hc2tZIDwgMCB8fCBtYXNrWCArIHdpZHRoID4gbWFza0NhbnZhcy53aWR0aCB8fCBtYXNrWSArIGhlaWdodCA+IG1hc2tDYW52YXMuaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWFza0V4dGVuc2lvblwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmNvbnRleHQ7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UobWFza0NhbnZhcywgLW1hc2tYLCAtbWFza1kpO1xuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1hdG9wXCI7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZHJvcDtcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2Utb3ZlclwiO1xuICAgICAgICBtYXNrQ2FudmFzID0gY2FudmFzLmNhbnZhcztcbiAgICAgICAgbWFza1ggPSBtYXNrWSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXNrQ3R4LnNhdmUoKTtcbiAgICAgICAgbWFza0N0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgIG1hc2tDdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICBjb25zdCBjbGlwID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICBjbGlwLnJlY3QobWFza1gsIG1hc2tZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgbWFza0N0eC5jbGlwKGNsaXApO1xuICAgICAgICBtYXNrQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24tYXRvcFwiO1xuICAgICAgICBtYXNrQ3R4LmZpbGxTdHlsZSA9IGJhY2tkcm9wO1xuICAgICAgICBtYXNrQ3R4LmZpbGxSZWN0KG1hc2tYLCBtYXNrWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIG1hc2tDdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBsYXllckN0eC5zYXZlKCk7XG4gICAgbGF5ZXJDdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgIGxheWVyQ3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICBpZiAoc3VidHlwZSA9PT0gXCJBbHBoYVwiICYmIHRyYW5zZmVyTWFwKSB7XG4gICAgICBsYXllckN0eC5maWx0ZXIgPSB0aGlzLmZpbHRlckZhY3RvcnkuYWRkQWxwaGFGaWx0ZXIodHJhbnNmZXJNYXApO1xuICAgIH0gZWxzZSBpZiAoc3VidHlwZSA9PT0gXCJMdW1pbm9zaXR5XCIpIHtcbiAgICAgIGxheWVyQ3R4LmZpbHRlciA9IHRoaXMuZmlsdGVyRmFjdG9yeS5hZGRMdW1pbm9zaXR5RmlsdGVyKHRyYW5zZmVyTWFwKTtcbiAgICB9XG4gICAgY29uc3QgY2xpcCA9IG5ldyBQYXRoMkQoKTtcbiAgICBjbGlwLnJlY3QobGF5ZXJPZmZzZXRYLCBsYXllck9mZnNldFksIHdpZHRoLCBoZWlnaHQpO1xuICAgIGxheWVyQ3R4LmNsaXAoY2xpcCk7XG4gICAgbGF5ZXJDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1pblwiO1xuICAgIGxheWVyQ3R4LmRyYXdJbWFnZShtYXNrQ2FudmFzLCBtYXNrWCwgbWFza1ksIHdpZHRoLCBoZWlnaHQsIGxheWVyT2Zmc2V0WCwgbGF5ZXJPZmZzZXRZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBsYXllckN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgc2F2ZShvcElkeCkge1xuICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICBjb3B5Q3R4U3RhdGUodGhpcy5jdHgsIHRoaXMuc3VzcGVuZGVkQ3R4KTtcbiAgICB9XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIGNvbnN0IG9sZCA9IHRoaXMuY3VycmVudDtcbiAgICB0aGlzLnN0YXRlU3RhY2sucHVzaChvbGQpO1xuICAgIHRoaXMuY3VycmVudCA9IG9sZC5jbG9uZSgpO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnNhdmUob3BJZHgpO1xuICB9XG4gIHJlc3RvcmUob3BJZHgpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZXN0b3JlKG9wSWR4KTtcbiAgICBpZiAodGhpcy5zdGF0ZVN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgICAgdGhpcy5lbmRTTWFza01vZGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5zdGF0ZVN0YWNrLnBvcCgpO1xuICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgY29weUN0eFN0YXRlKHRoaXMuc3VzcGVuZGVkQ3R4LCB0aGlzLmN0eCk7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tTTWFza1N0YXRlKCk7XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IC0xO1xuICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICB9XG4gIHRyYW5zZm9ybShvcElkeCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZEluY3JlbWVudGFsRGF0YShcInRyYW5zZm9ybVwiLCBvcElkeCk7XG4gICAgdGhpcy5jdHgudHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPSAtMTtcbiAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgfVxuICBjb25zdHJ1Y3RQYXRoKG9wSWR4LCBvcCwgZGF0YSwgbWluTWF4KSB7XG4gICAgbGV0IFtwYXRoXSA9IGRhdGE7XG4gICAgaWYgKCFtaW5NYXgpIHtcbiAgICAgIHBhdGggfHw9IGRhdGFbMF0gPSBuZXcgUGF0aDJEKCk7XG4gICAgICB0aGlzW29wXShvcElkeCwgcGF0aCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmRlcGVuZGVuY3lUcmFja2VyICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBvdXRlckV4dHJhU2l6ZSA9IG9wID09PSBPUFMuc3Ryb2tlID8gdGhpcy5jdXJyZW50LmxpbmVXaWR0aCAvIDIgOiAwO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlci5yZXNldEJCb3gob3BJZHgpLnJlY29yZEJCb3gob3BJZHgsIHRoaXMuY3R4LCBtaW5NYXhbMF0gLSBvdXRlckV4dHJhU2l6ZSwgbWluTWF4WzJdICsgb3V0ZXJFeHRyYVNpemUsIG1pbk1heFsxXSAtIG91dGVyRXh0cmFTaXplLCBtaW5NYXhbM10gKyBvdXRlckV4dHJhU2l6ZSkucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBbXCJ0cmFuc2Zvcm1cIl0pO1xuICAgIH1cbiAgICBpZiAoIShwYXRoIGluc3RhbmNlb2YgUGF0aDJEKSkge1xuICAgICAgY29uc3QgcGF0aDJkID0gZGF0YVswXSA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBhdGgubGVuZ3RoOyBpIDwgaWk7KSB7XG4gICAgICAgIHN3aXRjaCAocGF0aFtpKytdKSB7XG4gICAgICAgICAgY2FzZSBEcmF3T1BTLm1vdmVUbzpcbiAgICAgICAgICAgIHBhdGgyZC5tb3ZlVG8ocGF0aFtpKytdLCBwYXRoW2krK10pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBEcmF3T1BTLmxpbmVUbzpcbiAgICAgICAgICAgIHBhdGgyZC5saW5lVG8ocGF0aFtpKytdLCBwYXRoW2krK10pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBEcmF3T1BTLmN1cnZlVG86XG4gICAgICAgICAgICBwYXRoMmQuYmV6aWVyQ3VydmVUbyhwYXRoW2krK10sIHBhdGhbaSsrXSwgcGF0aFtpKytdLCBwYXRoW2krK10sIHBhdGhbaSsrXSwgcGF0aFtpKytdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRHJhd09QUy5jbG9zZVBhdGg6XG4gICAgICAgICAgICBwYXRoMmQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgd2FybihgVW5yZWNvZ25pemVkIGRyYXdpbmcgcGF0aCBvcGVyYXRvcjogJHtwYXRoW2kgLSAxXX1gKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXRoID0gcGF0aDJkO1xuICAgIH1cbiAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KG1pbk1heCwgZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCksIHRoaXMuY3VycmVudC5taW5NYXgpO1xuICAgIHRoaXNbb3BdKG9wSWR4LCBwYXRoKTtcbiAgICB0aGlzLl9wYXRoU3RhcnRJZHggPSBvcElkeDtcbiAgfVxuICBjbG9zZVBhdGgob3BJZHgpIHtcbiAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcbiAgfVxuICBzdHJva2Uob3BJZHgsIHBhdGgsIGNvbnN1bWVQYXRoID0gdHJ1ZSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHN0cm9rZUNvbG9yID0gdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuY3VycmVudC5zdHJva2VBbHBoYTtcbiAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgaWYgKHR5cGVvZiBzdHJva2VDb2xvciA9PT0gXCJvYmplY3RcIiAmJiBzdHJva2VDb2xvcj8uZ2V0UGF0dGVybikge1xuICAgICAgICBjb25zdCBiYXNlVHJhbnNmb3JtID0gc3Ryb2tlQ29sb3IuaXNNb2RpZnlpbmdDdXJyZW50VHJhbnNmb3JtKCkgPyBjdHguZ2V0VHJhbnNmb3JtKCkgOiBudWxsO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSwgUGF0aFR5cGUuU1RST0tFKTtcbiAgICAgICAgaWYgKGJhc2VUcmFuc2Zvcm0pIHtcbiAgICAgICAgICBjb25zdCBuZXdQYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICAgIG5ld1BhdGguYWRkUGF0aChwYXRoLCBjdHguZ2V0VHJhbnNmb3JtKCkuaW52ZXJ0U2VsZigpLm11bHRpcGx5U2VsZihiYXNlVHJhbnNmb3JtKSk7XG4gICAgICAgICAgcGF0aCA9IG5ld1BhdGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNjYWxlQW5kU3Ryb2tlKHBhdGgsIGZhbHNlKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVzY2FsZUFuZFN0cm9rZShwYXRoLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBEZXBlbmRlbmNpZXMuc3Ryb2tlKTtcbiAgICBpZiAoY29uc3VtZVBhdGgpIHtcbiAgICAgIHRoaXMuY29uc3VtZVBhdGgob3BJZHgsIHBhdGgsIHRoaXMuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KFBhdGhUeXBlLlNUUk9LRSwgZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCkpKTtcbiAgICB9XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5jdXJyZW50LmZpbGxBbHBoYTtcbiAgfVxuICBjbG9zZVN0cm9rZShvcElkeCwgcGF0aCkge1xuICAgIHRoaXMuc3Ryb2tlKG9wSWR4LCBwYXRoKTtcbiAgfVxuICBmaWxsKG9wSWR4LCBwYXRoLCBjb25zdW1lUGF0aCA9IHRydWUpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgIGNvbnN0IGlzUGF0dGVybkZpbGwgPSB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgbGV0IG5lZWRSZXN0b3JlID0gZmFsc2U7XG4gICAgaWYgKGlzUGF0dGVybkZpbGwpIHtcbiAgICAgIGNvbnN0IGJhc2VUcmFuc2Zvcm0gPSBmaWxsQ29sb3IuaXNNb2RpZnlpbmdDdXJyZW50VHJhbnNmb3JtKCkgPyBjdHguZ2V0VHJhbnNmb3JtKCkgOiBudWxsO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8uc2F2ZShvcElkeCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSwgUGF0aFR5cGUuRklMTCk7XG4gICAgICBpZiAoYmFzZVRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCBuZXdQYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICBuZXdQYXRoLmFkZFBhdGgocGF0aCwgY3R4LmdldFRyYW5zZm9ybSgpLmludmVydFNlbGYoKS5tdWx0aXBseVNlbGYoYmFzZVRyYW5zZm9ybSkpO1xuICAgICAgICBwYXRoID0gbmV3UGF0aDtcbiAgICAgIH1cbiAgICAgIG5lZWRSZXN0b3JlID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgaW50ZXJzZWN0ID0gdGhpcy5jdXJyZW50LmdldENsaXBwZWRQYXRoQm91bmRpbmdCb3goKTtcbiAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSAmJiBpbnRlcnNlY3QgIT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLnBlbmRpbmdFT0ZpbGwpIHtcbiAgICAgICAgY3R4LmZpbGwocGF0aCwgXCJldmVub2RkXCIpO1xuICAgICAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5maWxsKHBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmREZXBlbmRlbmNpZXMob3BJZHgsIERlcGVuZGVuY2llcy5maWxsKTtcbiAgICBpZiAobmVlZFJlc3RvcmUpIHtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZXN0b3JlKG9wSWR4KTtcbiAgICB9XG4gICAgaWYgKGNvbnN1bWVQYXRoKSB7XG4gICAgICB0aGlzLmNvbnN1bWVQYXRoKG9wSWR4LCBwYXRoLCBpbnRlcnNlY3QpO1xuICAgIH1cbiAgfVxuICBlb0ZpbGwob3BJZHgsIHBhdGgpIHtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSB0cnVlO1xuICAgIHRoaXMuZmlsbChvcElkeCwgcGF0aCk7XG4gIH1cbiAgZmlsbFN0cm9rZShvcElkeCwgcGF0aCkge1xuICAgIHRoaXMuZmlsbChvcElkeCwgcGF0aCwgZmFsc2UpO1xuICAgIHRoaXMuc3Ryb2tlKG9wSWR4LCBwYXRoLCBmYWxzZSk7XG4gICAgdGhpcy5jb25zdW1lUGF0aChvcElkeCwgcGF0aCk7XG4gIH1cbiAgZW9GaWxsU3Ryb2tlKG9wSWR4LCBwYXRoKSB7XG4gICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gdHJ1ZTtcbiAgICB0aGlzLmZpbGxTdHJva2Uob3BJZHgsIHBhdGgpO1xuICB9XG4gIGNsb3NlRmlsbFN0cm9rZShvcElkeCwgcGF0aCkge1xuICAgIHRoaXMuZmlsbFN0cm9rZShvcElkeCwgcGF0aCk7XG4gIH1cbiAgY2xvc2VFT0ZpbGxTdHJva2Uob3BJZHgsIHBhdGgpIHtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSB0cnVlO1xuICAgIHRoaXMuZmlsbFN0cm9rZShvcElkeCwgcGF0aCk7XG4gIH1cbiAgZW5kUGF0aChvcElkeCwgcGF0aCkge1xuICAgIHRoaXMuY29uc3VtZVBhdGgob3BJZHgsIHBhdGgpO1xuICB9XG4gIHJhd0ZpbGxQYXRoKG9wSWR4LCBwYXRoKSB7XG4gICAgdGhpcy5jdHguZmlsbChwYXRoKTtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmREZXBlbmRlbmNpZXMob3BJZHgsIERlcGVuZGVuY2llcy5yYXdGaWxsUGF0aCkucmVjb3JkT3BlcmF0aW9uKG9wSWR4KTtcbiAgfVxuICBjbGlwKG9wSWR4KSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkRnV0dXJlRm9yY2VkRGVwZW5kZW5jeShcImNsaXBNb2RlXCIsIG9wSWR4KTtcbiAgICB0aGlzLnBlbmRpbmdDbGlwID0gTk9STUFMX0NMSVA7XG4gIH1cbiAgZW9DbGlwKG9wSWR4KSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkRnV0dXJlRm9yY2VkRGVwZW5kZW5jeShcImNsaXBNb2RlXCIsIG9wSWR4KTtcbiAgICB0aGlzLnBlbmRpbmdDbGlwID0gRU9fQ0xJUDtcbiAgfVxuICBiZWdpblRleHQob3BJZHgpIHtcbiAgICB0aGlzLmN1cnJlbnQudGV4dE1hdHJpeCA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50LnRleHRNYXRyaXhTY2FsZSA9IDE7XG4gICAgdGhpcy5jdXJyZW50LnggPSB0aGlzLmN1cnJlbnQubGluZVggPSAwO1xuICAgIHRoaXMuY3VycmVudC55ID0gdGhpcy5jdXJyZW50LmxpbmVZID0gMDtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRPcGVuTWFya2VyKG9wSWR4KS5yZXNldEluY3JlbWVudGFsRGF0YShcInNhbWVMaW5lVGV4dFwiKS5yZXNldEluY3JlbWVudGFsRGF0YShcIm1vdmVUZXh0XCIsIG9wSWR4KTtcbiAgfVxuICBlbmRUZXh0KG9wSWR4KSB7XG4gICAgY29uc3QgcGF0aHMgPSB0aGlzLnBlbmRpbmdUZXh0UGF0aHM7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgaWYgKHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGVwZW5kZW5jeVRyYWNrZXJcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgaWYgKHBhdGhzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkRnV0dXJlRm9yY2VkRGVwZW5kZW5jeShcInRleHRDbGlwXCIsIGRlcGVuZGVuY3lUcmFja2VyLmdldE9wZW5NYXJrZXIoKSkucmVjb3JkRnV0dXJlRm9yY2VkRGVwZW5kZW5jeShcInRleHRDbGlwXCIsIG9wSWR4KTtcbiAgICAgIH1cbiAgICAgIGRlcGVuZGVuY3lUcmFja2VyLnJlY29yZENsb3NlTWFya2VyKG9wSWR4KTtcbiAgICB9XG4gICAgaWYgKHBhdGhzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IG5ld1BhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgICBjb25zdCBpbnZUcmFuc2YgPSBjdHguZ2V0VHJhbnNmb3JtKCkuaW52ZXJ0U2VsZigpO1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgZm9udFNpemUsXG4gICAgICAgIHBhdGhcbiAgICAgIH0gb2YgcGF0aHMpIHtcbiAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbmV3UGF0aC5hZGRQYXRoKHBhdGgsIG5ldyBET01NYXRyaXgodHJhbnNmb3JtKS5wcmVNdWx0aXBseVNlbGYoaW52VHJhbnNmKS50cmFuc2xhdGUoeCwgeSkuc2NhbGUoZm9udFNpemUsIC1mb250U2l6ZSkpO1xuICAgICAgfVxuICAgICAgY3R4LmNsaXAobmV3UGF0aCk7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdUZXh0UGF0aHM7XG4gIH1cbiAgc2V0Q2hhclNwYWNpbmcob3BJZHgsIHNwYWNpbmcpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwiY2hhclNwYWNpbmdcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3VycmVudC5jaGFyU3BhY2luZyA9IHNwYWNpbmc7XG4gIH1cbiAgc2V0V29yZFNwYWNpbmcob3BJZHgsIHNwYWNpbmcpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwid29yZFNwYWNpbmdcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3VycmVudC53b3JkU3BhY2luZyA9IHNwYWNpbmc7XG4gIH1cbiAgc2V0SFNjYWxlKG9wSWR4LCBzY2FsZSkge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJoU2NhbGVcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3VycmVudC50ZXh0SFNjYWxlID0gc2NhbGUgLyAxMDA7XG4gIH1cbiAgc2V0TGVhZGluZyhvcElkeCwgbGVhZGluZykge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJsZWFkaW5nXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN1cnJlbnQubGVhZGluZyA9IC1sZWFkaW5nO1xuICB9XG4gIHNldEZvbnQob3BJZHgsIGZvbnRSZWZOYW1lLCBzaXplKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImZvbnRcIiwgb3BJZHgpLnJlY29yZE5hbWVkRGVwZW5kZW5jeShvcElkeCwgZm9udFJlZk5hbWUpO1xuICAgIGNvbnN0IGZvbnRPYmogPSB0aGlzLmNvbW1vbk9ianMuZ2V0KGZvbnRSZWZOYW1lKTtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGlmICghZm9udE9iaikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBmaW5kIGZvbnQgZm9yICR7Zm9udFJlZk5hbWV9YCk7XG4gICAgfVxuICAgIGN1cnJlbnQuZm9udE1hdHJpeCA9IGZvbnRPYmouZm9udE1hdHJpeCB8fCBGT05UX0lERU5USVRZX01BVFJJWDtcbiAgICBpZiAoY3VycmVudC5mb250TWF0cml4WzBdID09PSAwIHx8IGN1cnJlbnQuZm9udE1hdHJpeFszXSA9PT0gMCkge1xuICAgICAgd2FybihcIkludmFsaWQgZm9udCBtYXRyaXggZm9yIGZvbnQgXCIgKyBmb250UmVmTmFtZSk7XG4gICAgfVxuICAgIGlmIChzaXplIDwgMCkge1xuICAgICAgc2l6ZSA9IC1zaXplO1xuICAgICAgY3VycmVudC5mb250RGlyZWN0aW9uID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQuZm9udERpcmVjdGlvbiA9IDE7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5mb250ID0gZm9udE9iajtcbiAgICB0aGlzLmN1cnJlbnQuZm9udFNpemUgPSBzaXplO1xuICAgIGlmIChmb250T2JqLmlzVHlwZTNGb250KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSBmb250T2JqLmxvYWRlZE5hbWUgfHwgXCJzYW5zLXNlcmlmXCI7XG4gICAgY29uc3QgdHlwZWZhY2UgPSBmb250T2JqLnN5c3RlbUZvbnRJbmZvPy5jc3MgfHwgYFwiJHtuYW1lfVwiLCAke2ZvbnRPYmouZmFsbGJhY2tOYW1lfWA7XG4gICAgbGV0IGJvbGQgPSBcIm5vcm1hbFwiO1xuICAgIGlmIChmb250T2JqLmJsYWNrKSB7XG4gICAgICBib2xkID0gXCI5MDBcIjtcbiAgICB9IGVsc2UgaWYgKGZvbnRPYmouYm9sZCkge1xuICAgICAgYm9sZCA9IFwiYm9sZFwiO1xuICAgIH1cbiAgICBjb25zdCBpdGFsaWMgPSBmb250T2JqLml0YWxpYyA/IFwiaXRhbGljXCIgOiBcIm5vcm1hbFwiO1xuICAgIGxldCBicm93c2VyRm9udFNpemUgPSBzaXplO1xuICAgIGlmIChzaXplIDwgTUlOX0ZPTlRfU0laRSkge1xuICAgICAgYnJvd3NlckZvbnRTaXplID0gTUlOX0ZPTlRfU0laRTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPiBNQVhfRk9OVF9TSVpFKSB7XG4gICAgICBicm93c2VyRm9udFNpemUgPSBNQVhfRk9OVF9TSVpFO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQuZm9udFNpemVTY2FsZSA9IHNpemUgLyBicm93c2VyRm9udFNpemU7XG4gICAgdGhpcy5jdHguZm9udCA9IGAke2l0YWxpY30gJHtib2xkfSAke2Jyb3dzZXJGb250U2l6ZX1weCAke3R5cGVmYWNlfWA7XG4gIH1cbiAgc2V0VGV4dFJlbmRlcmluZ01vZGUob3BJZHgsIG1vZGUpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwidGV4dFJlbmRlcmluZ01vZGVcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9IG1vZGU7XG4gIH1cbiAgc2V0VGV4dFJpc2Uob3BJZHgsIHJpc2UpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwidGV4dFJpc2VcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3VycmVudC50ZXh0UmlzZSA9IHJpc2U7XG4gIH1cbiAgbW92ZVRleHQob3BJZHgsIHgsIHkpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZXNldEluY3JlbWVudGFsRGF0YShcInNhbWVMaW5lVGV4dFwiKS5yZWNvcmRJbmNyZW1lbnRhbERhdGEoXCJtb3ZlVGV4dFwiLCBvcElkeCk7XG4gICAgdGhpcy5jdXJyZW50LnggPSB0aGlzLmN1cnJlbnQubGluZVggKz0geDtcbiAgICB0aGlzLmN1cnJlbnQueSA9IHRoaXMuY3VycmVudC5saW5lWSArPSB5O1xuICB9XG4gIHNldExlYWRpbmdNb3ZlVGV4dChvcElkeCwgeCwgeSkge1xuICAgIHRoaXMuc2V0TGVhZGluZyhvcElkeCwgLXkpO1xuICAgIHRoaXMubW92ZVRleHQob3BJZHgsIHgsIHkpO1xuICB9XG4gIHNldFRleHRNYXRyaXgob3BJZHgsIG1hdHJpeCkge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJ0ZXh0TWF0cml4XCIsIG9wSWR4KTtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50XG4gICAgfSA9IHRoaXM7XG4gICAgY3VycmVudC50ZXh0TWF0cml4ID0gbWF0cml4O1xuICAgIGN1cnJlbnQudGV4dE1hdHJpeFNjYWxlID0gTWF0aC5oeXBvdChtYXRyaXhbMF0sIG1hdHJpeFsxXSk7XG4gICAgY3VycmVudC54ID0gY3VycmVudC5saW5lWCA9IDA7XG4gICAgY3VycmVudC55ID0gY3VycmVudC5saW5lWSA9IDA7XG4gIH1cbiAgbmV4dExpbmUob3BJZHgpIHtcbiAgICB0aGlzLm1vdmVUZXh0KG9wSWR4LCAwLCB0aGlzLmN1cnJlbnQubGVhZGluZyk7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkSW5jcmVtZW50YWxEYXRhKFwibW92ZVRleHRcIiwgdGhpcy5kZXBlbmRlbmN5VHJhY2tlci5nZXRTaW1wbGVJbmRleChcImxlYWRpbmdcIikgPz8gb3BJZHgpO1xuICB9XG4gICNnZXRTY2FsZWRQYXRoKHBhdGgsIGN1cnJlbnRUcmFuc2Zvcm0sIHRyYW5zZm9ybSkge1xuICAgIGNvbnN0IG5ld1BhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgbmV3UGF0aC5hZGRQYXRoKHBhdGgsIG5ldyBET01NYXRyaXgodHJhbnNmb3JtKS5pbnZlcnRTZWxmKCkubXVsdGlwbHlTZWxmKGN1cnJlbnRUcmFuc2Zvcm0pKTtcbiAgICByZXR1cm4gbmV3UGF0aDtcbiAgfVxuICBwYWludENoYXIob3BJZHgsIGNoYXJhY3RlciwgeCwgeSwgcGF0dGVybkZpbGxUcmFuc2Zvcm0sIHBhdHRlcm5TdHJva2VUcmFuc2Zvcm0pIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgY29uc3QgdGV4dFJlbmRlcmluZ01vZGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlO1xuICAgIGNvbnN0IGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZSAvIGN1cnJlbnQuZm9udFNpemVTY2FsZTtcbiAgICBjb25zdCBmaWxsU3Ryb2tlTW9kZSA9IHRleHRSZW5kZXJpbmdNb2RlICYgVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0VfTUFTSztcbiAgICBjb25zdCBpc0FkZFRvUGF0aFNldCA9ICEhKHRleHRSZW5kZXJpbmdNb2RlICYgVGV4dFJlbmRlcmluZ01vZGUuQUREX1RPX1BBVEhfRkxBRyk7XG4gICAgY29uc3QgcGF0dGVybkZpbGwgPSBjdXJyZW50LnBhdHRlcm5GaWxsICYmICFmb250Lm1pc3NpbmdGaWxlO1xuICAgIGNvbnN0IHBhdHRlcm5TdHJva2UgPSBjdXJyZW50LnBhdHRlcm5TdHJva2UgJiYgIWZvbnQubWlzc2luZ0ZpbGU7XG4gICAgbGV0IHBhdGg7XG4gICAgaWYgKChmb250LmRpc2FibGVGb250RmFjZSB8fCBpc0FkZFRvUGF0aFNldCB8fCBwYXR0ZXJuRmlsbCB8fCBwYXR0ZXJuU3Ryb2tlKSAmJiAhZm9udC5taXNzaW5nRmlsZSkge1xuICAgICAgcGF0aCA9IGZvbnQuZ2V0UGF0aEdlbmVyYXRvcih0aGlzLmNvbW1vbk9ianMsIGNoYXJhY3Rlcik7XG4gICAgfVxuICAgIGlmIChwYXRoICYmIChmb250LmRpc2FibGVGb250RmFjZSB8fCBwYXR0ZXJuRmlsbCB8fCBwYXR0ZXJuU3Ryb2tlKSkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBjdHguc2NhbGUoZm9udFNpemUsIC1mb250U2l6ZSk7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRDaGFyYWN0ZXJCQm94KG9wSWR4LCBjdHgsIGZvbnQpO1xuICAgICAgbGV0IGN1cnJlbnRUcmFuc2Zvcm07XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTEwgfHwgZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGlmIChwYXR0ZXJuRmlsbFRyYW5zZm9ybSkge1xuICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0gPSBjdHguZ2V0VHJhbnNmb3JtKCk7XG4gICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSguLi5wYXR0ZXJuRmlsbFRyYW5zZm9ybSk7XG4gICAgICAgICAgY29uc3Qgc2NhbGVkUGF0aCA9IHRoaXMuI2dldFNjYWxlZFBhdGgocGF0aCwgY3VycmVudFRyYW5zZm9ybSwgcGF0dGVybkZpbGxUcmFuc2Zvcm0pO1xuICAgICAgICAgIGN0eC5maWxsKHNjYWxlZFBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5maWxsKHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgaWYgKHBhdHRlcm5TdHJva2VUcmFuc2Zvcm0pIHtcbiAgICAgICAgICBjdXJyZW50VHJhbnNmb3JtIHx8PSBjdHguZ2V0VHJhbnNmb3JtKCk7XG4gICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSguLi5wYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtKTtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBkXG4gICAgICAgICAgfSA9IGN1cnJlbnRUcmFuc2Zvcm07XG4gICAgICAgICAgY29uc3QgaW52UGF0dGVyblRyYW5zZm9ybSA9IFV0aWwuaW52ZXJzZVRyYW5zZm9ybShwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtKTtcbiAgICAgICAgICBjb25zdCB0cmFuc2YgPSBVdGlsLnRyYW5zZm9ybShbYSwgYiwgYywgZCwgMCwgMF0sIGludlBhdHRlcm5UcmFuc2Zvcm0pO1xuICAgICAgICAgIFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodHJhbnNmLCBYWSk7XG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCAqPSBNYXRoLm1heChYWVswXSwgWFlbMV0pIC8gZm9udFNpemU7XG4gICAgICAgICAgY3R4LnN0cm9rZSh0aGlzLiNnZXRTY2FsZWRQYXRoKHBhdGgsIGN1cnJlbnRUcmFuc2Zvcm0sIHBhdHRlcm5TdHJva2VUcmFuc2Zvcm0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgubGluZVdpZHRoIC89IGZvbnRTaXplO1xuICAgICAgICAgIGN0eC5zdHJva2UocGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTCB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KGNoYXJhY3RlciwgeCwgeSk7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZENoYXJhY3RlckJCb3gob3BJZHgsIGN0eCwgZm9udCwgZm9udFNpemUsIHgsIHksICgpID0+IGN0eC5tZWFzdXJlVGV4dChjaGFyYWN0ZXIpKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuU1RST0tFIHx8IGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBpZiAodGhpcy5kZXBlbmRlbmN5VHJhY2tlcikge1xuICAgICAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZENoYXJhY3RlckJCb3gob3BJZHgsIGN0eCwgZm9udCwgZm9udFNpemUsIHgsIHksICgpID0+IGN0eC5tZWFzdXJlVGV4dChjaGFyYWN0ZXIpKS5yZWNvcmREZXBlbmRlbmNpZXMob3BJZHgsIERlcGVuZGVuY2llcy5zdHJva2UpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2VUZXh0KGNoYXJhY3RlciwgeCwgeSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0FkZFRvUGF0aFNldCkge1xuICAgICAgY29uc3QgcGF0aHMgPSB0aGlzLnBlbmRpbmdUZXh0UGF0aHMgfHw9IFtdO1xuICAgICAgcGF0aHMucHVzaCh7XG4gICAgICAgIHRyYW5zZm9ybTogZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgcGF0aFxuICAgICAgfSk7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRDaGFyYWN0ZXJCQm94KG9wSWR4LCBjdHgsIGZvbnQsIGZvbnRTaXplLCB4LCB5KTtcbiAgICB9XG4gIH1cbiAgZ2V0IGlzRm9udFN1YnBpeGVsQUFFbmFibGVkKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQ6IGN0eFxuICAgIH0gPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlzRm9udFN1YnBpeGVsQUFFbmFibGVkXCIsIDEwLCAxMCk7XG4gICAgY3R4LnNjYWxlKDEuNSwgMSk7XG4gICAgY3R4LmZpbGxUZXh0KFwiSVwiLCAwLCAxMCk7XG4gICAgY29uc3QgZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMTAsIDEwKS5kYXRhO1xuICAgIGxldCBlbmFibGVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDM7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICBpZiAoZGF0YVtpXSA+IDAgJiYgZGF0YVtpXSA8IDI1NSkge1xuICAgICAgICBlbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZFwiLCBlbmFibGVkKTtcbiAgfVxuICBzaG93VGV4dChvcElkeCwgZ2x5cGhzKSB7XG4gICAgaWYgKHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIpIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBEZXBlbmRlbmNpZXMuc2hvd1RleHQpLmNvcHlEZXBlbmRlbmNpZXNGcm9tSW5jcmVtZW50YWxPcGVyYXRpb24ob3BJZHgsIFwic2FtZUxpbmVUZXh0XCIpLnJlc2V0QkJveChvcElkeCk7XG4gICAgICBpZiAodGhpcy5jdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlICYgVGV4dFJlbmRlcmluZ01vZGUuQUREX1RPX1BBVEhfRkxBRykge1xuICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyLnJlY29yZEZ1dHVyZUZvcmNlZERlcGVuZGVuY3koXCJ0ZXh0Q2xpcFwiLCBvcElkeCkuaW5oZXJpdFBlbmRpbmdEZXBlbmRlbmNpZXNBc0Z1dHVyZUZvcmNlZERlcGVuZGVuY2llcygpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgaWYgKGZvbnQuaXNUeXBlM0ZvbnQpIHtcbiAgICAgIHRoaXMuc2hvd1R5cGUzVGV4dChvcElkeCwgZ2x5cGhzKTtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZE9wZXJhdGlvbihvcElkeCkucmVjb3JkSW5jcmVtZW50YWxEYXRhKFwic2FtZUxpbmVUZXh0XCIsIG9wSWR4KTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZTtcbiAgICBpZiAoZm9udFNpemUgPT09IDApIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZE9wZXJhdGlvbihvcElkeCk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmb250U2l6ZVNjYWxlID0gY3VycmVudC5mb250U2l6ZVNjYWxlO1xuICAgIGNvbnN0IGNoYXJTcGFjaW5nID0gY3VycmVudC5jaGFyU3BhY2luZztcbiAgICBjb25zdCB3b3JkU3BhY2luZyA9IGN1cnJlbnQud29yZFNwYWNpbmc7XG4gICAgY29uc3QgZm9udERpcmVjdGlvbiA9IGN1cnJlbnQuZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCB0ZXh0SFNjYWxlID0gY3VycmVudC50ZXh0SFNjYWxlICogZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCBnbHlwaHNMZW5ndGggPSBnbHlwaHMubGVuZ3RoO1xuICAgIGNvbnN0IHZlcnRpY2FsID0gZm9udC52ZXJ0aWNhbDtcbiAgICBjb25zdCBzcGFjaW5nRGlyID0gdmVydGljYWwgPyAxIDogLTE7XG4gICAgY29uc3QgZGVmYXVsdFZNZXRyaWNzID0gZm9udC5kZWZhdWx0Vk1ldHJpY3M7XG4gICAgY29uc3Qgd2lkdGhBZHZhbmNlU2NhbGUgPSBmb250U2l6ZSAqIGN1cnJlbnQuZm9udE1hdHJpeFswXTtcbiAgICBjb25zdCBzaW1wbGVGaWxsVGV4dCA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTEwgJiYgIWZvbnQuZGlzYWJsZUZvbnRGYWNlICYmICFjdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgaWYgKGN1cnJlbnQudGV4dE1hdHJpeCkge1xuICAgICAgY3R4LnRyYW5zZm9ybSguLi5jdXJyZW50LnRleHRNYXRyaXgpO1xuICAgIH1cbiAgICBjdHgudHJhbnNsYXRlKGN1cnJlbnQueCwgY3VycmVudC55ICsgY3VycmVudC50ZXh0UmlzZSk7XG4gICAgaWYgKGZvbnREaXJlY3Rpb24gPiAwKSB7XG4gICAgICBjdHguc2NhbGUodGV4dEhTY2FsZSwgLTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguc2NhbGUodGV4dEhTY2FsZSwgMSk7XG4gICAgfVxuICAgIGxldCBwYXR0ZXJuRmlsbFRyYW5zZm9ybSwgcGF0dGVyblN0cm9rZVRyYW5zZm9ybTtcbiAgICBpZiAoY3VycmVudC5wYXR0ZXJuRmlsbCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGNvbnN0IHBhdHRlcm4gPSBjdXJyZW50LmZpbGxDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSwgUGF0aFR5cGUuRklMTCk7XG4gICAgICBwYXR0ZXJuRmlsbFRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gcGF0dGVybjtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnQucGF0dGVyblN0cm9rZSkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGNvbnN0IHBhdHRlcm4gPSBjdXJyZW50LnN0cm9rZUNvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpLCBQYXRoVHlwZS5TVFJPS0UpO1xuICAgICAgcGF0dGVyblN0cm9rZVRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBwYXR0ZXJuO1xuICAgIH1cbiAgICBsZXQgbGluZVdpZHRoID0gY3VycmVudC5saW5lV2lkdGg7XG4gICAgY29uc3Qgc2NhbGUgPSBjdXJyZW50LnRleHRNYXRyaXhTY2FsZTtcbiAgICBpZiAoc2NhbGUgPT09IDAgfHwgbGluZVdpZHRoID09PSAwKSB7XG4gICAgICBjb25zdCBmaWxsU3Ryb2tlTW9kZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgJiBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRV9NQVNLO1xuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGxpbmVXaWR0aCA9IHRoaXMuZ2V0U2luZ2xlUGl4ZWxXaWR0aCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lV2lkdGggLz0gc2NhbGU7XG4gICAgfVxuICAgIGlmIChmb250U2l6ZVNjYWxlICE9PSAxLjApIHtcbiAgICAgIGN0eC5zY2FsZShmb250U2l6ZVNjYWxlLCBmb250U2l6ZVNjYWxlKTtcbiAgICAgIGxpbmVXaWR0aCAvPSBmb250U2l6ZVNjYWxlO1xuICAgIH1cbiAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgIGlmIChmb250LmlzSW52YWxpZFBERmpzRm9udCkge1xuICAgICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICAgIGxldCB3aWR0aCA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGdseXBoIG9mIGdseXBocykge1xuICAgICAgICBjaGFycy5wdXNoKGdseXBoLnVuaWNvZGUpO1xuICAgICAgICB3aWR0aCArPSBnbHlwaC53aWR0aDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGpvaW5lZENoYXJzID0gY2hhcnMuam9pbihcIlwiKTtcbiAgICAgIGN0eC5maWxsVGV4dChqb2luZWRDaGFycywgMCwgMCk7XG4gICAgICBpZiAodGhpcy5kZXBlbmRlbmN5VHJhY2tlciAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBtZWFzdXJlID0gY3R4Lm1lYXN1cmVUZXh0KGpvaW5lZENoYXJzKTtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRCQm94KG9wSWR4LCB0aGlzLmN0eCwgLW1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hMZWZ0LCBtZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQsIC1tZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50LCBtZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCkucmVjb3JkT3BlcmF0aW9uKG9wSWR4KS5yZWNvcmRJbmNyZW1lbnRhbERhdGEoXCJzYW1lTGluZVRleHRcIiwgb3BJZHgpO1xuICAgICAgfVxuICAgICAgY3VycmVudC54ICs9IHdpZHRoICogd2lkdGhBZHZhbmNlU2NhbGUgKiB0ZXh0SFNjYWxlO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuY29tcG9zZSgpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IHggPSAwLFxuICAgICAgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzTGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBnbHlwaCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB4ICs9IHNwYWNpbmdEaXIgKiBnbHlwaCAqIGZvbnRTaXplIC8gMTAwMDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgcmVzdG9yZU5lZWRlZCA9IGZhbHNlO1xuICAgICAgY29uc3Qgc3BhY2luZyA9IChnbHlwaC5pc1NwYWNlID8gd29yZFNwYWNpbmcgOiAwKSArIGNoYXJTcGFjaW5nO1xuICAgICAgY29uc3QgY2hhcmFjdGVyID0gZ2x5cGguZm9udENoYXI7XG4gICAgICBjb25zdCBhY2NlbnQgPSBnbHlwaC5hY2NlbnQ7XG4gICAgICBsZXQgc2NhbGVkWCwgc2NhbGVkWTtcbiAgICAgIGxldCB3aWR0aCA9IGdseXBoLndpZHRoO1xuICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgIGNvbnN0IHZtZXRyaWMgPSBnbHlwaC52bWV0cmljIHx8IGRlZmF1bHRWTWV0cmljcztcbiAgICAgICAgY29uc3QgdnggPSAtKGdseXBoLnZtZXRyaWMgPyB2bWV0cmljWzFdIDogd2lkdGggKiAwLjUpICogd2lkdGhBZHZhbmNlU2NhbGU7XG4gICAgICAgIGNvbnN0IHZ5ID0gdm1ldHJpY1syXSAqIHdpZHRoQWR2YW5jZVNjYWxlO1xuICAgICAgICB3aWR0aCA9IHZtZXRyaWMgPyAtdm1ldHJpY1swXSA6IHdpZHRoO1xuICAgICAgICBzY2FsZWRYID0gdnggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICBzY2FsZWRZID0gKHggKyB2eSkgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGVkWCA9IHggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICBzY2FsZWRZID0gMDtcbiAgICAgIH1cbiAgICAgIGxldCBtZWFzdXJlO1xuICAgICAgaWYgKGZvbnQucmVtZWFzdXJlICYmIHdpZHRoID4gMCkge1xuICAgICAgICBtZWFzdXJlID0gY3R4Lm1lYXN1cmVUZXh0KGNoYXJhY3Rlcik7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVkV2lkdGggPSBtZWFzdXJlLndpZHRoICogMTAwMCAvIGZvbnRTaXplICogZm9udFNpemVTY2FsZTtcbiAgICAgICAgaWYgKHdpZHRoIDwgbWVhc3VyZWRXaWR0aCAmJiB0aGlzLmlzRm9udFN1YnBpeGVsQUFFbmFibGVkKSB7XG4gICAgICAgICAgY29uc3QgY2hhcmFjdGVyU2NhbGVYID0gd2lkdGggLyBtZWFzdXJlZFdpZHRoO1xuICAgICAgICAgIHJlc3RvcmVOZWVkZWQgPSB0cnVlO1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgY3R4LnNjYWxlKGNoYXJhY3RlclNjYWxlWCwgMSk7XG4gICAgICAgICAgc2NhbGVkWCAvPSBjaGFyYWN0ZXJTY2FsZVg7XG4gICAgICAgIH0gZWxzZSBpZiAod2lkdGggIT09IG1lYXN1cmVkV2lkdGgpIHtcbiAgICAgICAgICBzY2FsZWRYICs9ICh3aWR0aCAtIG1lYXN1cmVkV2lkdGgpIC8gMjAwMCAqIGZvbnRTaXplIC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29udGVudFZpc2libGUgJiYgKGdseXBoLmlzSW5Gb250IHx8IGZvbnQubWlzc2luZ0ZpbGUpKSB7XG4gICAgICAgIGlmIChzaW1wbGVGaWxsVGV4dCAmJiAhYWNjZW50KSB7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KGNoYXJhY3Rlciwgc2NhbGVkWCwgc2NhbGVkWSk7XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkQ2hhcmFjdGVyQkJveChvcElkeCwgY3R4LCBtZWFzdXJlID8ge1xuICAgICAgICAgICAgYmJveDogbnVsbFxuICAgICAgICAgIH0gOiBmb250LCBmb250U2l6ZSAvIGZvbnRTaXplU2NhbGUsIHNjYWxlZFgsIHNjYWxlZFksICgpID0+IG1lYXN1cmUgPz8gY3R4Lm1lYXN1cmVUZXh0KGNoYXJhY3RlcikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFpbnRDaGFyKG9wSWR4LCBjaGFyYWN0ZXIsIHNjYWxlZFgsIHNjYWxlZFksIHBhdHRlcm5GaWxsVHJhbnNmb3JtLCBwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtKTtcbiAgICAgICAgICBpZiAoYWNjZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRBY2NlbnRYID0gc2NhbGVkWCArIGZvbnRTaXplICogYWNjZW50Lm9mZnNldC54IC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlZEFjY2VudFkgPSBzY2FsZWRZIC0gZm9udFNpemUgKiBhY2NlbnQub2Zmc2V0LnkgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICAgICAgdGhpcy5wYWludENoYXIob3BJZHgsIGFjY2VudC5mb250Q2hhciwgc2NhbGVkQWNjZW50WCwgc2NhbGVkQWNjZW50WSwgcGF0dGVybkZpbGxUcmFuc2Zvcm0sIHBhdHRlcm5TdHJva2VUcmFuc2Zvcm0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY2hhcldpZHRoID0gdmVydGljYWwgPyB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlIC0gc3BhY2luZyAqIGZvbnREaXJlY3Rpb24gOiB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlICsgc3BhY2luZyAqIGZvbnREaXJlY3Rpb247XG4gICAgICB4ICs9IGNoYXJXaWR0aDtcbiAgICAgIGlmIChyZXN0b3JlTmVlZGVkKSB7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgY3VycmVudC55IC09IHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQueCArPSB4ICogdGV4dEhTY2FsZTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRPcGVyYXRpb24ob3BJZHgpLnJlY29yZEluY3JlbWVudGFsRGF0YShcInNhbWVMaW5lVGV4dFwiLCBvcElkeCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBzaG93VHlwZTNUZXh0KG9wSWR4LCBnbHlwaHMpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgY29uc3QgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplO1xuICAgIGNvbnN0IGZvbnREaXJlY3Rpb24gPSBjdXJyZW50LmZvbnREaXJlY3Rpb247XG4gICAgY29uc3Qgc3BhY2luZ0RpciA9IGZvbnQudmVydGljYWwgPyAxIDogLTE7XG4gICAgY29uc3QgY2hhclNwYWNpbmcgPSBjdXJyZW50LmNoYXJTcGFjaW5nO1xuICAgIGNvbnN0IHdvcmRTcGFjaW5nID0gY3VycmVudC53b3JkU3BhY2luZztcbiAgICBjb25zdCB0ZXh0SFNjYWxlID0gY3VycmVudC50ZXh0SFNjYWxlICogZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCBmb250TWF0cml4ID0gY3VycmVudC5mb250TWF0cml4IHx8IEZPTlRfSURFTlRJVFlfTUFUUklYO1xuICAgIGNvbnN0IGdseXBoc0xlbmd0aCA9IGdseXBocy5sZW5ndGg7XG4gICAgY29uc3QgaXNUZXh0SW52aXNpYmxlID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuSU5WSVNJQkxFO1xuICAgIGxldCBpLCBnbHlwaCwgd2lkdGgsIHNwYWNpbmdMZW5ndGg7XG4gICAgaWYgKGlzVGV4dEludmlzaWJsZSB8fCBmb250U2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBpZiAoY3VycmVudC50ZXh0TWF0cml4KSB7XG4gICAgICBjdHgudHJhbnNmb3JtKC4uLmN1cnJlbnQudGV4dE1hdHJpeCk7XG4gICAgfVxuICAgIGN0eC50cmFuc2xhdGUoY3VycmVudC54LCBjdXJyZW50LnkgKyBjdXJyZW50LnRleHRSaXNlKTtcbiAgICBjdHguc2NhbGUodGV4dEhTY2FsZSwgZm9udERpcmVjdGlvbik7XG4gICAgY29uc3QgZGVwZW5kZW5jeVRyYWNrZXIgPSB0aGlzLmRlcGVuZGVuY3lUcmFja2VyO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIgPSBkZXBlbmRlbmN5VHJhY2tlciA/IG5ldyBDYW52YXNOZXN0ZWREZXBlbmRlbmN5VHJhY2tlcihkZXBlbmRlbmN5VHJhY2tlciwgb3BJZHgpIDogbnVsbDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzTGVuZ3RoOyArK2kpIHtcbiAgICAgIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBnbHlwaCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBzcGFjaW5nTGVuZ3RoID0gc3BhY2luZ0RpciAqIGdseXBoICogZm9udFNpemUgLyAxMDAwO1xuICAgICAgICB0aGlzLmN0eC50cmFuc2xhdGUoc3BhY2luZ0xlbmd0aCwgMCk7XG4gICAgICAgIGN1cnJlbnQueCArPSBzcGFjaW5nTGVuZ3RoICogdGV4dEhTY2FsZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBzcGFjaW5nID0gKGdseXBoLmlzU3BhY2UgPyB3b3JkU3BhY2luZyA6IDApICsgY2hhclNwYWNpbmc7XG4gICAgICBjb25zdCBvcGVyYXRvckxpc3QgPSBmb250LmNoYXJQcm9jT3BlcmF0b3JMaXN0W2dseXBoLm9wZXJhdG9yTGlzdElkXTtcbiAgICAgIGlmICghb3BlcmF0b3JMaXN0KSB7XG4gICAgICAgIHdhcm4oYFR5cGUzIGNoYXJhY3RlciBcIiR7Z2x5cGgub3BlcmF0b3JMaXN0SWR9XCIgaXMgbm90IGF2YWlsYWJsZS5gKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICAgICAgY3R4LnNjYWxlKGZvbnRTaXplLCBmb250U2l6ZSk7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0oLi4uZm9udE1hdHJpeCk7XG4gICAgICAgIHRoaXMuZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QpO1xuICAgICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHAgPSBbZ2x5cGgud2lkdGgsIDBdO1xuICAgICAgVXRpbC5hcHBseVRyYW5zZm9ybShwLCBmb250TWF0cml4KTtcbiAgICAgIHdpZHRoID0gcFswXSAqIGZvbnRTaXplICsgc3BhY2luZztcbiAgICAgIGN0eC50cmFuc2xhdGUod2lkdGgsIDApO1xuICAgICAgY3VycmVudC54ICs9IHdpZHRoICogdGV4dEhTY2FsZTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICBpZiAoZGVwZW5kZW5jeVRyYWNrZXIpIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkTmVzdGVkRGVwZW5kZW5jaWVzKCk7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyID0gZGVwZW5kZW5jeVRyYWNrZXI7XG4gICAgfVxuICB9XG4gIHNldENoYXJXaWR0aChvcElkeCwgeFdpZHRoLCB5V2lkdGgpIHt9XG4gIHNldENoYXJXaWR0aEFuZEJvdW5kcyhvcElkeCwgeFdpZHRoLCB5V2lkdGgsIGxseCwgbGx5LCB1cngsIHVyeSkge1xuICAgIGNvbnN0IGNsaXAgPSBuZXcgUGF0aDJEKCk7XG4gICAgY2xpcC5yZWN0KGxseCwgbGx5LCB1cnggLSBsbHgsIHVyeSAtIGxseSk7XG4gICAgdGhpcy5jdHguY2xpcChjbGlwKTtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRCQm94KG9wSWR4LCB0aGlzLmN0eCwgbGx4LCB1cngsIGxseSwgdXJ5KS5yZWNvcmRDbGlwQm94KG9wSWR4LCB0aGlzLmN0eCwgbGx4LCB1cngsIGxseSwgdXJ5KTtcbiAgICB0aGlzLmVuZFBhdGgob3BJZHgpO1xuICB9XG4gIGdldENvbG9yTl9QYXR0ZXJuKG9wSWR4LCBJUikge1xuICAgIGxldCBwYXR0ZXJuO1xuICAgIGlmIChJUlswXSA9PT0gXCJUaWxpbmdQYXR0ZXJuXCIpIHtcbiAgICAgIGNvbnN0IGJhc2VUcmFuc2Zvcm0gPSB0aGlzLmJhc2VUcmFuc2Zvcm0gfHwgZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCk7XG4gICAgICBjb25zdCBjYW52YXNHcmFwaGljc0ZhY3RvcnkgPSB7XG4gICAgICAgIGNyZWF0ZUNhbnZhc0dyYXBoaWNzOiBjdHggPT4gbmV3IENhbnZhc0dyYXBoaWNzKGN0eCwgdGhpcy5jb21tb25PYmpzLCB0aGlzLm9ianMsIHRoaXMuY2FudmFzRmFjdG9yeSwgdGhpcy5maWx0ZXJGYWN0b3J5LCB7XG4gICAgICAgICAgb3B0aW9uYWxDb250ZW50Q29uZmlnOiB0aGlzLm9wdGlvbmFsQ29udGVudENvbmZpZyxcbiAgICAgICAgICBtYXJrZWRDb250ZW50U3RhY2s6IHRoaXMubWFya2VkQ29udGVudFN0YWNrXG4gICAgICAgIH0sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0aGlzLmRlcGVuZGVuY3lUcmFja2VyID8gbmV3IENhbnZhc05lc3RlZERlcGVuZGVuY3lUcmFja2VyKHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIsIG9wSWR4KSA6IG51bGwpXG4gICAgICB9O1xuICAgICAgcGF0dGVybiA9IG5ldyBUaWxpbmdQYXR0ZXJuKElSLCB0aGlzLmN0eCwgY2FudmFzR3JhcGhpY3NGYWN0b3J5LCBiYXNlVHJhbnNmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0dGVybiA9IHRoaXMuX2dldFBhdHRlcm4ob3BJZHgsIElSWzFdLCBJUlsyXSk7XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG4gIHNldFN0cm9rZUNvbG9yTihvcElkeCwgLi4uYXJncykge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJzdHJva2VDb2xvclwiLCBvcElkeCk7XG4gICAgdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gdGhpcy5nZXRDb2xvck5fUGF0dGVybihvcElkeCwgYXJncyk7XG4gICAgdGhpcy5jdXJyZW50LnBhdHRlcm5TdHJva2UgPSB0cnVlO1xuICB9XG4gIHNldEZpbGxDb2xvck4ob3BJZHgsIC4uLmFyZ3MpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwiZmlsbENvbG9yXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gdGhpcy5nZXRDb2xvck5fUGF0dGVybihvcElkeCwgYXJncyk7XG4gICAgdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsID0gdHJ1ZTtcbiAgfVxuICBzZXRTdHJva2VSR0JDb2xvcihvcElkeCwgY29sb3IpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwic3Ryb2tlQ29sb3JcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gY29sb3I7XG4gICAgdGhpcy5jdXJyZW50LnBhdHRlcm5TdHJva2UgPSBmYWxzZTtcbiAgfVxuICBzZXRTdHJva2VUcmFuc3BhcmVudChvcElkeCkge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJzdHJva2VDb2xvclwiLCBvcElkeCk7XG4gICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgdGhpcy5jdXJyZW50LnBhdHRlcm5TdHJva2UgPSBmYWxzZTtcbiAgfVxuICBzZXRGaWxsUkdCQ29sb3Iob3BJZHgsIGNvbG9yKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImZpbGxDb2xvclwiLCBvcElkeCk7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IGNvbG9yO1xuICAgIHRoaXMuY3VycmVudC5wYXR0ZXJuRmlsbCA9IGZhbHNlO1xuICB9XG4gIHNldEZpbGxUcmFuc3BhcmVudChvcElkeCkge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJmaWxsQ29sb3JcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsID0gZmFsc2U7XG4gIH1cbiAgX2dldFBhdHRlcm4ob3BJZHgsIG9iaklkLCBtYXRyaXggPSBudWxsKSB7XG4gICAgbGV0IHBhdHRlcm47XG4gICAgaWYgKHRoaXMuY2FjaGVkUGF0dGVybnMuaGFzKG9iaklkKSkge1xuICAgICAgcGF0dGVybiA9IHRoaXMuY2FjaGVkUGF0dGVybnMuZ2V0KG9iaklkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0dGVybiA9IGdldFNoYWRpbmdQYXR0ZXJuKHRoaXMuZ2V0T2JqZWN0KG9wSWR4LCBvYmpJZCkpO1xuICAgICAgdGhpcy5jYWNoZWRQYXR0ZXJucy5zZXQob2JqSWQsIHBhdHRlcm4pO1xuICAgIH1cbiAgICBpZiAobWF0cml4KSB7XG4gICAgICBwYXR0ZXJuLm1hdHJpeCA9IG1hdHJpeDtcbiAgICB9XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbiAgc2hhZGluZ0ZpbGwob3BJZHgsIG9iaklkKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIHRoaXMuc2F2ZShvcElkeCk7XG4gICAgY29uc3QgcGF0dGVybiA9IHRoaXMuX2dldFBhdHRlcm4ob3BJZHgsIG9iaklkKTtcbiAgICBjdHguZmlsbFN0eWxlID0gcGF0dGVybi5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSwgUGF0aFR5cGUuU0hBRElORyk7XG4gICAgY29uc3QgaW52ID0gZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KTtcbiAgICBpZiAoaW52KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSBjdHguY2FudmFzO1xuICAgICAgY29uc3QgbWluTWF4ID0gTUlOX01BWF9JTklULnNsaWNlKCk7XG4gICAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFswLCAwLCB3aWR0aCwgaGVpZ2h0XSwgaW52LCBtaW5NYXgpO1xuICAgICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IG1pbk1heDtcbiAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KHgwLCB5MCwgeDEgLSB4MCwgeTEgLSB5MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KC0xZTEwLCAtMWUxMCwgMmUxMCwgMmUxMCk7XG4gICAgfVxuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc2V0QkJveChvcElkeCkucmVjb3JkRnVsbFBhZ2VCQm94KG9wSWR4KS5yZWNvcmREZXBlbmRlbmNpZXMob3BJZHgsIERlcGVuZGVuY2llcy50cmFuc2Zvcm0pLnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLmZpbGwpLnJlY29yZE9wZXJhdGlvbihvcElkeCk7XG4gICAgdGhpcy5jb21wb3NlKHRoaXMuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KCkpO1xuICAgIHRoaXMucmVzdG9yZShvcElkeCk7XG4gIH1cbiAgYmVnaW5JbmxpbmVJbWFnZSgpIHtcbiAgICB1bnJlYWNoYWJsZShcIlNob3VsZCBub3QgY2FsbCBiZWdpbklubGluZUltYWdlXCIpO1xuICB9XG4gIGJlZ2luSW1hZ2VEYXRhKCkge1xuICAgIHVucmVhY2hhYmxlKFwiU2hvdWxkIG5vdCBjYWxsIGJlZ2luSW1hZ2VEYXRhXCIpO1xuICB9XG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbihvcElkeCwgbWF0cml4LCBiYm94KSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2F2ZShvcElkeCk7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtU3RhY2sucHVzaCh0aGlzLmJhc2VUcmFuc2Zvcm0pO1xuICAgIGlmIChtYXRyaXgpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtKG9wSWR4LCAuLi5tYXRyaXgpO1xuICAgIH1cbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KTtcbiAgICBpZiAoYmJveCkge1xuICAgICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChiYm94LCB0aGlzLmJhc2VUcmFuc2Zvcm0sIHRoaXMuY3VycmVudC5taW5NYXgpO1xuICAgICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IGJib3g7XG4gICAgICBjb25zdCBjbGlwID0gbmV3IFBhdGgyRCgpO1xuICAgICAgY2xpcC5yZWN0KHgwLCB5MCwgeDEgLSB4MCwgeTEgLSB5MCk7XG4gICAgICB0aGlzLmN0eC5jbGlwKGNsaXApO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkQ2xpcEJveChvcElkeCwgdGhpcy5jdHgsIHgwLCB4MSwgeTAsIHkxKTtcbiAgICAgIHRoaXMuZW5kUGF0aChvcElkeCk7XG4gICAgfVxuICB9XG4gIHBhaW50Rm9ybVhPYmplY3RFbmQob3BJZHgpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZXN0b3JlKG9wSWR4KTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjay5wb3AoKTtcbiAgfVxuICBiZWdpbkdyb3VwKG9wSWR4LCBncm91cCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNhdmUob3BJZHgpO1xuICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmVuZFNNYXNrTW9kZSgpO1xuICAgICAgdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudEN0eCA9IHRoaXMuY3R4O1xuICAgIGlmICghZ3JvdXAuaXNvbGF0ZWQpIHtcbiAgICAgIGluZm8oXCJUT0RPOiBTdXBwb3J0IG5vbi1pc29sYXRlZCBncm91cHMuXCIpO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAua25vY2tvdXQpIHtcbiAgICAgIHdhcm4oXCJLbm9ja291dCBncm91cHMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGN1cnJlbnRDdHgpO1xuICAgIGlmIChncm91cC5tYXRyaXgpIHtcbiAgICAgIGN1cnJlbnRDdHgudHJhbnNmb3JtKC4uLmdyb3VwLm1hdHJpeCk7XG4gICAgfVxuICAgIGlmICghZ3JvdXAuYmJveCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQm91bmRpbmcgYm94IGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG4gICAgbGV0IGJvdW5kcyA9IE1JTl9NQVhfSU5JVC5zbGljZSgpO1xuICAgIFV0aWwuYXhpYWxBbGlnbmVkQm91bmRpbmdCb3goZ3JvdXAuYmJveCwgZ2V0Q3VycmVudFRyYW5zZm9ybShjdXJyZW50Q3R4KSwgYm91bmRzKTtcbiAgICBjb25zdCBjYW52YXNCb3VuZHMgPSBbMCwgMCwgY3VycmVudEN0eC5jYW52YXMud2lkdGgsIGN1cnJlbnRDdHguY2FudmFzLmhlaWdodF07XG4gICAgYm91bmRzID0gVXRpbC5pbnRlcnNlY3QoYm91bmRzLCBjYW52YXNCb3VuZHMpIHx8IFswLCAwLCAwLCAwXTtcbiAgICBjb25zdCBvZmZzZXRYID0gTWF0aC5mbG9vcihib3VuZHNbMF0pO1xuICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLmZsb29yKGJvdW5kc1sxXSk7XG4gICAgY29uc3QgZHJhd25XaWR0aCA9IE1hdGgubWF4KE1hdGguY2VpbChib3VuZHNbMl0pIC0gb2Zmc2V0WCwgMSk7XG4gICAgY29uc3QgZHJhd25IZWlnaHQgPSBNYXRoLm1heChNYXRoLmNlaWwoYm91bmRzWzNdKSAtIG9mZnNldFksIDEpO1xuICAgIHRoaXMuY3VycmVudC5zdGFydE5ld1BhdGhBbmRDbGlwQm94KFswLCAwLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodF0pO1xuICAgIGxldCBjYWNoZUlkID0gXCJncm91cEF0XCIgKyB0aGlzLmdyb3VwTGV2ZWw7XG4gICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICBjYWNoZUlkICs9IFwiX3NtYXNrX1wiICsgdGhpcy5zbWFza0NvdW50ZXIrKyAlIDI7XG4gICAgfVxuICAgIGNvbnN0IHNjcmF0Y2hDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhjYWNoZUlkLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodCk7XG4gICAgY29uc3QgZ3JvdXBDdHggPSBzY3JhdGNoQ2FudmFzLmNvbnRleHQ7XG4gICAgZ3JvdXBDdHgudHJhbnNsYXRlKC1vZmZzZXRYLCAtb2Zmc2V0WSk7XG4gICAgZ3JvdXBDdHgudHJhbnNmb3JtKC4uLmN1cnJlbnRUcmFuc2Zvcm0pO1xuICAgIGxldCBjbGlwID0gbmV3IFBhdGgyRCgpO1xuICAgIGNvbnN0IFt4MCwgeTAsIHgxLCB5MV0gPSBncm91cC5iYm94O1xuICAgIGNsaXAucmVjdCh4MCwgeTAsIHgxIC0geDAsIHkxIC0geTApO1xuICAgIGlmIChncm91cC5tYXRyaXgpIHtcbiAgICAgIGNvbnN0IHBhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgICBwYXRoLmFkZFBhdGgoY2xpcCwgbmV3IERPTU1hdHJpeChncm91cC5tYXRyaXgpKTtcbiAgICAgIGNsaXAgPSBwYXRoO1xuICAgIH1cbiAgICBncm91cEN0eC5jbGlwKGNsaXApO1xuICAgIGlmIChncm91cC5zbWFzaykge1xuICAgICAgdGhpcy5zbWFza1N0YWNrLnB1c2goe1xuICAgICAgICBjYW52YXM6IHNjcmF0Y2hDYW52YXMuY2FudmFzLFxuICAgICAgICBjb250ZXh0OiBncm91cEN0eCxcbiAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WSxcbiAgICAgICAgc3VidHlwZTogZ3JvdXAuc21hc2suc3VidHlwZSxcbiAgICAgICAgYmFja2Ryb3A6IGdyb3VwLnNtYXNrLmJhY2tkcm9wLFxuICAgICAgICB0cmFuc2Zlck1hcDogZ3JvdXAuc21hc2sudHJhbnNmZXJNYXAgfHwgbnVsbCxcbiAgICAgICAgc3RhcnRUcmFuc2Zvcm1JbnZlcnNlOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFncm91cC5zbWFzayB8fCB0aGlzLmRlcGVuZGVuY3lUcmFja2VyKSB7XG4gICAgICBjdXJyZW50Q3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGN1cnJlbnRDdHgudHJhbnNsYXRlKG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgY3VycmVudEN0eC5zYXZlKCk7XG4gICAgfVxuICAgIGNvcHlDdHhTdGF0ZShjdXJyZW50Q3R4LCBncm91cEN0eCk7XG4gICAgdGhpcy5jdHggPSBncm91cEN0eDtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5pbmhlcml0U2ltcGxlRGF0YUFzRnV0dXJlRm9yY2VkRGVwZW5kZW5jaWVzKFtcImZpbGxBbHBoYVwiLCBcInN0cm9rZUFscGhhXCIsIFwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXCJdKS5wdXNoQmFzZVRyYW5zZm9ybShjdXJyZW50Q3R4KTtcbiAgICB0aGlzLnNldEdTdGF0ZShvcElkeCwgW1tcIkJNXCIsIFwic291cmNlLW92ZXJcIl0sIFtcImNhXCIsIDFdLCBbXCJDQVwiLCAxXV0pO1xuICAgIHRoaXMuZ3JvdXBTdGFjay5wdXNoKGN1cnJlbnRDdHgpO1xuICAgIHRoaXMuZ3JvdXBMZXZlbCsrO1xuICB9XG4gIGVuZEdyb3VwKG9wSWR4LCBncm91cCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmdyb3VwTGV2ZWwtLTtcbiAgICBjb25zdCBncm91cEN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuZ3JvdXBTdGFjay5wb3AoKTtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5wb3BCYXNlVHJhbnNmb3JtKCk7XG4gICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICB0aGlzLnRlbXBTTWFzayA9IHRoaXMuc21hc2tTdGFjay5wb3AoKTtcbiAgICAgIHRoaXMucmVzdG9yZShvcElkeCk7XG4gICAgICBpZiAodGhpcy5kZXBlbmRlbmN5VHJhY2tlcikge1xuICAgICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRNdHggPSBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMucmVzdG9yZShvcElkeCk7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oLi4uY3VycmVudE10eCk7XG4gICAgICBjb25zdCBkaXJ0eUJveCA9IE1JTl9NQVhfSU5JVC5zbGljZSgpO1xuICAgICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChbMCwgMCwgZ3JvdXBDdHguY2FudmFzLndpZHRoLCBncm91cEN0eC5jYW52YXMuaGVpZ2h0XSwgY3VycmVudE10eCwgZGlydHlCb3gpO1xuICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKGdyb3VwQ3R4LmNhbnZhcywgMCwgMCk7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLmNvbXBvc2UoZGlydHlCb3gpO1xuICAgIH1cbiAgfVxuICBiZWdpbkFubm90YXRpb24ob3BJZHgsIGlkLCByZWN0LCB0cmFuc2Zvcm0sIG1hdHJpeCwgaGFzT3duQ2FudmFzKSB7XG4gICAgdGhpcy4jcmVzdG9yZUluaXRpYWxTdGF0ZSgpO1xuICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgdGhpcy5zYXZlKG9wSWR4KTtcbiAgICBpZiAodGhpcy5iYXNlVHJhbnNmb3JtKSB7XG4gICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oLi4udGhpcy5iYXNlVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gcmVjdFsyXSAtIHJlY3RbMF07XG4gICAgICBjb25zdCBoZWlnaHQgPSByZWN0WzNdIC0gcmVjdFsxXTtcbiAgICAgIGlmIChoYXNPd25DYW52YXMgJiYgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwKSB7XG4gICAgICAgIHRyYW5zZm9ybSA9IHRyYW5zZm9ybS5zbGljZSgpO1xuICAgICAgICB0cmFuc2Zvcm1bNF0gLT0gcmVjdFswXTtcbiAgICAgICAgdHJhbnNmb3JtWzVdIC09IHJlY3RbMV07XG4gICAgICAgIHJlY3QgPSByZWN0LnNsaWNlKCk7XG4gICAgICAgIHJlY3RbMF0gPSByZWN0WzFdID0gMDtcbiAgICAgICAgcmVjdFsyXSA9IHdpZHRoO1xuICAgICAgICByZWN0WzNdID0gaGVpZ2h0O1xuICAgICAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpLCBYWSk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB2aWV3cG9ydFNjYWxlXG4gICAgICAgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBjYW52YXNXaWR0aCA9IE1hdGguY2VpbCh3aWR0aCAqIHRoaXMub3V0cHV0U2NhbGVYICogdmlld3BvcnRTY2FsZSk7XG4gICAgICAgIGNvbnN0IGNhbnZhc0hlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgKiB0aGlzLm91dHB1dFNjYWxlWSAqIHZpZXdwb3J0U2NhbGUpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25DYW52YXMgPSB0aGlzLmNhbnZhc0ZhY3RvcnkuY3JlYXRlKGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY2FudmFzLFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgfSA9IHRoaXMuYW5ub3RhdGlvbkNhbnZhcztcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwLnNldChpZCwgY2FudmFzKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzLnNhdmVkQ3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIHRoaXMuY3R4ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oWFlbMF0sIDAsIDAsIC1YWVsxXSwgMCwgaGVpZ2h0ICogWFlbMV0pO1xuICAgICAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgICAgIHRoaXMuZW5kUGF0aChvcElkeCk7XG4gICAgICAgIGNvbnN0IGNsaXAgPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgIGNsaXAucmVjdChyZWN0WzBdLCByZWN0WzFdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5jdHguY2xpcChjbGlwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jdXJyZW50ID0gbmV3IENhbnZhc0V4dHJhU3RhdGUodGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLnRyYW5zZm9ybShvcElkeCwgLi4udHJhbnNmb3JtKTtcbiAgICB0aGlzLnRyYW5zZm9ybShvcElkeCwgLi4ubWF0cml4KTtcbiAgfVxuICBlbmRBbm5vdGF0aW9uKG9wSWR4KSB7XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkNhbnZhcykge1xuICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy4jZHJhd0ZpbHRlcigpO1xuICAgICAgdGhpcy5jdHggPSB0aGlzLmFubm90YXRpb25DYW52YXMuc2F2ZWRDdHg7XG4gICAgICBkZWxldGUgdGhpcy5hbm5vdGF0aW9uQ2FudmFzLnNhdmVkQ3R4O1xuICAgICAgZGVsZXRlIHRoaXMuYW5ub3RhdGlvbkNhbnZhcztcbiAgICB9XG4gIH1cbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0KG9wSWR4LCBpbWcpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY291bnQgPSBpbWcuY291bnQ7XG4gICAgaW1nID0gdGhpcy5nZXRPYmplY3Qob3BJZHgsIGltZy5kYXRhLCBpbWcpO1xuICAgIGltZy5jb3VudCA9IGNvdW50O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG1hc2sgPSB0aGlzLl9jcmVhdGVNYXNrQ2FudmFzKG9wSWR4LCBpbWcpO1xuICAgIGNvbnN0IG1hc2tDYW52YXMgPSBtYXNrLmNhbnZhcztcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgY3R4LmRyYXdJbWFnZShtYXNrQ2FudmFzLCBtYXNrLm9mZnNldFgsIG1hc2sub2Zmc2V0WSk7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVzZXRCQm94KG9wSWR4KS5yZWNvcmRCQm94KG9wSWR4LCB0aGlzLmN0eCwgbWFzay5vZmZzZXRYLCBtYXNrLm9mZnNldFggKyBtYXNrQ2FudmFzLndpZHRoLCBtYXNrLm9mZnNldFksIG1hc2sub2Zmc2V0WSArIG1hc2tDYW52YXMuaGVpZ2h0KS5yZWNvcmRPcGVyYXRpb24ob3BJZHgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0KG9wSWR4LCBpbWcsIHNjYWxlWCwgc2tld1ggPSAwLCBza2V3WSA9IDAsIHNjYWxlWSwgcG9zaXRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGltZyA9IHRoaXMuZ2V0T2JqZWN0KG9wSWR4LCBpbWcuZGF0YSwgaW1nKTtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCk7XG4gICAgY3R4LnRyYW5zZm9ybShzY2FsZVgsIHNrZXdYLCBza2V3WSwgc2NhbGVZLCAwLCAwKTtcbiAgICBjb25zdCBtYXNrID0gdGhpcy5fY3JlYXRlTWFza0NhbnZhcyhvcElkeCwgaW1nKTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIG1hc2sub2Zmc2V0WCAtIGN1cnJlbnRUcmFuc2Zvcm1bNF0sIG1hc2sub2Zmc2V0WSAtIGN1cnJlbnRUcmFuc2Zvcm1bNV0pO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc2V0QkJveChvcElkeCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHRyYW5zID0gVXRpbC50cmFuc2Zvcm0oY3VycmVudFRyYW5zZm9ybSwgW3NjYWxlWCwgc2tld1gsIHNrZXdZLCBzY2FsZVksIHBvc2l0aW9uc1tpXSwgcG9zaXRpb25zW2kgKyAxXV0pO1xuICAgICAgY3R4LmRyYXdJbWFnZShtYXNrLmNhbnZhcywgdHJhbnNbNF0sIHRyYW5zWzVdKTtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZEJCb3gob3BJZHgsIHRoaXMuY3R4LCB0cmFuc1s0XSwgdHJhbnNbNF0gKyBtYXNrLmNhbnZhcy53aWR0aCwgdHJhbnNbNV0sIHRyYW5zWzVdICsgbWFzay5jYW52YXMuaGVpZ2h0KTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRPcGVyYXRpb24ob3BJZHgpO1xuICB9XG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwKG9wSWR4LCBpbWFnZXMpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjb25zdCBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc2V0QkJveChvcElkeCkucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBEZXBlbmRlbmNpZXMudHJhbnNmb3JtQW5kRmlsbCk7XG4gICAgZm9yIChjb25zdCBpbWFnZSBvZiBpbWFnZXMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgdHJhbnNmb3JtXG4gICAgICB9ID0gaW1hZ2U7XG4gICAgICBjb25zdCBtYXNrQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtYXNrQ2FudmFzXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgbWFza0N0eCA9IG1hc2tDYW52YXMuY29udGV4dDtcbiAgICAgIG1hc2tDdHguc2F2ZSgpO1xuICAgICAgY29uc3QgaW1nID0gdGhpcy5nZXRPYmplY3Qob3BJZHgsIGRhdGEsIGltYWdlKTtcbiAgICAgIHB1dEJpbmFyeUltYWdlTWFzayhtYXNrQ3R4LCBpbWcpO1xuICAgICAgbWFza0N0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1pblwiO1xuICAgICAgbWFza0N0eC5maWxsU3R5bGUgPSBpc1BhdHRlcm5GaWxsID8gZmlsbENvbG9yLmdldFBhdHRlcm4obWFza0N0eCwgdGhpcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSwgUGF0aFR5cGUuRklMTCkgOiBmaWxsQ29sb3I7XG4gICAgICBtYXNrQ3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgbWFza0N0eC5yZXN0b3JlKCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSguLi50cmFuc2Zvcm0pO1xuICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcbiAgICAgIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhjdHgsIG1hc2tDYW52YXMuY2FudmFzLCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCAwLCAtMSwgMSwgMSk7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRCQm94KG9wSWR4LCBjdHgsIDAsIHdpZHRoLCAwLCBoZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkT3BlcmF0aW9uKG9wSWR4KTtcbiAgfVxuICBwYWludEltYWdlWE9iamVjdChvcElkeCwgb2JqSWQpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW1nRGF0YSA9IHRoaXMuZ2V0T2JqZWN0KG9wSWR4LCBvYmpJZCk7XG4gICAgaWYgKCFpbWdEYXRhKSB7XG4gICAgICB3YXJuKFwiRGVwZW5kZW50IGltYWdlIGlzbid0IHJlYWR5IHlldFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdChvcElkeCwgaW1nRGF0YSk7XG4gIH1cbiAgcGFpbnRJbWFnZVhPYmplY3RSZXBlYXQob3BJZHgsIG9iaklkLCBzY2FsZVgsIHNjYWxlWSwgcG9zaXRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGltZ0RhdGEgPSB0aGlzLmdldE9iamVjdChvcElkeCwgb2JqSWQpO1xuICAgIGlmICghaW1nRGF0YSkge1xuICAgICAgd2FybihcIkRlcGVuZGVudCBpbWFnZSBpc24ndCByZWFkeSB5ZXRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICBjb25zdCBtYXAgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgbWFwLnB1c2goe1xuICAgICAgICB0cmFuc2Zvcm06IFtzY2FsZVgsIDAsIDAsIHNjYWxlWSwgcG9zaXRpb25zW2ldLCBwb3NpdGlvbnNbaSArIDFdXSxcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgdzogd2lkdGgsXG4gICAgICAgIGg6IGhlaWdodFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cChvcElkeCwgaW1nRGF0YSwgbWFwKTtcbiAgfVxuICBhcHBseVRyYW5zZmVyTWFwc1RvQ2FudmFzKGN0eCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzICE9PSBcIm5vbmVcIikge1xuICAgICAgY3R4LmZpbHRlciA9IHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHM7XG4gICAgICBjdHguZHJhd0ltYWdlKGN0eC5jYW52YXMsIDAsIDApO1xuICAgICAgY3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICAgIH1cbiAgICByZXR1cm4gY3R4LmNhbnZhcztcbiAgfVxuICBhcHBseVRyYW5zZmVyTWFwc1RvQml0bWFwKGltZ0RhdGEpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyA9PT0gXCJub25lXCIpIHtcbiAgICAgIHJldHVybiBpbWdEYXRhLmJpdG1hcDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYml0bWFwLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gaW1nRGF0YTtcbiAgICBjb25zdCB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlubGluZUltYWdlXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgIHRtcEN0eC5maWx0ZXIgPSB0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzO1xuICAgIHRtcEN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwKTtcbiAgICB0bXBDdHguZmlsdGVyID0gXCJub25lXCI7XG4gICAgcmV0dXJuIHRtcENhbnZhcy5jYW52YXM7XG4gIH1cbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3Qob3BJZHgsIGltZ0RhdGEpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIHRoaXMuc2F2ZShvcElkeCk7XG4gICAgY29uc3Qge1xuICAgICAgZmlsdGVyXG4gICAgfSA9IGN0eDtcbiAgICBpZiAoZmlsdGVyICE9PSBcIm5vbmVcIiAmJiBmaWx0ZXIgIT09IFwiXCIpIHtcbiAgICAgIGN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgICB9XG4gICAgY3R4LnNjYWxlKDEgLyB3aWR0aCwgLTEgLyBoZWlnaHQpO1xuICAgIGxldCBpbWdUb1BhaW50O1xuICAgIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgICAgaW1nVG9QYWludCA9IHRoaXMuYXBwbHlUcmFuc2Zlck1hcHNUb0JpdG1hcChpbWdEYXRhKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gXCJmdW5jdGlvblwiICYmIGltZ0RhdGEgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCAhaW1nRGF0YS5kYXRhKSB7XG4gICAgICBpbWdUb1BhaW50ID0gaW1nRGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpbmxpbmVJbWFnZVwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgcHV0QmluYXJ5SW1hZ2VEYXRhKHRtcEN0eCwgaW1nRGF0YSk7XG4gICAgICBpbWdUb1BhaW50ID0gdGhpcy5hcHBseVRyYW5zZmVyTWFwc1RvQ2FudmFzKHRtcEN0eCk7XG4gICAgfVxuICAgIGNvbnN0IHNjYWxlZCA9IHRoaXMuX3NjYWxlSW1hZ2UoaW1nVG9QYWludCwgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSk7XG4gICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGdldEltYWdlU21vb3RoaW5nRW5hYmxlZChnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCksIGltZ0RhdGEuaW50ZXJwb2xhdGUpO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc2V0QkJveChvcElkeCkucmVjb3JkQkJveChvcElkeCwgY3R4LCAwLCB3aWR0aCwgLWhlaWdodCwgMCkucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBEZXBlbmRlbmNpZXMuaW1hZ2VYT2JqZWN0KS5yZWNvcmRPcGVyYXRpb24ob3BJZHgpO1xuICAgIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhjdHgsIHNjYWxlZC5pbWcsIDAsIDAsIHNjYWxlZC5wYWludFdpZHRoLCBzY2FsZWQucGFpbnRIZWlnaHQsIDAsIC1oZWlnaHQsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICAgIHRoaXMucmVzdG9yZShvcElkeCk7XG4gIH1cbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cChvcElkeCwgaW1nRGF0YSwgbWFwKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGxldCBpbWdUb1BhaW50O1xuICAgIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgICAgaW1nVG9QYWludCA9IGltZ0RhdGEuYml0bWFwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3ID0gaW1nRGF0YS53aWR0aDtcbiAgICAgIGNvbnN0IGggPSBpbWdEYXRhLmhlaWdodDtcbiAgICAgIGNvbnN0IHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiaW5saW5lSW1hZ2VcIiwgdywgaCk7XG4gICAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHB1dEJpbmFyeUltYWdlRGF0YSh0bXBDdHgsIGltZ0RhdGEpO1xuICAgICAgaW1nVG9QYWludCA9IHRoaXMuYXBwbHlUcmFuc2Zlck1hcHNUb0NhbnZhcyh0bXBDdHgpO1xuICAgIH1cbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZXNldEJCb3gob3BJZHgpO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgbWFwKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSguLi5lbnRyeS50cmFuc2Zvcm0pO1xuICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcbiAgICAgIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhjdHgsIGltZ1RvUGFpbnQsIGVudHJ5LngsIGVudHJ5LnksIGVudHJ5LncsIGVudHJ5LmgsIDAsIC0xLCAxLCAxKTtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZEJCb3gob3BJZHgsIGN0eCwgMCwgMSwgLTEsIDApO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkT3BlcmF0aW9uKG9wSWR4KTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuICBwYWludFNvbGlkQ29sb3JJbWFnZU1hc2sob3BJZHgpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVzZXRCQm94KG9wSWR4KS5yZWNvcmRCQm94KG9wSWR4LCB0aGlzLmN0eCwgMCwgMSwgMCwgMSkucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBEZXBlbmRlbmNpZXMuZmlsbCkucmVjb3JkT3BlcmF0aW9uKG9wSWR4KTtcbiAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuICBtYXJrUG9pbnQob3BJZHgsIHRhZykge31cbiAgbWFya1BvaW50UHJvcHMob3BJZHgsIHRhZywgcHJvcGVydGllcykge31cbiAgYmVnaW5NYXJrZWRDb250ZW50KG9wSWR4LCB0YWcpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5iZWdpbk1hcmtlZENvbnRlbnQob3BJZHgpO1xuICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnB1c2goe1xuICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGJlZ2luTWFya2VkQ29udGVudFByb3BzKG9wSWR4LCB0YWcsIHByb3BlcnRpZXMpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5iZWdpbk1hcmtlZENvbnRlbnQob3BJZHgpO1xuICAgIGlmICh0YWcgPT09IFwiT0NcIikge1xuICAgICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucHVzaCh7XG4gICAgICAgIHZpc2libGU6IHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnLmlzVmlzaWJsZShwcm9wZXJ0aWVzKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnB1c2goe1xuICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5jb250ZW50VmlzaWJsZSA9IHRoaXMuaXNDb250ZW50VmlzaWJsZSgpO1xuICB9XG4gIGVuZE1hcmtlZENvbnRlbnQob3BJZHgpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5lbmRNYXJrZWRDb250ZW50KG9wSWR4KTtcbiAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wb3AoKTtcbiAgICB0aGlzLmNvbnRlbnRWaXNpYmxlID0gdGhpcy5pc0NvbnRlbnRWaXNpYmxlKCk7XG4gIH1cbiAgYmVnaW5Db21wYXQob3BJZHgpIHt9XG4gIGVuZENvbXBhdChvcElkeCkge31cbiAgY29uc3VtZVBhdGgob3BJZHgsIHBhdGgsIGNsaXBCb3gpIHtcbiAgICBjb25zdCBpc0VtcHR5ID0gdGhpcy5jdXJyZW50LmlzRW1wdHlDbGlwKCk7XG4gICAgaWYgKHRoaXMucGVuZGluZ0NsaXApIHtcbiAgICAgIHRoaXMuY3VycmVudC51cGRhdGVDbGlwRnJvbVBhdGgoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnBlbmRpbmdDbGlwKSB7XG4gICAgICB0aGlzLmNvbXBvc2UoY2xpcEJveCk7XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGlmICh0aGlzLnBlbmRpbmdDbGlwKSB7XG4gICAgICBpZiAoIWlzRW1wdHkpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NsaXAgPT09IEVPX0NMSVApIHtcbiAgICAgICAgICBjdHguY2xpcChwYXRoLCBcImV2ZW5vZGRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LmNsaXAocGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8uYmJveFRvQ2xpcEJveERyb3BPcGVyYXRpb24ob3BJZHgpLnJlY29yZEZ1dHVyZUZvcmNlZERlcGVuZGVuY3koXCJjbGlwUGF0aFwiLCBvcElkeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZE9wZXJhdGlvbihvcElkeCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5zdGFydE5ld1BhdGhBbmRDbGlwQm94KHRoaXMuY3VycmVudC5jbGlwQm94KTtcbiAgfVxuICBnZXRTaW5nbGVQaXhlbFdpZHRoKCkge1xuICAgIGlmICghdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCkge1xuICAgICAgY29uc3QgbSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpO1xuICAgICAgaWYgKG1bMV0gPT09IDAgJiYgbVsyXSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gMSAvIE1hdGgubWluKE1hdGguYWJzKG1bMF0pLCBNYXRoLmFicyhtWzNdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhYnNEZXQgPSBNYXRoLmFicyhtWzBdICogbVszXSAtIG1bMl0gKiBtWzFdKTtcbiAgICAgICAgY29uc3Qgbm9ybVggPSBNYXRoLmh5cG90KG1bMF0sIG1bMl0pO1xuICAgICAgICBjb25zdCBub3JtWSA9IE1hdGguaHlwb3QobVsxXSwgbVszXSk7XG4gICAgICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBNYXRoLm1heChub3JtWCwgbm9ybVkpIC8gYWJzRGV0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aDtcbiAgfVxuICBnZXRTY2FsZUZvclN0cm9raW5nKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID09PSAtMSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsaW5lV2lkdGhcbiAgICAgIH0gPSB0aGlzLmN1cnJlbnQ7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGEsXG4gICAgICAgIGIsXG4gICAgICAgIGMsXG4gICAgICAgIGRcbiAgICAgIH0gPSB0aGlzLmN0eC5nZXRUcmFuc2Zvcm0oKTtcbiAgICAgIGxldCBzY2FsZVgsIHNjYWxlWTtcbiAgICAgIGlmIChiID09PSAwICYmIGMgPT09IDApIHtcbiAgICAgICAgY29uc3Qgbm9ybVggPSBNYXRoLmFicyhhKTtcbiAgICAgICAgY29uc3Qgbm9ybVkgPSBNYXRoLmFicyhkKTtcbiAgICAgICAgaWYgKG5vcm1YID09PSBub3JtWSkge1xuICAgICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIHNjYWxlWCA9IHNjYWxlWSA9IDEgLyBub3JtWDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVkTGluZVdpZHRoID0gbm9ybVggKiBsaW5lV2lkdGg7XG4gICAgICAgICAgICBzY2FsZVggPSBzY2FsZVkgPSBzY2FsZWRMaW5lV2lkdGggPCAxID8gMSAvIHNjYWxlZExpbmVXaWR0aCA6IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgIHNjYWxlWCA9IDEgLyBub3JtWDtcbiAgICAgICAgICBzY2FsZVkgPSAxIC8gbm9ybVk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgc2NhbGVkWExpbmVXaWR0aCA9IG5vcm1YICogbGluZVdpZHRoO1xuICAgICAgICAgIGNvbnN0IHNjYWxlZFlMaW5lV2lkdGggPSBub3JtWSAqIGxpbmVXaWR0aDtcbiAgICAgICAgICBzY2FsZVggPSBzY2FsZWRYTGluZVdpZHRoIDwgMSA/IDEgLyBzY2FsZWRYTGluZVdpZHRoIDogMTtcbiAgICAgICAgICBzY2FsZVkgPSBzY2FsZWRZTGluZVdpZHRoIDwgMSA/IDEgLyBzY2FsZWRZTGluZVdpZHRoIDogMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYWJzRGV0ID0gTWF0aC5hYnMoYSAqIGQgLSBiICogYyk7XG4gICAgICAgIGNvbnN0IG5vcm1YID0gTWF0aC5oeXBvdChhLCBiKTtcbiAgICAgICAgY29uc3Qgbm9ybVkgPSBNYXRoLmh5cG90KGMsIGQpO1xuICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgc2NhbGVYID0gbm9ybVkgLyBhYnNEZXQ7XG4gICAgICAgICAgc2NhbGVZID0gbm9ybVggLyBhYnNEZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgYmFzZUFyZWEgPSBsaW5lV2lkdGggKiBhYnNEZXQ7XG4gICAgICAgICAgc2NhbGVYID0gbm9ybVkgPiBiYXNlQXJlYSA/IG5vcm1ZIC8gYmFzZUFyZWEgOiAxO1xuICAgICAgICAgIHNjYWxlWSA9IG5vcm1YID4gYmFzZUFyZWEgPyBub3JtWCAvIGJhc2VBcmVhIDogMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IHNjYWxlWDtcbiAgICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMV0gPSBzY2FsZVk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nO1xuICB9XG4gIHJlc2NhbGVBbmRTdHJva2UocGF0aCwgc2F2ZVJlc3RvcmUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdHgsXG4gICAgICBjdXJyZW50OiB7XG4gICAgICAgIGxpbmVXaWR0aFxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IFtzY2FsZVgsIHNjYWxlWV0gPSB0aGlzLmdldFNjYWxlRm9yU3Ryb2tpbmcoKTtcbiAgICBpZiAoc2NhbGVYID09PSBzY2FsZVkpIHtcbiAgICAgIGN0eC5saW5lV2lkdGggPSAobGluZVdpZHRoIHx8IDEpICogc2NhbGVYO1xuICAgICAgY3R4LnN0cm9rZShwYXRoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGFzaGVzID0gY3R4LmdldExpbmVEYXNoKCk7XG4gICAgaWYgKHNhdmVSZXN0b3JlKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgIH1cbiAgICBjdHguc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgIFNDQUxFX01BVFJJWC5hID0gMSAvIHNjYWxlWDtcbiAgICBTQ0FMRV9NQVRSSVguZCA9IDEgLyBzY2FsZVk7XG4gICAgY29uc3QgbmV3UGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICBuZXdQYXRoLmFkZFBhdGgocGF0aCwgU0NBTEVfTUFUUklYKTtcbiAgICBpZiAoZGFzaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHNjYWxlID0gTWF0aC5tYXgoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hlcy5tYXAoeCA9PiB4IC8gc2NhbGUpKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCAvPSBzY2FsZTtcbiAgICB9XG4gICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aCB8fCAxO1xuICAgIGN0eC5zdHJva2UobmV3UGF0aCk7XG4gICAgaWYgKHNhdmVSZXN0b3JlKSB7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBpc0NvbnRlbnRWaXNpYmxlKCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKCF0aGlzLm1hcmtlZENvbnRlbnRTdGFja1tpXS52aXNpYmxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmZvciAoY29uc3Qgb3AgaW4gT1BTKSB7XG4gIGlmIChDYW52YXNHcmFwaGljcy5wcm90b3R5cGVbb3BdICE9PSB1bmRlZmluZWQpIHtcbiAgICBDYW52YXNHcmFwaGljcy5wcm90b3R5cGVbT1BTW29wXV0gPSBDYW52YXNHcmFwaGljcy5wcm90b3R5cGVbb3BdO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3dvcmtlcl9vcHRpb25zLmpzXG5jbGFzcyBHbG9iYWxXb3JrZXJPcHRpb25zIHtcbiAgc3RhdGljICNwb3J0ID0gbnVsbDtcbiAgc3RhdGljICNzcmMgPSBcIlwiO1xuICBzdGF0aWMgZ2V0IHdvcmtlclBvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3BvcnQ7XG4gIH1cbiAgc3RhdGljIHNldCB3b3JrZXJQb3J0KHZhbCkge1xuICAgIGlmICghKHR5cGVvZiBXb3JrZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgdmFsIGluc3RhbmNlb2YgV29ya2VyKSAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYHdvcmtlclBvcnRgIHR5cGUuXCIpO1xuICAgIH1cbiAgICB0aGlzLiNwb3J0ID0gdmFsO1xuICB9XG4gIHN0YXRpYyBnZXQgd29ya2VyU3JjKCkge1xuICAgIHJldHVybiB0aGlzLiNzcmM7XG4gIH1cbiAgc3RhdGljIHNldCB3b3JrZXJTcmModmFsKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYHdvcmtlclNyY2AgdHlwZS5cIik7XG4gICAgfVxuICAgIHRoaXMuI3NyYyA9IHZhbDtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9tZXRhZGF0YS5qc1xuY2xhc3MgTWV0YWRhdGEge1xuICAjbWFwO1xuICAjZGF0YTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHBhcnNlZERhdGEsXG4gICAgcmF3RGF0YVxuICB9KSB7XG4gICAgdGhpcy4jbWFwID0gcGFyc2VkRGF0YTtcbiAgICB0aGlzLiNkYXRhID0gcmF3RGF0YTtcbiAgfVxuICBnZXRSYXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RhdGE7XG4gIH1cbiAgZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy4jbWFwLmdldChuYW1lKSA/PyBudWxsO1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLiNtYXAuZW50cmllcygpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L29wdGlvbmFsX2NvbnRlbnRfY29uZmlnLmpzXG5cblxuY29uc3QgSU5URVJOQUwgPSBTeW1ib2woXCJJTlRFUk5BTFwiKTtcbmNsYXNzIE9wdGlvbmFsQ29udGVudEdyb3VwIHtcbiAgI2lzRGlzcGxheSA9IGZhbHNlO1xuICAjaXNQcmludCA9IGZhbHNlO1xuICAjdXNlclNldCA9IGZhbHNlO1xuICAjdmlzaWJsZSA9IHRydWU7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmluZ0ludGVudCwge1xuICAgIG5hbWUsXG4gICAgaW50ZW50LFxuICAgIHVzYWdlLFxuICAgIHJiR3JvdXBzXG4gIH0pIHtcbiAgICB0aGlzLiNpc0Rpc3BsYXkgPSAhIShyZW5kZXJpbmdJbnRlbnQgJiBSZW5kZXJpbmdJbnRlbnRGbGFnLkRJU1BMQVkpO1xuICAgIHRoaXMuI2lzUHJpbnQgPSAhIShyZW5kZXJpbmdJbnRlbnQgJiBSZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuaW50ZW50ID0gaW50ZW50O1xuICAgIHRoaXMudXNhZ2UgPSB1c2FnZTtcbiAgICB0aGlzLnJiR3JvdXBzID0gcmJHcm91cHM7XG4gIH1cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgaWYgKHRoaXMuI3VzZXJTZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLiN2aXNpYmxlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI3Zpc2libGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcHJpbnQsXG4gICAgICB2aWV3XG4gICAgfSA9IHRoaXMudXNhZ2U7XG4gICAgaWYgKHRoaXMuI2lzRGlzcGxheSkge1xuICAgICAgcmV0dXJuIHZpZXc/LnZpZXdTdGF0ZSAhPT0gXCJPRkZcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI2lzUHJpbnQpIHtcbiAgICAgIHJldHVybiBwcmludD8ucHJpbnRTdGF0ZSAhPT0gXCJPRkZcIjtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgX3NldFZpc2libGUoaW50ZXJuYWwsIHZpc2libGUsIHVzZXJTZXQgPSBmYWxzZSkge1xuICAgIGlmIChpbnRlcm5hbCAhPT0gSU5URVJOQUwpIHtcbiAgICAgIHVucmVhY2hhYmxlKFwiSW50ZXJuYWwgbWV0aG9kIGBfc2V0VmlzaWJsZWAgY2FsbGVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy4jdXNlclNldCA9IHVzZXJTZXQ7XG4gICAgdGhpcy4jdmlzaWJsZSA9IHZpc2libGU7XG4gIH1cbn1cbmNsYXNzIE9wdGlvbmFsQ29udGVudENvbmZpZyB7XG4gICNjYWNoZWRHZXRIYXNoID0gbnVsbDtcbiAgI2dyb3VwcyA9IG5ldyBNYXAoKTtcbiAgI2luaXRpYWxIYXNoID0gbnVsbDtcbiAgI29yZGVyID0gbnVsbDtcbiAgY29uc3RydWN0b3IoZGF0YSwgcmVuZGVyaW5nSW50ZW50ID0gUmVuZGVyaW5nSW50ZW50RmxhZy5ESVNQTEFZKSB7XG4gICAgdGhpcy5yZW5kZXJpbmdJbnRlbnQgPSByZW5kZXJpbmdJbnRlbnQ7XG4gICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICB0aGlzLmNyZWF0b3IgPSBudWxsO1xuICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubmFtZSA9IGRhdGEubmFtZTtcbiAgICB0aGlzLmNyZWF0b3IgPSBkYXRhLmNyZWF0b3I7XG4gICAgdGhpcy4jb3JkZXIgPSBkYXRhLm9yZGVyO1xuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgZGF0YS5ncm91cHMpIHtcbiAgICAgIHRoaXMuI2dyb3Vwcy5zZXQoZ3JvdXAuaWQsIG5ldyBPcHRpb25hbENvbnRlbnRHcm91cChyZW5kZXJpbmdJbnRlbnQsIGdyb3VwKSk7XG4gICAgfVxuICAgIGlmIChkYXRhLmJhc2VTdGF0ZSA9PT0gXCJPRkZcIikge1xuICAgICAgZm9yIChjb25zdCBncm91cCBvZiB0aGlzLiNncm91cHMudmFsdWVzKCkpIHtcbiAgICAgICAgZ3JvdXAuX3NldFZpc2libGUoSU5URVJOQUwsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBvbiBvZiBkYXRhLm9uKSB7XG4gICAgICB0aGlzLiNncm91cHMuZ2V0KG9uKS5fc2V0VmlzaWJsZShJTlRFUk5BTCwgdHJ1ZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb2ZmIG9mIGRhdGEub2ZmKSB7XG4gICAgICB0aGlzLiNncm91cHMuZ2V0KG9mZikuX3NldFZpc2libGUoSU5URVJOQUwsIGZhbHNlKTtcbiAgICB9XG4gICAgdGhpcy4jaW5pdGlhbEhhc2ggPSB0aGlzLmdldEhhc2goKTtcbiAgfVxuICAjZXZhbHVhdGVWaXNpYmlsaXR5RXhwcmVzc2lvbihhcnJheSkge1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IG9wZXJhdG9yID0gYXJyYXlbMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2ldO1xuICAgICAgbGV0IHN0YXRlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudCkpIHtcbiAgICAgICAgc3RhdGUgPSB0aGlzLiNldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLiNncm91cHMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgIHN0YXRlID0gdGhpcy4jZ3JvdXBzLmdldChlbGVtZW50KS52aXNpYmxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7ZWxlbWVudH1gKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgXCJBbmRcIjpcbiAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiT3JcIjpcbiAgICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk5vdFwiOlxuICAgICAgICAgIHJldHVybiAhc3RhdGU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcGVyYXRvciA9PT0gXCJBbmRcIjtcbiAgfVxuICBpc1Zpc2libGUoZ3JvdXApIHtcbiAgICBpZiAodGhpcy4jZ3JvdXBzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWdyb3VwKSB7XG4gICAgICBpbmZvKFwiT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZGVmaW5lZC5cIik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGdyb3VwLnR5cGUgPT09IFwiT0NHXCIpIHtcbiAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhncm91cC5pZCkpIHtcbiAgICAgICAgd2FybihgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7Z3JvdXAuaWR9YCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuI2dyb3Vwcy5nZXQoZ3JvdXAuaWQpLnZpc2libGU7XG4gICAgfSBlbHNlIGlmIChncm91cC50eXBlID09PSBcIk9DTURcIikge1xuICAgICAgaWYgKGdyb3VwLmV4cHJlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2V2YWx1YXRlVmlzaWJpbGl0eUV4cHJlc3Npb24oZ3JvdXAuZXhwcmVzc2lvbik7XG4gICAgICB9XG4gICAgICBpZiAoIWdyb3VwLnBvbGljeSB8fCBncm91cC5wb2xpY3kgPT09IFwiQW55T25cIikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGdyb3VwLmlkcykge1xuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLiNncm91cHMuZ2V0KGlkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChncm91cC5wb2xpY3kgPT09IFwiQWxsT25cIikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGdyb3VwLmlkcykge1xuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAucG9saWN5ID09PSBcIkFueU9mZlwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgd2FybihgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuZ2V0KGlkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChncm91cC5wb2xpY3kgPT09IFwiQWxsT2ZmXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBncm91cC5pZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy4jZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHdhcm4oYFVua25vd24gb3B0aW9uYWwgY29udGVudCBwb2xpY3kgJHtncm91cC5wb2xpY3l9LmApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHdhcm4oYFVua25vd24gZ3JvdXAgdHlwZSAke2dyb3VwLnR5cGV9LmApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHNldFZpc2liaWxpdHkoaWQsIHZpc2libGUgPSB0cnVlLCBwcmVzZXJ2ZVJCID0gdHJ1ZSkge1xuICAgIGNvbnN0IGdyb3VwID0gdGhpcy4jZ3JvdXBzLmdldChpZCk7XG4gICAgaWYgKCFncm91cCkge1xuICAgICAgd2FybihgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcmVzZXJ2ZVJCICYmIHZpc2libGUgJiYgZ3JvdXAucmJHcm91cHMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGNvbnN0IHJiR3JvdXAgb2YgZ3JvdXAucmJHcm91cHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBvdGhlcklkIG9mIHJiR3JvdXApIHtcbiAgICAgICAgICBpZiAob3RoZXJJZCAhPT0gaWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2dyb3Vwcy5nZXQob3RoZXJJZCk/Ll9zZXRWaXNpYmxlKElOVEVSTkFMLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGdyb3VwLl9zZXRWaXNpYmxlKElOVEVSTkFMLCAhIXZpc2libGUsIHRydWUpO1xuICAgIHRoaXMuI2NhY2hlZEdldEhhc2ggPSBudWxsO1xuICB9XG4gIHNldE9DR1N0YXRlKHtcbiAgICBzdGF0ZSxcbiAgICBwcmVzZXJ2ZVJCXG4gIH0pIHtcbiAgICBsZXQgb3BlcmF0b3I7XG4gICAgZm9yIChjb25zdCBlbGVtIG9mIHN0YXRlKSB7XG4gICAgICBzd2l0Y2ggKGVsZW0pIHtcbiAgICAgICAgY2FzZSBcIk9OXCI6XG4gICAgICAgIGNhc2UgXCJPRkZcIjpcbiAgICAgICAgY2FzZSBcIlRvZ2dsZVwiOlxuICAgICAgICAgIG9wZXJhdG9yID0gZWxlbTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdyb3VwID0gdGhpcy4jZ3JvdXBzLmdldChlbGVtKTtcbiAgICAgIGlmICghZ3JvdXApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgXCJPTlwiOlxuICAgICAgICAgIHRoaXMuc2V0VmlzaWJpbGl0eShlbGVtLCB0cnVlLCBwcmVzZXJ2ZVJCKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk9GRlwiOlxuICAgICAgICAgIHRoaXMuc2V0VmlzaWJpbGl0eShlbGVtLCBmYWxzZSwgcHJlc2VydmVSQik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJUb2dnbGVcIjpcbiAgICAgICAgICB0aGlzLnNldFZpc2liaWxpdHkoZWxlbSwgIWdyb3VwLnZpc2libGUsIHByZXNlcnZlUkIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNjYWNoZWRHZXRIYXNoID0gbnVsbDtcbiAgfVxuICBnZXQgaGFzSW5pdGlhbFZpc2liaWxpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2luaXRpYWxIYXNoID09PSBudWxsIHx8IHRoaXMuZ2V0SGFzaCgpID09PSB0aGlzLiNpbml0aWFsSGFzaDtcbiAgfVxuICBnZXRPcmRlcigpIHtcbiAgICBpZiAoIXRoaXMuI2dyb3Vwcy5zaXplKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuI29yZGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy4jb3JkZXIuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIFsuLi50aGlzLiNncm91cHMua2V5cygpXTtcbiAgfVxuICBnZXRHcm91cChpZCkge1xuICAgIHJldHVybiB0aGlzLiNncm91cHMuZ2V0KGlkKSB8fCBudWxsO1xuICB9XG4gIGdldEhhc2goKSB7XG4gICAgaWYgKHRoaXMuI2NhY2hlZEdldEhhc2ggIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLiNjYWNoZWRHZXRIYXNoO1xuICAgIH1cbiAgICBjb25zdCBoYXNoID0gbmV3IE11cm11ckhhc2gzXzY0KCk7XG4gICAgZm9yIChjb25zdCBbaWQsIGdyb3VwXSBvZiB0aGlzLiNncm91cHMpIHtcbiAgICAgIGhhc2gudXBkYXRlKGAke2lkfToke2dyb3VwLnZpc2libGV9YCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNjYWNoZWRHZXRIYXNoID0gaGFzaC5oZXhkaWdlc3QoKTtcbiAgfVxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZ3JvdXBzLmVudHJpZXMoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS90cmFuc3BvcnRfc3RyZWFtLmpzXG5cblxuY2xhc3MgUERGRGF0YVRyYW5zcG9ydFN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHBkZkRhdGFSYW5nZVRyYW5zcG9ydCwge1xuICAgIGRpc2FibGVSYW5nZSA9IGZhbHNlLFxuICAgIGRpc2FibGVTdHJlYW0gPSBmYWxzZVxuICB9KSB7XG4gICAgYXNzZXJ0KHBkZkRhdGFSYW5nZVRyYW5zcG9ydCwgJ1BERkRhdGFUcmFuc3BvcnRTdHJlYW0gLSBtaXNzaW5nIHJlcXVpcmVkIFwicGRmRGF0YVJhbmdlVHJhbnNwb3J0XCIgYXJndW1lbnQuJyk7XG4gICAgY29uc3Qge1xuICAgICAgbGVuZ3RoLFxuICAgICAgaW5pdGlhbERhdGEsXG4gICAgICBwcm9ncmVzc2l2ZURvbmUsXG4gICAgICBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZVxuICAgIH0gPSBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQ7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmtzID0gW107XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lID0gcHJvZ3Jlc3NpdmVEb25lO1xuICAgIHRoaXMuX2NvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU7XG4gICAgaWYgKGluaXRpYWxEYXRhPy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBpbml0aWFsRGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgaW5pdGlhbERhdGEuYnl0ZUxlbmd0aCA9PT0gaW5pdGlhbERhdGEuYnVmZmVyLmJ5dGVMZW5ndGggPyBpbml0aWFsRGF0YS5idWZmZXIgOiBuZXcgVWludDhBcnJheShpbml0aWFsRGF0YSkuYnVmZmVyO1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmtzLnB1c2goYnVmZmVyKTtcbiAgICB9XG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0ID0gcGRmRGF0YVJhbmdlVHJhbnNwb3J0O1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIWRpc2FibGVTdHJlYW07XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9ICFkaXNhYmxlUmFuZ2U7XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IGxlbmd0aDtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZWFkZXJzID0gW107XG4gICAgcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFkZFJhbmdlTGlzdGVuZXIoKGJlZ2luLCBjaHVuaykgPT4ge1xuICAgICAgdGhpcy5fb25SZWNlaXZlRGF0YSh7XG4gICAgICAgIGJlZ2luLFxuICAgICAgICBjaHVua1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFkZFByb2dyZXNzTGlzdGVuZXIoKGxvYWRlZCwgdG90YWwpID0+IHtcbiAgICAgIHRoaXMuX29uUHJvZ3Jlc3Moe1xuICAgICAgICBsb2FkZWQsXG4gICAgICAgIHRvdGFsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXIoY2h1bmsgPT4ge1xuICAgICAgdGhpcy5fb25SZWNlaXZlRGF0YSh7XG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgdGhpcy5fb25Qcm9ncmVzc2l2ZURvbmUoKTtcbiAgICB9KTtcbiAgICBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQudHJhbnNwb3J0UmVhZHkoKTtcbiAgfVxuICBfb25SZWNlaXZlRGF0YSh7XG4gICAgYmVnaW4sXG4gICAgY2h1bmtcbiAgfSkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGNodW5rIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBjaHVuay5ieXRlTGVuZ3RoID09PSBjaHVuay5idWZmZXIuYnl0ZUxlbmd0aCA/IGNodW5rLmJ1ZmZlciA6IG5ldyBVaW50OEFycmF5KGNodW5rKS5idWZmZXI7XG4gICAgaWYgKGJlZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcikge1xuICAgICAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlci5fZW5xdWV1ZShidWZmZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcXVldWVkQ2h1bmtzLnB1c2goYnVmZmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZm91bmQgPSB0aGlzLl9yYW5nZVJlYWRlcnMuc29tZShmdW5jdGlvbiAocmFuZ2VSZWFkZXIpIHtcbiAgICAgICAgaWYgKHJhbmdlUmVhZGVyLl9iZWdpbiAhPT0gYmVnaW4pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ2VSZWFkZXIuX2VucXVldWUoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICAgIGFzc2VydChmb3VuZCwgXCJfb25SZWNlaXZlRGF0YSAtIG5vIGBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXJgIGluc3RhbmNlIGZvdW5kLlwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0IF9wcm9ncmVzc2l2ZURhdGFMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5fbG9hZGVkID8/IDA7XG4gIH1cbiAgX29uUHJvZ3Jlc3MoZXZ0KSB7XG4gICAgaWYgKGV2dC50b3RhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9yYW5nZVJlYWRlcnNbMF0/Lm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICAgIHRvdGFsOiBldnQudG90YWxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfb25Qcm9ncmVzc2l2ZURvbmUoKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LnByb2dyZXNzaXZlRG9uZSgpO1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlRG9uZSA9IHRydWU7XG4gIH1cbiAgX3JlbW92ZVJhbmdlUmVhZGVyKHJlYWRlcikge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9yYW5nZVJlYWRlcnMuaW5kZXhPZihyZWFkZXIpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRoaXMuX3JhbmdlUmVhZGVycy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgYXNzZXJ0KCF0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciwgXCJQREZEYXRhVHJhbnNwb3J0U3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgIGNvbnN0IHF1ZXVlZENodW5rcyA9IHRoaXMuX3F1ZXVlZENodW5rcztcbiAgICB0aGlzLl9xdWV1ZWRDaHVua3MgPSBudWxsO1xuICAgIHJldHVybiBuZXcgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJlYWRlcih0aGlzLCBxdWV1ZWRDaHVua3MsIHRoaXMuX3Byb2dyZXNzaXZlRG9uZSwgdGhpcy5fY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUpO1xuICB9XG4gIGdldFJhbmdlUmVhZGVyKGJlZ2luLCBlbmQpIHtcbiAgICBpZiAoZW5kIDw9IHRoaXMuX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXIodGhpcywgYmVnaW4sIGVuZCk7XG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LnJlcXVlc3REYXRhUmFuZ2UoYmVnaW4sIGVuZCk7XG4gICAgdGhpcy5fcmFuZ2VSZWFkZXJzLnB1c2gocmVhZGVyKTtcbiAgICByZXR1cm4gcmVhZGVyO1xuICB9XG4gIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiB0aGlzLl9yYW5nZVJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFib3J0KCk7XG4gIH1cbn1cbmNsYXNzIFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIHF1ZXVlZENodW5rcywgcHJvZ3Jlc3NpdmVEb25lID0gZmFsc2UsIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gbnVsbCkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9kb25lID0gcHJvZ3Jlc3NpdmVEb25lIHx8IGZhbHNlO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gaXNQZGZGaWxlKGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lKSA/IGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lIDogbnVsbDtcbiAgICB0aGlzLl9xdWV1ZWRDaHVua3MgPSBxdWV1ZWRDaHVua3MgfHwgW107XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICBmb3IgKGNvbnN0IGNodW5rIG9mIHRoaXMuX3F1ZXVlZENodW5rcykge1xuICAgICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5faGVhZGVyc1JlYWR5ID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgc3RyZWFtLl9mdWxsUmVxdWVzdFJlYWRlciA9IHRoaXM7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBfZW5xdWV1ZShjaHVuaykge1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rcy5wdXNoKGNodW5rKTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gIH1cbiAgZ2V0IGhlYWRlcnNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhZGVyc1JlYWR5O1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbS5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbS5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGNvbnRlbnRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbS5fY29udGVudExlbmd0aDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGlmICh0aGlzLl9xdWV1ZWRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9xdWV1ZWRDaHVua3Muc2hpZnQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuICAgIHJldHVybiByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gIH1cbiAgcHJvZ3Jlc3NpdmVEb25lKCkge1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICB9XG59XG5jbGFzcyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIGJlZ2luLCBlbmQpIHtcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fYmVnaW4gPSBiZWdpbjtcbiAgICB0aGlzLl9lbmQgPSBlbmQ7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgX2VucXVldWUoY2h1bmspIHtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IGNodW5rO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZXF1ZXN0c0NhcGFiaWxpdHkgPSB0aGlzLl9yZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgcmVxdWVzdHNDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgdGhpcy5fc3RyZWFtLl9yZW1vdmVSYW5nZVJlYWRlcih0aGlzKTtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgaWYgKHRoaXMuX3F1ZXVlZENodW5rKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuX3F1ZXVlZENodW5rO1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0Q2FwYWJpbGl0eSk7XG4gICAgcmV0dXJuIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9zdHJlYW0uX3JlbW92ZVJhbmdlUmVhZGVyKHRoaXMpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2NvbnRlbnRfZGlzcG9zaXRpb24uanNcblxuZnVuY3Rpb24gZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyKGNvbnRlbnREaXNwb3NpdGlvbikge1xuICBsZXQgbmVlZHNFbmNvZGluZ0ZpeHVwID0gdHJ1ZTtcbiAgbGV0IHRtcCA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVxcXFwqXCIsIFwiaVwiKS5leGVjKGNvbnRlbnREaXNwb3NpdGlvbik7XG4gIGlmICh0bXApIHtcbiAgICB0bXAgPSB0bXBbMV07XG4gICAgbGV0IGZpbGVuYW1lID0gcmZjMjYxNnVucXVvdGUodG1wKTtcbiAgICBmaWxlbmFtZSA9IHVuZXNjYXBlKGZpbGVuYW1lKTtcbiAgICBmaWxlbmFtZSA9IHJmYzU5ODdkZWNvZGUoZmlsZW5hbWUpO1xuICAgIGZpbGVuYW1lID0gcmZjMjA0N2RlY29kZShmaWxlbmFtZSk7XG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoZmlsZW5hbWUpO1xuICB9XG4gIHRtcCA9IHJmYzIyMzFnZXRwYXJhbShjb250ZW50RGlzcG9zaXRpb24pO1xuICBpZiAodG1wKSB7XG4gICAgY29uc3QgZmlsZW5hbWUgPSByZmMyMDQ3ZGVjb2RlKHRtcCk7XG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoZmlsZW5hbWUpO1xuICB9XG4gIHRtcCA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVwiLCBcImlcIikuZXhlYyhjb250ZW50RGlzcG9zaXRpb24pO1xuICBpZiAodG1wKSB7XG4gICAgdG1wID0gdG1wWzFdO1xuICAgIGxldCBmaWxlbmFtZSA9IHJmYzI2MTZ1bnF1b3RlKHRtcCk7XG4gICAgZmlsZW5hbWUgPSByZmMyMDQ3ZGVjb2RlKGZpbGVuYW1lKTtcbiAgICByZXR1cm4gZml4dXBFbmNvZGluZyhmaWxlbmFtZSk7XG4gIH1cbiAgZnVuY3Rpb24gdG9QYXJhbVJlZ0V4cChhdHRyaWJ1dGVQYXR0ZXJuLCBmbGFncykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiKD86Xnw7KVxcXFxzKlwiICsgYXR0cmlidXRlUGF0dGVybiArIFwiXFxcXHMqPVxcXFxzKlwiICsgXCIoXCIgKyAnW15cIjtcXFxcc11bXjtcXFxcc10qJyArIFwifFwiICsgJ1wiKD86W15cIlxcXFxcXFxcXXxcXFxcXFxcXFwiPykrXCI/JyArIFwiKVwiLCBmbGFncyk7XG4gIH1cbiAgZnVuY3Rpb24gdGV4dGRlY29kZShlbmNvZGluZywgdmFsdWUpIHtcbiAgICBpZiAoZW5jb2RpbmcpIHtcbiAgICAgIGlmICghL15bXFx4MDAtXFx4RkZdKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcsIHtcbiAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gc3RyaW5nVG9CeXRlcyh2YWx1ZSk7XG4gICAgICAgIHZhbHVlID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgbmVlZHNFbmNvZGluZ0ZpeHVwID0gZmFsc2U7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBmaXh1cEVuY29kaW5nKHZhbHVlKSB7XG4gICAgaWYgKG5lZWRzRW5jb2RpbmdGaXh1cCAmJiAvW1xceDgwLVxceGZmXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdGV4dGRlY29kZShcInV0Zi04XCIsIHZhbHVlKTtcbiAgICAgIGlmIChuZWVkc0VuY29kaW5nRml4dXApIHtcbiAgICAgICAgdmFsdWUgPSB0ZXh0ZGVjb2RlKFwiaXNvLTg4NTktMVwiLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiByZmMyMjMxZ2V0cGFyYW0oY29udGVudERpc3Bvc2l0aW9uU3RyKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgIGxldCBtYXRjaDtcbiAgICBjb25zdCBpdGVyID0gdG9QYXJhbVJlZ0V4cChcImZpbGVuYW1lXFxcXCooKD8hMFxcXFxkKVxcXFxkKykoXFxcXCo/KVwiLCBcImlnXCIpO1xuICAgIHdoaWxlICgobWF0Y2ggPSBpdGVyLmV4ZWMoY29udGVudERpc3Bvc2l0aW9uU3RyKSkgIT09IG51bGwpIHtcbiAgICAgIGxldCBbLCBuLCBxdW90LCBwYXJ0XSA9IG1hdGNoO1xuICAgICAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgICAgIGlmIChuIGluIG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG1hdGNoZXNbbl0gPSBbcXVvdCwgcGFydF07XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBtYXRjaGVzLmxlbmd0aDsgKytuKSB7XG4gICAgICBpZiAoIShuIGluIG1hdGNoZXMpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGV0IFtxdW90LCBwYXJ0XSA9IG1hdGNoZXNbbl07XG4gICAgICBwYXJ0ID0gcmZjMjYxNnVucXVvdGUocGFydCk7XG4gICAgICBpZiAocXVvdCkge1xuICAgICAgICBwYXJ0ID0gdW5lc2NhcGUocGFydCk7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgcGFydCA9IHJmYzU5ODdkZWNvZGUocGFydCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzI2MTZ1bnF1b3RlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJ1wiJykpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gdmFsdWUuc2xpY2UoMSkuc3BsaXQoJ1xcXFxcIicpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBxdW90aW5kZXggPSBwYXJ0c1tpXS5pbmRleE9mKCdcIicpO1xuICAgICAgICBpZiAocXVvdGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHBhcnRzW2ldID0gcGFydHNbaV0uc2xpY2UoMCwgcXVvdGluZGV4KTtcbiAgICAgICAgICBwYXJ0cy5sZW5ndGggPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0c1tpXSA9IHBhcnRzW2ldLnJlcGxhY2VBbGwoL1xcXFwoLikvZywgXCIkMVwiKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gcGFydHMuam9pbignXCInKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzU5ODdkZWNvZGUoZXh0dmFsdWUpIHtcbiAgICBjb25zdCBlbmNvZGluZ2VuZCA9IGV4dHZhbHVlLmluZGV4T2YoXCInXCIpO1xuICAgIGlmIChlbmNvZGluZ2VuZCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBleHR2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgZW5jb2RpbmcgPSBleHR2YWx1ZS5zbGljZSgwLCBlbmNvZGluZ2VuZCk7XG4gICAgY29uc3QgbGFuZ3ZhbHVlID0gZXh0dmFsdWUuc2xpY2UoZW5jb2RpbmdlbmQgKyAxKTtcbiAgICBjb25zdCB2YWx1ZSA9IGxhbmd2YWx1ZS5yZXBsYWNlKC9eW14nXSonLywgXCJcIik7XG4gICAgcmV0dXJuIHRleHRkZWNvZGUoZW5jb2RpbmcsIHZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiByZmMyMDQ3ZGVjb2RlKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZS5zdGFydHNXaXRoKFwiPT9cIikgfHwgL1tcXHgwMC1cXHgxOVxceDgwLVxceGZmXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2VBbGwoLz1cXD8oW1xcdy1dKilcXD8oW1FxQmJdKVxcPygoPzpbXj9dfFxcPyg/IT0pKSopXFw/PS9nLCBmdW5jdGlvbiAobWF0Y2hlcywgY2hhcnNldCwgZW5jb2RpbmcsIHRleHQpIHtcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gXCJxXCIgfHwgZW5jb2RpbmcgPT09IFwiUVwiKSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2VBbGwoXCJfXCIsIFwiIFwiKTtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZUFsbCgvPShbMC05YS1mQS1GXXsyfSkvZywgZnVuY3Rpb24gKG1hdGNoLCBoZXgpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChoZXgsIDE2KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGV4dGRlY29kZShjaGFyc2V0LCB0ZXh0KTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHRleHQgPSBhdG9iKHRleHQpO1xuICAgICAgfSBjYXRjaCB7fVxuICAgICAgcmV0dXJuIHRleHRkZWNvZGUoY2hhcnNldCwgdGV4dCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L25ldHdvcmtfdXRpbHMuanNcblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUhlYWRlcnMoaXNIdHRwLCBodHRwSGVhZGVycykge1xuICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgaWYgKCFpc0h0dHAgfHwgIWh0dHBIZWFkZXJzIHx8IHR5cGVvZiBodHRwSGVhZGVycyAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBoZWFkZXJzO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGh0dHBIZWFkZXJzKSB7XG4gICAgY29uc3QgdmFsID0gaHR0cEhlYWRlcnNba2V5XTtcbiAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5mdW5jdGlvbiBnZXRSZXNwb25zZU9yaWdpbih1cmwpIHtcbiAgcmV0dXJuIFVSTC5wYXJzZSh1cmwpPy5vcmlnaW4gPz8gbnVsbDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKHtcbiAgcmVzcG9uc2VIZWFkZXJzLFxuICBpc0h0dHAsXG4gIHJhbmdlQ2h1bmtTaXplLFxuICBkaXNhYmxlUmFuZ2Vcbn0pIHtcbiAgY29uc3QgcmV0dXJuVmFsdWVzID0ge1xuICAgIGFsbG93UmFuZ2VSZXF1ZXN0czogZmFsc2UsXG4gICAgc3VnZ2VzdGVkTGVuZ3RoOiB1bmRlZmluZWRcbiAgfTtcbiAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQocmVzcG9uc2VIZWFkZXJzLmdldChcIkNvbnRlbnQtTGVuZ3RoXCIpLCAxMCk7XG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihsZW5ndGgpKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICByZXR1cm5WYWx1ZXMuc3VnZ2VzdGVkTGVuZ3RoID0gbGVuZ3RoO1xuICBpZiAobGVuZ3RoIDw9IDIgKiByYW5nZUNodW5rU2l6ZSkge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgaWYgKGRpc2FibGVSYW5nZSB8fCAhaXNIdHRwKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICBpZiAocmVzcG9uc2VIZWFkZXJzLmdldChcIkFjY2VwdC1SYW5nZXNcIikgIT09IFwiYnl0ZXNcIikge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgY29uc3QgY29udGVudEVuY29kaW5nID0gcmVzcG9uc2VIZWFkZXJzLmdldChcIkNvbnRlbnQtRW5jb2RpbmdcIikgfHwgXCJpZGVudGl0eVwiO1xuICBpZiAoY29udGVudEVuY29kaW5nICE9PSBcImlkZW50aXR5XCIpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIHJldHVyblZhbHVlcy5hbGxvd1JhbmdlUmVxdWVzdHMgPSB0cnVlO1xuICByZXR1cm4gcmV0dXJuVmFsdWVzO1xufVxuZnVuY3Rpb24gZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcihyZXNwb25zZUhlYWRlcnMpIHtcbiAgY29uc3QgY29udGVudERpc3Bvc2l0aW9uID0gcmVzcG9uc2VIZWFkZXJzLmdldChcIkNvbnRlbnQtRGlzcG9zaXRpb25cIik7XG4gIGlmIChjb250ZW50RGlzcG9zaXRpb24pIHtcbiAgICBsZXQgZmlsZW5hbWUgPSBnZXRGaWxlbmFtZUZyb21Db250ZW50RGlzcG9zaXRpb25IZWFkZXIoY29udGVudERpc3Bvc2l0aW9uKTtcbiAgICBpZiAoZmlsZW5hbWUuaW5jbHVkZXMoXCIlXCIpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmaWxlbmFtZSA9IGRlY29kZVVSSUNvbXBvbmVudChmaWxlbmFtZSk7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfVxuICAgIGlmIChpc1BkZkZpbGUoZmlsZW5hbWUpKSB7XG4gICAgICByZXR1cm4gZmlsZW5hbWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VFcnJvcihzdGF0dXMsIHVybCkge1xuICByZXR1cm4gbmV3IFJlc3BvbnNlRXhjZXB0aW9uKGBVbmV4cGVjdGVkIHNlcnZlciByZXNwb25zZSAoJHtzdGF0dXN9KSB3aGlsZSByZXRyaWV2aW5nIFBERiBcIiR7dXJsfVwiLmAsIHN0YXR1cywgc3RhdHVzID09PSA0MDQgfHwgc3RhdHVzID09PSAwICYmIHVybC5zdGFydHNXaXRoKFwiZmlsZTpcIikpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVSZXNwb25zZVN0YXR1cyhzdGF0dXMpIHtcbiAgcmV0dXJuIHN0YXR1cyA9PT0gMjAwIHx8IHN0YXR1cyA9PT0gMjA2O1xufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9mZXRjaF9zdHJlYW0uanNcblxuXG5mdW5jdGlvbiBjcmVhdGVGZXRjaE9wdGlvbnMoaGVhZGVycywgd2l0aENyZWRlbnRpYWxzLCBhYm9ydENvbnRyb2xsZXIpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgaGVhZGVycyxcbiAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgY3JlZGVudGlhbHM6IHdpdGhDcmVkZW50aWFscyA/IFwiaW5jbHVkZVwiIDogXCJzYW1lLW9yaWdpblwiLFxuICAgIHJlZGlyZWN0OiBcImZvbGxvd1wiXG4gIH07XG59XG5mdW5jdGlvbiBnZXRBcnJheUJ1ZmZlcih2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gdmFsLmJ1ZmZlcjtcbiAgfVxuICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHdhcm4oYGdldEFycmF5QnVmZmVyIC0gdW5leHBlY3RlZCBkYXRhIGZvcm1hdDogJHt2YWx9YCk7XG4gIHJldHVybiBuZXcgVWludDhBcnJheSh2YWwpLmJ1ZmZlcjtcbn1cbmNsYXNzIFBERkZldGNoU3RyZWFtIHtcbiAgX3Jlc3BvbnNlT3JpZ2luID0gbnVsbDtcbiAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5pc0h0dHAgPSAvXmh0dHBzPzovaS50ZXN0KHNvdXJjZS51cmwpO1xuICAgIHRoaXMuaGVhZGVycyA9IGNyZWF0ZUhlYWRlcnModGhpcy5pc0h0dHAsIHNvdXJjZS5odHRwSGVhZGVycyk7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMgPSBbXTtcbiAgfVxuICBnZXQgX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Ll9sb2FkZWQgPz8gMDtcbiAgfVxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgIGFzc2VydCghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGRmV0Y2hTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBuZXcgUERGRmV0Y2hTdHJlYW1SZWFkZXIodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyO1xuICB9XG4gIGdldFJhbmdlUmVhZGVyKGJlZ2luLCBlbmQpIHtcbiAgICBpZiAoZW5kIDw9IHRoaXMuX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBQREZGZXRjaFN0cmVhbVJhbmdlUmVhZGVyKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgIHJldHVybiByZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFBERkZldGNoU3RyZWFtUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX3JlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSBzb3VyY2Uud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gc291cmNlLmRpc2FibGVSYW5nZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICBpZiAoIXRoaXMuX3JhbmdlQ2h1bmtTaXplICYmICF0aGlzLl9kaXNhYmxlUmFuZ2UpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlUmFuZ2U7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHN0cmVhbS5oZWFkZXJzKTtcbiAgICBjb25zdCB1cmwgPSBzb3VyY2UudXJsO1xuICAgIGZldGNoKHVybCwgY3JlYXRlRmV0Y2hPcHRpb25zKGhlYWRlcnMsIHRoaXMuX3dpdGhDcmVkZW50aWFscywgdGhpcy5fYWJvcnRDb250cm9sbGVyKSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICBzdHJlYW0uX3Jlc3BvbnNlT3JpZ2luID0gZ2V0UmVzcG9uc2VPcmlnaW4ocmVzcG9uc2UudXJsKTtcbiAgICAgIGlmICghdmFsaWRhdGVSZXNwb25zZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZVJlc3BvbnNlRXJyb3IocmVzcG9uc2Uuc3RhdHVzLCB1cmwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlLmhlYWRlcnM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFsbG93UmFuZ2VSZXF1ZXN0cyxcbiAgICAgICAgc3VnZ2VzdGVkTGVuZ3RoXG4gICAgICB9ID0gdmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXMoe1xuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGlzSHR0cDogc3RyZWFtLmlzSHR0cCxcbiAgICAgICAgcmFuZ2VDaHVua1NpemU6IHRoaXMuX3JhbmdlQ2h1bmtTaXplLFxuICAgICAgICBkaXNhYmxlUmFuZ2U6IHRoaXMuX2Rpc2FibGVSYW5nZVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gYWxsb3dSYW5nZVJlcXVlc3RzO1xuICAgICAgdGhpcy5fY29udGVudExlbmd0aCA9IHN1Z2dlc3RlZExlbmd0aCB8fCB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICAgICAgdGhpcy5fZmlsZW5hbWUgPSBleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKHJlc3BvbnNlSGVhZGVycyk7XG4gICAgICBpZiAoIXRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkICYmIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwobmV3IEFib3J0RXhjZXB0aW9uKFwiU3RyZWFtaW5nIGlzIGRpc2FibGVkLlwiKSk7XG4gICAgICB9XG4gICAgfSkuY2F0Y2godGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KTtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudExlbmd0aDtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGRvbmVcbiAgICB9ID0gYXdhaXQgdGhpcy5fcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkLFxuICAgICAgdG90YWw6IHRoaXMuX2NvbnRlbnRMZW5ndGhcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGdldEFycmF5QnVmZmVyKHZhbHVlKSxcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fcmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgfVxufVxuY2xhc3MgUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgYmVnaW4sIGVuZCkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSBzb3VyY2Uud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gICAgdGhpcy5fYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhzdHJlYW0uaGVhZGVycyk7XG4gICAgaGVhZGVycy5hcHBlbmQoXCJSYW5nZVwiLCBgYnl0ZXM9JHtiZWdpbn0tJHtlbmQgLSAxfWApO1xuICAgIGNvbnN0IHVybCA9IHNvdXJjZS51cmw7XG4gICAgZmV0Y2godXJsLCBjcmVhdGVGZXRjaE9wdGlvbnMoaGVhZGVycywgdGhpcy5fd2l0aENyZWRlbnRpYWxzLCB0aGlzLl9hYm9ydENvbnRyb2xsZXIpKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlT3JpZ2luID0gZ2V0UmVzcG9uc2VPcmlnaW4ocmVzcG9uc2UudXJsKTtcbiAgICAgIGlmIChyZXNwb25zZU9yaWdpbiAhPT0gc3RyZWFtLl9yZXNwb25zZU9yaWdpbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHJhbmdlIHJlc3BvbnNlLW9yaWdpbiBcIiR7cmVzcG9uc2VPcmlnaW59XCIgdG8gbWF0Y2ggXCIke3N0cmVhbS5fcmVzcG9uc2VPcmlnaW59XCIuYCk7XG4gICAgICB9XG4gICAgICBpZiAoIXZhbGlkYXRlUmVzcG9uc2VTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICB0aHJvdyBjcmVhdGVSZXNwb25zZUVycm9yKHJlc3BvbnNlLnN0YXR1cywgdXJsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIHRoaXMuX3JlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgfSkuY2F0Y2godGhpcy5fcmVhZENhcGFiaWxpdHkucmVqZWN0KTtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlLFxuICAgICAgZG9uZVxuICAgIH0gPSBhd2FpdCB0aGlzLl9yZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZG9uZVxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiB0aGlzLl9sb2FkZWRcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGdldEFycmF5QnVmZmVyKHZhbHVlKSxcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fcmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9uZXR3b3JrLmpzXG5cblxuY29uc3QgT0tfUkVTUE9OU0UgPSAyMDA7XG5jb25zdCBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0UgPSAyMDY7XG5mdW5jdGlvbiBuZXR3b3JrX2dldEFycmF5QnVmZmVyKHhocikge1xuICBjb25zdCBkYXRhID0geGhyLnJlc3BvbnNlO1xuICBpZiAodHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICByZXR1cm4gc3RyaW5nVG9CeXRlcyhkYXRhKS5idWZmZXI7XG59XG5jbGFzcyBOZXR3b3JrTWFuYWdlciB7XG4gIF9yZXNwb25zZU9yaWdpbiA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1cmwsXG4gICAgaHR0cEhlYWRlcnMsXG4gICAgd2l0aENyZWRlbnRpYWxzXG4gIH0pIHtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLmlzSHR0cCA9IC9eaHR0cHM/Oi9pLnRlc3QodXJsKTtcbiAgICB0aGlzLmhlYWRlcnMgPSBjcmVhdGVIZWFkZXJzKHRoaXMuaXNIdHRwLCBodHRwSGVhZGVycyk7XG4gICAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSB3aXRoQ3JlZGVudGlhbHMgfHwgZmFsc2U7XG4gICAgdGhpcy5jdXJyWGhySWQgPSAwO1xuICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICByZXF1ZXN0KGFyZ3MpIHtcbiAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBjb25zdCB4aHJJZCA9IHRoaXMuY3VyclhocklkKys7XG4gICAgY29uc3QgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF0gPSB7XG4gICAgICB4aHJcbiAgICB9O1xuICAgIHhoci5vcGVuKFwiR0VUXCIsIHRoaXMudXJsKTtcbiAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHM7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIHRoaXMuaGVhZGVycykge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0h0dHAgJiYgXCJiZWdpblwiIGluIGFyZ3MgJiYgXCJlbmRcIiBpbiBhcmdzKSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIlJhbmdlXCIsIGBieXRlcz0ke2FyZ3MuYmVnaW59LSR7YXJncy5lbmQgLSAxfWApO1xuICAgICAgcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMgPSBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzID0gT0tfUkVTUE9OU0U7XG4gICAgfVxuICAgIHhoci5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgYXNzZXJ0KGFyZ3Mub25FcnJvciwgXCJFeHBlY3RlZCBgb25FcnJvcmAgY2FsbGJhY2sgdG8gYmUgcHJvdmlkZWQuXCIpO1xuICAgIHhoci5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgYXJncy5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgIH07XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHRoaXMub25TdGF0ZUNoYW5nZS5iaW5kKHRoaXMsIHhocklkKTtcbiAgICB4aHIub25wcm9ncmVzcyA9IHRoaXMub25Qcm9ncmVzcy5iaW5kKHRoaXMsIHhocklkKTtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZCA9IGFyZ3Mub25IZWFkZXJzUmVjZWl2ZWQ7XG4gICAgcGVuZGluZ1JlcXVlc3Qub25Eb25lID0gYXJncy5vbkRvbmU7XG4gICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvciA9IGFyZ3Mub25FcnJvcjtcbiAgICBwZW5kaW5nUmVxdWVzdC5vblByb2dyZXNzID0gYXJncy5vblByb2dyZXNzO1xuICAgIHhoci5zZW5kKG51bGwpO1xuICAgIHJldHVybiB4aHJJZDtcbiAgfVxuICBvblByb2dyZXNzKHhocklkLCBldnQpIHtcbiAgICBjb25zdCBwZW5kaW5nUmVxdWVzdCA9IHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcbiAgICBpZiAoIXBlbmRpbmdSZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uUHJvZ3Jlc3M/LihldnQpO1xuICB9XG4gIG9uU3RhdGVDaGFuZ2UoeGhySWQsIGV2dCkge1xuICAgIGNvbnN0IHBlbmRpbmdSZXF1ZXN0ID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdO1xuICAgIGlmICghcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeGhyID0gcGVuZGluZ1JlcXVlc3QueGhyO1xuICAgIGlmICh4aHIucmVhZHlTdGF0ZSA+PSAyICYmIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkKSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZCgpO1xuICAgICAgZGVsZXRlIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkO1xuICAgIH1cbiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEoeGhySWQgaW4gdGhpcy5wZW5kaW5nUmVxdWVzdHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgaWYgKHhoci5zdGF0dXMgPT09IDAgJiYgdGhpcy5pc0h0dHApIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHhoclN0YXR1cyA9IHhoci5zdGF0dXMgfHwgT0tfUkVTUE9OU0U7XG4gICAgY29uc3Qgb2tfcmVzcG9uc2Vfb25fcmFuZ2VfcmVxdWVzdCA9IHhoclN0YXR1cyA9PT0gT0tfUkVTUE9OU0UgJiYgcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMgPT09IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRTtcbiAgICBpZiAoIW9rX3Jlc3BvbnNlX29uX3JhbmdlX3JlcXVlc3QgJiYgeGhyU3RhdHVzICE9PSBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cykge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2h1bmsgPSBuZXR3b3JrX2dldEFycmF5QnVmZmVyKHhocik7XG4gICAgaWYgKHhoclN0YXR1cyA9PT0gUEFSVElBTF9DT05URU5UX1JFU1BPTlNFKSB7XG4gICAgICBjb25zdCByYW5nZUhlYWRlciA9IHhoci5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtUmFuZ2VcIik7XG4gICAgICBjb25zdCBtYXRjaGVzID0gL2J5dGVzIChcXGQrKS0oXFxkKylcXC8oXFxkKykvLmV4ZWMocmFuZ2VIZWFkZXIpO1xuICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgcGVuZGluZ1JlcXVlc3Qub25Eb25lKHtcbiAgICAgICAgICBiZWdpbjogcGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApLFxuICAgICAgICAgIGNodW5rXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihgTWlzc2luZyBvciBpbnZhbGlkIFwiQ29udGVudC1SYW5nZVwiIGhlYWRlci5gKTtcbiAgICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcigwKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNodW5rKSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUoe1xuICAgICAgICBiZWdpbjogMCxcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgIH1cbiAgfVxuICBnZXRSZXF1ZXN0WGhyKHhocklkKSB7XG4gICAgcmV0dXJuIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXS54aHI7XG4gIH1cbiAgaXNQZW5kaW5nUmVxdWVzdCh4aHJJZCkge1xuICAgIHJldHVybiB4aHJJZCBpbiB0aGlzLnBlbmRpbmdSZXF1ZXN0cztcbiAgfVxuICBhYm9ydFJlcXVlc3QoeGhySWQpIHtcbiAgICBjb25zdCB4aHIgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF0ueGhyO1xuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgeGhyLmFib3J0KCk7XG4gIH1cbn1cbmNsYXNzIFBERk5ldHdvcmtTdHJlYW0ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5fbWFuYWdlciA9IG5ldyBOZXR3b3JrTWFuYWdlcihzb3VyY2UpO1xuICAgIHRoaXMuX3JhbmdlQ2h1bmtTaXplID0gc291cmNlLnJhbmdlQ2h1bmtTaXplO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzID0gW107XG4gIH1cbiAgX29uUmFuZ2VSZXF1ZXN0UmVhZGVyQ2xvc2VkKHJlYWRlcikge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLmluZGV4T2YocmVhZGVyKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbiAgZ2V0RnVsbFJlYWRlcigpIHtcbiAgICBhc3NlcnQoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERk5ldHdvcmtTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBuZXcgUERGTmV0d29ya1N0cmVhbUZ1bGxSZXF1ZXN0UmVhZGVyKHRoaXMuX21hbmFnZXIsIHRoaXMuX3NvdXJjZSk7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyO1xuICB9XG4gIGdldFJhbmdlUmVhZGVyKGJlZ2luLCBlbmQpIHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUERGTmV0d29ya1N0cmVhbVJhbmdlUmVxdWVzdFJlYWRlcih0aGlzLl9tYW5hZ2VyLCBiZWdpbiwgZW5kKTtcbiAgICByZWFkZXIub25DbG9zZWQgPSB0aGlzLl9vblJhbmdlUmVxdWVzdFJlYWRlckNsb3NlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgIHJldHVybiByZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFBERk5ldHdvcmtTdHJlYW1GdWxsUmVxdWVzdFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIsIHNvdXJjZSkge1xuICAgIHRoaXMuX21hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuX3VybCA9IHNvdXJjZS51cmw7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RJZCA9IG1hbmFnZXIucmVxdWVzdCh7XG4gICAgICBvbkhlYWRlcnNSZWNlaXZlZDogdGhpcy5fb25IZWFkZXJzUmVjZWl2ZWQuYmluZCh0aGlzKSxcbiAgICAgIG9uRG9uZTogdGhpcy5fb25Eb25lLmJpbmQodGhpcyksXG4gICAgICBvbkVycm9yOiB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyksXG4gICAgICBvblByb2dyZXNzOiB0aGlzLl9vblByb2dyZXNzLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHNvdXJjZS5kaXNhYmxlUmFuZ2UgfHwgZmFsc2U7XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jYWNoZWRDaHVua3MgPSBbXTtcbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBfb25IZWFkZXJzUmVjZWl2ZWQoKSB7XG4gICAgY29uc3QgZnVsbFJlcXVlc3RYaHJJZCA9IHRoaXMuX2Z1bGxSZXF1ZXN0SWQ7XG4gICAgY29uc3QgZnVsbFJlcXVlc3RYaHIgPSB0aGlzLl9tYW5hZ2VyLmdldFJlcXVlc3RYaHIoZnVsbFJlcXVlc3RYaHJJZCk7XG4gICAgdGhpcy5fbWFuYWdlci5fcmVzcG9uc2VPcmlnaW4gPSBnZXRSZXNwb25zZU9yaWdpbihmdWxsUmVxdWVzdFhoci5yZXNwb25zZVVSTCk7XG4gICAgY29uc3QgcmF3UmVzcG9uc2VIZWFkZXJzID0gZnVsbFJlcXVlc3RYaHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG4gICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gbmV3IEhlYWRlcnMocmF3UmVzcG9uc2VIZWFkZXJzID8gcmF3UmVzcG9uc2VIZWFkZXJzLnRyaW1TdGFydCgpLnJlcGxhY2UoL1teXFxTIF0rJC8sIFwiXCIpLnNwbGl0KC9bXFxyXFxuXSsvKS5tYXAoeCA9PiB7XG4gICAgICBjb25zdCBba2V5LCAuLi52YWxdID0geC5zcGxpdChcIjogXCIpO1xuICAgICAgcmV0dXJuIFtrZXksIHZhbC5qb2luKFwiOiBcIildO1xuICAgIH0pIDogW10pO1xuICAgIGNvbnN0IHtcbiAgICAgIGFsbG93UmFuZ2VSZXF1ZXN0cyxcbiAgICAgIHN1Z2dlc3RlZExlbmd0aFxuICAgIH0gPSB2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyh7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICBpc0h0dHA6IHRoaXMuX21hbmFnZXIuaXNIdHRwLFxuICAgICAgcmFuZ2VDaHVua1NpemU6IHRoaXMuX3JhbmdlQ2h1bmtTaXplLFxuICAgICAgZGlzYWJsZVJhbmdlOiB0aGlzLl9kaXNhYmxlUmFuZ2VcbiAgICB9KTtcbiAgICBpZiAoYWxsb3dSYW5nZVJlcXVlc3RzKSB7XG4gICAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHN1Z2dlc3RlZExlbmd0aCB8fCB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcihyZXNwb25zZUhlYWRlcnMpO1xuICAgIGlmICh0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLl9tYW5hZ2VyLmFib3J0UmVxdWVzdChmdWxsUmVxdWVzdFhocklkKTtcbiAgICB9XG4gICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIF9vbkRvbmUoZGF0YSkge1xuICAgIGlmIChkYXRhKSB7XG4gICAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgIHZhbHVlOiBkYXRhLmNodW5rLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkQ2h1bmtzLnB1c2goZGF0YS5jaHVuayk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGlmICh0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gIH1cbiAgX29uRXJyb3Ioc3RhdHVzKSB7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBjcmVhdGVSZXNwb25zZUVycm9yKHN0YXR1cywgdGhpcy5fdXJsKTtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlamVjdCh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fY2FjaGVkQ2h1bmtzLmxlbmd0aCA9IDA7XG4gIH1cbiAgX29uUHJvZ3Jlc3MoZXZ0KSB7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgdG90YWw6IGV2dC5sZW5ndGhDb21wdXRhYmxlID8gZXZ0LnRvdGFsIDogdGhpcy5fY29udGVudExlbmd0aFxuICAgIH0pO1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudExlbmd0aDtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY2FjaGVkQ2h1bmtzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2FjaGVkQ2h1bmtzLnNoaWZ0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIGlmICh0aGlzLl9tYW5hZ2VyLmlzUGVuZGluZ1JlcXVlc3QodGhpcy5fZnVsbFJlcXVlc3RJZCkpIHtcbiAgICAgIHRoaXMuX21hbmFnZXIuYWJvcnRSZXF1ZXN0KHRoaXMuX2Z1bGxSZXF1ZXN0SWQpO1xuICAgIH1cbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gIH1cbn1cbmNsYXNzIFBERk5ldHdvcmtTdHJlYW1SYW5nZVJlcXVlc3RSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyLCBiZWdpbiwgZW5kKSB7XG4gICAgdGhpcy5fbWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5fdXJsID0gbWFuYWdlci51cmw7XG4gICAgdGhpcy5fcmVxdWVzdElkID0gbWFuYWdlci5yZXF1ZXN0KHtcbiAgICAgIGJlZ2luLFxuICAgICAgZW5kLFxuICAgICAgb25IZWFkZXJzUmVjZWl2ZWQ6IHRoaXMuX29uSGVhZGVyc1JlY2VpdmVkLmJpbmQodGhpcyksXG4gICAgICBvbkRvbmU6IHRoaXMuX29uRG9uZS5iaW5kKHRoaXMpLFxuICAgICAgb25FcnJvcjogdGhpcy5fb25FcnJvci5iaW5kKHRoaXMpLFxuICAgICAgb25Qcm9ncmVzczogdGhpcy5fb25Qcm9ncmVzcy5iaW5kKHRoaXMpXG4gICAgfSk7XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gICAgdGhpcy5vbkNsb3NlZCA9IG51bGw7XG4gIH1cbiAgX29uSGVhZGVyc1JlY2VpdmVkKCkge1xuICAgIGNvbnN0IHJlc3BvbnNlT3JpZ2luID0gZ2V0UmVzcG9uc2VPcmlnaW4odGhpcy5fbWFuYWdlci5nZXRSZXF1ZXN0WGhyKHRoaXMuX3JlcXVlc3RJZCk/LnJlc3BvbnNlVVJMKTtcbiAgICBpZiAocmVzcG9uc2VPcmlnaW4gIT09IHRoaXMuX21hbmFnZXIuX3Jlc3BvbnNlT3JpZ2luKSB7XG4gICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IG5ldyBFcnJvcihgRXhwZWN0ZWQgcmFuZ2UgcmVzcG9uc2Utb3JpZ2luIFwiJHtyZXNwb25zZU9yaWdpbn1cIiB0byBtYXRjaCBcIiR7dGhpcy5fbWFuYWdlci5fcmVzcG9uc2VPcmlnaW59XCIuYCk7XG4gICAgICB0aGlzLl9vbkVycm9yKDApO1xuICAgIH1cbiAgfVxuICBfY2xvc2UoKSB7XG4gICAgdGhpcy5vbkNsb3NlZD8uKHRoaXMpO1xuICB9XG4gIF9vbkRvbmUoZGF0YSkge1xuICAgIGNvbnN0IGNodW5rID0gZGF0YS5jaHVuaztcbiAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSB0aGlzLl9yZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IGNodW5rO1xuICAgIH1cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fY2xvc2UoKTtcbiAgfVxuICBfb25FcnJvcihzdGF0dXMpIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA/Pz0gY3JlYXRlUmVzcG9uc2VFcnJvcihzdGF0dXMsIHRoaXMuX3VybCk7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVqZWN0KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gIH1cbiAgX29uUHJvZ3Jlc3MoZXZ0KSB7XG4gICAgaWYgKCF0aGlzLmlzU3RyZWFtaW5nU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcXVldWVkQ2h1bmsgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bms7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIGlmICh0aGlzLl9tYW5hZ2VyLmlzUGVuZGluZ1JlcXVlc3QodGhpcy5fcmVxdWVzdElkKSkge1xuICAgICAgdGhpcy5fbWFuYWdlci5hYm9ydFJlcXVlc3QodGhpcy5fcmVxdWVzdElkKTtcbiAgICB9XG4gICAgdGhpcy5fY2xvc2UoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9ub2RlX3N0cmVhbS5qc1xuXG5cbmNvbnN0IHVybFJlZ2V4ID0gL15bYS16XVthLXowLTlcXC0rLl0rOi9pO1xuZnVuY3Rpb24gcGFyc2VVcmxPclBhdGgoc291cmNlVXJsKSB7XG4gIGlmICh1cmxSZWdleC50ZXN0KHNvdXJjZVVybCkpIHtcbiAgICByZXR1cm4gbmV3IFVSTChzb3VyY2VVcmwpO1xuICB9XG4gIGNvbnN0IHVybCA9IHByb2Nlc3MuZ2V0QnVpbHRpbk1vZHVsZShcInVybFwiKTtcbiAgcmV0dXJuIG5ldyBVUkwodXJsLnBhdGhUb0ZpbGVVUkwoc291cmNlVXJsKSk7XG59XG5jbGFzcyBQREZOb2RlU3RyZWFtIHtcbiAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy51cmwgPSBwYXJzZVVybE9yUGF0aChzb3VyY2UudXJsKTtcbiAgICBhc3NlcnQodGhpcy51cmwucHJvdG9jb2wgPT09IFwiZmlsZTpcIiwgXCJQREZOb2RlU3RyZWFtIG9ubHkgc3VwcG9ydHMgZmlsZTovLyBVUkxzLlwiKTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycyA9IFtdO1xuICB9XG4gIGdldCBfcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uX2xvYWRlZCA/PyAwO1xuICB9XG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgYXNzZXJ0KCF0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciwgXCJQREZOb2RlU3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbmV3IFBERk5vZGVTdHJlYW1Gc0Z1bGxSZWFkZXIodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyO1xuICB9XG4gIGdldFJhbmdlUmVhZGVyKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoZW5kIDw9IHRoaXMuX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJhbmdlUmVhZGVyID0gbmV3IFBERk5vZGVTdHJlYW1Gc1JhbmdlUmVhZGVyKHRoaXMsIHN0YXJ0LCBlbmQpO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyYW5nZVJlYWRlcik7XG4gICAgcmV0dXJuIHJhbmdlUmVhZGVyO1xuICB9XG4gIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNsaWNlKDApKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuICB9XG59XG5jbGFzcyBQREZOb2RlU3RyZWFtRnNGdWxsUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgdGhpcy5fdXJsID0gc3RyZWFtLnVybDtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBudWxsO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gbnVsbDtcbiAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSBzb3VyY2UuZGlzYWJsZVJhbmdlIHx8IGZhbHNlO1xuICAgIHRoaXMuX3JhbmdlQ2h1bmtTaXplID0gc291cmNlLnJhbmdlQ2h1bmtTaXplO1xuICAgIGlmICghdGhpcy5fcmFuZ2VDaHVua1NpemUgJiYgIXRoaXMuX2Rpc2FibGVSYW5nZSkge1xuICAgICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVJhbmdlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gbnVsbDtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgY29uc3QgZnMgPSBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGUoXCJmc1wiKTtcbiAgICBmcy5wcm9taXNlcy5sc3RhdCh0aGlzLl91cmwpLnRoZW4oc3RhdCA9PiB7XG4gICAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3RhdC5zaXplO1xuICAgICAgdGhpcy5fc2V0UmVhZGFibGVTdHJlYW0oZnMuY3JlYXRlUmVhZFN0cmVhbSh0aGlzLl91cmwpKTtcbiAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9LCBlcnJvciA9PiB7XG4gICAgICBpZiAoZXJyb3IuY29kZSA9PT0gXCJFTk9FTlRcIikge1xuICAgICAgICBlcnJvciA9IGNyZWF0ZVJlc3BvbnNlRXJyb3IoMCwgdGhpcy5fdXJsLmhyZWYpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBlcnJvcjtcbiAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdChlcnJvcik7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGhlYWRlcnNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBnZXQgZmlsZW5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lO1xuICB9XG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICB9XG4gIGdldCBpc1JhbmdlU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBjb25zdCBjaHVuayA9IHRoaXMuX3JlYWRhYmxlU3RyZWFtLnJlYWQoKTtcbiAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkKCk7XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5sZW5ndGg7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiB0aGlzLl9sb2FkZWQsXG4gICAgICB0b3RhbDogdGhpcy5fY29udGVudExlbmd0aFxuICAgIH0pO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGNodW5rKS5idWZmZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBidWZmZXIsXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdHJlYW0pIHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kocmVhc29uKTtcbiAgfVxuICBfZXJyb3IocmVhc29uKSB7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSByZWFzb247XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIF9zZXRSZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gcmVhZGFibGVTdHJlYW07XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJyZWFkYWJsZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgcmVhZGFibGVTdHJlYW0uZGVzdHJveSgpO1xuICAgICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlcnJvclwiLCByZWFzb24gPT4ge1xuICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcbiAgICB9KTtcbiAgICBpZiAoIXRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkICYmIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMuX2Vycm9yKG5ldyBBYm9ydEV4Y2VwdGlvbihcInN0cmVhbWluZyBpcyBkaXNhYmxlZFwiKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveSh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgfVxuICB9XG59XG5jbGFzcyBQREZOb2RlU3RyZWFtRnNSYW5nZVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgc3RhcnQsIGVuZCkge1xuICAgIHRoaXMuX3VybCA9IHN0cmVhbS51cmw7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSBudWxsO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgICBjb25zdCBmcyA9IHByb2Nlc3MuZ2V0QnVpbHRpbk1vZHVsZShcImZzXCIpO1xuICAgIHRoaXMuX3NldFJlYWRhYmxlU3RyZWFtKGZzLmNyZWF0ZVJlYWRTdHJlYW0odGhpcy5fdXJsLCB7XG4gICAgICBzdGFydCxcbiAgICAgIGVuZDogZW5kIC0gMVxuICAgIH0pKTtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5fcmVhZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLl9zdG9yZWRFcnJvcjtcbiAgICB9XG4gICAgY29uc3QgY2h1bmsgPSB0aGlzLl9yZWFkYWJsZVN0cmVhbS5yZWFkKCk7XG4gICAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgcmV0dXJuIHRoaXMucmVhZCgpO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkXG4gICAgfSk7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmspLmJ1ZmZlcjtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGJ1ZmZlcixcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0cmVhbSkge1xuICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveShyZWFzb24pO1xuICB9XG4gIF9lcnJvcihyZWFzb24pIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgX3NldFJlYWRhYmxlU3RyZWFtKHJlYWRhYmxlU3RyZWFtKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSByZWFkYWJsZVN0cmVhbTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcInJlYWRhYmxlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICByZWFkYWJsZVN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVycm9yXCIsIHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveSh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgfVxuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3BkZl9vYmplY3RzLmpzXG5jb25zdCBJTklUSUFMX0RBVEEgPSBTeW1ib2woXCJJTklUSUFMX0RBVEFcIik7XG5jbGFzcyBQREZPYmplY3RzIHtcbiAgI29ianMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAjZW5zdXJlT2JqKG9iaklkKSB7XG4gICAgcmV0dXJuIHRoaXMuI29ianNbb2JqSWRdIHx8PSB7XG4gICAgICAuLi5Qcm9taXNlLndpdGhSZXNvbHZlcnMoKSxcbiAgICAgIGRhdGE6IElOSVRJQUxfREFUQVxuICAgIH07XG4gIH1cbiAgZ2V0KG9iaklkLCBjYWxsYmFjayA9IG51bGwpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IG9iaiA9IHRoaXMuI2Vuc3VyZU9iaihvYmpJZCk7XG4gICAgICBvYmoucHJvbWlzZS50aGVuKCgpID0+IGNhbGxiYWNrKG9iai5kYXRhKSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jb2Jqc1tvYmpJZF07XG4gICAgaWYgKCFvYmogfHwgb2JqLmRhdGEgPT09IElOSVRJQUxfREFUQSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXF1ZXN0aW5nIG9iamVjdCB0aGF0IGlzbid0IHJlc29sdmVkIHlldCAke29iaklkfS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iai5kYXRhO1xuICB9XG4gIGhhcyhvYmpJZCkge1xuICAgIGNvbnN0IG9iaiA9IHRoaXMuI29ianNbb2JqSWRdO1xuICAgIHJldHVybiAhIW9iaiAmJiBvYmouZGF0YSAhPT0gSU5JVElBTF9EQVRBO1xuICB9XG4gIGRlbGV0ZShvYmpJZCkge1xuICAgIGNvbnN0IG9iaiA9IHRoaXMuI29ianNbb2JqSWRdO1xuICAgIGlmICghb2JqIHx8IG9iai5kYXRhID09PSBJTklUSUFMX0RBVEEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuI29ianNbb2JqSWRdO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJlc29sdmUob2JqSWQsIGRhdGEgPSBudWxsKSB7XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jZW5zdXJlT2JqKG9iaklkKTtcbiAgICBvYmouZGF0YSA9IGRhdGE7XG4gICAgb2JqLnJlc29sdmUoKTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IG9iaklkIGluIHRoaXMuI29ianMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YVxuICAgICAgfSA9IHRoaXMuI29ianNbb2JqSWRdO1xuICAgICAgZGF0YT8uYml0bWFwPy5jbG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLiNvYmpzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgZm9yIChjb25zdCBvYmpJZCBpbiB0aGlzLiNvYmpzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGFcbiAgICAgIH0gPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICAgIGlmIChkYXRhID09PSBJTklUSUFMX0RBVEEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB5aWVsZCBbb2JqSWQsIGRhdGFdO1xuICAgIH1cbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS90ZXh0X2xheWVyLmpzXG5cblxuY29uc3QgTUFYX1RFWFRfRElWU19UT19SRU5ERVIgPSAxMDAwMDA7XG5jb25zdCBERUZBVUxUX0ZPTlRfU0laRSA9IDMwO1xuY2xhc3MgVGV4dExheWVyIHtcbiAgI2NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgI2NvbnRhaW5lciA9IG51bGw7XG4gICNkaXNhYmxlUHJvY2Vzc0l0ZW1zID0gZmFsc2U7XG4gICNmb250SW5zcGVjdG9yRW5hYmxlZCA9ICEhZ2xvYmFsVGhpcy5Gb250SW5zcGVjdG9yPy5lbmFibGVkO1xuICAjbGFuZyA9IG51bGw7XG4gICNsYXlvdXRUZXh0UGFyYW1zID0gbnVsbDtcbiAgI3BhZ2VIZWlnaHQgPSAwO1xuICAjcGFnZVdpZHRoID0gMDtcbiAgI3JlYWRlciA9IG51bGw7XG4gICNyb290Q29udGFpbmVyID0gbnVsbDtcbiAgI3JvdGF0aW9uID0gMDtcbiAgI3NjYWxlID0gMDtcbiAgI3N0eWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAjdGV4dENvbnRlbnRJdGVtc1N0ciA9IFtdO1xuICAjdGV4dENvbnRlbnRTb3VyY2UgPSBudWxsO1xuICAjdGV4dERpdnMgPSBbXTtcbiAgI3RleHREaXZQcm9wZXJ0aWVzID0gbmV3IFdlYWtNYXAoKTtcbiAgI3RyYW5zZm9ybSA9IG51bGw7XG4gIHN0YXRpYyAjYXNjZW50Q2FjaGUgPSBuZXcgTWFwKCk7XG4gIHN0YXRpYyAjY2FudmFzQ29udGV4dHMgPSBuZXcgTWFwKCk7XG4gIHN0YXRpYyAjY2FudmFzQ3R4Rm9udHMgPSBuZXcgV2Vha01hcCgpO1xuICBzdGF0aWMgI21pbkZvbnRTaXplID0gbnVsbDtcbiAgc3RhdGljICNwZW5kaW5nVGV4dExheWVycyA9IG5ldyBTZXQoKTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHRleHRDb250ZW50U291cmNlLFxuICAgIGNvbnRhaW5lcixcbiAgICB2aWV3cG9ydFxuICB9KSB7XG4gICAgaWYgKHRleHRDb250ZW50U291cmNlIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICAgIHRoaXMuI3RleHRDb250ZW50U291cmNlID0gdGV4dENvbnRlbnRTb3VyY2U7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGV4dENvbnRlbnRTb3VyY2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRoaXMuI3RleHRDb250ZW50U291cmNlID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0Q29udGVudFNvdXJjZSk7XG4gICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBcInRleHRDb250ZW50U291cmNlXCIgcGFyYW1ldGVyIHNwZWNpZmllZC4nKTtcbiAgICB9XG4gICAgdGhpcy4jY29udGFpbmVyID0gdGhpcy4jcm9vdENvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLiNzY2FsZSA9IHZpZXdwb3J0LnNjYWxlICogT3V0cHV0U2NhbGUucGl4ZWxSYXRpbztcbiAgICB0aGlzLiNyb3RhdGlvbiA9IHZpZXdwb3J0LnJvdGF0aW9uO1xuICAgIHRoaXMuI2xheW91dFRleHRQYXJhbXMgPSB7XG4gICAgICBkaXY6IG51bGwsXG4gICAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgICAgY3R4OiBudWxsXG4gICAgfTtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0LFxuICAgICAgcGFnZVgsXG4gICAgICBwYWdlWVxuICAgIH0gPSB2aWV3cG9ydC5yYXdEaW1zO1xuICAgIHRoaXMuI3RyYW5zZm9ybSA9IFsxLCAwLCAwLCAtMSwgLXBhZ2VYLCBwYWdlWSArIHBhZ2VIZWlnaHRdO1xuICAgIHRoaXMuI3BhZ2VXaWR0aCA9IHBhZ2VXaWR0aDtcbiAgICB0aGlzLiNwYWdlSGVpZ2h0ID0gcGFnZUhlaWdodDtcbiAgICBUZXh0TGF5ZXIuI2Vuc3VyZU1pbkZvbnRTaXplQ29tcHV0ZWQoKTtcbiAgICBzZXRMYXllckRpbWVuc2lvbnMoY29udGFpbmVyLCB2aWV3cG9ydCk7XG4gICAgdGhpcy4jY2FwYWJpbGl0eS5wcm9taXNlLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgVGV4dExheWVyLiNwZW5kaW5nVGV4dExheWVycy5kZWxldGUodGhpcyk7XG4gICAgICB0aGlzLiNsYXlvdXRUZXh0UGFyYW1zID0gbnVsbDtcbiAgICAgIHRoaXMuI3N0eWxlQ2FjaGUgPSBudWxsO1xuICAgIH0pLmNhdGNoKCgpID0+IHt9KTtcbiAgfVxuICBzdGF0aWMgZ2V0IGZvbnRGYW1pbHlNYXAoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNXaW5kb3dzLFxuICAgICAgaXNGaXJlZm94XG4gICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImZvbnRGYW1pbHlNYXBcIiwgbmV3IE1hcChbW1wic2Fucy1zZXJpZlwiLCBgJHtpc1dpbmRvd3MgJiYgaXNGaXJlZm94ID8gXCJDYWxpYnJpLCBcIiA6IFwiXCJ9c2Fucy1zZXJpZmBdLCBbXCJtb25vc3BhY2VcIiwgYCR7aXNXaW5kb3dzICYmIGlzRmlyZWZveCA/IFwiTHVjaWRhIENvbnNvbGUsIFwiIDogXCJcIn1tb25vc3BhY2VgXV0pKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgcHVtcCA9ICgpID0+IHtcbiAgICAgIHRoaXMuI3JlYWRlci5yZWFkKCkudGhlbigoe1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZG9uZVxuICAgICAgfSkgPT4ge1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIHRoaXMuI2NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNsYW5nID8/PSB2YWx1ZS5sYW5nO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuI3N0eWxlQ2FjaGUsIHZhbHVlLnN0eWxlcyk7XG4gICAgICAgIHRoaXMuI3Byb2Nlc3NJdGVtcyh2YWx1ZS5pdGVtcyk7XG4gICAgICAgIHB1bXAoKTtcbiAgICAgIH0sIHRoaXMuI2NhcGFiaWxpdHkucmVqZWN0KTtcbiAgICB9O1xuICAgIHRoaXMuI3JlYWRlciA9IHRoaXMuI3RleHRDb250ZW50U291cmNlLmdldFJlYWRlcigpO1xuICAgIFRleHRMYXllci4jcGVuZGluZ1RleHRMYXllcnMuYWRkKHRoaXMpO1xuICAgIHB1bXAoKTtcbiAgICByZXR1cm4gdGhpcy4jY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIHVwZGF0ZSh7XG4gICAgdmlld3BvcnQsXG4gICAgb25CZWZvcmUgPSBudWxsXG4gIH0pIHtcbiAgICBjb25zdCBzY2FsZSA9IHZpZXdwb3J0LnNjYWxlICogT3V0cHV0U2NhbGUucGl4ZWxSYXRpbztcbiAgICBjb25zdCByb3RhdGlvbiA9IHZpZXdwb3J0LnJvdGF0aW9uO1xuICAgIGlmIChyb3RhdGlvbiAhPT0gdGhpcy4jcm90YXRpb24pIHtcbiAgICAgIG9uQmVmb3JlPy4oKTtcbiAgICAgIHRoaXMuI3JvdGF0aW9uID0gcm90YXRpb247XG4gICAgICBzZXRMYXllckRpbWVuc2lvbnModGhpcy4jcm9vdENvbnRhaW5lciwge1xuICAgICAgICByb3RhdGlvblxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2FsZSAhPT0gdGhpcy4jc2NhbGUpIHtcbiAgICAgIG9uQmVmb3JlPy4oKTtcbiAgICAgIHRoaXMuI3NjYWxlID0gc2NhbGU7XG4gICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIGRpdjogbnVsbCxcbiAgICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgICAgY3R4OiBUZXh0TGF5ZXIuI2dldEN0eCh0aGlzLiNsYW5nKVxuICAgICAgfTtcbiAgICAgIGZvciAoY29uc3QgZGl2IG9mIHRoaXMuI3RleHREaXZzKSB7XG4gICAgICAgIHBhcmFtcy5wcm9wZXJ0aWVzID0gdGhpcy4jdGV4dERpdlByb3BlcnRpZXMuZ2V0KGRpdik7XG4gICAgICAgIHBhcmFtcy5kaXYgPSBkaXY7XG4gICAgICAgIHRoaXMuI2xheW91dChwYXJhbXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYW5jZWwoKSB7XG4gICAgY29uc3QgYWJvcnRFeCA9IG5ldyBBYm9ydEV4Y2VwdGlvbihcIlRleHRMYXllciB0YXNrIGNhbmNlbGxlZC5cIik7XG4gICAgdGhpcy4jcmVhZGVyPy5jYW5jZWwoYWJvcnRFeCkuY2F0Y2goKCkgPT4ge30pO1xuICAgIHRoaXMuI3JlYWRlciA9IG51bGw7XG4gICAgdGhpcy4jY2FwYWJpbGl0eS5yZWplY3QoYWJvcnRFeCk7XG4gIH1cbiAgZ2V0IHRleHREaXZzKCkge1xuICAgIHJldHVybiB0aGlzLiN0ZXh0RGl2cztcbiAgfVxuICBnZXQgdGV4dENvbnRlbnRJdGVtc1N0cigpIHtcbiAgICByZXR1cm4gdGhpcy4jdGV4dENvbnRlbnRJdGVtc1N0cjtcbiAgfVxuICAjcHJvY2Vzc0l0ZW1zKGl0ZW1zKSB7XG4gICAgaWYgKHRoaXMuI2Rpc2FibGVQcm9jZXNzSXRlbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jbGF5b3V0VGV4dFBhcmFtcy5jdHggPz89IFRleHRMYXllci4jZ2V0Q3R4KHRoaXMuI2xhbmcpO1xuICAgIGNvbnN0IHRleHREaXZzID0gdGhpcy4jdGV4dERpdnMsXG4gICAgICB0ZXh0Q29udGVudEl0ZW1zU3RyID0gdGhpcy4jdGV4dENvbnRlbnRJdGVtc1N0cjtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgIGlmICh0ZXh0RGl2cy5sZW5ndGggPiBNQVhfVEVYVF9ESVZTX1RPX1JFTkRFUikge1xuICAgICAgICB3YXJuKFwiSWdub3JpbmcgYWRkaXRpb25hbCB0ZXh0RGl2cyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cIik7XG4gICAgICAgIHRoaXMuI2Rpc2FibGVQcm9jZXNzSXRlbXMgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXRlbS5zdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXRlbS50eXBlID09PSBcImJlZ2luTWFya2VkQ29udGVudFByb3BzXCIgfHwgaXRlbS50eXBlID09PSBcImJlZ2luTWFya2VkQ29udGVudFwiKSB7XG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy4jY29udGFpbmVyO1xuICAgICAgICAgIHRoaXMuI2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgIHRoaXMuI2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibWFya2VkQ29udGVudFwiKTtcbiAgICAgICAgICBpZiAoaXRlbS5pZCkge1xuICAgICAgICAgICAgdGhpcy4jY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImlkXCIsIGAke2l0ZW0uaWR9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudC5hcHBlbmQodGhpcy4jY29udGFpbmVyKTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtLnR5cGUgPT09IFwiZW5kTWFya2VkQ29udGVudFwiKSB7XG4gICAgICAgICAgdGhpcy4jY29udGFpbmVyID0gdGhpcy4jY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0ZXh0Q29udGVudEl0ZW1zU3RyLnB1c2goaXRlbS5zdHIpO1xuICAgICAgdGhpcy4jYXBwZW5kVGV4dChpdGVtKTtcbiAgICB9XG4gIH1cbiAgI2FwcGVuZFRleHQoZ2VvbSkge1xuICAgIGNvbnN0IHRleHREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBjb25zdCB0ZXh0RGl2UHJvcGVydGllcyA9IHtcbiAgICAgIGFuZ2xlOiAwLFxuICAgICAgY2FudmFzV2lkdGg6IDAsXG4gICAgICBoYXNUZXh0OiBnZW9tLnN0ciAhPT0gXCJcIixcbiAgICAgIGhhc0VPTDogZ2VvbS5oYXNFT0wsXG4gICAgICBmb250U2l6ZTogMFxuICAgIH07XG4gICAgdGhpcy4jdGV4dERpdnMucHVzaCh0ZXh0RGl2KTtcbiAgICBjb25zdCB0eCA9IFV0aWwudHJhbnNmb3JtKHRoaXMuI3RyYW5zZm9ybSwgZ2VvbS50cmFuc2Zvcm0pO1xuICAgIGxldCBhbmdsZSA9IE1hdGguYXRhbjIodHhbMV0sIHR4WzBdKTtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuI3N0eWxlQ2FjaGVbZ2VvbS5mb250TmFtZV07XG4gICAgaWYgKHN0eWxlLnZlcnRpY2FsKSB7XG4gICAgICBhbmdsZSArPSBNYXRoLlBJIC8gMjtcbiAgICB9XG4gICAgbGV0IGZvbnRGYW1pbHkgPSB0aGlzLiNmb250SW5zcGVjdG9yRW5hYmxlZCAmJiBzdHlsZS5mb250U3Vic3RpdHV0aW9uIHx8IHN0eWxlLmZvbnRGYW1pbHk7XG4gICAgZm9udEZhbWlseSA9IFRleHRMYXllci5mb250RmFtaWx5TWFwLmdldChmb250RmFtaWx5KSB8fCBmb250RmFtaWx5O1xuICAgIGNvbnN0IGZvbnRIZWlnaHQgPSBNYXRoLmh5cG90KHR4WzJdLCB0eFszXSk7XG4gICAgY29uc3QgZm9udEFzY2VudCA9IGZvbnRIZWlnaHQgKiBUZXh0TGF5ZXIuI2dldEFzY2VudChmb250RmFtaWx5LCBzdHlsZSwgdGhpcy4jbGFuZyk7XG4gICAgbGV0IGxlZnQsIHRvcDtcbiAgICBpZiAoYW5nbGUgPT09IDApIHtcbiAgICAgIGxlZnQgPSB0eFs0XTtcbiAgICAgIHRvcCA9IHR4WzVdIC0gZm9udEFzY2VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IHR4WzRdICsgZm9udEFzY2VudCAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgIHRvcCA9IHR4WzVdIC0gZm9udEFzY2VudCAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICB9XG4gICAgY29uc3Qgc2NhbGVGYWN0b3JTdHIgPSBcImNhbGModmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSAqXCI7XG4gICAgY29uc3QgZGl2U3R5bGUgPSB0ZXh0RGl2LnN0eWxlO1xuICAgIGlmICh0aGlzLiNjb250YWluZXIgPT09IHRoaXMuI3Jvb3RDb250YWluZXIpIHtcbiAgICAgIGRpdlN0eWxlLmxlZnQgPSBgJHsoMTAwICogbGVmdCAvIHRoaXMuI3BhZ2VXaWR0aCkudG9GaXhlZCgyKX0lYDtcbiAgICAgIGRpdlN0eWxlLnRvcCA9IGAkeygxMDAgKiB0b3AgLyB0aGlzLiNwYWdlSGVpZ2h0KS50b0ZpeGVkKDIpfSVgO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXZTdHlsZS5sZWZ0ID0gYCR7c2NhbGVGYWN0b3JTdHJ9JHtsZWZ0LnRvRml4ZWQoMil9cHgpYDtcbiAgICAgIGRpdlN0eWxlLnRvcCA9IGAke3NjYWxlRmFjdG9yU3RyfSR7dG9wLnRvRml4ZWQoMil9cHgpYDtcbiAgICB9XG4gICAgZGl2U3R5bGUuZm9udFNpemUgPSBgJHtzY2FsZUZhY3RvclN0cn0keyhUZXh0TGF5ZXIuI21pbkZvbnRTaXplICogZm9udEhlaWdodCkudG9GaXhlZCgyKX1weClgO1xuICAgIGRpdlN0eWxlLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgIHRleHREaXZQcm9wZXJ0aWVzLmZvbnRTaXplID0gZm9udEhlaWdodDtcbiAgICB0ZXh0RGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIik7XG4gICAgdGV4dERpdi50ZXh0Q29udGVudCA9IGdlb20uc3RyO1xuICAgIHRleHREaXYuZGlyID0gZ2VvbS5kaXI7XG4gICAgaWYgKHRoaXMuI2ZvbnRJbnNwZWN0b3JFbmFibGVkKSB7XG4gICAgICB0ZXh0RGl2LmRhdGFzZXQuZm9udE5hbWUgPSBzdHlsZS5mb250U3Vic3RpdHV0aW9uTG9hZGVkTmFtZSB8fCBnZW9tLmZvbnROYW1lO1xuICAgIH1cbiAgICBpZiAoYW5nbGUgIT09IDApIHtcbiAgICAgIHRleHREaXZQcm9wZXJ0aWVzLmFuZ2xlID0gYW5nbGUgKiAoMTgwIC8gTWF0aC5QSSk7XG4gICAgfVxuICAgIGxldCBzaG91bGRTY2FsZVRleHQgPSBmYWxzZTtcbiAgICBpZiAoZ2VvbS5zdHIubGVuZ3RoID4gMSkge1xuICAgICAgc2hvdWxkU2NhbGVUZXh0ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGdlb20uc3RyICE9PSBcIiBcIiAmJiBnZW9tLnRyYW5zZm9ybVswXSAhPT0gZ2VvbS50cmFuc2Zvcm1bM10pIHtcbiAgICAgIGNvbnN0IGFic1NjYWxlWCA9IE1hdGguYWJzKGdlb20udHJhbnNmb3JtWzBdKSxcbiAgICAgICAgYWJzU2NhbGVZID0gTWF0aC5hYnMoZ2VvbS50cmFuc2Zvcm1bM10pO1xuICAgICAgaWYgKGFic1NjYWxlWCAhPT0gYWJzU2NhbGVZICYmIE1hdGgubWF4KGFic1NjYWxlWCwgYWJzU2NhbGVZKSAvIE1hdGgubWluKGFic1NjYWxlWCwgYWJzU2NhbGVZKSA+IDEuNSkge1xuICAgICAgICBzaG91bGRTY2FsZVRleHQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2hvdWxkU2NhbGVUZXh0KSB7XG4gICAgICB0ZXh0RGl2UHJvcGVydGllcy5jYW52YXNXaWR0aCA9IHN0eWxlLnZlcnRpY2FsID8gZ2VvbS5oZWlnaHQgOiBnZW9tLndpZHRoO1xuICAgIH1cbiAgICB0aGlzLiN0ZXh0RGl2UHJvcGVydGllcy5zZXQodGV4dERpdiwgdGV4dERpdlByb3BlcnRpZXMpO1xuICAgIHRoaXMuI2xheW91dFRleHRQYXJhbXMuZGl2ID0gdGV4dERpdjtcbiAgICB0aGlzLiNsYXlvdXRUZXh0UGFyYW1zLnByb3BlcnRpZXMgPSB0ZXh0RGl2UHJvcGVydGllcztcbiAgICB0aGlzLiNsYXlvdXQodGhpcy4jbGF5b3V0VGV4dFBhcmFtcyk7XG4gICAgaWYgKHRleHREaXZQcm9wZXJ0aWVzLmhhc1RleHQpIHtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5hcHBlbmQodGV4dERpdik7XG4gICAgfVxuICAgIGlmICh0ZXh0RGl2UHJvcGVydGllcy5oYXNFT0wpIHtcbiAgICAgIGNvbnN0IGJyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpO1xuICAgICAgYnIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5hcHBlbmQoYnIpO1xuICAgIH1cbiAgfVxuICAjbGF5b3V0KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpdixcbiAgICAgIHByb3BlcnRpZXMsXG4gICAgICBjdHhcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGRpdjtcbiAgICBsZXQgdHJhbnNmb3JtID0gXCJcIjtcbiAgICBpZiAoVGV4dExheWVyLiNtaW5Gb250U2l6ZSA+IDEpIHtcbiAgICAgIHRyYW5zZm9ybSA9IGBzY2FsZSgkezEgLyBUZXh0TGF5ZXIuI21pbkZvbnRTaXplfSlgO1xuICAgIH1cbiAgICBpZiAocHJvcGVydGllcy5jYW52YXNXaWR0aCAhPT0gMCAmJiBwcm9wZXJ0aWVzLmhhc1RleHQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZm9udEZhbWlseVxuICAgICAgfSA9IHN0eWxlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjYW52YXNXaWR0aCxcbiAgICAgICAgZm9udFNpemVcbiAgICAgIH0gPSBwcm9wZXJ0aWVzO1xuICAgICAgVGV4dExheWVyLiNlbnN1cmVDdHhGb250KGN0eCwgZm9udFNpemUgKiB0aGlzLiNzY2FsZSwgZm9udEZhbWlseSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoXG4gICAgICB9ID0gY3R4Lm1lYXN1cmVUZXh0KGRpdi50ZXh0Q29udGVudCk7XG4gICAgICBpZiAod2lkdGggPiAwKSB7XG4gICAgICAgIHRyYW5zZm9ybSA9IGBzY2FsZVgoJHtjYW52YXNXaWR0aCAqIHRoaXMuI3NjYWxlIC8gd2lkdGh9KSAke3RyYW5zZm9ybX1gO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcGVydGllcy5hbmdsZSAhPT0gMCkge1xuICAgICAgdHJhbnNmb3JtID0gYHJvdGF0ZSgke3Byb3BlcnRpZXMuYW5nbGV9ZGVnKSAke3RyYW5zZm9ybX1gO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGNsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuI3BlbmRpbmdUZXh0TGF5ZXJzLnNpemUgPiAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FzY2VudENhY2hlLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBjYW52YXNcbiAgICB9IG9mIHRoaXMuI2NhbnZhc0NvbnRleHRzLnZhbHVlcygpKSB7XG4gICAgICBjYW52YXMucmVtb3ZlKCk7XG4gICAgfVxuICAgIHRoaXMuI2NhbnZhc0NvbnRleHRzLmNsZWFyKCk7XG4gIH1cbiAgc3RhdGljICNnZXRDdHgobGFuZyA9IG51bGwpIHtcbiAgICBsZXQgY3R4ID0gdGhpcy4jY2FudmFzQ29udGV4dHMuZ2V0KGxhbmcgfHw9IFwiXCIpO1xuICAgIGlmICghY3R4KSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgY2FudmFzLmNsYXNzTmFtZSA9IFwiaGlkZGVuQ2FudmFzRWxlbWVudFwiO1xuICAgICAgY2FudmFzLmxhbmcgPSBsYW5nO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoY2FudmFzKTtcbiAgICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgICBhbHBoYTogZmFsc2UsXG4gICAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLiNjYW52YXNDb250ZXh0cy5zZXQobGFuZywgY3R4KTtcbiAgICAgIHRoaXMuI2NhbnZhc0N0eEZvbnRzLnNldChjdHgsIHtcbiAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgZmFtaWx5OiBcIlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGN0eDtcbiAgfVxuICBzdGF0aWMgI2Vuc3VyZUN0eEZvbnQoY3R4LCBzaXplLCBmYW1pbHkpIHtcbiAgICBjb25zdCBjYWNoZWQgPSB0aGlzLiNjYW52YXNDdHhGb250cy5nZXQoY3R4KTtcbiAgICBpZiAoc2l6ZSA9PT0gY2FjaGVkLnNpemUgJiYgZmFtaWx5ID09PSBjYWNoZWQuZmFtaWx5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN0eC5mb250ID0gYCR7c2l6ZX1weCAke2ZhbWlseX1gO1xuICAgIGNhY2hlZC5zaXplID0gc2l6ZTtcbiAgICBjYWNoZWQuZmFtaWx5ID0gZmFtaWx5O1xuICB9XG4gIHN0YXRpYyAjZW5zdXJlTWluRm9udFNpemVDb21wdXRlZCgpIHtcbiAgICBpZiAodGhpcy4jbWluRm9udFNpemUgIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgZGl2LnN0eWxlLmxpbmVIZWlnaHQgPSAxO1xuICAgIGRpdi5zdHlsZS5mb250U2l6ZSA9IFwiMXB4XCI7XG4gICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIGRpdi50ZXh0Q29udGVudCA9IFwiWFwiO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKGRpdik7XG4gICAgdGhpcy4jbWluRm9udFNpemUgPSBkaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgIGRpdi5yZW1vdmUoKTtcbiAgfVxuICBzdGF0aWMgI2dldEFzY2VudChmb250RmFtaWx5LCBzdHlsZSwgbGFuZykge1xuICAgIGNvbnN0IGNhY2hlZEFzY2VudCA9IHRoaXMuI2FzY2VudENhY2hlLmdldChmb250RmFtaWx5KTtcbiAgICBpZiAoY2FjaGVkQXNjZW50KSB7XG4gICAgICByZXR1cm4gY2FjaGVkQXNjZW50O1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLiNnZXRDdHgobGFuZyk7XG4gICAgY3R4LmNhbnZhcy53aWR0aCA9IGN0eC5jYW52YXMuaGVpZ2h0ID0gREVGQVVMVF9GT05UX1NJWkU7XG4gICAgdGhpcy4jZW5zdXJlQ3R4Rm9udChjdHgsIERFRkFVTFRfRk9OVF9TSVpFLCBmb250RmFtaWx5KTtcbiAgICBjb25zdCBtZXRyaWNzID0gY3R4Lm1lYXN1cmVUZXh0KFwiXCIpO1xuICAgIGNvbnN0IGFzY2VudCA9IG1ldHJpY3MuZm9udEJvdW5kaW5nQm94QXNjZW50O1xuICAgIGNvbnN0IGRlc2NlbnQgPSBNYXRoLmFicyhtZXRyaWNzLmZvbnRCb3VuZGluZ0JveERlc2NlbnQpO1xuICAgIGN0eC5jYW52YXMud2lkdGggPSBjdHguY2FudmFzLmhlaWdodCA9IDA7XG4gICAgbGV0IHJhdGlvID0gMC44O1xuICAgIGlmIChhc2NlbnQpIHtcbiAgICAgIHJhdGlvID0gYXNjZW50IC8gKGFzY2VudCArIGRlc2NlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybS5pc0ZpcmVmb3gpIHtcbiAgICAgICAgd2FybihcIkVuYWJsZSB0aGUgYGRvbS50ZXh0TWV0cmljcy5mb250Qm91bmRpbmdCb3guZW5hYmxlZGAgcHJlZmVyZW5jZSBcIiArIFwiaW4gYGFib3V0OmNvbmZpZ2AgdG8gaW1wcm92ZSBUZXh0TGF5ZXIgcmVuZGVyaW5nLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZS5hc2NlbnQpIHtcbiAgICAgICAgcmF0aW8gPSBzdHlsZS5hc2NlbnQ7XG4gICAgICB9IGVsc2UgaWYgKHN0eWxlLmRlc2NlbnQpIHtcbiAgICAgICAgcmF0aW8gPSAxICsgc3R5bGUuZGVzY2VudDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jYXNjZW50Q2FjaGUuc2V0KGZvbnRGYW1pbHksIHJhdGlvKTtcbiAgICByZXR1cm4gcmF0aW87XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkveGZhX3RleHQuanNcbmNsYXNzIFhmYVRleHQge1xuICBzdGF0aWMgdGV4dENvbnRlbnQoeGZhKSB7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICBpdGVtcyxcbiAgICAgIHN0eWxlczogT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIH07XG4gICAgZnVuY3Rpb24gd2Fsayhub2RlKSB7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHN0ciA9IG51bGw7XG4gICAgICBjb25zdCBuYW1lID0gbm9kZS5uYW1lO1xuICAgICAgaWYgKG5hbWUgPT09IFwiI3RleHRcIikge1xuICAgICAgICBzdHIgPSBub2RlLnZhbHVlO1xuICAgICAgfSBlbHNlIGlmICghWGZhVGV4dC5zaG91bGRCdWlsZFRleHQobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChub2RlPy5hdHRyaWJ1dGVzPy50ZXh0Q29udGVudCkge1xuICAgICAgICBzdHIgPSBub2RlLmF0dHJpYnV0ZXMudGV4dENvbnRlbnQ7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudmFsdWUpIHtcbiAgICAgICAgc3RyID0gbm9kZS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIgIT09IG51bGwpIHtcbiAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgc3RyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICB3YWxrKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2Fsayh4ZmEpO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbiAgc3RhdGljIHNob3VsZEJ1aWxkVGV4dChuYW1lKSB7XG4gICAgcmV0dXJuICEobmFtZSA9PT0gXCJ0ZXh0YXJlYVwiIHx8IG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcIm9wdGlvblwiIHx8IG5hbWUgPT09IFwic2VsZWN0XCIpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2FwaS5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY29uc3QgUkVOREVSSU5HX0NBTkNFTExFRF9USU1FT1VUID0gMTAwO1xuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoc3JjID0ge30pIHtcbiAgaWYgKHR5cGVvZiBzcmMgPT09IFwic3RyaW5nXCIgfHwgc3JjIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgc3JjID0ge1xuICAgICAgdXJsOiBzcmNcbiAgICB9O1xuICB9IGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhzcmMpKSB7XG4gICAgc3JjID0ge1xuICAgICAgZGF0YTogc3JjXG4gICAgfTtcbiAgfVxuICBjb25zdCB0YXNrID0gbmV3IFBERkRvY3VtZW50TG9hZGluZ1Rhc2soKTtcbiAgY29uc3Qge1xuICAgIGRvY0lkXG4gIH0gPSB0YXNrO1xuICBjb25zdCB1cmwgPSBzcmMudXJsID8gZ2V0VXJsUHJvcChzcmMudXJsKSA6IG51bGw7XG4gIGNvbnN0IGRhdGEgPSBzcmMuZGF0YSA/IGdldERhdGFQcm9wKHNyYy5kYXRhKSA6IG51bGw7XG4gIGNvbnN0IGh0dHBIZWFkZXJzID0gc3JjLmh0dHBIZWFkZXJzIHx8IG51bGw7XG4gIGNvbnN0IHdpdGhDcmVkZW50aWFscyA9IHNyYy53aXRoQ3JlZGVudGlhbHMgPT09IHRydWU7XG4gIGNvbnN0IHBhc3N3b3JkID0gc3JjLnBhc3N3b3JkID8/IG51bGw7XG4gIGNvbnN0IHJhbmdlVHJhbnNwb3J0ID0gc3JjLnJhbmdlIGluc3RhbmNlb2YgUERGRGF0YVJhbmdlVHJhbnNwb3J0ID8gc3JjLnJhbmdlIDogbnVsbDtcbiAgY29uc3QgcmFuZ2VDaHVua1NpemUgPSBOdW1iZXIuaXNJbnRlZ2VyKHNyYy5yYW5nZUNodW5rU2l6ZSkgJiYgc3JjLnJhbmdlQ2h1bmtTaXplID4gMCA/IHNyYy5yYW5nZUNodW5rU2l6ZSA6IDIgKiogMTY7XG4gIGxldCB3b3JrZXIgPSBzcmMud29ya2VyIGluc3RhbmNlb2YgUERGV29ya2VyID8gc3JjLndvcmtlciA6IG51bGw7XG4gIGNvbnN0IHZlcmJvc2l0eSA9IHNyYy52ZXJib3NpdHk7XG4gIGNvbnN0IGRvY0Jhc2VVcmwgPSB0eXBlb2Ygc3JjLmRvY0Jhc2VVcmwgPT09IFwic3RyaW5nXCIgJiYgIWlzRGF0YVNjaGVtZShzcmMuZG9jQmFzZVVybCkgPyBzcmMuZG9jQmFzZVVybCA6IG51bGw7XG4gIGNvbnN0IGNNYXBVcmwgPSBnZXRGYWN0b3J5VXJsUHJvcChzcmMuY01hcFVybCk7XG4gIGNvbnN0IGNNYXBQYWNrZWQgPSBzcmMuY01hcFBhY2tlZCAhPT0gZmFsc2U7XG4gIGNvbnN0IENNYXBSZWFkZXJGYWN0b3J5ID0gc3JjLkNNYXBSZWFkZXJGYWN0b3J5IHx8IChpc05vZGVKUyA/IE5vZGVDTWFwUmVhZGVyRmFjdG9yeSA6IERPTUNNYXBSZWFkZXJGYWN0b3J5KTtcbiAgY29uc3QgaWNjVXJsID0gZ2V0RmFjdG9yeVVybFByb3Aoc3JjLmljY1VybCk7XG4gIGNvbnN0IHN0YW5kYXJkRm9udERhdGFVcmwgPSBnZXRGYWN0b3J5VXJsUHJvcChzcmMuc3RhbmRhcmRGb250RGF0YVVybCk7XG4gIGNvbnN0IFN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gc3JjLlN0YW5kYXJkRm9udERhdGFGYWN0b3J5IHx8IChpc05vZGVKUyA/IE5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA6IERPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5KTtcbiAgY29uc3Qgd2FzbVVybCA9IGdldEZhY3RvcnlVcmxQcm9wKHNyYy53YXNtVXJsKTtcbiAgY29uc3QgV2FzbUZhY3RvcnkgPSBzcmMuV2FzbUZhY3RvcnkgfHwgKGlzTm9kZUpTID8gTm9kZVdhc21GYWN0b3J5IDogRE9NV2FzbUZhY3RvcnkpO1xuICBjb25zdCBpZ25vcmVFcnJvcnMgPSBzcmMuc3RvcEF0RXJyb3JzICE9PSB0cnVlO1xuICBjb25zdCBtYXhJbWFnZVNpemUgPSBOdW1iZXIuaXNJbnRlZ2VyKHNyYy5tYXhJbWFnZVNpemUpICYmIHNyYy5tYXhJbWFnZVNpemUgPiAtMSA/IHNyYy5tYXhJbWFnZVNpemUgOiAtMTtcbiAgY29uc3QgaXNFdmFsU3VwcG9ydGVkID0gc3JjLmlzRXZhbFN1cHBvcnRlZCAhPT0gZmFsc2U7XG4gIGNvbnN0IGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkID0gdHlwZW9mIHNyYy5pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCA9PT0gXCJib29sZWFuXCIgPyBzcmMuaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQgOiAhaXNOb2RlSlM7XG4gIGNvbnN0IGlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkID0gdHlwZW9mIHNyYy5pc0ltYWdlRGVjb2RlclN1cHBvcnRlZCA9PT0gXCJib29sZWFuXCIgPyBzcmMuaXNJbWFnZURlY29kZXJTdXBwb3J0ZWQgOiAhaXNOb2RlSlMgJiYgKHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm0uaXNGaXJlZm94IHx8ICFnbG9iYWxUaGlzLmNocm9tZSk7XG4gIGNvbnN0IGNhbnZhc01heEFyZWFJbkJ5dGVzID0gTnVtYmVyLmlzSW50ZWdlcihzcmMuY2FudmFzTWF4QXJlYUluQnl0ZXMpID8gc3JjLmNhbnZhc01heEFyZWFJbkJ5dGVzIDogLTE7XG4gIGNvbnN0IGRpc2FibGVGb250RmFjZSA9IHR5cGVvZiBzcmMuZGlzYWJsZUZvbnRGYWNlID09PSBcImJvb2xlYW5cIiA/IHNyYy5kaXNhYmxlRm9udEZhY2UgOiBpc05vZGVKUztcbiAgY29uc3QgZm9udEV4dHJhUHJvcGVydGllcyA9IHNyYy5mb250RXh0cmFQcm9wZXJ0aWVzID09PSB0cnVlO1xuICBjb25zdCBlbmFibGVYZmEgPSBzcmMuZW5hYmxlWGZhID09PSB0cnVlO1xuICBjb25zdCBvd25lckRvY3VtZW50ID0gc3JjLm93bmVyRG9jdW1lbnQgfHwgZ2xvYmFsVGhpcy5kb2N1bWVudDtcbiAgY29uc3QgZGlzYWJsZVJhbmdlID0gc3JjLmRpc2FibGVSYW5nZSA9PT0gdHJ1ZTtcbiAgY29uc3QgZGlzYWJsZVN0cmVhbSA9IHNyYy5kaXNhYmxlU3RyZWFtID09PSB0cnVlO1xuICBjb25zdCBkaXNhYmxlQXV0b0ZldGNoID0gc3JjLmRpc2FibGVBdXRvRmV0Y2ggPT09IHRydWU7XG4gIGNvbnN0IHBkZkJ1ZyA9IHNyYy5wZGZCdWcgPT09IHRydWU7XG4gIGNvbnN0IENhbnZhc0ZhY3RvcnkgPSBzcmMuQ2FudmFzRmFjdG9yeSB8fCAoaXNOb2RlSlMgPyBOb2RlQ2FudmFzRmFjdG9yeSA6IERPTUNhbnZhc0ZhY3RvcnkpO1xuICBjb25zdCBGaWx0ZXJGYWN0b3J5ID0gc3JjLkZpbHRlckZhY3RvcnkgfHwgKGlzTm9kZUpTID8gTm9kZUZpbHRlckZhY3RvcnkgOiBET01GaWx0ZXJGYWN0b3J5KTtcbiAgY29uc3QgZW5hYmxlSFdBID0gc3JjLmVuYWJsZUhXQSA9PT0gdHJ1ZTtcbiAgY29uc3QgdXNlV2FzbSA9IHNyYy51c2VXYXNtICE9PSBmYWxzZTtcbiAgY29uc3QgbGVuZ3RoID0gcmFuZ2VUcmFuc3BvcnQgPyByYW5nZVRyYW5zcG9ydC5sZW5ndGggOiBzcmMubGVuZ3RoID8/IE5hTjtcbiAgY29uc3QgdXNlU3lzdGVtRm9udHMgPSB0eXBlb2Ygc3JjLnVzZVN5c3RlbUZvbnRzID09PSBcImJvb2xlYW5cIiA/IHNyYy51c2VTeXN0ZW1Gb250cyA6ICFpc05vZGVKUyAmJiAhZGlzYWJsZUZvbnRGYWNlO1xuICBjb25zdCB1c2VXb3JrZXJGZXRjaCA9IHR5cGVvZiBzcmMudXNlV29ya2VyRmV0Y2ggPT09IFwiYm9vbGVhblwiID8gc3JjLnVzZVdvcmtlckZldGNoIDogISEoQ01hcFJlYWRlckZhY3RvcnkgPT09IERPTUNNYXBSZWFkZXJGYWN0b3J5ICYmIFN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID09PSBET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSAmJiBXYXNtRmFjdG9yeSA9PT0gRE9NV2FzbUZhY3RvcnkgJiYgY01hcFVybCAmJiBzdGFuZGFyZEZvbnREYXRhVXJsICYmIHdhc21VcmwgJiYgaXNWYWxpZEZldGNoVXJsKGNNYXBVcmwsIGRvY3VtZW50LmJhc2VVUkkpICYmIGlzVmFsaWRGZXRjaFVybChzdGFuZGFyZEZvbnREYXRhVXJsLCBkb2N1bWVudC5iYXNlVVJJKSAmJiBpc1ZhbGlkRmV0Y2hVcmwod2FzbVVybCwgZG9jdW1lbnQuYmFzZVVSSSkpO1xuICBjb25zdCBzdHlsZUVsZW1lbnQgPSBudWxsO1xuICBzZXRWZXJib3NpdHlMZXZlbCh2ZXJib3NpdHkpO1xuICBjb25zdCB0cmFuc3BvcnRGYWN0b3J5ID0ge1xuICAgIGNhbnZhc0ZhY3Rvcnk6IG5ldyBDYW52YXNGYWN0b3J5KHtcbiAgICAgIG93bmVyRG9jdW1lbnQsXG4gICAgICBlbmFibGVIV0FcbiAgICB9KSxcbiAgICBmaWx0ZXJGYWN0b3J5OiBuZXcgRmlsdGVyRmFjdG9yeSh7XG4gICAgICBkb2NJZCxcbiAgICAgIG93bmVyRG9jdW1lbnRcbiAgICB9KSxcbiAgICBjTWFwUmVhZGVyRmFjdG9yeTogdXNlV29ya2VyRmV0Y2ggPyBudWxsIDogbmV3IENNYXBSZWFkZXJGYWN0b3J5KHtcbiAgICAgIGJhc2VVcmw6IGNNYXBVcmwsXG4gICAgICBpc0NvbXByZXNzZWQ6IGNNYXBQYWNrZWRcbiAgICB9KSxcbiAgICBzdGFuZGFyZEZvbnREYXRhRmFjdG9yeTogdXNlV29ya2VyRmV0Y2ggPyBudWxsIDogbmV3IFN0YW5kYXJkRm9udERhdGFGYWN0b3J5KHtcbiAgICAgIGJhc2VVcmw6IHN0YW5kYXJkRm9udERhdGFVcmxcbiAgICB9KSxcbiAgICB3YXNtRmFjdG9yeTogdXNlV29ya2VyRmV0Y2ggPyBudWxsIDogbmV3IFdhc21GYWN0b3J5KHtcbiAgICAgIGJhc2VVcmw6IHdhc21VcmxcbiAgICB9KVxuICB9O1xuICBpZiAoIXdvcmtlcikge1xuICAgIHdvcmtlciA9IFBERldvcmtlci5jcmVhdGUoe1xuICAgICAgdmVyYm9zaXR5LFxuICAgICAgcG9ydDogR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJQb3J0XG4gICAgfSk7XG4gICAgdGFzay5fd29ya2VyID0gd29ya2VyO1xuICB9XG4gIGNvbnN0IGRvY1BhcmFtcyA9IHtcbiAgICBkb2NJZCxcbiAgICBhcGlWZXJzaW9uOiBcIjUuNC4xNDlcIixcbiAgICBkYXRhLFxuICAgIHBhc3N3b3JkLFxuICAgIGRpc2FibGVBdXRvRmV0Y2gsXG4gICAgcmFuZ2VDaHVua1NpemUsXG4gICAgbGVuZ3RoLFxuICAgIGRvY0Jhc2VVcmwsXG4gICAgZW5hYmxlWGZhLFxuICAgIGV2YWx1YXRvck9wdGlvbnM6IHtcbiAgICAgIG1heEltYWdlU2l6ZSxcbiAgICAgIGRpc2FibGVGb250RmFjZSxcbiAgICAgIGlnbm9yZUVycm9ycyxcbiAgICAgIGlzRXZhbFN1cHBvcnRlZCxcbiAgICAgIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkLFxuICAgICAgaXNJbWFnZURlY29kZXJTdXBwb3J0ZWQsXG4gICAgICBjYW52YXNNYXhBcmVhSW5CeXRlcyxcbiAgICAgIGZvbnRFeHRyYVByb3BlcnRpZXMsXG4gICAgICB1c2VTeXN0ZW1Gb250cyxcbiAgICAgIHVzZVdhc20sXG4gICAgICB1c2VXb3JrZXJGZXRjaCxcbiAgICAgIGNNYXBVcmwsXG4gICAgICBpY2NVcmwsXG4gICAgICBzdGFuZGFyZEZvbnREYXRhVXJsLFxuICAgICAgd2FzbVVybFxuICAgIH1cbiAgfTtcbiAgY29uc3QgdHJhbnNwb3J0UGFyYW1zID0ge1xuICAgIG93bmVyRG9jdW1lbnQsXG4gICAgcGRmQnVnLFxuICAgIHN0eWxlRWxlbWVudCxcbiAgICBsb2FkaW5nUGFyYW1zOiB7XG4gICAgICBkaXNhYmxlQXV0b0ZldGNoLFxuICAgICAgZW5hYmxlWGZhXG4gICAgfVxuICB9O1xuICB3b3JrZXIucHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGFzay5kZXN0cm95ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvYWRpbmcgYWJvcnRlZFwiKTtcbiAgICB9XG4gICAgaWYgKHdvcmtlci5kZXN0cm95ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpO1xuICAgIH1cbiAgICBjb25zdCB3b3JrZXJJZFByb21pc2UgPSB3b3JrZXIubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RG9jUmVxdWVzdFwiLCBkb2NQYXJhbXMsIGRhdGEgPyBbZGF0YS5idWZmZXJdIDogbnVsbCk7XG4gICAgbGV0IG5ldHdvcmtTdHJlYW07XG4gICAgaWYgKHJhbmdlVHJhbnNwb3J0KSB7XG4gICAgICBuZXR3b3JrU3RyZWFtID0gbmV3IFBERkRhdGFUcmFuc3BvcnRTdHJlYW0ocmFuZ2VUcmFuc3BvcnQsIHtcbiAgICAgICAgZGlzYWJsZVJhbmdlLFxuICAgICAgICBkaXNhYmxlU3RyZWFtXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFkYXRhKSB7XG4gICAgICBpZiAoIXVybCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXREb2N1bWVudCAtIG5vIGB1cmxgIHBhcmFtZXRlciBwcm92aWRlZC5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBOZXR3b3JrU3RyZWFtID0gaXNWYWxpZEZldGNoVXJsKHVybCkgPyBQREZGZXRjaFN0cmVhbSA6IGlzTm9kZUpTID8gUERGTm9kZVN0cmVhbSA6IFBERk5ldHdvcmtTdHJlYW07XG4gICAgICBuZXR3b3JrU3RyZWFtID0gbmV3IE5ldHdvcmtTdHJlYW0oe1xuICAgICAgICB1cmwsXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgaHR0cEhlYWRlcnMsXG4gICAgICAgIHdpdGhDcmVkZW50aWFscyxcbiAgICAgICAgcmFuZ2VDaHVua1NpemUsXG4gICAgICAgIGRpc2FibGVSYW5nZSxcbiAgICAgICAgZGlzYWJsZVN0cmVhbVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB3b3JrZXJJZFByb21pc2UudGhlbih3b3JrZXJJZCA9PiB7XG4gICAgICBpZiAodGFzay5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9hZGluZyBhYm9ydGVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHdvcmtlci5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcihkb2NJZCwgd29ya2VySWQsIHdvcmtlci5wb3J0KTtcbiAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IG5ldyBXb3JrZXJUcmFuc3BvcnQobWVzc2FnZUhhbmRsZXIsIHRhc2ssIG5ldHdvcmtTdHJlYW0sIHRyYW5zcG9ydFBhcmFtcywgdHJhbnNwb3J0RmFjdG9yeSwgZW5hYmxlSFdBKTtcbiAgICAgIHRhc2suX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLnNlbmQoXCJSZWFkeVwiLCBudWxsKTtcbiAgICB9KTtcbiAgfSkuY2F0Y2godGFzay5fY2FwYWJpbGl0eS5yZWplY3QpO1xuICByZXR1cm4gdGFzaztcbn1cbmNsYXNzIFBERkRvY3VtZW50TG9hZGluZ1Rhc2sge1xuICBzdGF0aWMgI2RvY0lkID0gMDtcbiAgX2NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgX3RyYW5zcG9ydCA9IG51bGw7XG4gIF93b3JrZXIgPSBudWxsO1xuICBkb2NJZCA9IGBkJHtQREZEb2N1bWVudExvYWRpbmdUYXNrLiNkb2NJZCsrfWA7XG4gIGRlc3Ryb3llZCA9IGZhbHNlO1xuICBvblBhc3N3b3JkID0gbnVsbDtcbiAgb25Qcm9ncmVzcyA9IG51bGw7XG4gIGdldCBwcm9taXNlKCkge1xuICAgIHJldHVybiB0aGlzLl9jYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgYXN5bmMgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLl93b3JrZXI/LnBvcnQpIHtcbiAgICAgICAgdGhpcy5fd29ya2VyLl9wZW5kaW5nRGVzdHJveSA9IHRydWU7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLl90cmFuc3BvcnQ/LmRlc3Ryb3koKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKHRoaXMuX3dvcmtlcj8ucG9ydCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fd29ya2VyLl9wZW5kaW5nRGVzdHJveTtcbiAgICAgIH1cbiAgICAgIHRocm93IGV4O1xuICAgIH1cbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMuX3dvcmtlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG4gIH1cbiAgYXN5bmMgZ2V0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERhdGEoKTtcbiAgfVxufVxuY2xhc3MgUERGRGF0YVJhbmdlVHJhbnNwb3J0IHtcbiAgI2NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgI3Byb2dyZXNzaXZlRG9uZUxpc3RlbmVycyA9IFtdO1xuICAjcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzID0gW107XG4gICNwcm9ncmVzc0xpc3RlbmVycyA9IFtdO1xuICAjcmFuZ2VMaXN0ZW5lcnMgPSBbXTtcbiAgY29uc3RydWN0b3IobGVuZ3RoLCBpbml0aWFsRGF0YSwgcHJvZ3Jlc3NpdmVEb25lID0gZmFsc2UsIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gbnVsbCkge1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuaW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICB0aGlzLnByb2dyZXNzaXZlRG9uZSA9IHByb2dyZXNzaXZlRG9uZTtcbiAgICB0aGlzLmNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU7XG4gIH1cbiAgYWRkUmFuZ2VMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuI3JhbmdlTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIGFkZFByb2dyZXNzTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLiNwcm9ncmVzc0xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuICBhZGRQcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuI3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuICBhZGRQcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuI3Byb2dyZXNzaXZlRG9uZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuICBvbkRhdGFSYW5nZShiZWdpbiwgY2h1bmspIHtcbiAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuI3JhbmdlTGlzdGVuZXJzKSB7XG4gICAgICBsaXN0ZW5lcihiZWdpbiwgY2h1bmspO1xuICAgIH1cbiAgfVxuICBvbkRhdGFQcm9ncmVzcyhsb2FkZWQsIHRvdGFsKSB7XG4gICAgdGhpcy4jY2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLiNwcm9ncmVzc0xpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcihsb2FkZWQsIHRvdGFsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBvbkRhdGFQcm9ncmVzc2l2ZVJlYWQoY2h1bmspIHtcbiAgICB0aGlzLiNjYXBhYmlsaXR5LnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuI3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcihjaHVuayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgb25EYXRhUHJvZ3Jlc3NpdmVEb25lKCkge1xuICAgIHRoaXMuI2NhcGFiaWxpdHkucHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy4jcHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdHJhbnNwb3J0UmVhZHkoKSB7XG4gICAgdGhpcy4jY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgcmVxdWVzdERhdGFSYW5nZShiZWdpbiwgZW5kKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgUERGRGF0YVJhbmdlVHJhbnNwb3J0LnJlcXVlc3REYXRhUmFuZ2VcIik7XG4gIH1cbiAgYWJvcnQoKSB7fVxufVxuY2xhc3MgUERGRG9jdW1lbnRQcm94eSB7XG4gIGNvbnN0cnVjdG9yKHBkZkluZm8sIHRyYW5zcG9ydCkge1xuICAgIHRoaXMuX3BkZkluZm8gPSBwZGZJbmZvO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgfVxuICBnZXQgYW5ub3RhdGlvblN0b3JhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgfVxuICBnZXQgY2FudmFzRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmNhbnZhc0ZhY3Rvcnk7XG4gIH1cbiAgZ2V0IGZpbHRlckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5maWx0ZXJGYWN0b3J5O1xuICB9XG4gIGdldCBudW1QYWdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGRmSW5mby5udW1QYWdlcztcbiAgfVxuICBnZXQgZmluZ2VycHJpbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wZGZJbmZvLmZpbmdlcnByaW50cztcbiAgfVxuICBnZXQgaXNQdXJlWGZhKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc1B1cmVYZmFcIiwgISF0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmEpO1xuICB9XG4gIGdldCBhbGxYZmFIdG1sKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmE7XG4gIH1cbiAgZ2V0UGFnZShwYWdlTnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlKHBhZ2VOdW1iZXIpO1xuICB9XG4gIGdldFBhZ2VJbmRleChyZWYpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VJbmRleChyZWYpO1xuICB9XG4gIGdldERlc3RpbmF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERlc3RpbmF0aW9ucygpO1xuICB9XG4gIGdldERlc3RpbmF0aW9uKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREZXN0aW5hdGlvbihpZCk7XG4gIH1cbiAgZ2V0UGFnZUxhYmVscygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VMYWJlbHMoKTtcbiAgfVxuICBnZXRQYWdlTGF5b3V0KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUxheW91dCgpO1xuICB9XG4gIGdldFBhZ2VNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZU1vZGUoKTtcbiAgfVxuICBnZXRWaWV3ZXJQcmVmZXJlbmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFZpZXdlclByZWZlcmVuY2VzKCk7XG4gIH1cbiAgZ2V0T3BlbkFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE9wZW5BY3Rpb24oKTtcbiAgfVxuICBnZXRBdHRhY2htZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldEF0dGFjaG1lbnRzKCk7XG4gIH1cbiAgZ2V0QW5ub3RhdGlvbnNCeVR5cGUodHlwZXMsIHBhZ2VJbmRleGVzVG9Ta2lwKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRBbm5vdGF0aW9uc0J5VHlwZSh0eXBlcywgcGFnZUluZGV4ZXNUb1NraXApO1xuICB9XG4gIGdldEpTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERvY0pTQWN0aW9ucygpO1xuICB9XG4gIGdldE91dGxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRPdXRsaW5lKCk7XG4gIH1cbiAgZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKHtcbiAgICBpbnRlbnQgPSBcImRpc3BsYXlcIlxuICB9ID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICByZW5kZXJpbmdJbnRlbnRcbiAgICB9ID0gdGhpcy5fdHJhbnNwb3J0LmdldFJlbmRlcmluZ0ludGVudChpbnRlbnQpO1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKHJlbmRlcmluZ0ludGVudCk7XG4gIH1cbiAgZ2V0UGVybWlzc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQZXJtaXNzaW9ucygpO1xuICB9XG4gIGdldE1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0TWV0YWRhdGEoKTtcbiAgfVxuICBnZXRNYXJrSW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE1hcmtJbmZvKCk7XG4gIH1cbiAgZ2V0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERhdGEoKTtcbiAgfVxuICBzYXZlRG9jdW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5zYXZlRG9jdW1lbnQoKTtcbiAgfVxuICBnZXREb3dubG9hZEluZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5kb3dubG9hZEluZm9DYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2xlYW51cChrZWVwTG9hZGVkRm9udHMgPSBmYWxzZSkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuc3RhcnRDbGVhbnVwKGtlZXBMb2FkZWRGb250cyB8fCB0aGlzLmlzUHVyZVhmYSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkaW5nVGFzay5kZXN0cm95KCk7XG4gIH1cbiAgY2FjaGVkUGFnZU51bWJlcihyZWYpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmNhY2hlZFBhZ2VOdW1iZXIocmVmKTtcbiAgfVxuICBnZXQgbG9hZGluZ1BhcmFtcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmxvYWRpbmdQYXJhbXM7XG4gIH1cbiAgZ2V0IGxvYWRpbmdUYXNrKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQubG9hZGluZ1Rhc2s7XG4gIH1cbiAgZ2V0RmllbGRPYmplY3RzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RmllbGRPYmplY3RzKCk7XG4gIH1cbiAgaGFzSlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuaGFzSlNBY3Rpb25zKCk7XG4gIH1cbiAgZ2V0Q2FsY3VsYXRpb25PcmRlcklkcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldENhbGN1bGF0aW9uT3JkZXJJZHMoKTtcbiAgfVxufVxuY2xhc3MgUERGUGFnZVByb3h5IHtcbiAgI3BlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKHBhZ2VJbmRleCwgcGFnZUluZm8sIHRyYW5zcG9ydCwgcGRmQnVnID0gZmFsc2UpIHtcbiAgICB0aGlzLl9wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgdGhpcy5fcGFnZUluZm8gPSBwYWdlSW5mbztcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgdGhpcy5fc3RhdHMgPSBwZGZCdWcgPyBuZXcgU3RhdFRpbWVyKCkgOiBudWxsO1xuICAgIHRoaXMuX3BkZkJ1ZyA9IHBkZkJ1ZztcbiAgICB0aGlzLmNvbW1vbk9ianMgPSB0cmFuc3BvcnQuY29tbW9uT2JqcztcbiAgICB0aGlzLm9ianMgPSBuZXcgUERGT2JqZWN0cygpO1xuICAgIHRoaXMuX2ludGVudFN0YXRlcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMucmVjb3JkZWRHcm91cHMgPSBudWxsO1xuICB9XG4gIGdldCBwYWdlTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5kZXggKyAxO1xuICB9XG4gIGdldCByb3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnJvdGF0ZTtcbiAgfVxuICBnZXQgcmVmKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby5yZWY7XG4gIH1cbiAgZ2V0IHVzZXJVbml0KCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby51c2VyVW5pdDtcbiAgfVxuICBnZXQgdmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZm8udmlldztcbiAgfVxuICBnZXRWaWV3cG9ydCh7XG4gICAgc2NhbGUsXG4gICAgcm90YXRpb24gPSB0aGlzLnJvdGF0ZSxcbiAgICBvZmZzZXRYID0gMCxcbiAgICBvZmZzZXRZID0gMCxcbiAgICBkb250RmxpcCA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHJldHVybiBuZXcgUGFnZVZpZXdwb3J0KHtcbiAgICAgIHZpZXdCb3g6IHRoaXMudmlldyxcbiAgICAgIHVzZXJVbml0OiB0aGlzLnVzZXJVbml0LFxuICAgICAgc2NhbGUsXG4gICAgICByb3RhdGlvbixcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZLFxuICAgICAgZG9udEZsaXBcbiAgICB9KTtcbiAgfVxuICBnZXRBbm5vdGF0aW9ucyh7XG4gICAgaW50ZW50ID0gXCJkaXNwbGF5XCJcbiAgfSA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVuZGVyaW5nSW50ZW50XG4gICAgfSA9IHRoaXMuX3RyYW5zcG9ydC5nZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50KTtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldEFubm90YXRpb25zKHRoaXMuX3BhZ2VJbmRleCwgcmVuZGVyaW5nSW50ZW50KTtcbiAgfVxuICBnZXRKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlSlNBY3Rpb25zKHRoaXMuX3BhZ2VJbmRleCk7XG4gIH1cbiAgZ2V0IGZpbHRlckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5maWx0ZXJGYWN0b3J5O1xuICB9XG4gIGdldCBpc1B1cmVYZmEoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzUHVyZVhmYVwiLCAhIXRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYSk7XG4gIH1cbiAgYXN5bmMgZ2V0WGZhKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmE/LmNoaWxkcmVuW3RoaXMuX3BhZ2VJbmRleF0gfHwgbnVsbDtcbiAgfVxuICByZW5kZXIoe1xuICAgIGNhbnZhc0NvbnRleHQsXG4gICAgY2FudmFzID0gY2FudmFzQ29udGV4dC5jYW52YXMsXG4gICAgdmlld3BvcnQsXG4gICAgaW50ZW50ID0gXCJkaXNwbGF5XCIsXG4gICAgYW5ub3RhdGlvbk1vZGUgPSBBbm5vdGF0aW9uTW9kZS5FTkFCTEUsXG4gICAgdHJhbnNmb3JtID0gbnVsbCxcbiAgICBiYWNrZ3JvdW5kID0gbnVsbCxcbiAgICBvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlID0gbnVsbCxcbiAgICBhbm5vdGF0aW9uQ2FudmFzTWFwID0gbnVsbCxcbiAgICBwYWdlQ29sb3JzID0gbnVsbCxcbiAgICBwcmludEFubm90YXRpb25TdG9yYWdlID0gbnVsbCxcbiAgICBpc0VkaXRpbmcgPSBmYWxzZSxcbiAgICByZWNvcmRPcGVyYXRpb25zID0gZmFsc2UsXG4gICAgZmlsdGVyZWRPcGVyYXRpb25JbmRleGVzID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5fc3RhdHM/LnRpbWUoXCJPdmVyYWxsXCIpO1xuICAgIGNvbnN0IGludGVudEFyZ3MgPSB0aGlzLl90cmFuc3BvcnQuZ2V0UmVuZGVyaW5nSW50ZW50KGludGVudCwgYW5ub3RhdGlvbk1vZGUsIHByaW50QW5ub3RhdGlvblN0b3JhZ2UsIGlzRWRpdGluZyk7XG4gICAgY29uc3Qge1xuICAgICAgcmVuZGVyaW5nSW50ZW50LFxuICAgICAgY2FjaGVLZXlcbiAgICB9ID0gaW50ZW50QXJncztcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UgfHw9IHRoaXMuX3RyYW5zcG9ydC5nZXRPcHRpb25hbENvbnRlbnRDb25maWcocmVuZGVyaW5nSW50ZW50KTtcbiAgICBsZXQgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoIWludGVudFN0YXRlKSB7XG4gICAgICBpbnRlbnRTdGF0ZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuc2V0KGNhY2hlS2V5LCBpbnRlbnRTdGF0ZSk7XG4gICAgfVxuICAgIGlmIChpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCk7XG4gICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgaW50ZW50UHJpbnQgPSAhIShyZW5kZXJpbmdJbnRlbnQgJiBSZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UKTtcbiAgICBpZiAoIWludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkpIHtcbiAgICAgIGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCA9IHtcbiAgICAgICAgZm5BcnJheTogW10sXG4gICAgICAgIGFyZ3NBcnJheTogW10sXG4gICAgICAgIGxhc3RDaHVuazogZmFsc2UsXG4gICAgICAgIHNlcGFyYXRlQW5ub3RzOiBudWxsXG4gICAgICB9O1xuICAgICAgdGhpcy5fc3RhdHM/LnRpbWUoXCJQYWdlIFJlcXVlc3RcIik7XG4gICAgICB0aGlzLl9wdW1wT3BlcmF0b3JMaXN0KGludGVudEFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBzaG91bGRSZWNvcmRPcGVyYXRpb25zID0gIXRoaXMucmVjb3JkZWRHcm91cHMgJiYgKHJlY29yZE9wZXJhdGlvbnMgfHwgdGhpcy5fcGRmQnVnICYmIGdsb2JhbFRoaXMuU3RlcHBlck1hbmFnZXI/LmVuYWJsZWQpO1xuICAgIGNvbnN0IGNvbXBsZXRlID0gZXJyb3IgPT4ge1xuICAgICAgaW50ZW50U3RhdGUucmVuZGVyVGFza3MuZGVsZXRlKGludGVybmFsUmVuZGVyVGFzayk7XG4gICAgICBpZiAoc2hvdWxkUmVjb3JkT3BlcmF0aW9ucykge1xuICAgICAgICBjb25zdCByZWNvcmRlZEdyb3VwcyA9IGludGVybmFsUmVuZGVyVGFzay5nZng/LmRlcGVuZGVuY3lUcmFja2VyLnRha2UoKTtcbiAgICAgICAgaWYgKHJlY29yZGVkR3JvdXBzKSB7XG4gICAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLnN0ZXBwZXI/LnNldE9wZXJhdG9yR3JvdXBzKHJlY29yZGVkR3JvdXBzKTtcbiAgICAgICAgICBpZiAocmVjb3JkT3BlcmF0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRlZEdyb3VwcyA9IHJlY29yZGVkR3JvdXBzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmRPcGVyYXRpb25zKSB7XG4gICAgICAgICAgdGhpcy5yZWNvcmRlZEdyb3VwcyA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaW50ZW50UHJpbnQpIHtcbiAgICAgICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy4jdHJ5Q2xlYW51cCgpO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGludGVybmFsUmVuZGVyVGFzay5jYXBhYmlsaXR5LnJlamVjdChlcnJvcik7XG4gICAgICAgIHRoaXMuX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZSxcbiAgICAgICAgICByZWFzb246IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihlcnJvcilcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2suY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc3RhdHMpIHtcbiAgICAgICAgdGhpcy5fc3RhdHMudGltZUVuZChcIlJlbmRlcmluZ1wiKTtcbiAgICAgICAgdGhpcy5fc3RhdHMudGltZUVuZChcIk92ZXJhbGxcIik7XG4gICAgICAgIGlmIChnbG9iYWxUaGlzLlN0YXRzPy5lbmFibGVkKSB7XG4gICAgICAgICAgZ2xvYmFsVGhpcy5TdGF0cy5hZGQodGhpcy5wYWdlTnVtYmVyLCB0aGlzLl9zdGF0cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGludGVybmFsUmVuZGVyVGFzayA9IG5ldyBJbnRlcm5hbFJlbmRlclRhc2soe1xuICAgICAgY2FsbGJhY2s6IGNvbXBsZXRlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGNhbnZhcyxcbiAgICAgICAgY2FudmFzQ29udGV4dCxcbiAgICAgICAgZGVwZW5kZW5jeVRyYWNrZXI6IHNob3VsZFJlY29yZE9wZXJhdGlvbnMgPyBuZXcgQ2FudmFzRGVwZW5kZW5jeVRyYWNrZXIoY2FudmFzKSA6IG51bGwsXG4gICAgICAgIHZpZXdwb3J0LFxuICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgIGJhY2tncm91bmRcbiAgICAgIH0sXG4gICAgICBvYmpzOiB0aGlzLm9ianMsXG4gICAgICBjb21tb25PYmpzOiB0aGlzLmNvbW1vbk9ianMsXG4gICAgICBhbm5vdGF0aW9uQ2FudmFzTWFwLFxuICAgICAgb3BlcmF0b3JMaXN0OiBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMuX3BhZ2VJbmRleCxcbiAgICAgIGNhbnZhc0ZhY3Rvcnk6IHRoaXMuX3RyYW5zcG9ydC5jYW52YXNGYWN0b3J5LFxuICAgICAgZmlsdGVyRmFjdG9yeTogdGhpcy5fdHJhbnNwb3J0LmZpbHRlckZhY3RvcnksXG4gICAgICB1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWU6ICFpbnRlbnRQcmludCxcbiAgICAgIHBkZkJ1ZzogdGhpcy5fcGRmQnVnLFxuICAgICAgcGFnZUNvbG9ycyxcbiAgICAgIGVuYWJsZUhXQTogdGhpcy5fdHJhbnNwb3J0LmVuYWJsZUhXQSxcbiAgICAgIGZpbHRlcmVkT3BlcmF0aW9uSW5kZXhlc1xuICAgIH0pO1xuICAgIChpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcyB8fD0gbmV3IFNldCgpKS5hZGQoaW50ZXJuYWxSZW5kZXJUYXNrKTtcbiAgICBjb25zdCByZW5kZXJUYXNrID0gaW50ZXJuYWxSZW5kZXJUYXNrLnRhc2s7XG4gICAgUHJvbWlzZS5hbGwoW2ludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkucHJvbWlzZSwgb3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZV0pLnRoZW4oKFt0cmFuc3BhcmVuY3ksIG9wdGlvbmFsQ29udGVudENvbmZpZ10pID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9zdGF0cz8udGltZShcIlJlbmRlcmluZ1wiKTtcbiAgICAgIGlmICghKG9wdGlvbmFsQ29udGVudENvbmZpZy5yZW5kZXJpbmdJbnRlbnQgJiByZW5kZXJpbmdJbnRlbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgdXNlIHRoZSBzYW1lIGBpbnRlbnRgLWFyZ3VtZW50IHdoZW4gY2FsbGluZyB0aGUgYFBERlBhZ2VQcm94eS5yZW5kZXJgIFwiICsgXCJhbmQgYFBERkRvY3VtZW50UHJveHkuZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnYCBtZXRob2RzLlwiKTtcbiAgICAgIH1cbiAgICAgIGludGVybmFsUmVuZGVyVGFzay5pbml0aWFsaXplR3JhcGhpY3Moe1xuICAgICAgICB0cmFuc3BhcmVuY3ksXG4gICAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1xuICAgICAgfSk7XG4gICAgICBpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0Q2hhbmdlZCgpO1xuICAgIH0pLmNhdGNoKGNvbXBsZXRlKTtcbiAgICByZXR1cm4gcmVuZGVyVGFzaztcbiAgfVxuICBnZXRPcGVyYXRvckxpc3Qoe1xuICAgIGludGVudCA9IFwiZGlzcGxheVwiLFxuICAgIGFubm90YXRpb25Nb2RlID0gQW5ub3RhdGlvbk1vZGUuRU5BQkxFLFxuICAgIHByaW50QW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsLFxuICAgIGlzRWRpdGluZyA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIGZ1bmN0aW9uIG9wZXJhdG9yTGlzdENoYW5nZWQoKSB7XG4gICAgICBpZiAoaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0Lmxhc3RDaHVuaykge1xuICAgICAgICBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCk7XG4gICAgICAgIGludGVudFN0YXRlLnJlbmRlclRhc2tzLmRlbGV0ZShvcExpc3RUYXNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW50ZW50QXJncyA9IHRoaXMuX3RyYW5zcG9ydC5nZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50LCBhbm5vdGF0aW9uTW9kZSwgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSwgaXNFZGl0aW5nLCB0cnVlKTtcbiAgICBsZXQgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGludGVudEFyZ3MuY2FjaGVLZXkpO1xuICAgIGlmICghaW50ZW50U3RhdGUpIHtcbiAgICAgIGludGVudFN0YXRlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuX2ludGVudFN0YXRlcy5zZXQoaW50ZW50QXJncy5jYWNoZUtleSwgaW50ZW50U3RhdGUpO1xuICAgIH1cbiAgICBsZXQgb3BMaXN0VGFzaztcbiAgICBpZiAoIWludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5KSB7XG4gICAgICBvcExpc3RUYXNrID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIG9wTGlzdFRhc2sub3BlcmF0b3JMaXN0Q2hhbmdlZCA9IG9wZXJhdG9yTGlzdENoYW5nZWQ7XG4gICAgICBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgKGludGVudFN0YXRlLnJlbmRlclRhc2tzIHx8PSBuZXcgU2V0KCkpLmFkZChvcExpc3RUYXNrKTtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCA9IHtcbiAgICAgICAgZm5BcnJheTogW10sXG4gICAgICAgIGFyZ3NBcnJheTogW10sXG4gICAgICAgIGxhc3RDaHVuazogZmFsc2UsXG4gICAgICAgIHNlcGFyYXRlQW5ub3RzOiBudWxsXG4gICAgICB9O1xuICAgICAgdGhpcy5fc3RhdHM/LnRpbWUoXCJQYWdlIFJlcXVlc3RcIik7XG4gICAgICB0aGlzLl9wdW1wT3BlcmF0b3JMaXN0KGludGVudEFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBzdHJlYW1UZXh0Q29udGVudCh7XG4gICAgaW5jbHVkZU1hcmtlZENvbnRlbnQgPSBmYWxzZSxcbiAgICBkaXNhYmxlTm9ybWFsaXphdGlvbiA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IFRFWFRfQ09OVEVOVF9DSFVOS19TSVpFID0gMTAwO1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhTdHJlYW0oXCJHZXRUZXh0Q29udGVudFwiLCB7XG4gICAgICBwYWdlSW5kZXg6IHRoaXMuX3BhZ2VJbmRleCxcbiAgICAgIGluY2x1ZGVNYXJrZWRDb250ZW50OiBpbmNsdWRlTWFya2VkQ29udGVudCA9PT0gdHJ1ZSxcbiAgICAgIGRpc2FibGVOb3JtYWxpemF0aW9uOiBkaXNhYmxlTm9ybWFsaXphdGlvbiA9PT0gdHJ1ZVxuICAgIH0sIHtcbiAgICAgIGhpZ2hXYXRlck1hcms6IFRFWFRfQ09OVEVOVF9DSFVOS19TSVpFLFxuICAgICAgc2l6ZSh0ZXh0Q29udGVudCkge1xuICAgICAgICByZXR1cm4gdGV4dENvbnRlbnQuaXRlbXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldFRleHRDb250ZW50KHBhcmFtcyA9IHt9KSB7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0WGZhKCkudGhlbih4ZmEgPT4gWGZhVGV4dC50ZXh0Q29udGVudCh4ZmEpKTtcbiAgICB9XG4gICAgY29uc3QgcmVhZGFibGVTdHJlYW0gPSB0aGlzLnN0cmVhbVRleHRDb250ZW50KHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIHB1bXAoKSB7XG4gICAgICAgIHJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAoe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfSkge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICByZXNvbHZlKHRleHRDb250ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGV4dENvbnRlbnQubGFuZyA/Pz0gdmFsdWUubGFuZztcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHRleHRDb250ZW50LnN0eWxlcywgdmFsdWUuc3R5bGVzKTtcbiAgICAgICAgICB0ZXh0Q29udGVudC5pdGVtcy5wdXNoKC4uLnZhbHVlLml0ZW1zKTtcbiAgICAgICAgICBwdW1wKCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWFkZXIgPSByZWFkYWJsZVN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgIGNvbnN0IHRleHRDb250ZW50ID0ge1xuICAgICAgICBpdGVtczogW10sXG4gICAgICAgIHN0eWxlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgbGFuZzogbnVsbFxuICAgICAgfTtcbiAgICAgIHB1bXAoKTtcbiAgICB9KTtcbiAgfVxuICBnZXRTdHJ1Y3RUcmVlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0U3RydWN0VHJlZSh0aGlzLl9wYWdlSW5kZXgpO1xuICB9XG4gIF9kZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBjb25zdCB3YWl0T24gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGludGVudFN0YXRlIG9mIHRoaXMuX2ludGVudFN0YXRlcy52YWx1ZXMoKSkge1xuICAgICAgdGhpcy5fYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgICAgICBpbnRlbnRTdGF0ZSxcbiAgICAgICAgcmVhc29uOiBuZXcgRXJyb3IoXCJQYWdlIHdhcyBkZXN0cm95ZWQuXCIpLFxuICAgICAgICBmb3JjZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBpZiAoaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGludGVybmFsUmVuZGVyVGFzayBvZiBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcykge1xuICAgICAgICB3YWl0T24ucHVzaChpbnRlcm5hbFJlbmRlclRhc2suY29tcGxldGVkKTtcbiAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmNhbmNlbCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm9ianMuY2xlYXIoKTtcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgIHJldHVybiBQcm9taXNlLmFsbCh3YWl0T24pO1xuICB9XG4gIGNsZWFudXAocmVzZXRTdGF0cyA9IGZhbHNlKSB7XG4gICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSB0cnVlO1xuICAgIGNvbnN0IHN1Y2Nlc3MgPSB0aGlzLiN0cnlDbGVhbnVwKCk7XG4gICAgaWYgKHJlc2V0U3RhdHMgJiYgc3VjY2Vzcykge1xuICAgICAgdGhpcy5fc3RhdHMgJiY9IG5ldyBTdGF0VGltZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3M7XG4gIH1cbiAgI3RyeUNsZWFudXAoKSB7XG4gICAgaWYgKCF0aGlzLiNwZW5kaW5nQ2xlYW51cCB8fCB0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHJlbmRlclRhc2tzLFxuICAgICAgb3BlcmF0b3JMaXN0XG4gICAgfSBvZiB0aGlzLl9pbnRlbnRTdGF0ZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChyZW5kZXJUYXNrcy5zaXplID4gMCB8fCAhb3BlcmF0b3JMaXN0Lmxhc3RDaHVuaykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2ludGVudFN0YXRlcy5jbGVhcigpO1xuICAgIHRoaXMub2Jqcy5jbGVhcigpO1xuICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgX3N0YXJ0UmVuZGVyUGFnZSh0cmFuc3BhcmVuY3ksIGNhY2hlS2V5KSB7XG4gICAgY29uc3QgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoIWludGVudFN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3N0YXRzPy50aW1lRW5kKFwiUGFnZSBSZXF1ZXN0XCIpO1xuICAgIGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHk/LnJlc29sdmUodHJhbnNwYXJlbmN5KTtcbiAgfVxuICBfcmVuZGVyUGFnZUNodW5rKG9wZXJhdG9yTGlzdENodW5rLCBpbnRlbnRTdGF0ZSkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IG9wZXJhdG9yTGlzdENodW5rLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5mbkFycmF5LnB1c2gob3BlcmF0b3JMaXN0Q2h1bmsuZm5BcnJheVtpXSk7XG4gICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QuYXJnc0FycmF5LnB1c2gob3BlcmF0b3JMaXN0Q2h1bmsuYXJnc0FycmF5W2ldKTtcbiAgICB9XG4gICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0Lmxhc3RDaHVuayA9IG9wZXJhdG9yTGlzdENodW5rLmxhc3RDaHVuaztcbiAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3Quc2VwYXJhdGVBbm5vdHMgPSBvcGVyYXRvckxpc3RDaHVuay5zZXBhcmF0ZUFubm90cztcbiAgICBmb3IgKGNvbnN0IGludGVybmFsUmVuZGVyVGFzayBvZiBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcykge1xuICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQoKTtcbiAgICB9XG4gICAgaWYgKG9wZXJhdG9yTGlzdENodW5rLmxhc3RDaHVuaykge1xuICAgICAgdGhpcy4jdHJ5Q2xlYW51cCgpO1xuICAgIH1cbiAgfVxuICBfcHVtcE9wZXJhdG9yTGlzdCh7XG4gICAgcmVuZGVyaW5nSW50ZW50LFxuICAgIGNhY2hlS2V5LFxuICAgIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlLFxuICAgIG1vZGlmaWVkSWRzXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBtYXAsXG4gICAgICB0cmFuc2ZlclxuICAgIH0gPSBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZTtcbiAgICBjb25zdCByZWFkYWJsZVN0cmVhbSA9IHRoaXMuX3RyYW5zcG9ydC5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFN0cmVhbShcIkdldE9wZXJhdG9yTGlzdFwiLCB7XG4gICAgICBwYWdlSW5kZXg6IHRoaXMuX3BhZ2VJbmRleCxcbiAgICAgIGludGVudDogcmVuZGVyaW5nSW50ZW50LFxuICAgICAgY2FjaGVLZXksXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZTogbWFwLFxuICAgICAgbW9kaWZpZWRJZHNcbiAgICB9LCB0cmFuc2Zlcik7XG4gICAgY29uc3QgcmVhZGVyID0gcmVhZGFibGVTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgY29uc3QgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSByZWFkZXI7XG4gICAgY29uc3QgcHVtcCA9ICgpID0+IHtcbiAgICAgIHJlYWRlci5yZWFkKCkudGhlbigoe1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZG9uZVxuICAgICAgfSkgPT4ge1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90cmFuc3BvcnQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbmRlclBhZ2VDaHVuayh2YWx1ZSwgaW50ZW50U3RhdGUpO1xuICAgICAgICBwdW1wKCk7XG4gICAgICB9LCByZWFzb24gPT4ge1xuICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0KSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0Lmxhc3RDaHVuayA9IHRydWU7XG4gICAgICAgICAgZm9yIChjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgb2YgaW50ZW50U3RhdGUucmVuZGVyVGFza3MpIHtcbiAgICAgICAgICAgIGludGVybmFsUmVuZGVyVGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuI3RyeUNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSkge1xuICAgICAgICAgIGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgcHVtcCgpO1xuICB9XG4gIF9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgaW50ZW50U3RhdGUsXG4gICAgcmVhc29uLFxuICAgIGZvcmNlID0gZmFsc2VcbiAgfSkge1xuICAgIGlmICghaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCk7XG4gICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFmb3JjZSkge1xuICAgICAgaWYgKGludGVudFN0YXRlLnJlbmRlclRhc2tzLnNpemUgPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFzb24gaW5zdGFuY2VvZiBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24pIHtcbiAgICAgICAgbGV0IGRlbGF5ID0gUkVOREVSSU5HX0NBTkNFTExFRF9USU1FT1VUO1xuICAgICAgICBpZiAocmVhc29uLmV4dHJhRGVsYXkgPiAwICYmIHJlYXNvbi5leHRyYURlbGF5IDwgMTAwMCkge1xuICAgICAgICAgIGRlbGF5ICs9IHJlYXNvbi5leHRyYURlbGF5O1xuICAgICAgICB9XG4gICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgICAgICAgICBpbnRlbnRTdGF0ZSxcbiAgICAgICAgICAgIHJlYXNvbixcbiAgICAgICAgICAgIGZvcmNlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIuY2FuY2VsKG5ldyBBYm9ydEV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSkpLmNhdGNoKCgpID0+IHt9KTtcbiAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSBudWxsO1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2N1ckNhY2hlS2V5LCBjdXJJbnRlbnRTdGF0ZV0gb2YgdGhpcy5faW50ZW50U3RhdGVzKSB7XG4gICAgICBpZiAoY3VySW50ZW50U3RhdGUgPT09IGludGVudFN0YXRlKSB7XG4gICAgICAgIHRoaXMuX2ludGVudFN0YXRlcy5kZWxldGUoY3VyQ2FjaGVLZXkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gIH1cbiAgZ2V0IHN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0cztcbiAgfVxufVxuY2xhc3MgUERGV29ya2VyIHtcbiAgI2NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgI21lc3NhZ2VIYW5kbGVyID0gbnVsbDtcbiAgI3BvcnQgPSBudWxsO1xuICAjd2ViV29ya2VyID0gbnVsbDtcbiAgc3RhdGljICNmYWtlV29ya2VySWQgPSAwO1xuICBzdGF0aWMgI2lzV29ya2VyRGlzYWJsZWQgPSBmYWxzZTtcbiAgc3RhdGljICN3b3JrZXJQb3J0cyA9IG5ldyBXZWFrTWFwKCk7XG4gIHN0YXRpYyB7XG4gICAgaWYgKGlzTm9kZUpTKSB7XG4gICAgICB0aGlzLiNpc1dvcmtlckRpc2FibGVkID0gdHJ1ZTtcbiAgICAgIEdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjIHx8PSBcIi4vcGRmLndvcmtlci5tanNcIjtcbiAgICB9XG4gICAgdGhpcy5faXNTYW1lT3JpZ2luID0gKGJhc2VVcmwsIG90aGVyVXJsKSA9PiB7XG4gICAgICBjb25zdCBiYXNlID0gVVJMLnBhcnNlKGJhc2VVcmwpO1xuICAgICAgaWYgKCFiYXNlPy5vcmlnaW4gfHwgYmFzZS5vcmlnaW4gPT09IFwibnVsbFwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG90aGVyID0gbmV3IFVSTChvdGhlclVybCwgYmFzZSk7XG4gICAgICByZXR1cm4gYmFzZS5vcmlnaW4gPT09IG90aGVyLm9yaWdpbjtcbiAgICB9O1xuICAgIHRoaXMuX2NyZWF0ZUNETldyYXBwZXIgPSB1cmwgPT4ge1xuICAgICAgY29uc3Qgd3JhcHBlciA9IGBhd2FpdCBpbXBvcnQoXCIke3VybH1cIik7YDtcbiAgICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFt3cmFwcGVyXSwge1xuICAgICAgICB0eXBlOiBcInRleHQvamF2YXNjcmlwdFwiXG4gICAgICB9KSk7XG4gICAgfTtcbiAgICB0aGlzLmZyb21Qb3J0ID0gcGFyYW1zID0+IHtcbiAgICAgIGRlcHJlY2F0ZWQoXCJgUERGV29ya2VyLmZyb21Qb3J0YCAtIHBsZWFzZSB1c2UgYFBERldvcmtlci5jcmVhdGVgIGluc3RlYWQuXCIpO1xuICAgICAgaWYgKCFwYXJhbXM/LnBvcnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUERGV29ya2VyLmZyb21Qb3J0IC0gaW52YWxpZCBtZXRob2Qgc2lnbmF0dXJlLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZShwYXJhbXMpO1xuICAgIH07XG4gIH1cbiAgY29uc3RydWN0b3Ioe1xuICAgIG5hbWUgPSBudWxsLFxuICAgIHBvcnQgPSBudWxsLFxuICAgIHZlcmJvc2l0eSA9IGdldFZlcmJvc2l0eUxldmVsKClcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMudmVyYm9zaXR5ID0gdmVyYm9zaXR5O1xuICAgIGlmIChwb3J0KSB7XG4gICAgICBpZiAoUERGV29ya2VyLiN3b3JrZXJQb3J0cy5oYXMocG9ydCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSBtb3JlIHRoYW4gb25lIFBERldvcmtlciBwZXIgcG9ydC5cIik7XG4gICAgICB9XG4gICAgICBQREZXb3JrZXIuI3dvcmtlclBvcnRzLnNldChwb3J0LCB0aGlzKTtcbiAgICAgIHRoaXMuI2luaXRpYWxpemVGcm9tUG9ydChwb3J0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jaW5pdGlhbGl6ZSgpO1xuICAgIH1cbiAgfVxuICBnZXQgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gICNyZXNvbHZlKCkge1xuICAgIHRoaXMuI2NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIHRoaXMuI21lc3NhZ2VIYW5kbGVyLnNlbmQoXCJjb25maWd1cmVcIiwge1xuICAgICAgdmVyYm9zaXR5OiB0aGlzLnZlcmJvc2l0eVxuICAgIH0pO1xuICB9XG4gIGdldCBwb3J0KCkge1xuICAgIHJldHVybiB0aGlzLiNwb3J0O1xuICB9XG4gIGdldCBtZXNzYWdlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gdGhpcy4jbWVzc2FnZUhhbmRsZXI7XG4gIH1cbiAgI2luaXRpYWxpemVGcm9tUG9ydChwb3J0KSB7XG4gICAgdGhpcy4jcG9ydCA9IHBvcnQ7XG4gICAgdGhpcy4jbWVzc2FnZUhhbmRsZXIgPSBuZXcgTWVzc2FnZUhhbmRsZXIoXCJtYWluXCIsIFwid29ya2VyXCIsIHBvcnQpO1xuICAgIHRoaXMuI21lc3NhZ2VIYW5kbGVyLm9uKFwicmVhZHlcIiwgKCkgPT4ge30pO1xuICAgIHRoaXMuI3Jlc29sdmUoKTtcbiAgfVxuICAjaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoUERGV29ya2VyLiNpc1dvcmtlckRpc2FibGVkIHx8IFBERldvcmtlci4jbWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICB0aGlzLiNzZXR1cEZha2VXb3JrZXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHtcbiAgICAgIHdvcmtlclNyY1xuICAgIH0gPSBQREZXb3JrZXI7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghUERGV29ya2VyLl9pc1NhbWVPcmlnaW4od2luZG93LmxvY2F0aW9uLCB3b3JrZXJTcmMpKSB7XG4gICAgICAgIHdvcmtlclNyYyA9IFBERldvcmtlci5fY3JlYXRlQ0ROV3JhcHBlcihuZXcgVVJMKHdvcmtlclNyYywgd2luZG93LmxvY2F0aW9uKS5ocmVmKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyU3JjLCB7XG4gICAgICAgIHR5cGU6IFwibW9kdWxlXCJcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSBuZXcgTWVzc2FnZUhhbmRsZXIoXCJtYWluXCIsIFwid29ya2VyXCIsIHdvcmtlcik7XG4gICAgICBjb25zdCB0ZXJtaW5hdGVFYXJseSA9ICgpID0+IHtcbiAgICAgICAgYWMuYWJvcnQoKTtcbiAgICAgICAgbWVzc2FnZUhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHRoaXMuI2NhcGFiaWxpdHkucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiNzZXR1cEZha2VXb3JrZXIoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy4jd2ViV29ya2VyKSB7XG4gICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBzaWduYWw6IGFjLnNpZ25hbFxuICAgICAgfSk7XG4gICAgICBtZXNzYWdlSGFuZGxlci5vbihcInRlc3RcIiwgZGF0YSA9PiB7XG4gICAgICAgIGFjLmFib3J0KCk7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCB8fCAhZGF0YSkge1xuICAgICAgICAgIHRlcm1pbmF0ZUVhcmx5KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI21lc3NhZ2VIYW5kbGVyID0gbWVzc2FnZUhhbmRsZXI7XG4gICAgICAgIHRoaXMuI3BvcnQgPSB3b3JrZXI7XG4gICAgICAgIHRoaXMuI3dlYldvcmtlciA9IHdvcmtlcjtcbiAgICAgICAgdGhpcy4jcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgICBtZXNzYWdlSGFuZGxlci5vbihcInJlYWR5XCIsIGRhdGEgPT4ge1xuICAgICAgICBhYy5hYm9ydCgpO1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICB0ZXJtaW5hdGVFYXJseSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHNlbmRUZXN0KCk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHRoaXMuI3NldHVwRmFrZVdvcmtlcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNlbmRUZXN0ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB0ZXN0T2JqID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZUhhbmRsZXIuc2VuZChcInRlc3RcIiwgdGVzdE9iaiwgW3Rlc3RPYmouYnVmZmVyXSk7XG4gICAgICB9O1xuICAgICAgc2VuZFRlc3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGluZm8oXCJUaGUgd29ya2VyIGhhcyBiZWVuIGRpc2FibGVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy4jc2V0dXBGYWtlV29ya2VyKCk7XG4gIH1cbiAgI3NldHVwRmFrZVdvcmtlcigpIHtcbiAgICBpZiAoIVBERldvcmtlci4jaXNXb3JrZXJEaXNhYmxlZCkge1xuICAgICAgd2FybihcIlNldHRpbmcgdXAgZmFrZSB3b3JrZXIuXCIpO1xuICAgICAgUERGV29ya2VyLiNpc1dvcmtlckRpc2FibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgUERGV29ya2VyLl9zZXR1cEZha2VXb3JrZXJHbG9iYWwudGhlbihXb3JrZXJNZXNzYWdlSGFuZGxlciA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhpcy4jY2FwYWJpbGl0eS5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwb3J0ID0gbmV3IExvb3BiYWNrUG9ydCgpO1xuICAgICAgdGhpcy4jcG9ydCA9IHBvcnQ7XG4gICAgICBjb25zdCBpZCA9IGBmYWtlJHtQREZXb3JrZXIuI2Zha2VXb3JrZXJJZCsrfWA7XG4gICAgICBjb25zdCB3b3JrZXJIYW5kbGVyID0gbmV3IE1lc3NhZ2VIYW5kbGVyKGlkICsgXCJfd29ya2VyXCIsIGlkLCBwb3J0KTtcbiAgICAgIFdvcmtlck1lc3NhZ2VIYW5kbGVyLnNldHVwKHdvcmtlckhhbmRsZXIsIHBvcnQpO1xuICAgICAgdGhpcy4jbWVzc2FnZUhhbmRsZXIgPSBuZXcgTWVzc2FnZUhhbmRsZXIoaWQsIGlkICsgXCJfd29ya2VyXCIsIHBvcnQpO1xuICAgICAgdGhpcy4jcmVzb2x2ZSgpO1xuICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLiNjYXBhYmlsaXR5LnJlamVjdChuZXcgRXJyb3IoYFNldHRpbmcgdXAgZmFrZSB3b3JrZXIgZmFpbGVkOiBcIiR7cmVhc29uLm1lc3NhZ2V9XCIuYCkpO1xuICAgIH0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMuI3dlYldvcmtlcj8udGVybWluYXRlKCk7XG4gICAgdGhpcy4jd2ViV29ya2VyID0gbnVsbDtcbiAgICBQREZXb3JrZXIuI3dvcmtlclBvcnRzLmRlbGV0ZSh0aGlzLiNwb3J0KTtcbiAgICB0aGlzLiNwb3J0ID0gbnVsbDtcbiAgICB0aGlzLiNtZXNzYWdlSGFuZGxlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuI21lc3NhZ2VIYW5kbGVyID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgY3JlYXRlKHBhcmFtcykge1xuICAgIGNvbnN0IGNhY2hlZFBvcnQgPSB0aGlzLiN3b3JrZXJQb3J0cy5nZXQocGFyYW1zPy5wb3J0KTtcbiAgICBpZiAoY2FjaGVkUG9ydCkge1xuICAgICAgaWYgKGNhY2hlZFBvcnQuX3BlbmRpbmdEZXN0cm95KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBERldvcmtlci5jcmVhdGUgLSB0aGUgd29ya2VyIGlzIGJlaW5nIGRlc3Ryb3llZC5cXG5cIiArIFwiUGxlYXNlIHJlbWVtYmVyIHRvIGF3YWl0IGBQREZEb2N1bWVudExvYWRpbmdUYXNrLmRlc3Ryb3koKWAtY2FsbHMuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlZFBvcnQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUERGV29ya2VyKHBhcmFtcyk7XG4gIH1cbiAgc3RhdGljIGdldCB3b3JrZXJTcmMoKSB7XG4gICAgaWYgKEdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjKSB7XG4gICAgICByZXR1cm4gR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmM7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm8gXCJHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyY1wiIHNwZWNpZmllZC4nKTtcbiAgfVxuICBzdGF0aWMgZ2V0ICNtYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnbG9iYWxUaGlzLnBkZmpzV29ya2VyPy5Xb3JrZXJNZXNzYWdlSGFuZGxlciB8fCBudWxsO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgX3NldHVwRmFrZVdvcmtlckdsb2JhbCgpIHtcbiAgICBjb25zdCBsb2FkZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAodGhpcy4jbWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNtYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXI7XG4gICAgICB9XG4gICAgICBjb25zdCB3b3JrZXIgPSBhd2FpdCBpbXBvcnQoXG4gICAgICAvKndlYnBhY2tJZ25vcmU6IHRydWUqL1xuICAgICAgLypAdml0ZS1pZ25vcmUqL1xuICAgICAgdGhpcy53b3JrZXJTcmMpO1xuICAgICAgcmV0dXJuIHdvcmtlci5Xb3JrZXJNZXNzYWdlSGFuZGxlcjtcbiAgICB9O1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfc2V0dXBGYWtlV29ya2VyR2xvYmFsXCIsIGxvYWRlcigpKTtcbiAgfVxufVxuY2xhc3MgV29ya2VyVHJhbnNwb3J0IHtcbiAgI21ldGhvZFByb21pc2VzID0gbmV3IE1hcCgpO1xuICAjcGFnZUNhY2hlID0gbmV3IE1hcCgpO1xuICAjcGFnZVByb21pc2VzID0gbmV3IE1hcCgpO1xuICAjcGFnZVJlZkNhY2hlID0gbmV3IE1hcCgpO1xuICAjcGFzc3dvcmRDYXBhYmlsaXR5ID0gbnVsbDtcbiAgY29uc3RydWN0b3IobWVzc2FnZUhhbmRsZXIsIGxvYWRpbmdUYXNrLCBuZXR3b3JrU3RyZWFtLCBwYXJhbXMsIGZhY3RvcnksIGVuYWJsZUhXQSkge1xuICAgIHRoaXMubWVzc2FnZUhhbmRsZXIgPSBtZXNzYWdlSGFuZGxlcjtcbiAgICB0aGlzLmxvYWRpbmdUYXNrID0gbG9hZGluZ1Rhc2s7XG4gICAgdGhpcy5jb21tb25PYmpzID0gbmV3IFBERk9iamVjdHMoKTtcbiAgICB0aGlzLmZvbnRMb2FkZXIgPSBuZXcgRm9udExvYWRlcih7XG4gICAgICBvd25lckRvY3VtZW50OiBwYXJhbXMub3duZXJEb2N1bWVudCxcbiAgICAgIHN0eWxlRWxlbWVudDogcGFyYW1zLnN0eWxlRWxlbWVudFxuICAgIH0pO1xuICAgIHRoaXMubG9hZGluZ1BhcmFtcyA9IHBhcmFtcy5sb2FkaW5nUGFyYW1zO1xuICAgIHRoaXMuX3BhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBmYWN0b3J5LmNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5maWx0ZXJGYWN0b3J5ID0gZmFjdG9yeS5maWx0ZXJGYWN0b3J5O1xuICAgIHRoaXMuY01hcFJlYWRlckZhY3RvcnkgPSBmYWN0b3J5LmNNYXBSZWFkZXJGYWN0b3J5O1xuICAgIHRoaXMuc3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBmYWN0b3J5LnN0YW5kYXJkRm9udERhdGFGYWN0b3J5O1xuICAgIHRoaXMud2FzbUZhY3RvcnkgPSBmYWN0b3J5Lndhc21GYWN0b3J5O1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eSA9IG51bGw7XG4gICAgdGhpcy5fbmV0d29ya1N0cmVhbSA9IG5ldHdvcmtTdHJlYW07XG4gICAgdGhpcy5fZnVsbFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbGFzdFByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLmRvd25sb2FkSW5mb0NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLmVuYWJsZUhXQSA9IGVuYWJsZUhXQTtcbiAgICB0aGlzLnNldHVwTWVzc2FnZUhhbmRsZXIoKTtcbiAgfVxuICAjY2FjaGVTaW1wbGVNZXRob2QobmFtZSwgZGF0YSA9IG51bGwpIHtcbiAgICBjb25zdCBjYWNoZWRQcm9taXNlID0gdGhpcy4jbWV0aG9kUHJvbWlzZXMuZ2V0KG5hbWUpO1xuICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKG5hbWUsIGRhdGEpO1xuICAgIHRoaXMuI21ldGhvZFByb21pc2VzLnNldChuYW1lLCBwcm9taXNlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBnZXQgYW5ub3RhdGlvblN0b3JhZ2UoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImFubm90YXRpb25TdG9yYWdlXCIsIG5ldyBBbm5vdGF0aW9uU3RvcmFnZSgpKTtcbiAgfVxuICBnZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50LCBhbm5vdGF0aW9uTW9kZSA9IEFubm90YXRpb25Nb2RlLkVOQUJMRSwgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA9IG51bGwsIGlzRWRpdGluZyA9IGZhbHNlLCBpc09wTGlzdCA9IGZhbHNlKSB7XG4gICAgbGV0IHJlbmRlcmluZ0ludGVudCA9IFJlbmRlcmluZ0ludGVudEZsYWcuRElTUExBWTtcbiAgICBsZXQgYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGUgPSBTZXJpYWxpemFibGVFbXB0eTtcbiAgICBzd2l0Y2ggKGludGVudCkge1xuICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgPSBSZW5kZXJpbmdJbnRlbnRGbGFnLkFOWTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGlzcGxheVwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwcmludFwiOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgPSBSZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHdhcm4oYGdldFJlbmRlcmluZ0ludGVudCAtIGludmFsaWQgaW50ZW50OiAke2ludGVudH1gKTtcbiAgICB9XG4gICAgY29uc3QgYW5ub3RhdGlvblN0b3JhZ2UgPSByZW5kZXJpbmdJbnRlbnQgJiBSZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UICYmIHByaW50QW5ub3RhdGlvblN0b3JhZ2UgaW5zdGFuY2VvZiBQcmludEFubm90YXRpb25TdG9yYWdlID8gcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA6IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgc3dpdGNoIChhbm5vdGF0aW9uTW9kZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uTW9kZS5ESVNBQkxFOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgKz0gUmVuZGVyaW5nSW50ZW50RmxhZy5BTk5PVEFUSU9OU19ESVNBQkxFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbk1vZGUuRU5BQkxFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbk1vZGUuRU5BQkxFX0ZPUk1TOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgKz0gUmVuZGVyaW5nSW50ZW50RmxhZy5BTk5PVEFUSU9OU19GT1JNUztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25Nb2RlLkVOQUJMRV9TVE9SQUdFOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgKz0gUmVuZGVyaW5nSW50ZW50RmxhZy5BTk5PVEFUSU9OU19TVE9SQUdFO1xuICAgICAgICBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSA9IGFubm90YXRpb25TdG9yYWdlLnNlcmlhbGl6YWJsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB3YXJuKGBnZXRSZW5kZXJpbmdJbnRlbnQgLSBpbnZhbGlkIGFubm90YXRpb25Nb2RlOiAke2Fubm90YXRpb25Nb2RlfWApO1xuICAgIH1cbiAgICBpZiAoaXNFZGl0aW5nKSB7XG4gICAgICByZW5kZXJpbmdJbnRlbnQgKz0gUmVuZGVyaW5nSW50ZW50RmxhZy5JU19FRElUSU5HO1xuICAgIH1cbiAgICBpZiAoaXNPcExpc3QpIHtcbiAgICAgIHJlbmRlcmluZ0ludGVudCArPSBSZW5kZXJpbmdJbnRlbnRGbGFnLk9QTElTVDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgaWRzOiBtb2RpZmllZElkcyxcbiAgICAgIGhhc2g6IG1vZGlmaWVkSWRzSGFzaFxuICAgIH0gPSBhbm5vdGF0aW9uU3RvcmFnZS5tb2RpZmllZElkcztcbiAgICBjb25zdCBjYWNoZUtleUJ1ZiA9IFtyZW5kZXJpbmdJbnRlbnQsIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlLmhhc2gsIG1vZGlmaWVkSWRzSGFzaF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbmRlcmluZ0ludGVudCxcbiAgICAgIGNhY2hlS2V5OiBjYWNoZUtleUJ1Zi5qb2luKFwiX1wiKSxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlLFxuICAgICAgbW9kaWZpZWRJZHNcbiAgICB9O1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveUNhcGFiaWxpdHkpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfVxuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5Py5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWQgZHVyaW5nIG9uUGFzc3dvcmQgY2FsbGJhY2tcIikpO1xuICAgIGNvbnN0IHdhaXRPbiA9IFtdO1xuICAgIGZvciAoY29uc3QgcGFnZSBvZiB0aGlzLiNwYWdlQ2FjaGUudmFsdWVzKCkpIHtcbiAgICAgIHdhaXRPbi5wdXNoKHBhZ2UuX2Rlc3Ryb3koKSk7XG4gICAgfVxuICAgIHRoaXMuI3BhZ2VDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuI3BhZ2VQcm9taXNlcy5jbGVhcigpO1xuICAgIHRoaXMuI3BhZ2VSZWZDYWNoZS5jbGVhcigpO1xuICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KFwiYW5ub3RhdGlvblN0b3JhZ2VcIikpIHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UucmVzZXRNb2RpZmllZCgpO1xuICAgIH1cbiAgICBjb25zdCB0ZXJtaW5hdGVkID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJUZXJtaW5hdGVcIiwgbnVsbCk7XG4gICAgd2FpdE9uLnB1c2godGVybWluYXRlZCk7XG4gICAgUHJvbWlzZS5hbGwod2FpdE9uKS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuY29tbW9uT2Jqcy5jbGVhcigpO1xuICAgICAgdGhpcy5mb250TG9hZGVyLmNsZWFyKCk7XG4gICAgICB0aGlzLiNtZXRob2RQcm9taXNlcy5jbGVhcigpO1xuICAgICAgdGhpcy5maWx0ZXJGYWN0b3J5LmRlc3Ryb3koKTtcbiAgICAgIFRleHRMYXllci5jbGVhbnVwKCk7XG4gICAgICB0aGlzLl9uZXR3b3JrU3RyZWFtPy5jYW5jZWxBbGxSZXF1ZXN0cyhuZXcgQWJvcnRFeGNlcHRpb24oXCJXb3JrZXIgd2FzIHRlcm1pbmF0ZWQuXCIpKTtcbiAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXI/LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXIgPSBudWxsO1xuICAgICAgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSwgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eS5yZWplY3QpO1xuICAgIHJldHVybiB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgc2V0dXBNZXNzYWdlSGFuZGxlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZXNzYWdlSGFuZGxlcixcbiAgICAgIGxvYWRpbmdUYXNrXG4gICAgfSA9IHRoaXM7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJHZXRSZWFkZXJcIiwgKGRhdGEsIHNpbmspID0+IHtcbiAgICAgIGFzc2VydCh0aGlzLl9uZXR3b3JrU3RyZWFtLCBcIkdldFJlYWRlciAtIG5vIGBJUERGU3RyZWFtYCBpbnN0YW5jZSBhdmFpbGFibGUuXCIpO1xuICAgICAgdGhpcy5fZnVsbFJlYWRlciA9IHRoaXMuX25ldHdvcmtTdHJlYW0uZ2V0RnVsbFJlYWRlcigpO1xuICAgICAgdGhpcy5fZnVsbFJlYWRlci5vblByb2dyZXNzID0gZXZ0ID0+IHtcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzID0ge1xuICAgICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZCxcbiAgICAgICAgICB0b3RhbDogZXZ0LnRvdGFsXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgc2luay5vblB1bGwgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH0pIHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NlcnQodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciwgXCJHZXRSZWFkZXIgLSBleHBlY3RlZCBhbiBBcnJheUJ1ZmZlci5cIik7XG4gICAgICAgICAgc2luay5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSwgMSwgW3ZhbHVlXSk7XG4gICAgICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgc2luay5lcnJvcihyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBzaW5rLm9uQ2FuY2VsID0gcmVhc29uID0+IHtcbiAgICAgICAgdGhpcy5fZnVsbFJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICAgICAgc2luay5yZWFkeS5jYXRjaChyZWFkeVJlYXNvbiA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IHJlYWR5UmVhc29uO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJSZWFkZXJIZWFkZXJzUmVhZHlcIiwgYXN5bmMgZGF0YSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLl9mdWxsUmVhZGVyLmhlYWRlcnNSZWFkeTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaXNTdHJlYW1pbmdTdXBwb3J0ZWQsXG4gICAgICAgIGlzUmFuZ2VTdXBwb3J0ZWQsXG4gICAgICAgIGNvbnRlbnRMZW5ndGhcbiAgICAgIH0gPSB0aGlzLl9mdWxsUmVhZGVyO1xuICAgICAgaWYgKCFpc1N0cmVhbWluZ1N1cHBvcnRlZCB8fCAhaXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgICBpZiAodGhpcy5fbGFzdFByb2dyZXNzKSB7XG4gICAgICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcz8uKHRoaXMuX2xhc3RQcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZnVsbFJlYWRlci5vblByb2dyZXNzID0gZXZ0ID0+IHtcbiAgICAgICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4oe1xuICAgICAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNTdHJlYW1pbmdTdXBwb3J0ZWQsXG4gICAgICAgIGlzUmFuZ2VTdXBwb3J0ZWQsXG4gICAgICAgIGNvbnRlbnRMZW5ndGhcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJHZXRSYW5nZVJlYWRlclwiLCAoZGF0YSwgc2luaykgPT4ge1xuICAgICAgYXNzZXJ0KHRoaXMuX25ldHdvcmtTdHJlYW0sIFwiR2V0UmFuZ2VSZWFkZXIgLSBubyBgSVBERlN0cmVhbWAgaW5zdGFuY2UgYXZhaWxhYmxlLlwiKTtcbiAgICAgIGNvbnN0IHJhbmdlUmVhZGVyID0gdGhpcy5fbmV0d29ya1N0cmVhbS5nZXRSYW5nZVJlYWRlcihkYXRhLmJlZ2luLCBkYXRhLmVuZCk7XG4gICAgICBpZiAoIXJhbmdlUmVhZGVyKSB7XG4gICAgICAgIHNpbmsuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2luay5vblB1bGwgPSAoKSA9PiB7XG4gICAgICAgIHJhbmdlUmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uICh7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9KSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHNpbmsuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXNzZXJ0KHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIsIFwiR2V0UmFuZ2VSZWFkZXIgLSBleHBlY3RlZCBhbiBBcnJheUJ1ZmZlci5cIik7XG4gICAgICAgICAgc2luay5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSwgMSwgW3ZhbHVlXSk7XG4gICAgICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgc2luay5lcnJvcihyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBzaW5rLm9uQ2FuY2VsID0gcmVhc29uID0+IHtcbiAgICAgICAgcmFuZ2VSZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgICAgIHNpbmsucmVhZHkuY2F0Y2gocmVhZHlSZWFzb24gPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyByZWFkeVJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiR2V0RG9jXCIsICh7XG4gICAgICBwZGZJbmZvXG4gICAgfSkgPT4ge1xuICAgICAgdGhpcy5fbnVtUGFnZXMgPSBwZGZJbmZvLm51bVBhZ2VzO1xuICAgICAgdGhpcy5faHRtbEZvclhmYSA9IHBkZkluZm8uaHRtbEZvclhmYTtcbiAgICAgIGRlbGV0ZSBwZGZJbmZvLmh0bWxGb3JYZmE7XG4gICAgICBsb2FkaW5nVGFzay5fY2FwYWJpbGl0eS5yZXNvbHZlKG5ldyBQREZEb2N1bWVudFByb3h5KHBkZkluZm8sIHRoaXMpKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRvY0V4Y2VwdGlvblwiLCBleCA9PiB7XG4gICAgICBsb2FkaW5nVGFzay5fY2FwYWJpbGl0eS5yZWplY3Qod3JhcFJlYXNvbihleCkpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiUGFzc3dvcmRSZXF1ZXN0XCIsIGV4ID0+IHtcbiAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFsb2FkaW5nVGFzay5vblBhc3N3b3JkKSB7XG4gICAgICAgICAgdGhyb3cgd3JhcFJlYXNvbihleCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBkYXRlUGFzc3dvcmQgPSBwYXNzd29yZCA9PiB7XG4gICAgICAgICAgaWYgKHBhc3N3b3JkIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5yZWplY3QocGFzc3dvcmQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgICAgIHBhc3N3b3JkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxvYWRpbmdUYXNrLm9uUGFzc3dvcmQodXBkYXRlUGFzc3dvcmQsIGV4LmNvZGUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5yZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRhdGFMb2FkZWRcIiwgZGF0YSA9PiB7XG4gICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGRhdGEubGVuZ3RoLFxuICAgICAgICB0b3RhbDogZGF0YS5sZW5ndGhcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kb3dubG9hZEluZm9DYXBhYmlsaXR5LnJlc29sdmUoZGF0YSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJTdGFydFJlbmRlclBhZ2VcIiwgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFnZSA9IHRoaXMuI3BhZ2VDYWNoZS5nZXQoZGF0YS5wYWdlSW5kZXgpO1xuICAgICAgcGFnZS5fc3RhcnRSZW5kZXJQYWdlKGRhdGEudHJhbnNwYXJlbmN5LCBkYXRhLmNhY2hlS2V5KTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcImNvbW1vbm9ialwiLCAoW2lkLCB0eXBlLCBleHBvcnRlZERhdGFdKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb21tb25PYmpzLmhhcyhpZCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcIkZvbnRcIjpcbiAgICAgICAgICBpZiAoXCJlcnJvclwiIGluIGV4cG9ydGVkRGF0YSkge1xuICAgICAgICAgICAgY29uc3QgZXhwb3J0ZWRFcnJvciA9IGV4cG9ydGVkRGF0YS5lcnJvcjtcbiAgICAgICAgICAgIHdhcm4oYEVycm9yIGR1cmluZyBmb250IGxvYWRpbmc6ICR7ZXhwb3J0ZWRFcnJvcn1gKTtcbiAgICAgICAgICAgIHRoaXMuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBleHBvcnRlZEVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpbnNwZWN0Rm9udCA9IHRoaXMuX3BhcmFtcy5wZGZCdWcgJiYgZ2xvYmFsVGhpcy5Gb250SW5zcGVjdG9yPy5lbmFibGVkID8gKGZvbnQsIHVybCkgPT4gZ2xvYmFsVGhpcy5Gb250SW5zcGVjdG9yLmZvbnRBZGRlZChmb250LCB1cmwpIDogbnVsbDtcbiAgICAgICAgICBjb25zdCBmb250ID0gbmV3IEZvbnRGYWNlT2JqZWN0KGV4cG9ydGVkRGF0YSwgaW5zcGVjdEZvbnQpO1xuICAgICAgICAgIHRoaXMuZm9udExvYWRlci5iaW5kKGZvbnQpLmNhdGNoKCgpID0+IG1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkZvbnRGYWxsYmFja1wiLCB7XG4gICAgICAgICAgICBpZFxuICAgICAgICAgIH0pKS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghZm9udC5mb250RXh0cmFQcm9wZXJ0aWVzICYmIGZvbnQuZGF0YSkge1xuICAgICAgICAgICAgICBmb250LmRhdGEgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb21tb25PYmpzLnJlc29sdmUoaWQsIGZvbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQ29weUxvY2FsSW1hZ2VcIjpcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBpbWFnZVJlZlxuICAgICAgICAgIH0gPSBleHBvcnRlZERhdGE7XG4gICAgICAgICAgYXNzZXJ0KGltYWdlUmVmLCBcIlRoZSBpbWFnZVJlZiBtdXN0IGJlIGRlZmluZWQuXCIpO1xuICAgICAgICAgIGZvciAoY29uc3QgcGFnZVByb3h5IG9mIHRoaXMuI3BhZ2VDYWNoZS52YWx1ZXMoKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbLCBkYXRhXSBvZiBwYWdlUHJveHkub2Jqcykge1xuICAgICAgICAgICAgICBpZiAoZGF0YT8ucmVmICE9PSBpbWFnZVJlZikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghZGF0YS5kYXRhTGVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5jb21tb25PYmpzLnJlc29sdmUoaWQsIHN0cnVjdHVyZWRDbG9uZShkYXRhKSk7XG4gICAgICAgICAgICAgIHJldHVybiBkYXRhLmRhdGFMZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRm9udFBhdGhcIjpcbiAgICAgICAgY2FzZSBcIkltYWdlXCI6XG4gICAgICAgIGNhc2UgXCJQYXR0ZXJuXCI6XG4gICAgICAgICAgdGhpcy5jb21tb25PYmpzLnJlc29sdmUoaWQsIGV4cG9ydGVkRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHb3QgdW5rbm93biBjb21tb24gb2JqZWN0IHR5cGUgJHt0eXBlfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJvYmpcIiwgKFtpZCwgcGFnZUluZGV4LCB0eXBlLCBpbWFnZURhdGFdKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFnZVByb3h5ID0gdGhpcy4jcGFnZUNhY2hlLmdldChwYWdlSW5kZXgpO1xuICAgICAgaWYgKHBhZ2VQcm94eS5vYmpzLmhhcyhpZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHBhZ2VQcm94eS5faW50ZW50U3RhdGVzLnNpemUgPT09IDApIHtcbiAgICAgICAgaW1hZ2VEYXRhPy5iaXRtYXA/LmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiSW1hZ2VcIjpcbiAgICAgICAgY2FzZSBcIlBhdHRlcm5cIjpcbiAgICAgICAgICBwYWdlUHJveHkub2Jqcy5yZXNvbHZlKGlkLCBpbWFnZURhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR290IHVua25vd24gb2JqZWN0IHR5cGUgJHt0eXBlfWApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRG9jUHJvZ3Jlc3NcIiwgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBkYXRhLmxvYWRlZCxcbiAgICAgICAgdG90YWw6IGRhdGEudG90YWxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRmV0Y2hCaW5hcnlEYXRhXCIsIGFzeW5jIGRhdGEgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzW2RhdGEudHlwZV07XG4gICAgICBpZiAoIWZhY3RvcnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2RhdGEudHlwZX0gbm90IGluaXRpYWxpemVkLCBzZWUgdGhlIFxcYHVzZVdvcmtlckZldGNoXFxgIHBhcmFtZXRlci5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWN0b3J5LmZldGNoKGRhdGEpO1xuICAgIH0pO1xuICB9XG4gIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RGF0YVwiLCBudWxsKTtcbiAgfVxuICBzYXZlRG9jdW1lbnQoKSB7XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2l6ZSA8PSAwKSB7XG4gICAgICB3YXJuKFwic2F2ZURvY3VtZW50IGNhbGxlZCB3aGlsZSBgYW5ub3RhdGlvblN0b3JhZ2VgIGlzIGVtcHR5LCBcIiArIFwicGxlYXNlIHVzZSB0aGUgZ2V0RGF0YS1tZXRob2QgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG1hcCxcbiAgICAgIHRyYW5zZmVyXG4gICAgfSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2VyaWFsaXphYmxlO1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIlNhdmVEb2N1bWVudFwiLCB7XG4gICAgICBpc1B1cmVYZmE6ICEhdGhpcy5faHRtbEZvclhmYSxcbiAgICAgIG51bVBhZ2VzOiB0aGlzLl9udW1QYWdlcyxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlOiBtYXAsXG4gICAgICBmaWxlbmFtZTogdGhpcy5fZnVsbFJlYWRlcj8uZmlsZW5hbWUgPz8gbnVsbFxuICAgIH0sIHRyYW5zZmVyKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UucmVzZXRNb2RpZmllZCgpO1xuICAgIH0pO1xuICB9XG4gIGdldFBhZ2UocGFnZU51bWJlcikge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihwYWdlTnVtYmVyKSB8fCBwYWdlTnVtYmVyIDw9IDAgfHwgcGFnZU51bWJlciA+IHRoaXMuX251bVBhZ2VzKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBwYWdlIHJlcXVlc3QuXCIpKTtcbiAgICB9XG4gICAgY29uc3QgcGFnZUluZGV4ID0gcGFnZU51bWJlciAtIDEsXG4gICAgICBjYWNoZWRQcm9taXNlID0gdGhpcy4jcGFnZVByb21pc2VzLmdldChwYWdlSW5kZXgpO1xuICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZVwiLCB7XG4gICAgICBwYWdlSW5kZXhcbiAgICB9KS50aGVuKHBhZ2VJbmZvID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3BvcnQgZGVzdHJveWVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHBhZ2VJbmZvLnJlZlN0cikge1xuICAgICAgICB0aGlzLiNwYWdlUmVmQ2FjaGUuc2V0KHBhZ2VJbmZvLnJlZlN0ciwgcGFnZU51bWJlcik7XG4gICAgICB9XG4gICAgICBjb25zdCBwYWdlID0gbmV3IFBERlBhZ2VQcm94eShwYWdlSW5kZXgsIHBhZ2VJbmZvLCB0aGlzLCB0aGlzLl9wYXJhbXMucGRmQnVnKTtcbiAgICAgIHRoaXMuI3BhZ2VDYWNoZS5zZXQocGFnZUluZGV4LCBwYWdlKTtcbiAgICAgIHJldHVybiBwYWdlO1xuICAgIH0pO1xuICAgIHRoaXMuI3BhZ2VQcm9taXNlcy5zZXQocGFnZUluZGV4LCBwcm9taXNlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBnZXRQYWdlSW5kZXgocmVmKSB7XG4gICAgaWYgKCFpc1JlZlByb3h5KHJlZikpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIHBhZ2VJbmRleCByZXF1ZXN0LlwiKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VJbmRleFwiLCB7XG4gICAgICBudW06IHJlZi5udW0sXG4gICAgICBnZW46IHJlZi5nZW5cbiAgICB9KTtcbiAgfVxuICBnZXRBbm5vdGF0aW9ucyhwYWdlSW5kZXgsIGludGVudCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldEFubm90YXRpb25zXCIsIHtcbiAgICAgIHBhZ2VJbmRleCxcbiAgICAgIGludGVudFxuICAgIH0pO1xuICB9XG4gIGdldEZpZWxkT2JqZWN0cygpIHtcbiAgICByZXR1cm4gdGhpcy4jY2FjaGVTaW1wbGVNZXRob2QoXCJHZXRGaWVsZE9iamVjdHNcIik7XG4gIH1cbiAgaGFzSlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLiNjYWNoZVNpbXBsZU1ldGhvZChcIkhhc0pTQWN0aW9uc1wiKTtcbiAgfVxuICBnZXRDYWxjdWxhdGlvbk9yZGVySWRzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldENhbGN1bGF0aW9uT3JkZXJJZHNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0RGVzdGluYXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldERlc3RpbmF0aW9uc1wiLCBudWxsKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbihpZCkge1xuICAgIGlmICh0eXBlb2YgaWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIGRlc3RpbmF0aW9uIHJlcXVlc3QuXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RGVzdGluYXRpb25cIiwge1xuICAgICAgaWRcbiAgICB9KTtcbiAgfVxuICBnZXRQYWdlTGFiZWxzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VMYWJlbHNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0UGFnZUxheW91dCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlTGF5b3V0XCIsIG51bGwpO1xuICB9XG4gIGdldFBhZ2VNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VNb2RlXCIsIG51bGwpO1xuICB9XG4gIGdldFZpZXdlclByZWZlcmVuY2VzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFZpZXdlclByZWZlcmVuY2VzXCIsIG51bGwpO1xuICB9XG4gIGdldE9wZW5BY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0T3BlbkFjdGlvblwiLCBudWxsKTtcbiAgfVxuICBnZXRBdHRhY2htZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRBdHRhY2htZW50c1wiLCBudWxsKTtcbiAgfVxuICBnZXRBbm5vdGF0aW9uc0J5VHlwZSh0eXBlcywgcGFnZUluZGV4ZXNUb1NraXApIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRBbm5vdGF0aW9uc0J5VHlwZVwiLCB7XG4gICAgICB0eXBlcyxcbiAgICAgIHBhZ2VJbmRleGVzVG9Ta2lwXG4gICAgfSk7XG4gIH1cbiAgZ2V0RG9jSlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLiNjYWNoZVNpbXBsZU1ldGhvZChcIkdldERvY0pTQWN0aW9uc1wiKTtcbiAgfVxuICBnZXRQYWdlSlNBY3Rpb25zKHBhZ2VJbmRleCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VKU0FjdGlvbnNcIiwge1xuICAgICAgcGFnZUluZGV4XG4gICAgfSk7XG4gIH1cbiAgZ2V0U3RydWN0VHJlZShwYWdlSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRTdHJ1Y3RUcmVlXCIsIHtcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0pO1xuICB9XG4gIGdldE91dGxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0T3V0bGluZVwiLCBudWxsKTtcbiAgfVxuICBnZXRPcHRpb25hbENvbnRlbnRDb25maWcocmVuZGVyaW5nSW50ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlU2ltcGxlTWV0aG9kKFwiR2V0T3B0aW9uYWxDb250ZW50Q29uZmlnXCIpLnRoZW4oZGF0YSA9PiBuZXcgT3B0aW9uYWxDb250ZW50Q29uZmlnKGRhdGEsIHJlbmRlcmluZ0ludGVudCkpO1xuICB9XG4gIGdldFBlcm1pc3Npb25zKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBlcm1pc3Npb25zXCIsIG51bGwpO1xuICB9XG4gIGdldE1ldGFkYXRhKCkge1xuICAgIGNvbnN0IG5hbWUgPSBcIkdldE1ldGFkYXRhXCIsXG4gICAgICBjYWNoZWRQcm9taXNlID0gdGhpcy4jbWV0aG9kUHJvbWlzZXMuZ2V0KG5hbWUpO1xuICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKG5hbWUsIG51bGwpLnRoZW4ocmVzdWx0cyA9PiAoe1xuICAgICAgaW5mbzogcmVzdWx0c1swXSxcbiAgICAgIG1ldGFkYXRhOiByZXN1bHRzWzFdID8gbmV3IE1ldGFkYXRhKHJlc3VsdHNbMV0pIDogbnVsbCxcbiAgICAgIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lOiB0aGlzLl9mdWxsUmVhZGVyPy5maWxlbmFtZSA/PyBudWxsLFxuICAgICAgY29udGVudExlbmd0aDogdGhpcy5fZnVsbFJlYWRlcj8uY29udGVudExlbmd0aCA/PyBudWxsXG4gICAgfSkpO1xuICAgIHRoaXMuI21ldGhvZFByb21pc2VzLnNldChuYW1lLCBwcm9taXNlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBnZXRNYXJrSW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRNYXJrSW5mb1wiLCBudWxsKTtcbiAgfVxuICBhc3luYyBzdGFydENsZWFudXAoa2VlcExvYWRlZEZvbnRzID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJDbGVhbnVwXCIsIG51bGwpO1xuICAgIGZvciAoY29uc3QgcGFnZSBvZiB0aGlzLiNwYWdlQ2FjaGUudmFsdWVzKCkpIHtcbiAgICAgIGNvbnN0IGNsZWFudXBTdWNjZXNzZnVsID0gcGFnZS5jbGVhbnVwKCk7XG4gICAgICBpZiAoIWNsZWFudXBTdWNjZXNzZnVsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgc3RhcnRDbGVhbnVwOiBQYWdlICR7cGFnZS5wYWdlTnVtYmVyfSBpcyBjdXJyZW50bHkgcmVuZGVyaW5nLmApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbW1vbk9ianMuY2xlYXIoKTtcbiAgICBpZiAoIWtlZXBMb2FkZWRGb250cykge1xuICAgICAgdGhpcy5mb250TG9hZGVyLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuI21ldGhvZFByb21pc2VzLmNsZWFyKCk7XG4gICAgdGhpcy5maWx0ZXJGYWN0b3J5LmRlc3Ryb3kodHJ1ZSk7XG4gICAgVGV4dExheWVyLmNsZWFudXAoKTtcbiAgfVxuICBjYWNoZWRQYWdlTnVtYmVyKHJlZikge1xuICAgIGlmICghaXNSZWZQcm94eShyZWYpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVmU3RyID0gcmVmLmdlbiA9PT0gMCA/IGAke3JlZi5udW19UmAgOiBgJHtyZWYubnVtfVIke3JlZi5nZW59YDtcbiAgICByZXR1cm4gdGhpcy4jcGFnZVJlZkNhY2hlLmdldChyZWZTdHIpID8/IG51bGw7XG4gIH1cbn1cbmNsYXNzIFJlbmRlclRhc2sge1xuICAjaW50ZXJuYWxSZW5kZXJUYXNrID0gbnVsbDtcbiAgb25Db250aW51ZSA9IG51bGw7XG4gIG9uRXJyb3IgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihpbnRlcm5hbFJlbmRlclRhc2spIHtcbiAgICB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2sgPSBpbnRlcm5hbFJlbmRlclRhc2s7XG4gIH1cbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ludGVybmFsUmVuZGVyVGFzay5jYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKGV4dHJhRGVsYXkgPSAwKSB7XG4gICAgdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrLmNhbmNlbChudWxsLCBleHRyYURlbGF5KTtcbiAgfVxuICBnZXQgc2VwYXJhdGVBbm5vdHMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2VwYXJhdGVBbm5vdHNcbiAgICB9ID0gdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdDtcbiAgICBpZiAoIXNlcGFyYXRlQW5ub3RzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25DYW52YXNNYXBcbiAgICB9ID0gdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrO1xuICAgIHJldHVybiBzZXBhcmF0ZUFubm90cy5mb3JtIHx8IHNlcGFyYXRlQW5ub3RzLmNhbnZhcyAmJiBhbm5vdGF0aW9uQ2FudmFzTWFwPy5zaXplID4gMDtcbiAgfVxufVxuY2xhc3MgSW50ZXJuYWxSZW5kZXJUYXNrIHtcbiAgI3JBRiA9IG51bGw7XG4gIHN0YXRpYyAjY2FudmFzSW5Vc2UgPSBuZXcgV2Vha1NldCgpO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY2FsbGJhY2ssXG4gICAgcGFyYW1zLFxuICAgIG9ianMsXG4gICAgY29tbW9uT2JqcyxcbiAgICBhbm5vdGF0aW9uQ2FudmFzTWFwLFxuICAgIG9wZXJhdG9yTGlzdCxcbiAgICBwYWdlSW5kZXgsXG4gICAgY2FudmFzRmFjdG9yeSxcbiAgICBmaWx0ZXJGYWN0b3J5LFxuICAgIHVzZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZhbHNlLFxuICAgIHBkZkJ1ZyA9IGZhbHNlLFxuICAgIHBhZ2VDb2xvcnMgPSBudWxsLFxuICAgIGVuYWJsZUhXQSA9IGZhbHNlLFxuICAgIGZpbHRlcmVkT3BlcmF0aW9uSW5kZXhlcyA9IG51bGxcbiAgfSkge1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLm9ianMgPSBvYmpzO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IGNvbW1vbk9ianM7XG4gICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwID0gYW5ub3RhdGlvbkNhbnZhc01hcDtcbiAgICB0aGlzLm9wZXJhdG9yTGlzdElkeCA9IG51bGw7XG4gICAgdGhpcy5vcGVyYXRvckxpc3QgPSBvcGVyYXRvckxpc3Q7XG4gICAgdGhpcy5fcGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5maWx0ZXJGYWN0b3J5ID0gZmlsdGVyRmFjdG9yeTtcbiAgICB0aGlzLl9wZGZCdWcgPSBwZGZCdWc7XG4gICAgdGhpcy5wYWdlQ29sb3JzID0gcGFnZUNvbG9ycztcbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLmdyYXBoaWNzUmVhZHlDYWxsYmFjayA9IG51bGw7XG4gICAgdGhpcy5ncmFwaGljc1JlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5fdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSB0cnVlICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLnRhc2sgPSBuZXcgUmVuZGVyVGFzayh0aGlzKTtcbiAgICB0aGlzLl9jYW5jZWxCb3VuZCA9IHRoaXMuY2FuY2VsLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fY29udGludWVCb3VuZCA9IHRoaXMuX2NvbnRpbnVlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fc2NoZWR1bGVOZXh0Qm91bmQgPSB0aGlzLl9zY2hlZHVsZU5leHQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9uZXh0Qm91bmQgPSB0aGlzLl9uZXh0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fY2FudmFzID0gcGFyYW1zLmNhbnZhcztcbiAgICB0aGlzLl9jYW52YXNDb250ZXh0ID0gcGFyYW1zLmNhbnZhcyA/IG51bGwgOiBwYXJhbXMuY2FudmFzQ29udGV4dDtcbiAgICB0aGlzLl9lbmFibGVIV0EgPSBlbmFibGVIV0E7XG4gICAgdGhpcy5fZGVwZW5kZW5jeVRyYWNrZXIgPSBwYXJhbXMuZGVwZW5kZW5jeVRyYWNrZXI7XG4gICAgdGhpcy5fZmlsdGVyZWRPcGVyYXRpb25JbmRleGVzID0gZmlsdGVyZWRPcGVyYXRpb25JbmRleGVzO1xuICB9XG4gIGdldCBjb21wbGV0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FwYWJpbGl0eS5wcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgfVxuICBpbml0aWFsaXplR3JhcGhpY3Moe1xuICAgIHRyYW5zcGFyZW5jeSA9IGZhbHNlLFxuICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1xuICB9KSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9jYW52YXMpIHtcbiAgICAgIGlmIChJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmhhcyh0aGlzLl9jYW52YXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgdGhlIHNhbWUgY2FudmFzIGR1cmluZyBtdWx0aXBsZSByZW5kZXIoKSBvcGVyYXRpb25zLiBcIiArIFwiVXNlIGRpZmZlcmVudCBjYW52YXMgb3IgZW5zdXJlIHByZXZpb3VzIG9wZXJhdGlvbnMgd2VyZSBcIiArIFwiY2FuY2VsbGVkIG9yIGNvbXBsZXRlZC5cIik7XG4gICAgICB9XG4gICAgICBJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmFkZCh0aGlzLl9jYW52YXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcGRmQnVnICYmIGdsb2JhbFRoaXMuU3RlcHBlck1hbmFnZXI/LmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuc3RlcHBlciA9IGdsb2JhbFRoaXMuU3RlcHBlck1hbmFnZXIuY3JlYXRlKHRoaXMuX3BhZ2VJbmRleCk7XG4gICAgICB0aGlzLnN0ZXBwZXIuaW5pdCh0aGlzLm9wZXJhdG9yTGlzdCk7XG4gICAgICB0aGlzLnN0ZXBwZXIubmV4dEJyZWFrUG9pbnQgPSB0aGlzLnN0ZXBwZXIuZ2V0TmV4dEJyZWFrUG9pbnQoKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgdmlld3BvcnQsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICBiYWNrZ3JvdW5kLFxuICAgICAgZGVwZW5kZW5jeVRyYWNrZXJcbiAgICB9ID0gdGhpcy5wYXJhbXM7XG4gICAgY29uc3QgY2FudmFzQ29udGV4dCA9IHRoaXMuX2NhbnZhc0NvbnRleHQgfHwgdGhpcy5fY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICBhbHBoYTogZmFsc2UsXG4gICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6ICF0aGlzLl9lbmFibGVIV0FcbiAgICB9KTtcbiAgICB0aGlzLmdmeCA9IG5ldyBDYW52YXNHcmFwaGljcyhjYW52YXNDb250ZXh0LCB0aGlzLmNvbW1vbk9ianMsIHRoaXMub2JqcywgdGhpcy5jYW52YXNGYWN0b3J5LCB0aGlzLmZpbHRlckZhY3RvcnksIHtcbiAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1xuICAgIH0sIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCwgdGhpcy5wYWdlQ29sb3JzLCBkZXBlbmRlbmN5VHJhY2tlcik7XG4gICAgdGhpcy5nZnguYmVnaW5EcmF3aW5nKHtcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgdHJhbnNwYXJlbmN5LFxuICAgICAgYmFja2dyb3VuZFxuICAgIH0pO1xuICAgIHRoaXMub3BlcmF0b3JMaXN0SWR4ID0gMDtcbiAgICB0aGlzLmdyYXBoaWNzUmVhZHkgPSB0cnVlO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrPy4oKTtcbiAgfVxuICBjYW5jZWwoZXJyb3IgPSBudWxsLCBleHRyYURlbGF5ID0gMCkge1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB0aGlzLmdmeD8uZW5kRHJhd2luZygpO1xuICAgIGlmICh0aGlzLiNyQUYpIHtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLiNyQUYpO1xuICAgICAgdGhpcy4jckFGID0gbnVsbDtcbiAgICB9XG4gICAgSW50ZXJuYWxSZW5kZXJUYXNrLiNjYW52YXNJblVzZS5kZWxldGUodGhpcy5fY2FudmFzKTtcbiAgICBlcnJvciB8fD0gbmV3IFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbihgUmVuZGVyaW5nIGNhbmNlbGxlZCwgcGFnZSAke3RoaXMuX3BhZ2VJbmRleCArIDF9YCwgZXh0cmFEZWxheSk7XG4gICAgdGhpcy5jYWxsYmFjayhlcnJvcik7XG4gICAgdGhpcy50YXNrLm9uRXJyb3I/LihlcnJvcik7XG4gIH1cbiAgb3BlcmF0b3JMaXN0Q2hhbmdlZCgpIHtcbiAgICBpZiAoIXRoaXMuZ3JhcGhpY3NSZWFkeSkge1xuICAgICAgdGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2sgfHw9IHRoaXMuX2NvbnRpbnVlQm91bmQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3RlcHBlcj8udXBkYXRlT3BlcmF0b3JMaXN0KHRoaXMub3BlcmF0b3JMaXN0KTtcbiAgICBpZiAodGhpcy5ydW5uaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NvbnRpbnVlKCk7XG4gIH1cbiAgX2NvbnRpbnVlKCkge1xuICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnRhc2sub25Db250aW51ZSkge1xuICAgICAgdGhpcy50YXNrLm9uQ29udGludWUodGhpcy5fc2NoZWR1bGVOZXh0Qm91bmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zY2hlZHVsZU5leHQoKTtcbiAgICB9XG4gIH1cbiAgX3NjaGVkdWxlTmV4dCgpIHtcbiAgICBpZiAodGhpcy5fdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICB0aGlzLiNyQUYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy4jckFGID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbmV4dEJvdW5kKCkuY2F0Y2godGhpcy5fY2FuY2VsQm91bmQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4odGhpcy5fbmV4dEJvdW5kKS5jYXRjaCh0aGlzLl9jYW5jZWxCb3VuZCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIF9uZXh0KCkge1xuICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm9wZXJhdG9yTGlzdElkeCA9IHRoaXMuZ2Z4LmV4ZWN1dGVPcGVyYXRvckxpc3QodGhpcy5vcGVyYXRvckxpc3QsIHRoaXMub3BlcmF0b3JMaXN0SWR4LCB0aGlzLl9jb250aW51ZUJvdW5kLCB0aGlzLnN0ZXBwZXIsIHRoaXMuX2ZpbHRlcmVkT3BlcmF0aW9uSW5kZXhlcyk7XG4gICAgaWYgKHRoaXMub3BlcmF0b3JMaXN0SWR4ID09PSB0aGlzLm9wZXJhdG9yTGlzdC5hcmdzQXJyYXkubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmspIHtcbiAgICAgICAgdGhpcy5nZnguZW5kRHJhd2luZygpO1xuICAgICAgICBJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmRlbGV0ZSh0aGlzLl9jYW52YXMpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jb25zdCB2ZXJzaW9uID0gXCI1LjQuMTQ5XCI7XG5jb25zdCBidWlsZCA9IFwiOWUyZTllMjA5XCI7XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9jb2xvcl9waWNrZXIuanNcblxuXG5cbmNsYXNzIENvbG9yUGlja2VyIHtcbiAgI2J1dHRvbiA9IG51bGw7XG4gICNidXR0b25Td2F0Y2ggPSBudWxsO1xuICAjZGVmYXVsdENvbG9yO1xuICAjZHJvcGRvd24gPSBudWxsO1xuICAjZHJvcGRvd25XYXNGcm9tS2V5Ym9hcmQgPSBmYWxzZTtcbiAgI2lzTWFpbkNvbG9yUGlja2VyID0gZmFsc2U7XG4gICNlZGl0b3IgPSBudWxsO1xuICAjZXZlbnRCdXM7XG4gICNvcGVuRHJvcGRvd25BQyA9IG51bGw7XG4gICN1aU1hbmFnZXIgPSBudWxsO1xuICBzdGF0aWMgI2wxMG5Db2xvciA9IG51bGw7XG4gIHN0YXRpYyBnZXQgX2tleWJvYXJkTWFuYWdlcigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiRXNjYXBlXCIsIFwibWFjK0VzY2FwZVwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9oaWRlRHJvcGRvd25Gcm9tS2V5Ym9hcmRdLCBbW1wiIFwiLCBcIm1hYysgXCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX2NvbG9yU2VsZWN0RnJvbUtleWJvYXJkXSwgW1tcIkFycm93RG93blwiLCBcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dEb3duXCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIENvbG9yUGlja2VyLnByb3RvdHlwZS5fbW92ZVRvTmV4dF0sIFtbXCJBcnJvd1VwXCIsIFwiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93VXBcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX21vdmVUb1ByZXZpb3VzXSwgW1tcIkhvbWVcIiwgXCJtYWMrSG9tZVwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9tb3ZlVG9CZWdpbm5pbmddLCBbW1wiRW5kXCIsIFwibWFjK0VuZFwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9tb3ZlVG9FbmRdXSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBlZGl0b3IgPSBudWxsLFxuICAgIHVpTWFuYWdlciA9IG51bGxcbiAgfSkge1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuI2lzTWFpbkNvbG9yUGlja2VyID0gZmFsc2U7XG4gICAgICB0aGlzLiNlZGl0b3IgPSBlZGl0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2lzTWFpbkNvbG9yUGlja2VyID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy4jdWlNYW5hZ2VyID0gZWRpdG9yPy5fdWlNYW5hZ2VyIHx8IHVpTWFuYWdlcjtcbiAgICB0aGlzLiNldmVudEJ1cyA9IHRoaXMuI3VpTWFuYWdlci5fZXZlbnRCdXM7XG4gICAgdGhpcy4jZGVmYXVsdENvbG9yID0gZWRpdG9yPy5jb2xvcj8udG9VcHBlckNhc2UoKSB8fCB0aGlzLiN1aU1hbmFnZXI/LmhpZ2hsaWdodENvbG9ycy52YWx1ZXMoKS5uZXh0KCkudmFsdWUgfHwgXCIjRkZGRjk4XCI7XG4gICAgQ29sb3JQaWNrZXIuI2wxMG5Db2xvciB8fD0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBibHVlOiBcInBkZmpzLWVkaXRvci1jb2xvcnBpY2tlci1ibHVlXCIsXG4gICAgICBncmVlbjogXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItZ3JlZW5cIixcbiAgICAgIHBpbms6IFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLXBpbmtcIixcbiAgICAgIHJlZDogXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItcmVkXCIsXG4gICAgICB5ZWxsb3c6IFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLXllbGxvd1wiXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyQnV0dG9uKCkge1xuICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuI2J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYnV0dG9uLmNsYXNzTmFtZSA9IFwiY29sb3JQaWNrZXJcIjtcbiAgICBidXR0b24udGFiSW5kZXggPSBcIjBcIjtcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLWJ1dHRvblwiKTtcbiAgICBidXR0b24uYXJpYUhhc1BvcHVwID0gXCJ0cnVlXCI7XG4gICAgaWYgKHRoaXMuI2VkaXRvcikge1xuICAgICAgYnV0dG9uLmFyaWFDb250cm9scyA9IGAke3RoaXMuI2VkaXRvci5pZH1fY29sb3JwaWNrZXJfZHJvcGRvd25gO1xuICAgIH1cbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiN1aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuI29wZW5Ecm9wZG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4ja2V5RG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCBzd2F0Y2ggPSB0aGlzLiNidXR0b25Td2F0Y2ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBzd2F0Y2guY2xhc3NOYW1lID0gXCJzd2F0Y2hcIjtcbiAgICBzd2F0Y2guYXJpYUhpZGRlbiA9IFwidHJ1ZVwiO1xuICAgIHN3YXRjaC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLiNkZWZhdWx0Q29sb3I7XG4gICAgYnV0dG9uLmFwcGVuZChzd2F0Y2gpO1xuICAgIHJldHVybiBidXR0b247XG4gIH1cbiAgcmVuZGVyTWFpbkRyb3Bkb3duKCkge1xuICAgIGNvbnN0IGRyb3Bkb3duID0gdGhpcy4jZHJvcGRvd24gPSB0aGlzLiNnZXREcm9wZG93blJvb3QoKTtcbiAgICBkcm9wZG93bi5hcmlhT3JpZW50YXRpb24gPSBcImhvcml6b250YWxcIjtcbiAgICBkcm9wZG93bi5hcmlhTGFiZWxsZWRCeSA9IFwiaGlnaGxpZ2h0Q29sb3JQaWNrZXJMYWJlbFwiO1xuICAgIHJldHVybiBkcm9wZG93bjtcbiAgfVxuICAjZ2V0RHJvcGRvd25Sb290KCkge1xuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBkaXYuY2xhc3NOYW1lID0gXCJkcm9wZG93blwiO1xuICAgIGRpdi5yb2xlID0gXCJsaXN0Ym94XCI7XG4gICAgZGl2LmFyaWFNdWx0aVNlbGVjdGFibGUgPSBcImZhbHNlXCI7XG4gICAgZGl2LmFyaWFPcmllbnRhdGlvbiA9IFwidmVydGljYWxcIjtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLWRyb3Bkb3duXCIpO1xuICAgIGlmICh0aGlzLiNlZGl0b3IpIHtcbiAgICAgIGRpdi5pZCA9IGAke3RoaXMuI2VkaXRvci5pZH1fY29sb3JwaWNrZXJfZHJvcGRvd25gO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBjb2xvcl0gb2YgdGhpcy4jdWlNYW5hZ2VyLmhpZ2hsaWdodENvbG9ycykge1xuICAgICAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgIGJ1dHRvbi50YWJJbmRleCA9IFwiMFwiO1xuICAgICAgYnV0dG9uLnJvbGUgPSBcIm9wdGlvblwiO1xuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtY29sb3JcIiwgY29sb3IpO1xuICAgICAgYnV0dG9uLnRpdGxlID0gbmFtZTtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQ29sb3JQaWNrZXIuI2wxMG5Db2xvcltuYW1lXSk7XG4gICAgICBjb25zdCBzd2F0Y2ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIGJ1dHRvbi5hcHBlbmQoc3dhdGNoKTtcbiAgICAgIHN3YXRjaC5jbGFzc05hbWUgPSBcInN3YXRjaFwiO1xuICAgICAgc3dhdGNoLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xuICAgICAgYnV0dG9uLmFyaWFTZWxlY3RlZCA9IGNvbG9yID09PSB0aGlzLiNkZWZhdWx0Q29sb3I7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuI2NvbG9yU2VsZWN0LmJpbmQodGhpcywgY29sb3IpLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBkaXYuYXBwZW5kKGJ1dHRvbik7XG4gICAgfVxuICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNrZXlEb3duLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHJldHVybiBkaXY7XG4gIH1cbiAgI2NvbG9yU2VsZWN0KGNvbG9yLCBldmVudCkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHRoaXMuI2V2ZW50QnVzLmRpc3BhdGNoKFwic3dpdGNoYW5ub3RhdGlvbmVkaXRvcnBhcmFtc1wiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICB0eXBlOiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfQ09MT1IsXG4gICAgICB2YWx1ZTogY29sb3JcbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZUNvbG9yKGNvbG9yKTtcbiAgfVxuICBfY29sb3JTZWxlY3RGcm9tS2V5Ym9hcmQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLiNidXR0b24pIHtcbiAgICAgIHRoaXMuI29wZW5Ecm9wZG93bihldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yID0gZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtY29sb3JcIik7XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb2xvclNlbGVjdChjb2xvciwgZXZlbnQpO1xuICB9XG4gIF9tb3ZlVG9OZXh0KGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgdGhpcy4jb3BlbkRyb3Bkb3duKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy4jYnV0dG9uKSB7XG4gICAgICB0aGlzLiNkcm9wZG93bi5maXJzdENoaWxkPy5mb2N1cygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC50YXJnZXQubmV4dFNpYmxpbmc/LmZvY3VzKCk7XG4gIH1cbiAgX21vdmVUb1ByZXZpb3VzKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy4jZHJvcGRvd24/LmZpcnN0Q2hpbGQgfHwgZXZlbnQudGFyZ2V0ID09PSB0aGlzLiNidXR0b24pIHtcbiAgICAgIGlmICh0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgICB0aGlzLl9oaWRlRHJvcGRvd25Gcm9tS2V5Ym9hcmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgdGhpcy4jb3BlbkRyb3Bkb3duKGV2ZW50KTtcbiAgICB9XG4gICAgZXZlbnQudGFyZ2V0LnByZXZpb3VzU2libGluZz8uZm9jdXMoKTtcbiAgfVxuICBfbW92ZVRvQmVnaW5uaW5nKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgdGhpcy4jb3BlbkRyb3Bkb3duKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZHJvcGRvd24uZmlyc3RDaGlsZD8uZm9jdXMoKTtcbiAgfVxuICBfbW92ZVRvRW5kKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgdGhpcy4jb3BlbkRyb3Bkb3duKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZHJvcGRvd24ubGFzdENoaWxkPy5mb2N1cygpO1xuICB9XG4gICNrZXlEb3duKGV2ZW50KSB7XG4gICAgQ29sb3JQaWNrZXIuX2tleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgfVxuICAjb3BlbkRyb3Bkb3duKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLmhpZGVEcm9wZG93bigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNkcm9wZG93bldhc0Zyb21LZXlib2FyZCA9IGV2ZW50LmRldGFpbCA9PT0gMDtcbiAgICBpZiAoIXRoaXMuI29wZW5Ecm9wZG93bkFDKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd25BQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jcG9pbnRlckRvd24uYmluZCh0aGlzKSwge1xuICAgICAgICBzaWduYWw6IHRoaXMuI3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiNvcGVuRHJvcGRvd25BQylcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLiNidXR0b24uYXJpYUV4cGFuZGVkID0gXCJ0cnVlXCI7XG4gICAgaWYgKHRoaXMuI2Ryb3Bkb3duKSB7XG4gICAgICB0aGlzLiNkcm9wZG93bi5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByb290ID0gdGhpcy4jZHJvcGRvd24gPSB0aGlzLiNnZXREcm9wZG93blJvb3QoKTtcbiAgICB0aGlzLiNidXR0b24uYXBwZW5kKHJvb3QpO1xuICB9XG4gICNwb2ludGVyRG93bihldmVudCkge1xuICAgIGlmICh0aGlzLiNkcm9wZG93bj8uY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmhpZGVEcm9wZG93bigpO1xuICB9XG4gIGhpZGVEcm9wZG93bigpIHtcbiAgICB0aGlzLiNkcm9wZG93bj8uY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcbiAgICB0aGlzLiNidXR0b24uYXJpYUV4cGFuZGVkID0gXCJmYWxzZVwiO1xuICAgIHRoaXMuI29wZW5Ecm9wZG93bkFDPy5hYm9ydCgpO1xuICAgIHRoaXMuI29wZW5Ecm9wZG93bkFDID0gbnVsbDtcbiAgfVxuICBnZXQgI2lzRHJvcGRvd25WaXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLiNkcm9wZG93biAmJiAhdGhpcy4jZHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKFwiaGlkZGVuXCIpO1xuICB9XG4gIF9oaWRlRHJvcGRvd25Gcm9tS2V5Ym9hcmQoKSB7XG4gICAgaWYgKHRoaXMuI2lzTWFpbkNvbG9yUGlja2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jaXNEcm9wZG93blZpc2libGUpIHtcbiAgICAgIHRoaXMuI2VkaXRvcj8udW5zZWxlY3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5oaWRlRHJvcGRvd24oKTtcbiAgICB0aGlzLiNidXR0b24uZm9jdXMoe1xuICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZSxcbiAgICAgIGZvY3VzVmlzaWJsZTogdGhpcy4jZHJvcGRvd25XYXNGcm9tS2V5Ym9hcmRcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVDb2xvcihjb2xvcikge1xuICAgIGlmICh0aGlzLiNidXR0b25Td2F0Y2gpIHtcbiAgICAgIHRoaXMuI2J1dHRvblN3YXRjaC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNkcm9wZG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpID0gdGhpcy4jdWlNYW5hZ2VyLmhpZ2hsaWdodENvbG9ycy52YWx1ZXMoKTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuI2Ryb3Bkb3duLmNoaWxkcmVuKSB7XG4gICAgICBjaGlsZC5hcmlhU2VsZWN0ZWQgPSBpLm5leHQoKS52YWx1ZSA9PT0gY29sb3IudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNidXR0b24/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2J1dHRvbiA9IG51bGw7XG4gICAgdGhpcy4jYnV0dG9uU3dhdGNoID0gbnVsbDtcbiAgICB0aGlzLiNkcm9wZG93bj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jZHJvcGRvd24gPSBudWxsO1xuICB9XG59XG5jbGFzcyBCYXNpY0NvbG9yUGlja2VyIHtcbiAgI2lucHV0ID0gbnVsbDtcbiAgI2VkaXRvciA9IG51bGw7XG4gICN1aU1hbmFnZXIgPSBudWxsO1xuICBzdGF0aWMgI2wxMG5Db2xvciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvciA9IGVkaXRvcjtcbiAgICB0aGlzLiN1aU1hbmFnZXIgPSBlZGl0b3IuX3VpTWFuYWdlcjtcbiAgICBCYXNpY0NvbG9yUGlja2VyLiNsMTBuQ29sb3IgfHw9IE9iamVjdC5mcmVlemUoe1xuICAgICAgZnJlZXRleHQ6IFwicGRmanMtZWRpdG9yLWNvbG9yLXBpY2tlci1mcmVlLXRleHQtaW5wdXRcIixcbiAgICAgIGluazogXCJwZGZqcy1lZGl0b3ItY29sb3ItcGlja2VyLWluay1pbnB1dFwiXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyQnV0dG9uKCkge1xuICAgIGlmICh0aGlzLiNpbnB1dCkge1xuICAgICAgcmV0dXJuIHRoaXMuI2lucHV0O1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBlZGl0b3JUeXBlLFxuICAgICAgY29sb3JUeXBlLFxuICAgICAgY29sb3JWYWx1ZVxuICAgIH0gPSB0aGlzLiNlZGl0b3I7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLiNpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBpbnB1dC50eXBlID0gXCJjb2xvclwiO1xuICAgIGlucHV0LnZhbHVlID0gY29sb3JWYWx1ZSB8fCBcIiMwMDAwMDBcIjtcbiAgICBpbnB1dC5jbGFzc05hbWUgPSBcImJhc2ljQ29sb3JQaWNrZXJcIjtcbiAgICBpbnB1dC50YWJJbmRleCA9IDA7XG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEJhc2ljQ29sb3JQaWNrZXIuI2wxMG5Db2xvcltlZGl0b3JUeXBlXSk7XG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsICgpID0+IHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci51cGRhdGVQYXJhbXMoY29sb3JUeXBlLCBpbnB1dC52YWx1ZSk7XG4gICAgfSwge1xuICAgICAgc2lnbmFsOiB0aGlzLiN1aU1hbmFnZXIuX3NpZ25hbFxuICAgIH0pO1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuICB1cGRhdGUodmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuI2lucHV0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2lucHV0LnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNpbnB1dD8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jaW5wdXQgPSBudWxsO1xuICB9XG4gIGhpZGVEcm9wZG93bigpIHt9XG59XG5cbjsvLyAuL3NyYy9zaGFyZWQvc2NyaXB0aW5nX3V0aWxzLmpzXG5mdW5jdGlvbiBtYWtlQ29sb3JDb21wKG4pIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgbikpICogMjU1KS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpO1xufVxuZnVuY3Rpb24gc2NhbGVBbmRDbGFtcCh4KSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIDI1NSAqIHgpKTtcbn1cbmNsYXNzIENvbG9yQ29udmVydGVycyB7XG4gIHN0YXRpYyBDTVlLX0coW2MsIHksIG0sIGtdKSB7XG4gICAgcmV0dXJuIFtcIkdcIiwgMSAtIE1hdGgubWluKDEsIDAuMyAqIGMgKyAwLjU5ICogbSArIDAuMTEgKiB5ICsgayldO1xuICB9XG4gIHN0YXRpYyBHX0NNWUsoW2ddKSB7XG4gICAgcmV0dXJuIFtcIkNNWUtcIiwgMCwgMCwgMCwgMSAtIGddO1xuICB9XG4gIHN0YXRpYyBHX1JHQihbZ10pIHtcbiAgICByZXR1cm4gW1wiUkdCXCIsIGcsIGcsIGddO1xuICB9XG4gIHN0YXRpYyBHX3JnYihbZ10pIHtcbiAgICBnID0gc2NhbGVBbmRDbGFtcChnKTtcbiAgICByZXR1cm4gW2csIGcsIGddO1xuICB9XG4gIHN0YXRpYyBHX0hUTUwoW2ddKSB7XG4gICAgY29uc3QgRyA9IG1ha2VDb2xvckNvbXAoZyk7XG4gICAgcmV0dXJuIGAjJHtHfSR7R30ke0d9YDtcbiAgfVxuICBzdGF0aWMgUkdCX0coW3IsIGcsIGJdKSB7XG4gICAgcmV0dXJuIFtcIkdcIiwgMC4zICogciArIDAuNTkgKiBnICsgMC4xMSAqIGJdO1xuICB9XG4gIHN0YXRpYyBSR0JfcmdiKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNvbG9yLm1hcChzY2FsZUFuZENsYW1wKTtcbiAgfVxuICBzdGF0aWMgUkdCX0hUTUwoY29sb3IpIHtcbiAgICByZXR1cm4gYCMke2NvbG9yLm1hcChtYWtlQ29sb3JDb21wKS5qb2luKFwiXCIpfWA7XG4gIH1cbiAgc3RhdGljIFRfSFRNTCgpIHtcbiAgICByZXR1cm4gXCIjMDAwMDAwMDBcIjtcbiAgfVxuICBzdGF0aWMgVF9yZ2IoKSB7XG4gICAgcmV0dXJuIFtudWxsXTtcbiAgfVxuICBzdGF0aWMgQ01ZS19SR0IoW2MsIHksIG0sIGtdKSB7XG4gICAgcmV0dXJuIFtcIlJHQlwiLCAxIC0gTWF0aC5taW4oMSwgYyArIGspLCAxIC0gTWF0aC5taW4oMSwgbSArIGspLCAxIC0gTWF0aC5taW4oMSwgeSArIGspXTtcbiAgfVxuICBzdGF0aWMgQ01ZS19yZ2IoW2MsIHksIG0sIGtdKSB7XG4gICAgcmV0dXJuIFtzY2FsZUFuZENsYW1wKDEgLSBNYXRoLm1pbigxLCBjICsgaykpLCBzY2FsZUFuZENsYW1wKDEgLSBNYXRoLm1pbigxLCBtICsgaykpLCBzY2FsZUFuZENsYW1wKDEgLSBNYXRoLm1pbigxLCB5ICsgaykpXTtcbiAgfVxuICBzdGF0aWMgQ01ZS19IVE1MKGNvbXBvbmVudHMpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLkNNWUtfUkdCKGNvbXBvbmVudHMpLnNsaWNlKDEpO1xuICAgIHJldHVybiB0aGlzLlJHQl9IVE1MKHJnYik7XG4gIH1cbiAgc3RhdGljIFJHQl9DTVlLKFtyLCBnLCBiXSkge1xuICAgIGNvbnN0IGMgPSAxIC0gcjtcbiAgICBjb25zdCBtID0gMSAtIGc7XG4gICAgY29uc3QgeSA9IDEgLSBiO1xuICAgIGNvbnN0IGsgPSBNYXRoLm1pbihjLCBtLCB5KTtcbiAgICByZXR1cm4gW1wiQ01ZS1wiLCBjLCBtLCB5LCBrXTtcbiAgfVxufVxuY29uc3QgRGF0ZUZvcm1hdHMgPSAoLyogdW51c2VkIHB1cmUgZXhwcmVzc2lvbiBvciBzdXBlciAqLyBudWxsICYmIChbXCJtL2RcIiwgXCJtL2QveXlcIiwgXCJtbS9kZC95eVwiLCBcIm1tL3l5XCIsIFwiZC1tbW1cIiwgXCJkLW1tbS15eVwiLCBcImRkLW1tbS15eVwiLCBcInl5LW1tLWRkXCIsIFwibW1tLXl5XCIsIFwibW1tbS15eVwiLCBcIm1tbSBkLCB5eXl5XCIsIFwibW1tbSBkLCB5eXl5XCIsIFwibS9kL3l5IGg6TU0gdHRcIiwgXCJtL2QveXkgSEg6TU1cIl0pKTtcbmNvbnN0IFRpbWVGb3JtYXRzID0gKC8qIHVudXNlZCBwdXJlIGV4cHJlc3Npb24gb3Igc3VwZXIgKi8gbnVsbCAmJiAoW1wiSEg6TU1cIiwgXCJoOk1NIHR0XCIsIFwiSEg6TU06c3NcIiwgXCJoOk1NOnNzIHR0XCJdKSk7XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3N2Z19mYWN0b3J5LmpzXG5cblxuY2xhc3MgQmFzZVNWR0ZhY3Rvcnkge1xuICBjcmVhdGUod2lkdGgsIGhlaWdodCwgc2tpcERpbWVuc2lvbnMgPSBmYWxzZSkge1xuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFNWRyBkaW1lbnNpb25zXCIpO1xuICAgIH1cbiAgICBjb25zdCBzdmcgPSB0aGlzLl9jcmVhdGVTVkcoXCJzdmc6c3ZnXCIpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ2ZXJzaW9uXCIsIFwiMS4xXCIpO1xuICAgIGlmICghc2tpcERpbWVuc2lvbnMpIHtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBgJHt3aWR0aH1weGApO1xuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBgJHtoZWlnaHR9cHhgKTtcbiAgICB9XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcInByZXNlcnZlQXNwZWN0UmF0aW9cIiwgXCJub25lXCIpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsIGAwIDAgJHt3aWR0aH0gJHtoZWlnaHR9YCk7XG4gICAgcmV0dXJuIHN2ZztcbiAgfVxuICBjcmVhdGVFbGVtZW50KHR5cGUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgU1ZHIGVsZW1lbnQgdHlwZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVNWRyh0eXBlKTtcbiAgfVxuICBfY3JlYXRlU1ZHKHR5cGUpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgX2NyZWF0ZVNWR2AgY2FsbGVkLlwiKTtcbiAgfVxufVxuY2xhc3MgRE9NU1ZHRmFjdG9yeSBleHRlbmRzIEJhc2VTVkdGYWN0b3J5IHtcbiAgX2NyZWF0ZVNWRyh0eXBlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIHR5cGUpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3hmYV9sYXllci5qc1xuXG5jbGFzcyBYZmFMYXllciB7XG4gIHN0YXRpYyBzZXR1cFN0b3JhZ2UoaHRtbCwgaWQsIGVsZW1lbnQsIHN0b3JhZ2UsIGludGVudCkge1xuICAgIGNvbnN0IHN0b3JlZERhdGEgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0pO1xuICAgIHN3aXRjaCAoZWxlbWVudC5uYW1lKSB7XG4gICAgICBjYXNlIFwidGV4dGFyZWFcIjpcbiAgICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICBodG1sLnRleHRDb250ZW50ID0gc3RvcmVkRGF0YS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZW50ID09PSBcInByaW50XCIpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgaWYgKGVsZW1lbnQuYXR0cmlidXRlcy50eXBlID09PSBcInJhZGlvXCIgfHwgZWxlbWVudC5hdHRyaWJ1dGVzLnR5cGUgPT09IFwiY2hlY2tib3hcIikge1xuICAgICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlID09PSBlbGVtZW50LmF0dHJpYnV0ZXMueGZhT24pIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0b3JlZERhdGEudmFsdWUgPT09IGVsZW1lbnQuYXR0cmlidXRlcy54ZmFPZmYpIHtcbiAgICAgICAgICAgIGh0bWwucmVtb3ZlQXR0cmlidXRlKFwiY2hlY2tlZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGludGVudCA9PT0gXCJwcmludFwiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC5jaGVja2VkID8gZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZShcInhmYU9uXCIpIDogZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZShcInhmYU9mZlwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgc3RvcmVkRGF0YS52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnRlbnQgPT09IFwicHJpbnRcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBzdG9yZWREYXRhLnZhbHVlKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBlbGVtZW50LmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uLmF0dHJpYnV0ZXMudmFsdWUgPT09IHN0b3JlZERhdGEudmFsdWUpIHtcbiAgICAgICAgICAgICAgb3B0aW9uLmF0dHJpYnV0ZXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb24uYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShcInNlbGVjdGVkXCIpKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb24uYXR0cmlidXRlcy5zZWxlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBldmVudC50YXJnZXQub3B0aW9ucztcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnMuc2VsZWN0ZWRJbmRleCA9PT0gLTEgPyBcIlwiIDogb3B0aW9uc1tvcHRpb25zLnNlbGVjdGVkSW5kZXhdLnZhbHVlO1xuICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhdGljIHNldEF0dHJpYnV0ZXMoe1xuICAgIGh0bWwsXG4gICAgZWxlbWVudCxcbiAgICBzdG9yYWdlID0gbnVsbCxcbiAgICBpbnRlbnQsXG4gICAgbGlua1NlcnZpY2VcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9ID0gZWxlbWVudDtcbiAgICBjb25zdCBpc0hUTUxBbmNob3JFbGVtZW50ID0gaHRtbCBpbnN0YW5jZW9mIEhUTUxBbmNob3JFbGVtZW50O1xuICAgIGlmIChhdHRyaWJ1dGVzLnR5cGUgPT09IFwicmFkaW9cIikge1xuICAgICAgYXR0cmlidXRlcy5uYW1lID0gYCR7YXR0cmlidXRlcy5uYW1lfS0ke2ludGVudH1gO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKSkge1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkYXRhSWRcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImlkXCI6XG4gICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGh0bWwuc3R5bGUsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRleHRDb250ZW50XCI6XG4gICAgICAgICAgaHRtbC50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghaXNIVE1MQW5jaG9yRWxlbWVudCB8fCBrZXkgIT09IFwiaHJlZlwiICYmIGtleSAhPT0gXCJuZXdXaW5kb3dcIikge1xuICAgICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNIVE1MQW5jaG9yRWxlbWVudCkge1xuICAgICAgbGlua1NlcnZpY2UuYWRkTGlua0F0dHJpYnV0ZXMoaHRtbCwgYXR0cmlidXRlcy5ocmVmLCBhdHRyaWJ1dGVzLm5ld1dpbmRvdyk7XG4gICAgfVxuICAgIGlmIChzdG9yYWdlICYmIGF0dHJpYnV0ZXMuZGF0YUlkKSB7XG4gICAgICB0aGlzLnNldHVwU3RvcmFnZShodG1sLCBhdHRyaWJ1dGVzLmRhdGFJZCwgZWxlbWVudCwgc3RvcmFnZSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyByZW5kZXIocGFyYW1ldGVycykge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSBwYXJhbWV0ZXJzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGxpbmtTZXJ2aWNlID0gcGFyYW1ldGVycy5saW5rU2VydmljZTtcbiAgICBjb25zdCByb290ID0gcGFyYW1ldGVycy54ZmFIdG1sO1xuICAgIGNvbnN0IGludGVudCA9IHBhcmFtZXRlcnMuaW50ZW50IHx8IFwiZGlzcGxheVwiO1xuICAgIGNvbnN0IHJvb3RIdG1sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChyb290Lm5hbWUpO1xuICAgIGlmIChyb290LmF0dHJpYnV0ZXMpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlcyh7XG4gICAgICAgIGh0bWw6IHJvb3RIdG1sLFxuICAgICAgICBlbGVtZW50OiByb290LFxuICAgICAgICBpbnRlbnQsXG4gICAgICAgIGxpbmtTZXJ2aWNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgaXNOb3RGb3JSaWNoVGV4dCA9IGludGVudCAhPT0gXCJyaWNoVGV4dFwiO1xuICAgIGNvbnN0IHJvb3REaXYgPSBwYXJhbWV0ZXJzLmRpdjtcbiAgICByb290RGl2LmFwcGVuZChyb290SHRtbCk7XG4gICAgaWYgKHBhcmFtZXRlcnMudmlld3BvcnQpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGBtYXRyaXgoJHtwYXJhbWV0ZXJzLnZpZXdwb3J0LnRyYW5zZm9ybS5qb2luKFwiLFwiKX0pYDtcbiAgICAgIHJvb3REaXYuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIH1cbiAgICBpZiAoaXNOb3RGb3JSaWNoVGV4dCkge1xuICAgICAgcm9vdERpdi5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcInhmYUxheWVyIHhmYUZvbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IHRleHREaXZzID0gW107XG4gICAgaWYgKHJvb3QuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAocm9vdC52YWx1ZSkge1xuICAgICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocm9vdC52YWx1ZSk7XG4gICAgICAgIHJvb3RIdG1sLmFwcGVuZChub2RlKTtcbiAgICAgICAgaWYgKGlzTm90Rm9yUmljaFRleHQgJiYgWGZhVGV4dC5zaG91bGRCdWlsZFRleHQocm9vdC5uYW1lKSkge1xuICAgICAgICAgIHRleHREaXZzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRleHREaXZzXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzdGFjayA9IFtbcm9vdCwgLTEsIHJvb3RIdG1sXV07XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IFtwYXJlbnQsIGksIGh0bWxdID0gc3RhY2suYXQoLTEpO1xuICAgICAgaWYgKGkgKyAxID09PSBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkID0gcGFyZW50LmNoaWxkcmVuWysrc3RhY2suYXQoLTEpWzFdXTtcbiAgICAgIGlmIChjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZVxuICAgICAgfSA9IGNoaWxkO1xuICAgICAgaWYgKG5hbWUgPT09IFwiI3RleHRcIikge1xuICAgICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGQudmFsdWUpO1xuICAgICAgICB0ZXh0RGl2cy5wdXNoKG5vZGUpO1xuICAgICAgICBodG1sLmFwcGVuZChub2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZEh0bWwgPSBjaGlsZD8uYXR0cmlidXRlcz8ueG1sbnMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoY2hpbGQuYXR0cmlidXRlcy54bWxucywgbmFtZSkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpO1xuICAgICAgaHRtbC5hcHBlbmQoY2hpbGRIdG1sKTtcbiAgICAgIGlmIChjaGlsZC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgaHRtbDogY2hpbGRIdG1sLFxuICAgICAgICAgIGVsZW1lbnQ6IGNoaWxkLFxuICAgICAgICAgIHN0b3JhZ2UsXG4gICAgICAgICAgaW50ZW50LFxuICAgICAgICAgIGxpbmtTZXJ2aWNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuPy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN0YWNrLnB1c2goW2NoaWxkLCAtMSwgY2hpbGRIdG1sXSk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLnZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZC52YWx1ZSk7XG4gICAgICAgIGlmIChpc05vdEZvclJpY2hUZXh0ICYmIFhmYVRleHQuc2hvdWxkQnVpbGRUZXh0KG5hbWUpKSB7XG4gICAgICAgICAgdGV4dERpdnMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZEh0bWwuYXBwZW5kKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVsIG9mIHJvb3REaXYucXVlcnlTZWxlY3RvckFsbChcIi54ZmFOb25JbnRlcmFjdGl2ZSBpbnB1dCwgLnhmYU5vbkludGVyYWN0aXZlIHRleHRhcmVhXCIpKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJyZWFkT25seVwiLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHREaXZzXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgdXBkYXRlKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBgbWF0cml4KCR7cGFyYW1ldGVycy52aWV3cG9ydC50cmFuc2Zvcm0uam9pbihcIixcIil9KWA7XG4gICAgcGFyYW1ldGVycy5kaXYuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIHBhcmFtZXRlcnMuZGl2LmhpZGRlbiA9IGZhbHNlO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2Fubm90YXRpb25fbGF5ZXIuanNcblxuXG5cblxuXG5cbmNvbnN0IGFubm90YXRpb25fbGF5ZXJfREVGQVVMVF9GT05UX1NJWkUgPSA5O1xuY29uc3QgR2V0RWxlbWVudHNCeU5hbWVTZXQgPSBuZXcgV2Vha1NldCgpO1xuY29uc3QgVElNRVpPTkVfT0ZGU0VUID0gbmV3IERhdGUoKS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAgKiAxMDAwO1xuY2xhc3MgQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5IHtcbiAgc3RhdGljIGNyZWF0ZShwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3Qgc3VidHlwZSA9IHBhcmFtZXRlcnMuZGF0YS5hbm5vdGF0aW9uVHlwZTtcbiAgICBzd2l0Y2ggKHN1YnR5cGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuTElOSzpcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlRFWFQ6XG4gICAgICAgIHJldHVybiBuZXcgVGV4dEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5XSURHRVQ6XG4gICAgICAgIGNvbnN0IGZpZWxkVHlwZSA9IHBhcmFtZXRlcnMuZGF0YS5maWVsZFR5cGU7XG4gICAgICAgIHN3aXRjaCAoZmllbGRUeXBlKSB7XG4gICAgICAgICAgY2FzZSBcIlR4XCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICBjYXNlIFwiQnRuXCI6XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVycy5kYXRhLnJhZGlvQnV0dG9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1ldGVycy5kYXRhLmNoZWNrQm94KSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hlY2tib3hXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHVzaEJ1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgIGNhc2UgXCJDaFwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaG9pY2VXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICBjYXNlIFwiU2lnXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZVdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlBPUFVQOlxuICAgICAgICByZXR1cm4gbmV3IFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLkZSRUVURVhUOlxuICAgICAgICByZXR1cm4gbmV3IEZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLkxJTkU6XG4gICAgICAgIHJldHVybiBuZXcgTGluZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5TUVVBUkU6XG4gICAgICAgIHJldHVybiBuZXcgU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLkNJUkNMRTpcbiAgICAgICAgcmV0dXJuIG5ldyBDaXJjbGVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuUE9MWUxJTkU6XG4gICAgICAgIHJldHVybiBuZXcgUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuQ0FSRVQ6XG4gICAgICAgIHJldHVybiBuZXcgQ2FyZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuSU5LOlxuICAgICAgICByZXR1cm4gbmV3IElua0Fubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5QT0xZR09OOlxuICAgICAgICByZXR1cm4gbmV3IFBvbHlnb25Bbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuSElHSExJR0hUOlxuICAgICAgICByZXR1cm4gbmV3IEhpZ2hsaWdodEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5VTkRFUkxJTkU6XG4gICAgICAgIHJldHVybiBuZXcgVW5kZXJsaW5lQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlNRVUlHR0xZOlxuICAgICAgICByZXR1cm4gbmV3IFNxdWlnZ2x5QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlNUUklLRU9VVDpcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuU1RBTVA6XG4gICAgICAgIHJldHVybiBuZXcgU3RhbXBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuRklMRUFUVEFDSE1FTlQ6XG4gICAgICAgIHJldHVybiBuZXcgRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuZXcgQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICN1cGRhdGVzID0gbnVsbDtcbiAgI2hhc0JvcmRlciA9IGZhbHNlO1xuICAjcG9wdXBFbGVtZW50ID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycywge1xuICAgIGlzUmVuZGVyYWJsZSA9IGZhbHNlLFxuICAgIGlnbm9yZUJvcmRlciA9IGZhbHNlLFxuICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5pc1JlbmRlcmFibGUgPSBpc1JlbmRlcmFibGU7XG4gICAgdGhpcy5kYXRhID0gcGFyYW1ldGVycy5kYXRhO1xuICAgIHRoaXMubGF5ZXIgPSBwYXJhbWV0ZXJzLmxheWVyO1xuICAgIHRoaXMubGlua1NlcnZpY2UgPSBwYXJhbWV0ZXJzLmxpbmtTZXJ2aWNlO1xuICAgIHRoaXMuZG93bmxvYWRNYW5hZ2VyID0gcGFyYW1ldGVycy5kb3dubG9hZE1hbmFnZXI7XG4gICAgdGhpcy5pbWFnZVJlc291cmNlc1BhdGggPSBwYXJhbWV0ZXJzLmltYWdlUmVzb3VyY2VzUGF0aDtcbiAgICB0aGlzLnJlbmRlckZvcm1zID0gcGFyYW1ldGVycy5yZW5kZXJGb3JtcztcbiAgICB0aGlzLnN2Z0ZhY3RvcnkgPSBwYXJhbWV0ZXJzLnN2Z0ZhY3Rvcnk7XG4gICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZSA9IHBhcmFtZXRlcnMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgdGhpcy5lbmFibGVDb21tZW50ID0gcGFyYW1ldGVycy5lbmFibGVDb21tZW50O1xuICAgIHRoaXMuZW5hYmxlU2NyaXB0aW5nID0gcGFyYW1ldGVycy5lbmFibGVTY3JpcHRpbmc7XG4gICAgdGhpcy5oYXNKU0FjdGlvbnMgPSBwYXJhbWV0ZXJzLmhhc0pTQWN0aW9ucztcbiAgICB0aGlzLl9maWVsZE9iamVjdHMgPSBwYXJhbWV0ZXJzLmZpZWxkT2JqZWN0cztcbiAgICB0aGlzLnBhcmVudCA9IHBhcmFtZXRlcnMucGFyZW50O1xuICAgIGlmIChpc1JlbmRlcmFibGUpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5fY3JlYXRlQ29udGFpbmVyKGlnbm9yZUJvcmRlcik7XG4gICAgfVxuICAgIGlmIChjcmVhdGVRdWFkcmlsYXRlcmFscykge1xuICAgICAgdGhpcy5fY3JlYXRlUXVhZHJpbGF0ZXJhbHMoKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIF9oYXNQb3B1cERhdGEoe1xuICAgIGNvbnRlbnRzT2JqLFxuICAgIHJpY2hUZXh0XG4gIH0pIHtcbiAgICByZXR1cm4gISEoY29udGVudHNPYmo/LnN0ciB8fCByaWNoVGV4dD8uc3RyKTtcbiAgfVxuICBnZXQgX2lzRWRpdGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5pc0VkaXRhYmxlO1xuICB9XG4gIGdldCBoYXNQb3B1cERhdGEoKSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FbGVtZW50Ll9oYXNQb3B1cERhdGEodGhpcy5kYXRhKTtcbiAgfVxuICBnZXQgaGFzQ29tbWVudEJ1dHRvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lbmFibGVDb21tZW50ICYmIHRoaXMuX2lzRWRpdGFibGUgJiYgdGhpcy5oYXNQb3B1cEVsZW1lbnQ7XG4gIH1cbiAgZ2V0IGNvbW1lbnRCdXR0b25Qb3NpdGlvbigpIHtcbiAgICBjb25zdCB7XG4gICAgICBxdWFkUG9pbnRzLFxuICAgICAgcmVjdFxuICAgIH0gPSB0aGlzLmRhdGE7XG4gICAgbGV0IG1heFggPSAtSW5maW5pdHk7XG4gICAgbGV0IG1heFkgPSAtSW5maW5pdHk7XG4gICAgaWYgKHF1YWRQb2ludHM/Lmxlbmd0aCA+PSA4KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1YWRQb2ludHMubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgICAgaWYgKHF1YWRQb2ludHNbaSArIDFdID4gbWF4WSkge1xuICAgICAgICAgIG1heFkgPSBxdWFkUG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICBtYXhYID0gcXVhZFBvaW50c1tpICsgMl07XG4gICAgICAgIH0gZWxzZSBpZiAocXVhZFBvaW50c1tpICsgMV0gPT09IG1heFkpIHtcbiAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgcXVhZFBvaW50c1tpICsgMl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW21heFgsIG1heFldO1xuICAgIH1cbiAgICBpZiAocmVjdCkge1xuICAgICAgcmV0dXJuIFtyZWN0WzJdLCByZWN0WzNdXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0IGNvbW1lbnRCdXR0b25Db2xvcigpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5jb2xvcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IFtyLCBnLCBiXSA9IHRoaXMuZGF0YS5jb2xvcjtcbiAgICBjb25zdCBvcGFjaXR5ID0gdGhpcy5kYXRhLm9wYWNpdHkgPz8gMTtcbiAgICBjb25zdCBvcHBvc2l0ZU9wYWNpdHkgPSAyNTUgKiAoMSAtIG9wYWNpdHkpO1xuICAgIHJldHVybiB0aGlzLiNjaGFuZ2VMaWdodG5lc3MoTWF0aC5taW4ociArIG9wcG9zaXRlT3BhY2l0eSwgMjU1KSwgTWF0aC5taW4oZyArIG9wcG9zaXRlT3BhY2l0eSwgMjU1KSwgTWF0aC5taW4oYiArIG9wcG9zaXRlT3BhY2l0eSwgMjU1KSk7XG4gIH1cbiAgI2NoYW5nZUxpZ2h0bmVzcyhyLCBnLCBiKSB7XG4gICAgciAvPSAyNTU7XG4gICAgZyAvPSAyNTU7XG4gICAgYiAvPSAyNTU7XG4gICAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gICAgY29uc3QgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgY29uc3QgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgICBjb25zdCBuZXdMID0gKCgxICsgTWF0aC5zcXJ0KGwpKSAvIDIgKiAxMDApLnRvRml4ZWQoMik7XG4gICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICByZXR1cm4gYGhzbCgwLCAwJSwgJHtuZXdMfSUpYDtcbiAgICB9XG4gICAgY29uc3QgZCA9IG1heCAtIG1pbjtcbiAgICBsZXQgaDtcbiAgICBpZiAobWF4ID09PSByKSB7XG4gICAgICBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7XG4gICAgfSBlbHNlIGlmIChtYXggPT09IGcpIHtcbiAgICAgIGggPSAoYiAtIHIpIC8gZCArIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGggPSAociAtIGcpIC8gZCArIDQ7XG4gICAgfVxuICAgIGggPSAoaCAqIDYwKS50b0ZpeGVkKDIpO1xuICAgIGNvbnN0IHMgPSAoZCAvICgxIC0gTWF0aC5hYnMoMiAqIGwgLSAxKSkgKiAxMDApLnRvRml4ZWQoMik7XG4gICAgcmV0dXJuIGBoc2woJHtofSwgJHtzfSUsICR7bmV3TH0lKWA7XG4gIH1cbiAgX25vcm1hbGl6ZVBvaW50KHBvaW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZToge1xuICAgICAgICB2aWV3XG4gICAgICB9LFxuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgcmF3RGltczoge1xuICAgICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgICBwYWdlSGVpZ2h0LFxuICAgICAgICAgIHBhZ2VYLFxuICAgICAgICAgIHBhZ2VZXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9ID0gdGhpcy5wYXJlbnQ7XG4gICAgcG9pbnRbMV0gPSB2aWV3WzNdIC0gcG9pbnRbMV0gKyB2aWV3WzFdO1xuICAgIHBvaW50WzBdID0gMTAwICogKHBvaW50WzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRoO1xuICAgIHBvaW50WzFdID0gMTAwICogKHBvaW50WzFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodDtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH1cbiAgdXBkYXRlRWRpdGVkKHBhcmFtcykge1xuICAgIGlmICghdGhpcy5jb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5yZWN0KSB7XG4gICAgICB0aGlzLiN1cGRhdGVzIHx8PSB7XG4gICAgICAgIHJlY3Q6IHRoaXMuZGF0YS5yZWN0LnNsaWNlKDApXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICByZWN0LFxuICAgICAgcG9wdXA6IG5ld1BvcHVwXG4gICAgfSA9IHBhcmFtcztcbiAgICBpZiAocmVjdCkge1xuICAgICAgdGhpcy4jc2V0UmVjdEVkaXRlZChyZWN0KTtcbiAgICB9XG4gICAgbGV0IHBvcHVwID0gdGhpcy4jcG9wdXBFbGVtZW50Py5wb3B1cCB8fCB0aGlzLnBvcHVwO1xuICAgIGlmICghcG9wdXAgJiYgbmV3UG9wdXA/LnRleHQpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKG5ld1BvcHVwKTtcbiAgICAgIHBvcHVwID0gdGhpcy4jcG9wdXBFbGVtZW50LnBvcHVwO1xuICAgIH1cbiAgICBpZiAoIXBvcHVwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBvcHVwLnVwZGF0ZUVkaXRlZChwYXJhbXMpO1xuICAgIGlmIChuZXdQb3B1cD8uZGVsZXRlZCkge1xuICAgICAgcG9wdXAucmVtb3ZlKCk7XG4gICAgICB0aGlzLiNwb3B1cEVsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy5wb3B1cCA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJlc2V0RWRpdGVkKCkge1xuICAgIGlmICghdGhpcy4jdXBkYXRlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNzZXRSZWN0RWRpdGVkKHRoaXMuI3VwZGF0ZXMucmVjdCk7XG4gICAgdGhpcy4jcG9wdXBFbGVtZW50Py5wb3B1cC5yZXNldEVkaXRlZCgpO1xuICAgIHRoaXMuI3VwZGF0ZXMgPSBudWxsO1xuICB9XG4gICNzZXRSZWN0RWRpdGVkKHJlY3QpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXI6IHtcbiAgICAgICAgc3R5bGVcbiAgICAgIH0sXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHJlY3Q6IGN1cnJlbnRSZWN0LFxuICAgICAgICByb3RhdGlvblxuICAgICAgfSxcbiAgICAgIHBhcmVudDoge1xuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICAgICAgICBwYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgY3VycmVudFJlY3Q/LnNwbGljZSgwLCA0LCAuLi5yZWN0KTtcbiAgICBzdHlsZS5sZWZ0ID0gYCR7MTAwICogKHJlY3RbMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGh9JWA7XG4gICAgc3R5bGUudG9wID0gYCR7MTAwICogKHBhZ2VIZWlnaHQgLSByZWN0WzNdICsgcGFnZVkpIC8gcGFnZUhlaWdodH0lYDtcbiAgICBpZiAocm90YXRpb24gPT09IDApIHtcbiAgICAgIHN0eWxlLndpZHRoID0gYCR7MTAwICogKHJlY3RbMl0gLSByZWN0WzBdKSAvIHBhZ2VXaWR0aH0lYDtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGAkezEwMCAqIChyZWN0WzNdIC0gcmVjdFsxXSkgLyBwYWdlSGVpZ2h0fSVgO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFJvdGF0aW9uKHJvdGF0aW9uKTtcbiAgICB9XG4gIH1cbiAgX2NyZWF0ZUNvbnRhaW5lcihpZ25vcmVCb3JkZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgcGFyZW50OiB7XG4gICAgICAgIHBhZ2UsXG4gICAgICAgIHZpZXdwb3J0XG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIik7XG4gICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtYW5ub3RhdGlvbi1pZFwiLCBkYXRhLmlkKTtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQpICYmICEodGhpcyBpbnN0YW5jZW9mIExpbmtBbm5vdGF0aW9uRWxlbWVudCkpIHtcbiAgICAgIGNvbnRhaW5lci50YWJJbmRleCA9IDA7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGNvbnRhaW5lcjtcbiAgICBzdHlsZS56SW5kZXggPSB0aGlzLnBhcmVudC56SW5kZXg7XG4gICAgdGhpcy5wYXJlbnQuekluZGV4ICs9IDI7XG4gICAgaWYgKGRhdGEuYWx0ZXJuYXRpdmVUZXh0KSB7XG4gICAgICBjb250YWluZXIudGl0bGUgPSBkYXRhLmFsdGVybmF0aXZlVGV4dDtcbiAgICB9XG4gICAgaWYgKGRhdGEubm9Sb3RhdGUpIHtcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibm9yb3RhdGVcIik7XG4gICAgfVxuICAgIGlmICghZGF0YS5yZWN0IHx8IHRoaXMgaW5zdGFuY2VvZiBQb3B1cEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvdGF0aW9uXG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGlmICghZGF0YS5oYXNPd25DYW52YXMgJiYgcm90YXRpb24gIT09IDApIHtcbiAgICAgICAgdGhpcy5zZXRSb3RhdGlvbihyb3RhdGlvbiwgY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFpZ25vcmVCb3JkZXIgJiYgZGF0YS5ib3JkZXJTdHlsZS53aWR0aCA+IDApIHtcbiAgICAgIHN0eWxlLmJvcmRlcldpZHRoID0gYCR7ZGF0YS5ib3JkZXJTdHlsZS53aWR0aH1weGA7XG4gICAgICBjb25zdCBob3Jpem9udGFsUmFkaXVzID0gZGF0YS5ib3JkZXJTdHlsZS5ob3Jpem9udGFsQ29ybmVyUmFkaXVzO1xuICAgICAgY29uc3QgdmVydGljYWxSYWRpdXMgPSBkYXRhLmJvcmRlclN0eWxlLnZlcnRpY2FsQ29ybmVyUmFkaXVzO1xuICAgICAgaWYgKGhvcml6b250YWxSYWRpdXMgPiAwIHx8IHZlcnRpY2FsUmFkaXVzID4gMCkge1xuICAgICAgICBjb25zdCByYWRpdXMgPSBgY2FsYygke2hvcml6b250YWxSYWRpdXN9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKSAvIGNhbGMoJHt2ZXJ0aWNhbFJhZGl1c31weCAqIHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikpYDtcbiAgICAgICAgc3R5bGUuYm9yZGVyUmFkaXVzID0gcmFkaXVzO1xuICAgICAgfSBlbHNlIGlmICh0aGlzIGluc3RhbmNlb2YgUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgICBjb25zdCByYWRpdXMgPSBgY2FsYygke3dpZHRofXB4ICogdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSkgLyBjYWxjKCR7aGVpZ2h0fXB4ICogdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSlgO1xuICAgICAgICBzdHlsZS5ib3JkZXJSYWRpdXMgPSByYWRpdXM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGRhdGEuYm9yZGVyU3R5bGUuc3R5bGUpIHtcbiAgICAgICAgY2FzZSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLlNPTElEOlxuICAgICAgICAgIHN0eWxlLmJvcmRlclN0eWxlID0gXCJzb2xpZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuREFTSEVEOlxuICAgICAgICAgIHN0eWxlLmJvcmRlclN0eWxlID0gXCJkYXNoZWRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLkJFVkVMRUQ6XG4gICAgICAgICAgd2FybihcIlVuaW1wbGVtZW50ZWQgYm9yZGVyIHN0eWxlOiBiZXZlbGVkXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuSU5TRVQ6XG4gICAgICAgICAgd2FybihcIlVuaW1wbGVtZW50ZWQgYm9yZGVyIHN0eWxlOiBpbnNldFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLlVOREVSTElORTpcbiAgICAgICAgICBzdHlsZS5ib3JkZXJCb3R0b21TdHlsZSA9IFwic29saWRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJvcmRlckNvbG9yID0gZGF0YS5ib3JkZXJDb2xvciB8fCBudWxsO1xuICAgICAgaWYgKGJvcmRlckNvbG9yKSB7XG4gICAgICAgIHRoaXMuI2hhc0JvcmRlciA9IHRydWU7XG4gICAgICAgIHN0eWxlLmJvcmRlckNvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoYm9yZGVyQ29sb3JbMF0gfCAwLCBib3JkZXJDb2xvclsxXSB8IDAsIGJvcmRlckNvbG9yWzJdIHwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZS5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlY3QgPSBVdGlsLm5vcm1hbGl6ZVJlY3QoW2RhdGEucmVjdFswXSwgcGFnZS52aWV3WzNdIC0gZGF0YS5yZWN0WzFdICsgcGFnZS52aWV3WzFdLCBkYXRhLnJlY3RbMl0sIHBhZ2Uudmlld1szXSAtIGRhdGEucmVjdFszXSArIHBhZ2Uudmlld1sxXV0pO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICBwYWdlWCxcbiAgICAgIHBhZ2VZXG4gICAgfSA9IHZpZXdwb3J0LnJhd0RpbXM7XG4gICAgc3R5bGUubGVmdCA9IGAkezEwMCAqIChyZWN0WzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRofSVgO1xuICAgIHN0eWxlLnRvcCA9IGAkezEwMCAqIChyZWN0WzFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodH0lYDtcbiAgICBjb25zdCB7XG4gICAgICByb3RhdGlvblxuICAgIH0gPSBkYXRhO1xuICAgIGlmIChkYXRhLmhhc093bkNhbnZhcyB8fCByb3RhdGlvbiA9PT0gMCkge1xuICAgICAgc3R5bGUud2lkdGggPSBgJHsxMDAgKiB3aWR0aCAvIHBhZ2VXaWR0aH0lYDtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGAkezEwMCAqIGhlaWdodCAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Um90YXRpb24ocm90YXRpb24sIGNvbnRhaW5lcik7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbiAgc2V0Um90YXRpb24oYW5nbGUsIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEucmVjdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0XG4gICAgfSA9IHRoaXMucGFyZW50LnZpZXdwb3J0LnJhd0RpbXM7XG4gICAgbGV0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGFuZ2xlICUgMTgwICE9PSAwKSB7XG4gICAgICBbd2lkdGgsIGhlaWdodF0gPSBbaGVpZ2h0LCB3aWR0aF07XG4gICAgfVxuICAgIGNvbnRhaW5lci5zdHlsZS53aWR0aCA9IGAkezEwMCAqIHdpZHRoIC8gcGFnZVdpZHRofSVgO1xuICAgIGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBgJHsxMDAgKiBoZWlnaHQgLyBwYWdlSGVpZ2h0fSVgO1xuICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1haW4tcm90YXRpb25cIiwgKDM2MCAtIGFuZ2xlKSAlIDM2MCk7XG4gIH1cbiAgZ2V0IF9jb21tb25BY3Rpb25zKCkge1xuICAgIGNvbnN0IHNldENvbG9yID0gKGpzTmFtZSwgc3R5bGVOYW1lLCBldmVudCkgPT4ge1xuICAgICAgY29uc3QgY29sb3IgPSBldmVudC5kZXRhaWxbanNOYW1lXTtcbiAgICAgIGNvbnN0IGNvbG9yVHlwZSA9IGNvbG9yWzBdO1xuICAgICAgY29uc3QgY29sb3JBcnJheSA9IGNvbG9yLnNsaWNlKDEpO1xuICAgICAgZXZlbnQudGFyZ2V0LnN0eWxlW3N0eWxlTmFtZV0gPSBDb2xvckNvbnZlcnRlcnNbYCR7Y29sb3JUeXBlfV9IVE1MYF0oY29sb3JBcnJheSk7XG4gICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKHRoaXMuZGF0YS5pZCwge1xuICAgICAgICBbc3R5bGVOYW1lXTogQ29sb3JDb252ZXJ0ZXJzW2Ake2NvbG9yVHlwZX1fcmdiYF0oY29sb3JBcnJheSlcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9jb21tb25BY3Rpb25zXCIsIHtcbiAgICAgIGRpc3BsYXk6IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGRpc3BsYXlcbiAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgY29uc3QgaGlkZGVuID0gZGlzcGxheSAlIDIgPT09IDE7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSBoaWRkZW4gPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCI7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgbm9WaWV3OiBoaWRkZW4sXG4gICAgICAgICAgbm9QcmludDogZGlzcGxheSA9PT0gMSB8fCBkaXNwbGF5ID09PSAyXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHByaW50OiBldmVudCA9PiB7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgbm9QcmludDogIWV2ZW50LmRldGFpbC5wcmludFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBoaWRkZW46IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGhpZGRlblxuICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gaGlkZGVuID8gXCJoaWRkZW5cIiA6IFwidmlzaWJsZVwiO1xuICAgICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKHRoaXMuZGF0YS5pZCwge1xuICAgICAgICAgIG5vUHJpbnQ6IGhpZGRlbixcbiAgICAgICAgICBub1ZpZXc6IGhpZGRlblxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBmb2N1czogZXZlbnQgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGV2ZW50LnRhcmdldC5mb2N1cyh7XG4gICAgICAgICAgcHJldmVudFNjcm9sbDogZmFsc2VcbiAgICAgICAgfSksIDApO1xuICAgICAgfSxcbiAgICAgIHVzZXJOYW1lOiBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnRhcmdldC50aXRsZSA9IGV2ZW50LmRldGFpbC51c2VyTmFtZTtcbiAgICAgIH0sXG4gICAgICByZWFkb25seTogZXZlbnQgPT4ge1xuICAgICAgICBldmVudC50YXJnZXQuZGlzYWJsZWQgPSBldmVudC5kZXRhaWwucmVhZG9ubHk7XG4gICAgICB9LFxuICAgICAgcmVxdWlyZWQ6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5fc2V0UmVxdWlyZWQoZXZlbnQudGFyZ2V0LCBldmVudC5kZXRhaWwucmVxdWlyZWQpO1xuICAgICAgfSxcbiAgICAgIGJnQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJiZ0NvbG9yXCIsIFwiYmFja2dyb3VuZENvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBmaWxsQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJmaWxsQ29sb3JcIiwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGZnQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJmZ0NvbG9yXCIsIFwiY29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIHRleHRDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcInRleHRDb2xvclwiLCBcImNvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBib3JkZXJDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImJvcmRlckNvbG9yXCIsIFwiYm9yZGVyQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIHN0cm9rZUNvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwic3Ryb2tlQ29sb3JcIiwgXCJib3JkZXJDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgcm90YXRpb246IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYW5nbGUgPSBldmVudC5kZXRhaWwucm90YXRpb247XG4gICAgICAgIHRoaXMuc2V0Um90YXRpb24oYW5nbGUpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKHRoaXMuZGF0YS5pZCwge1xuICAgICAgICAgIHJvdGF0aW9uOiBhbmdsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpIHtcbiAgICBjb25zdCBjb21tb25BY3Rpb25zID0gdGhpcy5fY29tbW9uQWN0aW9ucztcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoanNFdmVudC5kZXRhaWwpKSB7XG4gICAgICBjb25zdCBhY3Rpb24gPSBhY3Rpb25zW25hbWVdIHx8IGNvbW1vbkFjdGlvbnNbbmFtZV07XG4gICAgICBhY3Rpb24/Lihqc0V2ZW50KTtcbiAgICB9XG4gIH1cbiAgX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGVsZW1lbnQpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlU2NyaXB0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0b3JlZERhdGEgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlLmdldFJhd1ZhbHVlKHRoaXMuZGF0YS5pZCk7XG4gICAgaWYgKCFzdG9yZWREYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbW1vbkFjdGlvbnMgPSB0aGlzLl9jb21tb25BY3Rpb25zO1xuICAgIGZvciAoY29uc3QgW2FjdGlvbk5hbWUsIGRldGFpbF0gb2YgT2JqZWN0LmVudHJpZXMoc3RvcmVkRGF0YSkpIHtcbiAgICAgIGNvbnN0IGFjdGlvbiA9IGNvbW1vbkFjdGlvbnNbYWN0aW9uTmFtZV07XG4gICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50UHJveHkgPSB7XG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBbYWN0aW9uTmFtZV06IGRldGFpbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGFyZ2V0OiBlbGVtZW50XG4gICAgICAgIH07XG4gICAgICAgIGFjdGlvbihldmVudFByb3h5KTtcbiAgICAgICAgZGVsZXRlIHN0b3JlZERhdGFbYWN0aW9uTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9jcmVhdGVRdWFkcmlsYXRlcmFscygpIHtcbiAgICBpZiAoIXRoaXMuY29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHF1YWRQb2ludHNcbiAgICB9ID0gdGhpcy5kYXRhO1xuICAgIGlmICghcXVhZFBvaW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbcmVjdEJsWCwgcmVjdEJsWSwgcmVjdFRyWCwgcmVjdFRyWV0gPSB0aGlzLmRhdGEucmVjdC5tYXAoeCA9PiBNYXRoLmZyb3VuZCh4KSk7XG4gICAgaWYgKHF1YWRQb2ludHMubGVuZ3RoID09PSA4KSB7XG4gICAgICBjb25zdCBbdHJYLCB0clksIGJsWCwgYmxZXSA9IHF1YWRQb2ludHMuc3ViYXJyYXkoMiwgNik7XG4gICAgICBpZiAocmVjdFRyWCA9PT0gdHJYICYmIHJlY3RUclkgPT09IHRyWSAmJiByZWN0QmxYID09PSBibFggJiYgcmVjdEJsWSA9PT0gYmxZKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy5jb250YWluZXI7XG4gICAgbGV0IHN2Z0J1ZmZlcjtcbiAgICBpZiAodGhpcy4jaGFzQm9yZGVyKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGJvcmRlckNvbG9yLFxuICAgICAgICBib3JkZXJXaWR0aFxuICAgICAgfSA9IHN0eWxlO1xuICAgICAgc3R5bGUuYm9yZGVyV2lkdGggPSAwO1xuICAgICAgc3ZnQnVmZmVyID0gW1widXJsKCdkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCxcIiwgYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiYCwgYCBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMSAxXCI+YCwgYDxnIGZpbGw9XCJ0cmFuc3BhcmVudFwiIHN0cm9rZT1cIiR7Ym9yZGVyQ29sb3J9XCIgc3Ryb2tlLXdpZHRoPVwiJHtib3JkZXJXaWR0aH1cIj5gXTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoYXNCb3JkZXJcIik7XG4gICAgfVxuICAgIGNvbnN0IHdpZHRoID0gcmVjdFRyWCAtIHJlY3RCbFg7XG4gICAgY29uc3QgaGVpZ2h0ID0gcmVjdFRyWSAtIHJlY3RCbFk7XG4gICAgY29uc3Qge1xuICAgICAgc3ZnRmFjdG9yeVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN2ZyA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Z1wiKTtcbiAgICBzdmcuY2xhc3NMaXN0LmFkZChcInF1YWRyaWxhdGVyYWxzQ29udGFpbmVyXCIpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCAwKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIDApO1xuICAgIHN2Zy5yb2xlID0gXCJub25lXCI7XG4gICAgY29uc3QgZGVmcyA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImRlZnNcIik7XG4gICAgc3ZnLmFwcGVuZChkZWZzKTtcbiAgICBjb25zdCBjbGlwUGF0aCA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImNsaXBQYXRoXCIpO1xuICAgIGNvbnN0IGlkID0gYGNsaXBwYXRoXyR7dGhpcy5kYXRhLmlkfWA7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlKFwiaWRcIiwgaWQpO1xuICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZShcImNsaXBQYXRoVW5pdHNcIiwgXCJvYmplY3RCb3VuZGluZ0JveFwiKTtcbiAgICBkZWZzLmFwcGVuZChjbGlwUGF0aCk7XG4gICAgZm9yIChsZXQgaSA9IDIsIGlpID0gcXVhZFBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSA4KSB7XG4gICAgICBjb25zdCB0clggPSBxdWFkUG9pbnRzW2ldO1xuICAgICAgY29uc3QgdHJZID0gcXVhZFBvaW50c1tpICsgMV07XG4gICAgICBjb25zdCBibFggPSBxdWFkUG9pbnRzW2kgKyAyXTtcbiAgICAgIGNvbnN0IGJsWSA9IHF1YWRQb2ludHNbaSArIDNdO1xuICAgICAgY29uc3QgcmVjdCA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInJlY3RcIik7XG4gICAgICBjb25zdCB4ID0gKGJsWCAtIHJlY3RCbFgpIC8gd2lkdGg7XG4gICAgICBjb25zdCB5ID0gKHJlY3RUclkgLSB0clkpIC8gaGVpZ2h0O1xuICAgICAgY29uc3QgcmVjdFdpZHRoID0gKHRyWCAtIGJsWCkgLyB3aWR0aDtcbiAgICAgIGNvbnN0IHJlY3RIZWlnaHQgPSAodHJZIC0gYmxZKSAvIGhlaWdodDtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwieFwiLCB4KTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwieVwiLCB5KTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgcmVjdFdpZHRoKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIHJlY3RIZWlnaHQpO1xuICAgICAgY2xpcFBhdGguYXBwZW5kKHJlY3QpO1xuICAgICAgc3ZnQnVmZmVyPy5wdXNoKGA8cmVjdCB2ZWN0b3ItZWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCIgeD1cIiR7eH1cIiB5PVwiJHt5fVwiIHdpZHRoPVwiJHtyZWN0V2lkdGh9XCIgaGVpZ2h0PVwiJHtyZWN0SGVpZ2h0fVwiLz5gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2hhc0JvcmRlcikge1xuICAgICAgc3ZnQnVmZmVyLnB1c2goYDwvZz48L3N2Zz4nKWApO1xuICAgICAgc3R5bGUuYmFja2dyb3VuZEltYWdlID0gc3ZnQnVmZmVyLmpvaW4oXCJcIik7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmNsaXBQYXRoID0gYHVybCgjJHtpZH0pYDtcbiAgfVxuICBfY3JlYXRlUG9wdXAocG9wdXBEYXRhID0gbnVsbCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGFcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgY29udGVudHNPYmosIG1vZGlmaWNhdGlvbkRhdGU7XG4gICAgaWYgKHBvcHVwRGF0YSkge1xuICAgICAgY29udGVudHNPYmogPSB7XG4gICAgICAgIHN0cjogcG9wdXBEYXRhLnRleHRcbiAgICAgIH07XG4gICAgICBtb2RpZmljYXRpb25EYXRlID0gcG9wdXBEYXRhLmRhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnRzT2JqID0gZGF0YS5jb250ZW50c09iajtcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGUgPSBkYXRhLm1vZGlmaWNhdGlvbkRhdGU7XG4gICAgfVxuICAgIGNvbnN0IHBvcHVwID0gdGhpcy4jcG9wdXBFbGVtZW50ID0gbmV3IFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQoe1xuICAgICAgZGF0YToge1xuICAgICAgICBjb2xvcjogZGF0YS5jb2xvcixcbiAgICAgICAgdGl0bGVPYmo6IGRhdGEudGl0bGVPYmosXG4gICAgICAgIG1vZGlmaWNhdGlvbkRhdGUsXG4gICAgICAgIGNvbnRlbnRzT2JqLFxuICAgICAgICByaWNoVGV4dDogZGF0YS5yaWNoVGV4dCxcbiAgICAgICAgcGFyZW50UmVjdDogZGF0YS5yZWN0LFxuICAgICAgICBib3JkZXJTdHlsZTogMCxcbiAgICAgICAgaWQ6IGBwb3B1cF8ke2RhdGEuaWR9YCxcbiAgICAgICAgcm90YXRpb246IGRhdGEucm90YXRpb24sXG4gICAgICAgIG5vUm90YXRlOiB0cnVlXG4gICAgICB9LFxuICAgICAgbGlua1NlcnZpY2U6IHRoaXMubGlua1NlcnZpY2UsXG4gICAgICBwYXJlbnQ6IHRoaXMucGFyZW50LFxuICAgICAgZWxlbWVudHM6IFt0aGlzXVxuICAgIH0pO1xuICAgIHRoaXMucGFyZW50LmRpdi5hcHBlbmQocG9wdXAucmVuZGVyKCkpO1xuICB9XG4gIGdldCBoYXNQb3B1cEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuI3BvcHVwRWxlbWVudCB8fCB0aGlzLnBvcHVwIHx8IHRoaXMuZGF0YS5wb3B1cFJlZik7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBBbm5vdGF0aW9uRWxlbWVudC5yZW5kZXJgIGNhbGxlZFwiKTtcbiAgfVxuICBfZ2V0RWxlbWVudHNCeU5hbWUobmFtZSwgc2tpcElkID0gbnVsbCkge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtdO1xuICAgIGlmICh0aGlzLl9maWVsZE9iamVjdHMpIHtcbiAgICAgIGNvbnN0IGZpZWxkT2JqID0gdGhpcy5fZmllbGRPYmplY3RzW25hbWVdO1xuICAgICAgaWYgKGZpZWxkT2JqKSB7XG4gICAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICAgIHBhZ2UsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgZXhwb3J0VmFsdWVzXG4gICAgICAgIH0gb2YgZmllbGRPYmopIHtcbiAgICAgICAgICBpZiAocGFnZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaWQgPT09IHNraXBJZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGV4cG9ydFZhbHVlID0gdHlwZW9mIGV4cG9ydFZhbHVlcyA9PT0gXCJzdHJpbmdcIiA/IGV4cG9ydFZhbHVlcyA6IG51bGw7XG4gICAgICAgICAgY29uc3QgZG9tRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWVsZW1lbnQtaWQ9XCIke2lkfVwiXWApO1xuICAgICAgICAgIGlmIChkb21FbGVtZW50ICYmICFHZXRFbGVtZW50c0J5TmFtZVNldC5oYXMoZG9tRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHdhcm4oYF9nZXRFbGVtZW50c0J5TmFtZSAtIGVsZW1lbnQgbm90IGFsbG93ZWQ6ICR7aWR9YCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmllbGRzLnB1c2goe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBleHBvcnRWYWx1ZSxcbiAgICAgICAgICAgIGRvbUVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZpZWxkcztcbiAgICB9XG4gICAgZm9yIChjb25zdCBkb21FbGVtZW50IG9mIGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKG5hbWUpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGV4cG9ydFZhbHVlXG4gICAgICB9ID0gZG9tRWxlbWVudDtcbiAgICAgIGNvbnN0IGlkID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIik7XG4gICAgICBpZiAoaWQgPT09IHNraXBJZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghR2V0RWxlbWVudHNCeU5hbWVTZXQuaGFzKGRvbUVsZW1lbnQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZmllbGRzLnB1c2goe1xuICAgICAgICBpZCxcbiAgICAgICAgZXhwb3J0VmFsdWUsXG4gICAgICAgIGRvbUVsZW1lbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGRzO1xuICB9XG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5wb3B1cD8ubWF5YmVTaG93KCk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMucG9wdXA/LmZvcmNlSGlkZSgpO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgY29uc3QgdHJpZ2dlcnMgPSB0aGlzLmdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmlnZ2VycykpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0cmlnZ2Vycykge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2Vycy5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgICB9XG4gIH1cbiAgX2VkaXRPbkRvdWJsZUNsaWNrKCkge1xuICAgIGlmICghdGhpcy5faXNFZGl0YWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uRWRpdG9yVHlwZTogbW9kZSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgaWQ6IGVkaXRJZFxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJkYmxjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcInN3aXRjaGFubm90YXRpb25lZGl0b3Jtb2RlXCIsIHtcbiAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICBtb2RlLFxuICAgICAgICBlZGl0SWQsXG4gICAgICAgIG11c3RFbnRlckluRWRpdE1vZGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnJlY3RbMl0gLSB0aGlzLmRhdGEucmVjdFswXTtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEucmVjdFszXSAtIHRoaXMuZGF0YS5yZWN0WzFdO1xuICB9XG59XG5jbGFzcyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMsIG9wdGlvbnMgPSBudWxsKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiAhIW9wdGlvbnM/Lmlnbm9yZUJvcmRlcixcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5pc1Rvb2x0aXBPbmx5ID0gcGFyYW1ldGVycy5kYXRhLmlzVG9vbHRpcE9ubHk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBsaW5rU2VydmljZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICBsaW5rLnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBkYXRhLmlkKTtcbiAgICBsZXQgaXNCb3VuZCA9IGZhbHNlO1xuICAgIGlmIChkYXRhLnVybCkge1xuICAgICAgbGlua1NlcnZpY2UuYWRkTGlua0F0dHJpYnV0ZXMobGluaywgZGF0YS51cmwsIGRhdGEubmV3V2luZG93KTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5hY3Rpb24pIHtcbiAgICAgIHRoaXMuX2JpbmROYW1lZEFjdGlvbihsaW5rLCBkYXRhLmFjdGlvbiwgZGF0YS5vdmVybGFpZFRleHQpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLmF0dGFjaG1lbnQpIHtcbiAgICAgIHRoaXMuI2JpbmRBdHRhY2htZW50KGxpbmssIGRhdGEuYXR0YWNobWVudCwgZGF0YS5vdmVybGFpZFRleHQsIGRhdGEuYXR0YWNobWVudERlc3QpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLnNldE9DR1N0YXRlKSB7XG4gICAgICB0aGlzLiNiaW5kU2V0T0NHU3RhdGUobGluaywgZGF0YS5zZXRPQ0dTdGF0ZSwgZGF0YS5vdmVybGFpZFRleHQpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLmRlc3QpIHtcbiAgICAgIHRoaXMuX2JpbmRMaW5rKGxpbmssIGRhdGEuZGVzdCwgZGF0YS5vdmVybGFpZFRleHQpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkYXRhLmFjdGlvbnMgJiYgKGRhdGEuYWN0aW9ucy5BY3Rpb24gfHwgZGF0YS5hY3Rpb25zW1wiTW91c2UgVXBcIl0gfHwgZGF0YS5hY3Rpb25zW1wiTW91c2UgRG93blwiXSkgJiYgdGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fYmluZEpTQWN0aW9uKGxpbmssIGRhdGEpO1xuICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnJlc2V0Rm9ybSkge1xuICAgICAgICB0aGlzLl9iaW5kUmVzZXRGb3JtQWN0aW9uKGxpbmssIGRhdGEucmVzZXRGb3JtKTtcbiAgICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNUb29sdGlwT25seSAmJiAhaXNCb3VuZCkge1xuICAgICAgICB0aGlzLl9iaW5kTGluayhsaW5rLCBcIlwiKTtcbiAgICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJsaW5rQW5ub3RhdGlvblwiKTtcbiAgICBpZiAoaXNCb3VuZCkge1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGxpbmspO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgI3NldEludGVybmFsTGluaygpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLWludGVybmFsLWxpbmtcIiwgXCJcIik7XG4gIH1cbiAgX2JpbmRMaW5rKGxpbmssIGRlc3RpbmF0aW9uLCBvdmVybGFpZFRleHQgPSBcIlwiKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXREZXN0aW5hdGlvbkhhc2goZGVzdGluYXRpb24pO1xuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIGlmIChkZXN0aW5hdGlvbikge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmdvVG9EZXN0aW5hdGlvbihkZXN0aW5hdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBpZiAoZGVzdGluYXRpb24gfHwgZGVzdGluYXRpb24gPT09IFwiXCIpIHtcbiAgICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICAgIH1cbiAgICBpZiAob3ZlcmxhaWRUZXh0KSB7XG4gICAgICBsaW5rLnRpdGxlID0gb3ZlcmxhaWRUZXh0O1xuICAgIH1cbiAgfVxuICBfYmluZE5hbWVkQWN0aW9uKGxpbmssIGFjdGlvbiwgb3ZlcmxhaWRUZXh0ID0gXCJcIikge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIHRoaXMubGlua1NlcnZpY2UuZXhlY3V0ZU5hbWVkQWN0aW9uKGFjdGlvbik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBpZiAob3ZlcmxhaWRUZXh0KSB7XG4gICAgICBsaW5rLnRpdGxlID0gb3ZlcmxhaWRUZXh0O1xuICAgIH1cbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgfVxuICAjYmluZEF0dGFjaG1lbnQobGluaywgYXR0YWNobWVudCwgb3ZlcmxhaWRUZXh0ID0gXCJcIiwgZGVzdCA9IG51bGwpIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldEFuY2hvclVybChcIlwiKTtcbiAgICBpZiAoYXR0YWNobWVudC5kZXNjcmlwdGlvbikge1xuICAgICAgbGluay50aXRsZSA9IGF0dGFjaG1lbnQuZGVzY3JpcHRpb247XG4gICAgfSBlbHNlIGlmIChvdmVybGFpZFRleHQpIHtcbiAgICAgIGxpbmsudGl0bGUgPSBvdmVybGFpZFRleHQ7XG4gICAgfVxuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIHRoaXMuZG93bmxvYWRNYW5hZ2VyPy5vcGVuT3JEb3dubG9hZERhdGEoYXR0YWNobWVudC5jb250ZW50LCBhdHRhY2htZW50LmZpbGVuYW1lLCBkZXN0KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gICNiaW5kU2V0T0NHU3RhdGUobGluaywgYWN0aW9uLCBvdmVybGFpZFRleHQgPSBcIlwiKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5saW5rU2VydmljZS5leGVjdXRlU2V0T0NHU3RhdGUoYWN0aW9uKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGlmIChvdmVybGFpZFRleHQpIHtcbiAgICAgIGxpbmsudGl0bGUgPSBvdmVybGFpZFRleHQ7XG4gICAgfVxuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gIF9iaW5kSlNBY3Rpb24obGluaywgZGF0YSkge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoW1tcIkFjdGlvblwiLCBcIm9uY2xpY2tcIl0sIFtcIk1vdXNlIFVwXCIsIFwib25tb3VzZXVwXCJdLCBbXCJNb3VzZSBEb3duXCIsIFwib25tb3VzZWRvd25cIl1dKTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoZGF0YS5hY3Rpb25zKSkge1xuICAgICAgY29uc3QganNOYW1lID0gbWFwLmdldChuYW1lKTtcbiAgICAgIGlmICghanNOYW1lKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGlua1tqc05hbWVdID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiBkYXRhLmlkLFxuICAgICAgICAgICAgbmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChkYXRhLm92ZXJsYWlkVGV4dCkge1xuICAgICAgbGluay50aXRsZSA9IGRhdGEub3ZlcmxhaWRUZXh0O1xuICAgIH1cbiAgICBpZiAoIWxpbmsub25jbGljaykge1xuICAgICAgbGluay5vbmNsaWNrID0gKCkgPT4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gIF9iaW5kUmVzZXRGb3JtQWN0aW9uKGxpbmssIHJlc2V0Rm9ybSkge1xuICAgIGNvbnN0IG90aGVyQ2xpY2tBY3Rpb24gPSBsaW5rLm9uY2xpY2s7XG4gICAgaWYgKCFvdGhlckNsaWNrQWN0aW9uKSB7XG4gICAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldEFuY2hvclVybChcIlwiKTtcbiAgICB9XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gICAgaWYgKCF0aGlzLl9maWVsZE9iamVjdHMpIHtcbiAgICAgIHdhcm4oYF9iaW5kUmVzZXRGb3JtQWN0aW9uIC0gXCJyZXNldEZvcm1cIiBhY3Rpb24gbm90IHN1cHBvcnRlZCwgYCArIFwiZW5zdXJlIHRoYXQgdGhlIGBmaWVsZE9iamVjdHNgIHBhcmFtZXRlciBpcyBwcm92aWRlZC5cIik7XG4gICAgICBpZiAoIW90aGVyQ2xpY2tBY3Rpb24pIHtcbiAgICAgICAgbGluay5vbmNsaWNrID0gKCkgPT4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIG90aGVyQ2xpY2tBY3Rpb24/LigpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBmaWVsZHM6IHJlc2V0Rm9ybUZpZWxkcyxcbiAgICAgICAgcmVmczogcmVzZXRGb3JtUmVmcyxcbiAgICAgICAgaW5jbHVkZVxuICAgICAgfSA9IHJlc2V0Rm9ybTtcbiAgICAgIGNvbnN0IGFsbEZpZWxkcyA9IFtdO1xuICAgICAgaWYgKHJlc2V0Rm9ybUZpZWxkcy5sZW5ndGggIT09IDAgfHwgcmVzZXRGb3JtUmVmcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgY29uc3QgZmllbGRJZHMgPSBuZXcgU2V0KHJlc2V0Rm9ybVJlZnMpO1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBvZiByZXNldEZvcm1GaWVsZHMpIHtcbiAgICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLl9maWVsZE9iamVjdHNbZmllbGROYW1lXSB8fCBbXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgfSBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGZpZWxkSWRzLmFkZChpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZmllbGRzIG9mIE9iamVjdC52YWx1ZXModGhpcy5fZmllbGRPYmplY3RzKSkge1xuICAgICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoZmllbGRJZHMuaGFzKGZpZWxkLmlkKSA9PT0gaW5jbHVkZSkge1xuICAgICAgICAgICAgICBhbGxGaWVsZHMucHVzaChmaWVsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkcyBvZiBPYmplY3QudmFsdWVzKHRoaXMuX2ZpZWxkT2JqZWN0cykpIHtcbiAgICAgICAgICBhbGxGaWVsZHMucHVzaCguLi5maWVsZHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICAgIGNvbnN0IGFsbElkcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBhbGxGaWVsZHMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGlkXG4gICAgICAgIH0gPSBmaWVsZDtcbiAgICAgICAgYWxsSWRzLnB1c2goaWQpO1xuICAgICAgICBzd2l0Y2ggKGZpZWxkLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGZpZWxkLmRlZmF1bHRWYWx1ZSB8fCBcIlwiO1xuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJjaGVja2JveFwiOlxuICAgICAgICAgIGNhc2UgXCJyYWRpb2J1dHRvblwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGZpZWxkLmRlZmF1bHRWYWx1ZSA9PT0gZmllbGQuZXhwb3J0VmFsdWVzO1xuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJjb21ib2JveFwiOlxuICAgICAgICAgIGNhc2UgXCJsaXN0Ym94XCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQuZGVmYXVsdFZhbHVlIHx8IFwiXCI7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvbUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1lbGVtZW50LWlkPVwiJHtpZH1cIl1gKTtcbiAgICAgICAgaWYgKCFkb21FbGVtZW50KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIUdldEVsZW1lbnRzQnlOYW1lU2V0Lmhhcyhkb21FbGVtZW50KSkge1xuICAgICAgICAgIHdhcm4oYF9iaW5kUmVzZXRGb3JtQWN0aW9uIC0gZWxlbWVudCBub3QgYWxsb3dlZDogJHtpZH1gKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBkb21FbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicmVzZXRmb3JtXCIpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZykge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiBcImFwcFwiLFxuICAgICAgICAgICAgaWRzOiBhbGxJZHMsXG4gICAgICAgICAgICBuYW1lOiBcIlJlc2V0Rm9ybVwiXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICB9XG59XG5jbGFzcyBUZXh0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInRleHRBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICBpbWFnZS5zcmMgPSB0aGlzLmltYWdlUmVzb3VyY2VzUGF0aCArIFwiYW5ub3RhdGlvbi1cIiArIHRoaXMuZGF0YS5uYW1lLnRvTG93ZXJDYXNlKCkgKyBcIi5zdmdcIjtcbiAgICBpbWFnZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy10ZXh0LWFubm90YXRpb24tdHlwZVwiKTtcbiAgICBpbWFnZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4tYXJnc1wiLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICB0eXBlOiB0aGlzLmRhdGEubmFtZVxuICAgIH0pKTtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGltYWdlKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIHNob3dFbGVtZW50QW5kSGlkZUNhbnZhcyhlbGVtZW50KSB7XG4gICAgaWYgKHRoaXMuZGF0YS5oYXNPd25DYW52YXMpIHtcbiAgICAgIGlmIChlbGVtZW50LnByZXZpb3VzU2libGluZz8ubm9kZU5hbWUgPT09IFwiQ0FOVkFTXCIpIHtcbiAgICAgICAgZWxlbWVudC5wcmV2aW91c1NpYmxpbmcuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQuaGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIF9nZXRLZXlNb2RpZmllcihldmVudCkge1xuICAgIHJldHVybiB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtLmlzTWFjID8gZXZlbnQubWV0YUtleSA6IGV2ZW50LmN0cmxLZXk7XG4gIH1cbiAgX3NldEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZWxlbWVudERhdGEsIGJhc2VOYW1lLCBldmVudE5hbWUsIHZhbHVlR2V0dGVyKSB7XG4gICAgaWYgKGJhc2VOYW1lLmluY2x1ZGVzKFwibW91c2VcIikpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihiYXNlTmFtZSwgZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmRhdGEuaWQsXG4gICAgICAgICAgICBuYW1lOiBldmVudE5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVHZXR0ZXIoZXZlbnQpLFxuICAgICAgICAgICAgc2hpZnQ6IGV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgbW9kaWZpZXI6IHRoaXMuX2dldEtleU1vZGlmaWVyKGV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGJhc2VOYW1lLCBldmVudCA9PiB7XG4gICAgICAgIGlmIChiYXNlTmFtZSA9PT0gXCJibHVyXCIpIHtcbiAgICAgICAgICBpZiAoIWVsZW1lbnREYXRhLmZvY3VzZWQgfHwgIWV2ZW50LnJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGJhc2VOYW1lID09PSBcImZvY3VzXCIpIHtcbiAgICAgICAgICBpZiAoZWxlbWVudERhdGEuZm9jdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50RGF0YS5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZhbHVlR2V0dGVyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQ6IHRoaXMuZGF0YS5pZCxcbiAgICAgICAgICAgIG5hbWU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZUdldHRlcihldmVudClcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9zZXRFdmVudExpc3RlbmVycyhlbGVtZW50LCBlbGVtZW50RGF0YSwgbmFtZXMsIGdldHRlcikge1xuICAgIGZvciAoY29uc3QgW2Jhc2VOYW1lLCBldmVudE5hbWVdIG9mIG5hbWVzKSB7XG4gICAgICBpZiAoZXZlbnROYW1lID09PSBcIkFjdGlvblwiIHx8IHRoaXMuZGF0YS5hY3Rpb25zPy5bZXZlbnROYW1lXSkge1xuICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcIkZvY3VzXCIgfHwgZXZlbnROYW1lID09PSBcIkJsdXJcIikge1xuICAgICAgICAgIGVsZW1lbnREYXRhIHx8PSB7XG4gICAgICAgICAgICBmb2N1c2VkOiBmYWxzZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcihlbGVtZW50LCBlbGVtZW50RGF0YSwgYmFzZU5hbWUsIGV2ZW50TmFtZSwgZ2V0dGVyKTtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJGb2N1c1wiICYmICF0aGlzLmRhdGEuYWN0aW9ucz8uQmx1cikge1xuICAgICAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZWxlbWVudERhdGEsIFwiYmx1clwiLCBcIkJsdXJcIiwgbnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnROYW1lID09PSBcIkJsdXJcIiAmJiAhdGhpcy5kYXRhLmFjdGlvbnM/LkZvY3VzKSB7XG4gICAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcihlbGVtZW50LCBlbGVtZW50RGF0YSwgXCJmb2N1c1wiLCBcIkZvY3VzXCIsIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCkge1xuICAgIGNvbnN0IGNvbG9yID0gdGhpcy5kYXRhLmJhY2tncm91bmRDb2xvciB8fCBudWxsO1xuICAgIGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3IgPT09IG51bGwgPyBcInRyYW5zcGFyZW50XCIgOiBVdGlsLm1ha2VIZXhDb2xvcihjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdKTtcbiAgfVxuICBfc2V0VGV4dFN0eWxlKGVsZW1lbnQpIHtcbiAgICBjb25zdCBURVhUX0FMSUdOTUVOVCA9IFtcImxlZnRcIiwgXCJjZW50ZXJcIiwgXCJyaWdodFwiXTtcbiAgICBjb25zdCB7XG4gICAgICBmb250Q29sb3JcbiAgICB9ID0gdGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YTtcbiAgICBjb25zdCBmb250U2l6ZSA9IHRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGEuZm9udFNpemUgfHwgYW5ub3RhdGlvbl9sYXllcl9ERUZBVUxUX0ZPTlRfU0laRTtcbiAgICBjb25zdCBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gICAgbGV0IGNvbXB1dGVkRm9udFNpemU7XG4gICAgY29uc3QgQk9SREVSX1NJWkUgPSAyO1xuICAgIGNvbnN0IHJvdW5kVG9PbmVEZWNpbWFsID0geCA9PiBNYXRoLnJvdW5kKDEwICogeCkgLyAxMDtcbiAgICBpZiAodGhpcy5kYXRhLm11bHRpTGluZSkge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5hYnModGhpcy5kYXRhLnJlY3RbM10gLSB0aGlzLmRhdGEucmVjdFsxXSAtIEJPUkRFUl9TSVpFKTtcbiAgICAgIGNvbnN0IG51bWJlck9mTGluZXMgPSBNYXRoLnJvdW5kKGhlaWdodCAvIChMSU5FX0ZBQ1RPUiAqIGZvbnRTaXplKSkgfHwgMTtcbiAgICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBoZWlnaHQgLyBudW1iZXJPZkxpbmVzO1xuICAgICAgY29tcHV0ZWRGb250U2l6ZSA9IE1hdGgubWluKGZvbnRTaXplLCByb3VuZFRvT25lRGVjaW1hbChsaW5lSGVpZ2h0IC8gTElORV9GQUNUT1IpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5hYnModGhpcy5kYXRhLnJlY3RbM10gLSB0aGlzLmRhdGEucmVjdFsxXSAtIEJPUkRFUl9TSVpFKTtcbiAgICAgIGNvbXB1dGVkRm9udFNpemUgPSBNYXRoLm1pbihmb250U2l6ZSwgcm91bmRUb09uZURlY2ltYWwoaGVpZ2h0IC8gTElORV9GQUNUT1IpKTtcbiAgICB9XG4gICAgc3R5bGUuZm9udFNpemUgPSBgY2FsYygke2NvbXB1dGVkRm9udFNpemV9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKWA7XG4gICAgc3R5bGUuY29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvcihmb250Q29sb3JbMF0sIGZvbnRDb2xvclsxXSwgZm9udENvbG9yWzJdKTtcbiAgICBpZiAodGhpcy5kYXRhLnRleHRBbGlnbm1lbnQgIT09IG51bGwpIHtcbiAgICAgIHN0eWxlLnRleHRBbGlnbiA9IFRFWFRfQUxJR05NRU5UW3RoaXMuZGF0YS50ZXh0QWxpZ25tZW50XTtcbiAgICB9XG4gIH1cbiAgX3NldFJlcXVpcmVkKGVsZW1lbnQsIGlzUmVxdWlyZWQpIHtcbiAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJyZXF1aXJlZFwiLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJyZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXJlcXVpcmVkXCIsIGlzUmVxdWlyZWQpO1xuICB9XG59XG5jbGFzcyBUZXh0V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBpc1JlbmRlcmFibGUgPSBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zIHx8IHBhcmFtZXRlcnMuZGF0YS5oYXNPd25DYW52YXMgfHwgIXBhcmFtZXRlcnMuZGF0YS5oYXNBcHBlYXJhbmNlICYmICEhcGFyYW1ldGVycy5kYXRhLmZpZWxkVmFsdWU7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlXG4gICAgfSk7XG4gIH1cbiAgc2V0UHJvcGVydHlPblNpYmxpbmdzKGJhc2UsIGtleSwgdmFsdWUsIGtleUluU3RvcmFnZSkge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShiYXNlLm5hbWUsIGJhc2UuaWQpKSB7XG4gICAgICBpZiAoZWxlbWVudC5kb21FbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuZG9tRWxlbWVudFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGVsZW1lbnQuaWQsIHtcbiAgICAgICAgW2tleUluU3RvcmFnZV06IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGlkID0gdGhpcy5kYXRhLmlkO1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ0ZXh0V2lkZ2V0QW5ub3RhdGlvblwiKTtcbiAgICBsZXQgZWxlbWVudCA9IG51bGw7XG4gICAgaWYgKHRoaXMucmVuZGVyRm9ybXMpIHtcbiAgICAgIGNvbnN0IHN0b3JlZERhdGEgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlOiB0aGlzLmRhdGEuZmllbGRWYWx1ZVxuICAgICAgfSk7XG4gICAgICBsZXQgdGV4dENvbnRlbnQgPSBzdG9yZWREYXRhLnZhbHVlIHx8IFwiXCI7XG4gICAgICBjb25zdCBtYXhMZW4gPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICAgIGNoYXJMaW1pdDogdGhpcy5kYXRhLm1heExlblxuICAgICAgfSkuY2hhckxpbWl0O1xuICAgICAgaWYgKG1heExlbiAmJiB0ZXh0Q29udGVudC5sZW5ndGggPiBtYXhMZW4pIHtcbiAgICAgICAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5zbGljZSgwLCBtYXhMZW4pO1xuICAgICAgfVxuICAgICAgbGV0IGZpZWxkRm9ybWF0dGVkVmFsdWVzID0gc3RvcmVkRGF0YS5mb3JtYXR0ZWRWYWx1ZSB8fCB0aGlzLmRhdGEudGV4dENvbnRlbnQ/LmpvaW4oXCJcXG5cIikgfHwgbnVsbDtcbiAgICAgIGlmIChmaWVsZEZvcm1hdHRlZFZhbHVlcyAmJiB0aGlzLmRhdGEuY29tYikge1xuICAgICAgICBmaWVsZEZvcm1hdHRlZFZhbHVlcyA9IGZpZWxkRm9ybWF0dGVkVmFsdWVzLnJlcGxhY2VBbGwoL1xccysvZywgXCJcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBlbGVtZW50RGF0YSA9IHtcbiAgICAgICAgdXNlclZhbHVlOiB0ZXh0Q29udGVudCxcbiAgICAgICAgZm9ybWF0dGVkVmFsdWU6IGZpZWxkRm9ybWF0dGVkVmFsdWVzLFxuICAgICAgICBsYXN0Q29tbWl0dGVkVmFsdWU6IG51bGwsXG4gICAgICAgIGNvbW1pdEtleTogMSxcbiAgICAgICAgZm9jdXNlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5kYXRhLm11bHRpTGluZSkge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xuICAgICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gZmllbGRGb3JtYXR0ZWRWYWx1ZXMgPz8gdGV4dENvbnRlbnQ7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuZG9Ob3RTY3JvbGwpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLm92ZXJmbG93WSA9IFwiaGlkZGVuXCI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgIGVsZW1lbnQudHlwZSA9IHRoaXMuZGF0YS5wYXNzd29yZCA/IFwicGFzc3dvcmRcIiA6IFwidGV4dFwiO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIGZpZWxkRm9ybWF0dGVkVmFsdWVzID8/IHRleHRDb250ZW50KTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5kb05vdFNjcm9sbCkge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGUub3ZlcmZsb3dYID0gXCJoaWRkZW5cIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGF0YS5oYXNPd25DYW52YXMpIHtcbiAgICAgICAgZWxlbWVudC5oaWRkZW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgR2V0RWxlbWVudHNCeU5hbWVTZXQuYWRkKGVsZW1lbnQpO1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgICAgZWxlbWVudC5kaXNhYmxlZCA9IHRoaXMuZGF0YS5yZWFkT25seTtcbiAgICAgIGVsZW1lbnQubmFtZSA9IHRoaXMuZGF0YS5maWVsZE5hbWU7XG4gICAgICBlbGVtZW50LnRhYkluZGV4ID0gMDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0ZXRpbWVGb3JtYXQsXG4gICAgICAgIGRhdGV0aW1lVHlwZSxcbiAgICAgICAgdGltZVN0ZXBcbiAgICAgIH0gPSB0aGlzLmRhdGE7XG4gICAgICBjb25zdCBoYXNEYXRlT3JUaW1lID0gISFkYXRldGltZVR5cGUgJiYgdGhpcy5lbmFibGVTY3JpcHRpbmc7XG4gICAgICBpZiAoZGF0ZXRpbWVGb3JtYXQpIHtcbiAgICAgICAgZWxlbWVudC50aXRsZSA9IGRhdGV0aW1lRm9ybWF0O1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0UmVxdWlyZWQoZWxlbWVudCwgdGhpcy5kYXRhLnJlcXVpcmVkKTtcbiAgICAgIGlmIChtYXhMZW4pIHtcbiAgICAgICAgZWxlbWVudC5tYXhMZW5ndGggPSBtYXhMZW47XG4gICAgICB9XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFByb3BlcnR5T25TaWJsaW5ncyhlbGVtZW50LCBcInZhbHVlXCIsIGV2ZW50LnRhcmdldC52YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSB0aGlzLmRhdGEuZGVmYXVsdEZpZWxkVmFsdWUgPz8gXCJcIjtcbiAgICAgICAgZWxlbWVudC52YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBsZXQgYmx1ckxpc3RlbmVyID0gZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZm9ybWF0dGVkVmFsdWVcbiAgICAgICAgfSA9IGVsZW1lbnREYXRhO1xuICAgICAgICBpZiAoZm9ybWF0dGVkVmFsdWUgIT09IG51bGwgJiYgZm9ybWF0dGVkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnRhcmdldC5zY3JvbGxMZWZ0ID0gMDtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5mb2N1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICBpZiAoaGFzRGF0ZU9yVGltZSkge1xuICAgICAgICAgICAgdGFyZ2V0LnR5cGUgPSBkYXRldGltZVR5cGU7XG4gICAgICAgICAgICBpZiAodGltZVN0ZXApIHtcbiAgICAgICAgICAgICAgdGFyZ2V0LnN0ZXAgPSB0aW1lU3RlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLnVzZXJWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWU7XG4gICAgICAgICAgICBpZiAoaGFzRGF0ZU9yVGltZSkge1xuICAgICAgICAgICAgICBpZiAoZGF0ZXRpbWVUeXBlID09PSBcInRpbWVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBbZGF0ZS5nZXRIb3VycygpLCBkYXRlLmdldE1pbnV0ZXMoKSwgZGF0ZS5nZXRTZWNvbmRzKCldO1xuICAgICAgICAgICAgICAgIHRhcmdldC52YWx1ZSA9IHBhcnRzLm1hcCh2ID0+IHYudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIikpLmpvaW4oXCI6XCIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldC52YWx1ZSA9IG5ldyBEYXRlKHZhbHVlIC0gVElNRVpPTkVfT0ZGU0VUKS50b0lTT1N0cmluZygpLnNwbGl0KGRhdGV0aW1lVHlwZSA9PT0gXCJkYXRlXCIgPyBcIlRcIiA6IFwiLlwiLCAxKVswXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGFyZ2V0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9IHRhcmdldC52YWx1ZTtcbiAgICAgICAgICBlbGVtZW50RGF0YS5jb21taXRLZXkgPSAxO1xuICAgICAgICAgIGlmICghdGhpcy5kYXRhLmFjdGlvbnM/LkZvY3VzKSB7XG4gICAgICAgICAgICBlbGVtZW50RGF0YS5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgICB0aGlzLnNob3dFbGVtZW50QW5kSGlkZUNhbnZhcyhqc0V2ZW50LnRhcmdldCk7XG4gICAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICAgIHZhbHVlKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IGV2ZW50LmRldGFpbC52YWx1ZSA/PyBcIlwiO1xuICAgICAgICAgICAgICBpZiAoIWhhc0RhdGVPclRpbWUpIHtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZWxlbWVudERhdGEudXNlclZhbHVlLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWUoZXZlbnQpIHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlXG4gICAgICAgICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgICAgICAgIGVsZW1lbnREYXRhLmZvcm1hdHRlZFZhbHVlID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgICAgIGlmIChmb3JtYXR0ZWRWYWx1ZSAhPT0gbnVsbCAmJiBmb3JtYXR0ZWRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGV2ZW50LnRhcmdldCAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKGhhc0RhdGVPclRpbWUpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnZhbHVlID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwgZGF0YSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VsUmFuZ2UoZXZlbnQpIHtcbiAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnNldFNlbGVjdGlvblJhbmdlKC4uLmV2ZW50LmRldGFpbC5zZWxSYW5nZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hhckxpbWl0OiBldmVudCA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBjaGFyTGltaXRcbiAgICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgICAgIGlmIChjaGFyTGltaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwibWF4TGVuZ3RoXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwibWF4TGVuZ3RoXCIsIGNoYXJMaW1pdCk7XG4gICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZTtcbiAgICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPD0gY2hhckxpbWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgY2hhckxpbWl0KTtcbiAgICAgICAgICAgICAgdGFyZ2V0LnZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgIHdpbGxDb21taXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICBjb21taXRLZXk6IDEsXG4gICAgICAgICAgICAgICAgICBzZWxTdGFydDogdGFyZ2V0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgc2VsRW5kOiB0YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIGVsZW1lbnREYXRhLmNvbW1pdEtleSA9IDE7XG4gICAgICAgICAgbGV0IGNvbW1pdEtleSA9IC0xO1xuICAgICAgICAgIGlmIChldmVudC5rZXkgPT09IFwiRXNjYXBlXCIpIHtcbiAgICAgICAgICAgIGNvbW1pdEtleSA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09IFwiRW50ZXJcIiAmJiAhdGhpcy5kYXRhLm11bHRpTGluZSkge1xuICAgICAgICAgICAgY29tbWl0S2V5ID0gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gXCJUYWJcIikge1xuICAgICAgICAgICAgZWxlbWVudERhdGEuY29tbWl0S2V5ID0gMztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbW1pdEtleSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5sYXN0Q29tbWl0dGVkVmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICB3aWxsQ29tbWl0OiB0cnVlLFxuICAgICAgICAgICAgICBjb21taXRLZXksXG4gICAgICAgICAgICAgIHNlbFN0YXJ0OiBldmVudC50YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgIHNlbEVuZDogZXZlbnQudGFyZ2V0LnNlbGVjdGlvbkVuZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgX2JsdXJMaXN0ZW5lciA9IGJsdXJMaXN0ZW5lcjtcbiAgICAgICAgYmx1ckxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBldmVudCA9PiB7XG4gICAgICAgICAgaWYgKCFlbGVtZW50RGF0YS5mb2N1c2VkIHx8ICFldmVudC5yZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5kYXRhLmFjdGlvbnM/LkJsdXIpIHtcbiAgICAgICAgICAgIGVsZW1lbnREYXRhLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgfSA9IGV2ZW50O1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSB0YXJnZXQ7XG4gICAgICAgICAgaWYgKGhhc0RhdGVPclRpbWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiBkYXRldGltZVR5cGUgPT09IFwidGltZVwiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gdmFsdWUuc3BsaXQoXCI6XCIpLm1hcCh2ID0+IHBhcnNlSW50KHYsIDEwKSk7XG4gICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUoMjAwMCwgMCwgMSwgcGFydHNbMF0sIHBhcnRzWzFdLCBwYXJ0c1syXSB8fCAwKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgIHRhcmdldC5zdGVwID0gXCJcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5sYXN0Q29tbWl0dGVkVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgd2lsbENvbW1pdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb21taXRLZXk6IGVsZW1lbnREYXRhLmNvbW1pdEtleSxcbiAgICAgICAgICAgICAgICBzZWxTdGFydDogZXZlbnQudGFyZ2V0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICAgIHNlbEVuZDogZXZlbnQudGFyZ2V0LnNlbGVjdGlvbkVuZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2JsdXJMaXN0ZW5lcihldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5kYXRhLmFjdGlvbnM/LktleXN0cm9rZSkge1xuICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgICAgfSA9IGV2ZW50O1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgIHNlbGVjdGlvbkVuZFxuICAgICAgICAgICAgfSA9IHRhcmdldDtcbiAgICAgICAgICAgIGxldCBzZWxTdGFydCA9IHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICBzZWxFbmQgPSBzZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LmlucHV0VHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlV29yZEJhY2t3YXJkXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5zdWJzdHJpbmcoMCwgc2VsZWN0aW9uU3RhcnQpLm1hdGNoKC9cXHcqW15cXHddKiQvKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxTdGFydCAtPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVXb3JkRm9yd2FyZFwiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdmFsdWUuc3Vic3RyaW5nKHNlbGVjdGlvblN0YXJ0KS5tYXRjaCgvXlteXFx3XSpcXHcqLyk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsRW5kICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiOlxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCA9PT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICBzZWxTdGFydCAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZUNvbnRlbnRGb3J3YXJkXCI6XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID09PSBzZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgIHNlbEVuZCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgY2hhbmdlOiBkYXRhIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgd2lsbENvbW1pdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2VsU3RhcnQsXG4gICAgICAgICAgICAgICAgc2VsRW5kXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBbW1wiZm9jdXNcIiwgXCJGb2N1c1wiXSwgW1wiYmx1clwiLCBcIkJsdXJcIl0sIFtcIm1vdXNlZG93blwiLCBcIk1vdXNlIERvd25cIl0sIFtcIm1vdXNlZW50ZXJcIiwgXCJNb3VzZSBFbnRlclwiXSwgW1wibW91c2VsZWF2ZVwiLCBcIk1vdXNlIEV4aXRcIl0sIFtcIm1vdXNldXBcIiwgXCJNb3VzZSBVcFwiXV0sIGV2ZW50ID0+IGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoYmx1ckxpc3RlbmVyKSB7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgYmx1ckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRhdGEuY29tYikge1xuICAgICAgICBjb25zdCBmaWVsZFdpZHRoID0gdGhpcy5kYXRhLnJlY3RbMl0gLSB0aGlzLmRhdGEucmVjdFswXTtcbiAgICAgICAgY29uc3QgY29tYldpZHRoID0gZmllbGRXaWR0aCAvIG1heExlbjtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiY29tYlwiKTtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5sZXR0ZXJTcGFjaW5nID0gYGNhbGMoJHtjb21iV2lkdGh9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpIC0gMWNoKWA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IHRoaXMuZGF0YS5maWVsZFZhbHVlO1xuICAgICAgZWxlbWVudC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gXCJtaWRkbGVcIjtcbiAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwidGFibGUtY2VsbFwiO1xuICAgICAgaWYgKHRoaXMuZGF0YS5oYXNPd25DYW52YXMpIHtcbiAgICAgICAgZWxlbWVudC5oaWRkZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9zZXRUZXh0U3R5bGUoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpO1xuICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChlbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFNpZ25hdHVyZVdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiAhIXBhcmFtZXRlcnMuZGF0YS5oYXNPd25DYW52YXNcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgQ2hlY2tib3hXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogcGFyYW1ldGVycy5yZW5kZXJGb3Jtc1xuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IGlkID0gZGF0YS5pZDtcbiAgICBsZXQgdmFsdWUgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICB2YWx1ZTogZGF0YS5leHBvcnRWYWx1ZSA9PT0gZGF0YS5maWVsZFZhbHVlXG4gICAgfSkudmFsdWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdmFsdWUgPSB2YWx1ZSAhPT0gXCJPZmZcIjtcbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvblwiLCBcImNoZWNrQm94XCIpO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgR2V0RWxlbWVudHNCeU5hbWVTZXQuYWRkKGVsZW1lbnQpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGlkKTtcbiAgICBlbGVtZW50LmRpc2FibGVkID0gZGF0YS5yZWFkT25seTtcbiAgICB0aGlzLl9zZXRSZXF1aXJlZChlbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuICAgIGVsZW1lbnQudHlwZSA9IFwiY2hlY2tib3hcIjtcbiAgICBlbGVtZW50Lm5hbWUgPSBkYXRhLmZpZWxkTmFtZTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCB0cnVlKTtcbiAgICB9XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJleHBvcnRWYWx1ZVwiLCBkYXRhLmV4cG9ydFZhbHVlKTtcbiAgICBlbGVtZW50LnRhYkluZGV4ID0gMDtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lLFxuICAgICAgICBjaGVja2VkXG4gICAgICB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgZm9yIChjb25zdCBjaGVja2JveCBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShuYW1lLCBpZCkpIHtcbiAgICAgICAgY29uc3QgY3VyQ2hlY2tlZCA9IGNoZWNrZWQgJiYgY2hlY2tib3guZXhwb3J0VmFsdWUgPT09IGRhdGEuZXhwb3J0VmFsdWU7XG4gICAgICAgIGlmIChjaGVja2JveC5kb21FbGVtZW50KSB7XG4gICAgICAgICAgY2hlY2tib3guZG9tRWxlbWVudC5jaGVja2VkID0gY3VyQ2hlY2tlZDtcbiAgICAgICAgfVxuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGNoZWNrYm94LmlkLCB7XG4gICAgICAgICAgdmFsdWU6IGN1ckNoZWNrZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlOiBjaGVja2VkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gZGF0YS5kZWZhdWx0RmllbGRWYWx1ZSB8fCBcIk9mZlwiO1xuICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBkZWZhdWx0VmFsdWUgPT09IGRhdGEuZXhwb3J0VmFsdWU7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZShldmVudCkge1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBldmVudC5kZXRhaWwudmFsdWUgIT09IFwiT2ZmXCI7XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQuY2hlY2tlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIG51bGwsIFtbXCJjaGFuZ2VcIiwgXCJWYWxpZGF0ZVwiXSwgW1wiY2hhbmdlXCIsIFwiQWN0aW9uXCJdLCBbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogcGFyYW1ldGVycy5yZW5kZXJGb3Jtc1xuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvblwiLCBcInJhZGlvQnV0dG9uXCIpO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgaWQgPSBkYXRhLmlkO1xuICAgIGxldCB2YWx1ZSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiBkYXRhLmZpZWxkVmFsdWUgPT09IGRhdGEuYnV0dG9uVmFsdWVcbiAgICB9KS52YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICE9PSBkYXRhLmJ1dHRvblZhbHVlO1xuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZm9yIChjb25zdCByYWRpbyBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShkYXRhLmZpZWxkTmFtZSwgaWQpKSB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUocmFkaW8uaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgR2V0RWxlbWVudHNCeU5hbWVTZXQuYWRkKGVsZW1lbnQpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGlkKTtcbiAgICBlbGVtZW50LmRpc2FibGVkID0gZGF0YS5yZWFkT25seTtcbiAgICB0aGlzLl9zZXRSZXF1aXJlZChlbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuICAgIGVsZW1lbnQudHlwZSA9IFwicmFkaW9cIjtcbiAgICBlbGVtZW50Lm5hbWUgPSBkYXRhLmZpZWxkTmFtZTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCB0cnVlKTtcbiAgICB9XG4gICAgZWxlbWVudC50YWJJbmRleCA9IDA7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgY2hlY2tlZFxuICAgICAgfSA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGZvciAoY29uc3QgcmFkaW8gb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUobmFtZSwgaWQpKSB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUocmFkaW8uaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlOiBjaGVja2VkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gZGF0YS5kZWZhdWx0RmllbGRWYWx1ZTtcbiAgICAgIGV2ZW50LnRhcmdldC5jaGVja2VkID0gZGVmYXVsdFZhbHVlICE9PSBudWxsICYmIGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGRlZmF1bHRWYWx1ZSA9PT0gZGF0YS5idXR0b25WYWx1ZTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgIGNvbnN0IHBkZkJ1dHRvblZhbHVlID0gZGF0YS5idXR0b25WYWx1ZTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIGpzRXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBhY3Rpb25zID0ge1xuICAgICAgICAgIHZhbHVlOiBldmVudCA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGVja2VkID0gcGRmQnV0dG9uVmFsdWUgPT09IGV2ZW50LmRldGFpbC52YWx1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmFkaW8gb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUoZXZlbnQudGFyZ2V0Lm5hbWUpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1ckNoZWNrZWQgPSBjaGVja2VkICYmIHJhZGlvLmlkID09PSBpZDtcbiAgICAgICAgICAgICAgaWYgKHJhZGlvLmRvbUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByYWRpby5kb21FbGVtZW50LmNoZWNrZWQgPSBjdXJDaGVja2VkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUocmFkaW8uaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogY3VyQ2hlY2tlZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgbnVsbCwgW1tcImNoYW5nZVwiLCBcIlZhbGlkYXRlXCJdLCBbXCJjaGFuZ2VcIiwgXCJBY3Rpb25cIl0sIFtcImZvY3VzXCIsIFwiRm9jdXNcIl0sIFtcImJsdXJcIiwgXCJCbHVyXCJdLCBbXCJtb3VzZWRvd25cIiwgXCJNb3VzZSBEb3duXCJdLCBbXCJtb3VzZWVudGVyXCIsIFwiTW91c2UgRW50ZXJcIl0sIFtcIm1vdXNlbGVhdmVcIiwgXCJNb3VzZSBFeGl0XCJdLCBbXCJtb3VzZXVwXCIsIFwiTW91c2UgVXBcIl1dLCBldmVudCA9PiBldmVudC50YXJnZXQuY2hlY2tlZCk7XG4gICAgfVxuICAgIHRoaXMuX3NldEJhY2tncm91bmRDb2xvcihlbGVtZW50KTtcbiAgICB0aGlzLl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyhlbGVtZW50KTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoZWxlbWVudCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBQdXNoQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaWdub3JlQm9yZGVyOiBwYXJhbWV0ZXJzLmRhdGEuaGFzQXBwZWFyYW5jZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBzdXBlci5yZW5kZXIoKTtcbiAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZChcImJ1dHRvbldpZGdldEFubm90YXRpb25cIiwgXCJwdXNoQnV0dG9uXCIpO1xuICAgIGNvbnN0IGxpbmtFbGVtZW50ID0gY29udGFpbmVyLmxhc3RDaGlsZDtcbiAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMgJiYgbGlua0VsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGxpbmtFbGVtZW50KTtcbiAgICAgIGxpbmtFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KHt9LCBqc0V2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBDaG9pY2VXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogcGFyYW1ldGVycy5yZW5kZXJGb3Jtc1xuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiY2hvaWNlV2lkZ2V0QW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBpZCA9IHRoaXMuZGF0YS5pZDtcbiAgICBjb25zdCBzdG9yZWREYXRhID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgdmFsdWU6IHRoaXMuZGF0YS5maWVsZFZhbHVlXG4gICAgfSk7XG4gICAgY29uc3Qgc2VsZWN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIik7XG4gICAgR2V0RWxlbWVudHNCeU5hbWVTZXQuYWRkKHNlbGVjdEVsZW1lbnQpO1xuICAgIHNlbGVjdEVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGlkKTtcbiAgICBzZWxlY3RFbGVtZW50LmRpc2FibGVkID0gdGhpcy5kYXRhLnJlYWRPbmx5O1xuICAgIHRoaXMuX3NldFJlcXVpcmVkKHNlbGVjdEVsZW1lbnQsIHRoaXMuZGF0YS5yZXF1aXJlZCk7XG4gICAgc2VsZWN0RWxlbWVudC5uYW1lID0gdGhpcy5kYXRhLmZpZWxkTmFtZTtcbiAgICBzZWxlY3RFbGVtZW50LnRhYkluZGV4ID0gMDtcbiAgICBsZXQgYWRkQW5FbXB0eUVudHJ5ID0gdGhpcy5kYXRhLmNvbWJvICYmIHRoaXMuZGF0YS5vcHRpb25zLmxlbmd0aCA+IDA7XG4gICAgaWYgKCF0aGlzLmRhdGEuY29tYm8pIHtcbiAgICAgIHNlbGVjdEVsZW1lbnQuc2l6ZSA9IHRoaXMuZGF0YS5vcHRpb25zLmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLmRhdGEubXVsdGlTZWxlY3QpIHtcbiAgICAgICAgc2VsZWN0RWxlbWVudC5tdWx0aXBsZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0Zm9ybVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSB0aGlzLmRhdGEuZGVmYXVsdEZpZWxkVmFsdWU7XG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBzZWxlY3RFbGVtZW50Lm9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gb3B0aW9uLnZhbHVlID09PSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBvcHRpb24gb2YgdGhpcy5kYXRhLm9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IG9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgb3B0aW9uRWxlbWVudC50ZXh0Q29udGVudCA9IG9wdGlvbi5kaXNwbGF5VmFsdWU7XG4gICAgICBvcHRpb25FbGVtZW50LnZhbHVlID0gb3B0aW9uLmV4cG9ydFZhbHVlO1xuICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUuaW5jbHVkZXMob3B0aW9uLmV4cG9ydFZhbHVlKSkge1xuICAgICAgICBvcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIsIHRydWUpO1xuICAgICAgICBhZGRBbkVtcHR5RW50cnkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHNlbGVjdEVsZW1lbnQuYXBwZW5kKG9wdGlvbkVsZW1lbnQpO1xuICAgIH1cbiAgICBsZXQgcmVtb3ZlRW1wdHlFbnRyeSA9IG51bGw7XG4gICAgaWYgKGFkZEFuRW1wdHlFbnRyeSkge1xuICAgICAgY29uc3Qgbm9uZU9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgbm9uZU9wdGlvbkVsZW1lbnQudmFsdWUgPSBcIiBcIjtcbiAgICAgIG5vbmVPcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcImhpZGRlblwiLCB0cnVlKTtcbiAgICAgIG5vbmVPcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIsIHRydWUpO1xuICAgICAgc2VsZWN0RWxlbWVudC5wcmVwZW5kKG5vbmVPcHRpb25FbGVtZW50KTtcbiAgICAgIHJlbW92ZUVtcHR5RW50cnkgPSAoKSA9PiB7XG4gICAgICAgIG5vbmVPcHRpb25FbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCByZW1vdmVFbXB0eUVudHJ5KTtcbiAgICAgICAgcmVtb3ZlRW1wdHlFbnRyeSA9IG51bGw7XG4gICAgICB9O1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgcmVtb3ZlRW1wdHlFbnRyeSk7XG4gICAgfVxuICAgIGNvbnN0IGdldFZhbHVlID0gaXNFeHBvcnQgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGlzRXhwb3J0ID8gXCJ2YWx1ZVwiIDogXCJ0ZXh0Q29udGVudFwiO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvcHRpb25zLFxuICAgICAgICBtdWx0aXBsZVxuICAgICAgfSA9IHNlbGVjdEVsZW1lbnQ7XG4gICAgICBpZiAoIW11bHRpcGxlKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnNlbGVjdGVkSW5kZXggPT09IC0xID8gbnVsbCA6IG9wdGlvbnNbb3B0aW9ucy5zZWxlY3RlZEluZGV4XVtuYW1lXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwob3B0aW9ucywgb3B0aW9uID0+IG9wdGlvbi5zZWxlY3RlZCkubWFwKG9wdGlvbiA9PiBvcHRpb25bbmFtZV0pO1xuICAgIH07XG4gICAgbGV0IHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgIGNvbnN0IGdldEl0ZW1zID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IGV2ZW50LnRhcmdldC5vcHRpb25zO1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChvcHRpb25zLCBvcHRpb24gPT4gKHtcbiAgICAgICAgZGlzcGxheVZhbHVlOiBvcHRpb24udGV4dENvbnRlbnQsXG4gICAgICAgIGV4cG9ydFZhbHVlOiBvcHRpb24udmFsdWVcbiAgICAgIH0pKTtcbiAgICB9O1xuICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICAgICAgdmFsdWUoZXZlbnQpIHtcbiAgICAgICAgICAgIHJlbW92ZUVtcHR5RW50cnk/LigpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBldmVudC5kZXRhaWwudmFsdWU7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBuZXcgU2V0KEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIHNlbGVjdEVsZW1lbnQub3B0aW9ucykge1xuICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZXMuaGFzKG9wdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG11bHRpcGxlU2VsZWN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxlY3RFbGVtZW50Lm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW92ZShldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHNlbGVjdEVsZW1lbnQub3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZXZlbnQuZGV0YWlsLnJlbW92ZTtcbiAgICAgICAgICAgIG9wdGlvbnNbaW5kZXhdLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZShpbmRleCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGkgPSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4LmNhbGwob3B0aW9ucywgb3B0aW9uID0+IG9wdGlvbi5zZWxlY3RlZCk7XG4gICAgICAgICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKSxcbiAgICAgICAgICAgICAgaXRlbXM6IGdldEl0ZW1zKGV2ZW50KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsZWFyKGV2ZW50KSB7XG4gICAgICAgICAgICB3aGlsZSAoc2VsZWN0RWxlbWVudC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5yZW1vdmUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICBpdGVtczogW11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnNlcnQoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgIGRpc3BsYXlWYWx1ZSxcbiAgICAgICAgICAgICAgZXhwb3J0VmFsdWVcbiAgICAgICAgICAgIH0gPSBldmVudC5kZXRhaWwuaW5zZXJ0O1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0Q2hpbGQgPSBzZWxlY3RFbGVtZW50LmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgb3B0aW9uRWxlbWVudC50ZXh0Q29udGVudCA9IGRpc3BsYXlWYWx1ZTtcbiAgICAgICAgICAgIG9wdGlvbkVsZW1lbnQudmFsdWUgPSBleHBvcnRWYWx1ZTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RDaGlsZCkge1xuICAgICAgICAgICAgICBzZWxlY3RDaGlsZC5iZWZvcmUob3B0aW9uRWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LmFwcGVuZChvcHRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpLFxuICAgICAgICAgICAgICBpdGVtczogZ2V0SXRlbXMoZXZlbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaXRlbXMoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgaXRlbXNcbiAgICAgICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgICAgICB3aGlsZSAoc2VsZWN0RWxlbWVudC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5yZW1vdmUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlWYWx1ZSxcbiAgICAgICAgICAgICAgICBleHBvcnRWYWx1ZVxuICAgICAgICAgICAgICB9ID0gaXRlbTtcbiAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgICAgICAgIG9wdGlvbkVsZW1lbnQudGV4dENvbnRlbnQgPSBkaXNwbGF5VmFsdWU7XG4gICAgICAgICAgICAgIG9wdGlvbkVsZW1lbnQudmFsdWUgPSBleHBvcnRWYWx1ZTtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5hcHBlbmQob3B0aW9uRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0RWxlbWVudC5vcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5vcHRpb25zWzBdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpLFxuICAgICAgICAgICAgICBpdGVtczogZ2V0SXRlbXMoZXZlbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaW5kaWNlcyhldmVudCkge1xuICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IG5ldyBTZXQoZXZlbnQuZGV0YWlsLmluZGljZXMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgZXZlbnQudGFyZ2V0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gaW5kaWNlcy5oYXMob3B0aW9uLmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZWRpdGFibGUoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5kaXNhYmxlZCA9ICFldmVudC5kZXRhaWwuZWRpdGFibGU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgZXhwb3J0VmFsdWUgPSBnZXRWYWx1ZSh0cnVlKTtcbiAgICAgICAgY29uc3QgY2hhbmdlID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgdmFsdWU6IGV4cG9ydFZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgIHZhbHVlOiBzZWxlY3RlZFZhbHVlcyxcbiAgICAgICAgICAgIGNoYW5nZSxcbiAgICAgICAgICAgIGNoYW5nZUV4OiBleHBvcnRWYWx1ZSxcbiAgICAgICAgICAgIHdpbGxDb21taXQ6IGZhbHNlLFxuICAgICAgICAgICAgY29tbWl0S2V5OiAxLFxuICAgICAgICAgICAga2V5RG93bjogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVycyhzZWxlY3RFbGVtZW50LCBudWxsLCBbW1wiZm9jdXNcIiwgXCJGb2N1c1wiXSwgW1wiYmx1clwiLCBcIkJsdXJcIl0sIFtcIm1vdXNlZG93blwiLCBcIk1vdXNlIERvd25cIl0sIFtcIm1vdXNlZW50ZXJcIiwgXCJNb3VzZSBFbnRlclwiXSwgW1wibW91c2VsZWF2ZVwiLCBcIk1vdXNlIEV4aXRcIl0sIFtcIm1vdXNldXBcIiwgXCJNb3VzZSBVcFwiXSwgW1wiaW5wdXRcIiwgXCJBY3Rpb25cIl0sIFtcImlucHV0XCIsIFwiVmFsaWRhdGVcIl1dLCBldmVudCA9PiBldmVudC50YXJnZXQudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5kYXRhLmNvbWJvKSB7XG4gICAgICB0aGlzLl9zZXRUZXh0U3R5bGUoc2VsZWN0RWxlbWVudCk7XG4gICAgfSBlbHNlIHt9XG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKHNlbGVjdEVsZW1lbnQpO1xuICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKHNlbGVjdEVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzZWxlY3RFbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgZWxlbWVudHNcbiAgICB9ID0gcGFyYW1ldGVycztcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IEFubm90YXRpb25FbGVtZW50Ll9oYXNQb3B1cERhdGEoZGF0YSlcbiAgICB9KTtcbiAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgdGhpcy5wb3B1cCA9IG51bGw7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRhaW5lclxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwicG9wdXBBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnRhaW5lci5yb2xlID0gXCJjb21tZW50XCI7XG4gICAgY29uc3QgcG9wdXAgPSB0aGlzLnBvcHVwID0gbmV3IFBvcHVwRWxlbWVudCh7XG4gICAgICBjb250YWluZXI6IHRoaXMuY29udGFpbmVyLFxuICAgICAgY29sb3I6IHRoaXMuZGF0YS5jb2xvcixcbiAgICAgIHRpdGxlT2JqOiB0aGlzLmRhdGEudGl0bGVPYmosXG4gICAgICBtb2RpZmljYXRpb25EYXRlOiB0aGlzLmRhdGEubW9kaWZpY2F0aW9uRGF0ZSB8fCB0aGlzLmRhdGEuY3JlYXRpb25EYXRlLFxuICAgICAgY29udGVudHNPYmo6IHRoaXMuZGF0YS5jb250ZW50c09iaixcbiAgICAgIHJpY2hUZXh0OiB0aGlzLmRhdGEucmljaFRleHQsXG4gICAgICByZWN0OiB0aGlzLmRhdGEucmVjdCxcbiAgICAgIHBhcmVudFJlY3Q6IHRoaXMuZGF0YS5wYXJlbnRSZWN0IHx8IG51bGwsXG4gICAgICBwYXJlbnQ6IHRoaXMucGFyZW50LFxuICAgICAgZWxlbWVudHM6IHRoaXMuZWxlbWVudHMsXG4gICAgICBvcGVuOiB0aGlzLmRhdGEub3BlbixcbiAgICAgIGV2ZW50QnVzOiB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzXG4gICAgfSk7XG4gICAgY29uc3QgZWxlbWVudElkcyA9IFtdO1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLmVsZW1lbnRzKSB7XG4gICAgICBlbGVtZW50LnBvcHVwID0gcG9wdXA7XG4gICAgICBlbGVtZW50LmNvbnRhaW5lci5hcmlhSGFzUG9wdXAgPSBcImRpYWxvZ1wiO1xuICAgICAgZWxlbWVudElkcy5wdXNoKGVsZW1lbnQuZGF0YS5pZCk7XG4gICAgICBlbGVtZW50LmFkZEhpZ2hsaWdodEFyZWEoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1jb250cm9sc1wiLCBlbGVtZW50SWRzLm1hcChpZCA9PiBgJHtBbm5vdGF0aW9uUHJlZml4fSR7aWR9YCkuam9pbihcIixcIikpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUG9wdXBFbGVtZW50IHtcbiAgI2JvdW5kS2V5RG93biA9IHRoaXMuI2tleURvd24uYmluZCh0aGlzKTtcbiAgI2JvdW5kSGlkZSA9IHRoaXMuI2hpZGUuYmluZCh0aGlzKTtcbiAgI2JvdW5kU2hvdyA9IHRoaXMuI3Nob3cuYmluZCh0aGlzKTtcbiAgI2JvdW5kVG9nZ2xlID0gdGhpcy4jdG9nZ2xlLmJpbmQodGhpcyk7XG4gICNjb2xvciA9IG51bGw7XG4gICNjb250YWluZXIgPSBudWxsO1xuICAjY29udGVudHNPYmogPSBudWxsO1xuICAjZGF0ZU9iaiA9IG51bGw7XG4gICNlbGVtZW50cyA9IG51bGw7XG4gICNldmVudEJ1cyA9IG51bGw7XG4gICNwYXJlbnQgPSBudWxsO1xuICAjcGFyZW50UmVjdCA9IG51bGw7XG4gICNwaW5uZWQgPSBmYWxzZTtcbiAgI3BvcHVwID0gbnVsbDtcbiAgI3BvcHVwQWJvcnRDb250cm9sbGVyID0gbnVsbDtcbiAgI3Bvc2l0aW9uID0gbnVsbDtcbiAgI2NvbW1lbnRCdXR0b24gPSBudWxsO1xuICAjY29tbWVudEJ1dHRvblBvc2l0aW9uID0gbnVsbDtcbiAgI2NvbW1lbnRCdXR0b25Db2xvciA9IG51bGw7XG4gICNyZWN0ID0gbnVsbDtcbiAgI3JpY2hUZXh0ID0gbnVsbDtcbiAgI3RpdGxlT2JqID0gbnVsbDtcbiAgI3VwZGF0ZXMgPSBudWxsO1xuICAjd2FzVmlzaWJsZSA9IGZhbHNlO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29udGFpbmVyLFxuICAgIGNvbG9yLFxuICAgIGVsZW1lbnRzLFxuICAgIHRpdGxlT2JqLFxuICAgIG1vZGlmaWNhdGlvbkRhdGUsXG4gICAgY29udGVudHNPYmosXG4gICAgcmljaFRleHQsXG4gICAgcGFyZW50LFxuICAgIHJlY3QsXG4gICAgcGFyZW50UmVjdCxcbiAgICBvcGVuLFxuICAgIGV2ZW50QnVzID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy4jY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuI3RpdGxlT2JqID0gdGl0bGVPYmo7XG4gICAgdGhpcy4jY29udGVudHNPYmogPSBjb250ZW50c09iajtcbiAgICB0aGlzLiNyaWNoVGV4dCA9IHJpY2hUZXh0O1xuICAgIHRoaXMuI3BhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLiNjb2xvciA9IGNvbG9yO1xuICAgIHRoaXMuI3JlY3QgPSByZWN0O1xuICAgIHRoaXMuI3BhcmVudFJlY3QgPSBwYXJlbnRSZWN0O1xuICAgIHRoaXMuI2VsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgdGhpcy4jZXZlbnRCdXMgPSBldmVudEJ1cztcbiAgICB0aGlzLiNkYXRlT2JqID0gUERGRGF0ZVN0cmluZy50b0RhdGVPYmplY3QobW9kaWZpY2F0aW9uRGF0ZSk7XG4gICAgdGhpcy50cmlnZ2VyID0gZWxlbWVudHMuZmxhdE1hcChlID0+IGUuZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpKTtcbiAgICB0aGlzLiNhZGRFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICAgIGlmIChvcGVuKSB7XG4gICAgICB0aGlzLiN0b2dnbGUoKTtcbiAgICB9XG4gIH1cbiAgI2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLiNwb3B1cEFib3J0Q29udHJvbGxlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNwb3B1cEFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCB7XG4gICAgICBzaWduYWxcbiAgICB9ID0gdGhpcy4jcG9wdXBBYm9ydENvbnRyb2xsZXI7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMudHJpZ2dlcikge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jYm91bmRUb2dnbGUsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgdGhpcy4jYm91bmRTaG93LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMuI2JvdW5kSGlkZSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwicG9wdXBUcmlnZ2VyQXJlYVwiKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuI2VsZW1lbnRzKSB7XG4gICAgICBlbGVtZW50LmNvbnRhaW5lcj8uYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlEb3duLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuI3JlbmRlckNvbW1lbnRCdXR0b24oKTtcbiAgfVxuICAjc2V0Q29tbWVudEJ1dHRvblBvc2l0aW9uKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLiNlbGVtZW50cy5maW5kKGUgPT4gZS5oYXNDb21tZW50QnV0dG9uKTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29tbWVudEJ1dHRvblBvc2l0aW9uID0gZWxlbWVudC5fbm9ybWFsaXplUG9pbnQoZWxlbWVudC5jb21tZW50QnV0dG9uUG9zaXRpb24pO1xuICAgIHRoaXMuI2NvbW1lbnRCdXR0b25Db2xvciA9IGVsZW1lbnQuY29tbWVudEJ1dHRvbkNvbG9yO1xuICB9XG4gICNyZW5kZXJDb21tZW50QnV0dG9uKCkge1xuICAgIGlmICh0aGlzLiNjb21tZW50QnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jY29tbWVudEJ1dHRvblBvc2l0aW9uKSB7XG4gICAgICB0aGlzLiNzZXRDb21tZW50QnV0dG9uUG9zaXRpb24oKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNjb21tZW50QnV0dG9uUG9zaXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy4jY29tbWVudEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYnV0dG9uLmNsYXNzTmFtZSA9IFwiYW5ub3RhdGlvbkNvbW1lbnRCdXR0b25cIjtcbiAgICBjb25zdCBwYXJlbnRDb250YWluZXIgPSB0aGlzLiNlbGVtZW50c1swXS5jb250YWluZXI7XG4gICAgYnV0dG9uLnN0eWxlLnpJbmRleCA9IHBhcmVudENvbnRhaW5lci5zdHlsZS56SW5kZXggKyAxO1xuICAgIGJ1dHRvbi50YWJJbmRleCA9IDA7XG4gICAgY29uc3Qge1xuICAgICAgc2lnbmFsXG4gICAgfSA9IHRoaXMuI3BvcHVwQWJvcnRDb250cm9sbGVyO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiaG92ZXJcIiwgdGhpcy4jYm91bmRUb2dnbGUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleURvd24sIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgW3tcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlkOiBlZGl0SWRcbiAgICAgICAgfSxcbiAgICAgICAgYW5ub3RhdGlvbkVkaXRvclR5cGU6IG1vZGVcbiAgICAgIH1dID0gdGhpcy4jZWxlbWVudHM7XG4gICAgICB0aGlzLiNldmVudEJ1cz8uZGlzcGF0Y2goXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ybW9kZVwiLCB7XG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgZWRpdElkLFxuICAgICAgICBtb2RlLFxuICAgICAgICBlZGl0Q29tbWVudDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gYnV0dG9uO1xuICAgIHN0eWxlLmxlZnQgPSBgY2FsYygke3RoaXMuI2NvbW1lbnRCdXR0b25Qb3NpdGlvblswXX0lKWA7XG4gICAgc3R5bGUudG9wID0gYGNhbGMoJHt0aGlzLiNjb21tZW50QnV0dG9uUG9zaXRpb25bMV19JSAtIHZhcigtLWNvbW1lbnQtYnV0dG9uLWRpbSkpYDtcbiAgICBpZiAodGhpcy4jY29tbWVudEJ1dHRvbkNvbG9yKSB7XG4gICAgICBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLiNjb21tZW50QnV0dG9uQ29sb3I7XG4gICAgfVxuICAgIHBhcmVudENvbnRhaW5lci5hZnRlcihidXR0b24pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy4jcG9wdXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcG9wdXAgPSB0aGlzLiNwb3B1cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgcG9wdXAuY2xhc3NOYW1lID0gXCJwb3B1cFwiO1xuICAgIGlmICh0aGlzLiNjb2xvcikge1xuICAgICAgY29uc3QgYmFzZUNvbG9yID0gcG9wdXAuc3R5bGUub3V0bGluZUNvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4udGhpcy4jY29sb3IpO1xuICAgICAgcG9wdXAuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYGNvbG9yLW1peChpbiBzcmdiLCAke2Jhc2VDb2xvcn0gMzAlLCB3aGl0ZSlgO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBoZWFkZXIuY2xhc3NOYW1lID0gXCJoZWFkZXJcIjtcbiAgICBpZiAodGhpcy4jdGl0bGVPYmo/LnN0cikge1xuICAgICAgY29uc3QgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHRpdGxlLmNsYXNzTmFtZSA9IFwidGl0bGVcIjtcbiAgICAgIGhlYWRlci5hcHBlbmQodGl0bGUpO1xuICAgICAgKHtcbiAgICAgICAgZGlyOiB0aXRsZS5kaXIsXG4gICAgICAgIHN0cjogdGl0bGUudGV4dENvbnRlbnRcbiAgICAgIH0gPSB0aGlzLiN0aXRsZU9iaik7XG4gICAgfVxuICAgIHBvcHVwLmFwcGVuZChoZWFkZXIpO1xuICAgIGlmICh0aGlzLiNkYXRlT2JqKSB7XG4gICAgICBjb25zdCBtb2RpZmljYXRpb25EYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRpbWVcIik7XG4gICAgICBtb2RpZmljYXRpb25EYXRlLmNsYXNzTmFtZSA9IFwicG9wdXBEYXRlXCI7XG4gICAgICBtb2RpZmljYXRpb25EYXRlLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWFubm90YXRpb24tZGF0ZS10aW1lLXN0cmluZ1wiKTtcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGUuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWFyZ3NcIiwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBkYXRlT2JqOiB0aGlzLiNkYXRlT2JqLnZhbHVlT2YoKVxuICAgICAgfSkpO1xuICAgICAgbW9kaWZpY2F0aW9uRGF0ZS5kYXRlVGltZSA9IHRoaXMuI2RhdGVPYmoudG9JU09TdHJpbmcoKTtcbiAgICAgIGhlYWRlci5hcHBlbmQobW9kaWZpY2F0aW9uRGF0ZSk7XG4gICAgfVxuICAgIGNvbnN0IGh0bWwgPSB0aGlzLiNodG1sO1xuICAgIGlmIChodG1sKSB7XG4gICAgICBYZmFMYXllci5yZW5kZXIoe1xuICAgICAgICB4ZmFIdG1sOiBodG1sLFxuICAgICAgICBpbnRlbnQ6IFwicmljaFRleHRcIixcbiAgICAgICAgZGl2OiBwb3B1cFxuICAgICAgfSk7XG4gICAgICBwb3B1cC5sYXN0Q2hpbGQuY2xhc3NMaXN0LmFkZChcInJpY2hUZXh0XCIsIFwicG9wdXBDb250ZW50XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb250ZW50cyA9IHRoaXMuX2Zvcm1hdENvbnRlbnRzKHRoaXMuI2NvbnRlbnRzT2JqKTtcbiAgICAgIHBvcHVwLmFwcGVuZChjb250ZW50cyk7XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lci5hcHBlbmQocG9wdXApO1xuICB9XG4gIGdldCAjaHRtbCgpIHtcbiAgICBjb25zdCByaWNoVGV4dCA9IHRoaXMuI3JpY2hUZXh0O1xuICAgIGNvbnN0IGNvbnRlbnRzT2JqID0gdGhpcy4jY29udGVudHNPYmo7XG4gICAgaWYgKHJpY2hUZXh0Py5zdHIgJiYgKCFjb250ZW50c09iaj8uc3RyIHx8IGNvbnRlbnRzT2JqLnN0ciA9PT0gcmljaFRleHQuc3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuI3JpY2hUZXh0Lmh0bWwgfHwgbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0ICNmb250U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaHRtbD8uYXR0cmlidXRlcz8uc3R5bGU/LmZvbnRTaXplIHx8IDA7XG4gIH1cbiAgZ2V0ICNmb250Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2h0bWw/LmF0dHJpYnV0ZXM/LnN0eWxlPy5jb2xvciB8fCBudWxsO1xuICB9XG4gICNtYWtlUG9wdXBDb250ZW50KHRleHQpIHtcbiAgICBjb25zdCBwb3B1cExpbmVzID0gW107XG4gICAgY29uc3QgcG9wdXBDb250ZW50ID0ge1xuICAgICAgc3RyOiB0ZXh0LFxuICAgICAgaHRtbDoge1xuICAgICAgICBuYW1lOiBcImRpdlwiLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgZGlyOiBcImF1dG9cIlxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICBuYW1lOiBcInBcIixcbiAgICAgICAgICBjaGlsZHJlbjogcG9wdXBMaW5lc1xuICAgICAgICB9XVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbGluZUF0dHJpYnV0ZXMgPSB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBjb2xvcjogdGhpcy4jZm9udENvbG9yLFxuICAgICAgICBmb250U2l6ZTogdGhpcy4jZm9udFNpemUgPyBgY2FsYygke3RoaXMuI2ZvbnRTaXplfXB4ICogdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSlgIDogXCJcIlxuICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIHRleHQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgIHBvcHVwTGluZXMucHVzaCh7XG4gICAgICAgIG5hbWU6IFwic3BhblwiLFxuICAgICAgICB2YWx1ZTogbGluZSxcbiAgICAgICAgYXR0cmlidXRlczogbGluZUF0dHJpYnV0ZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcG9wdXBDb250ZW50O1xuICB9XG4gIF9mb3JtYXRDb250ZW50cyh7XG4gICAgc3RyLFxuICAgIGRpclxuICB9KSB7XG4gICAgY29uc3QgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpO1xuICAgIHAuY2xhc3NMaXN0LmFkZChcInBvcHVwQ29udGVudFwiKTtcbiAgICBwLmRpciA9IGRpcjtcbiAgICBjb25zdCBsaW5lcyA9IHN0ci5zcGxpdCgvKD86XFxyXFxuP3xcXG4pLyk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGluZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgcC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGluZSkpO1xuICAgICAgaWYgKGkgPCBpaSAtIDEpIHtcbiAgICAgICAgcC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgI2tleURvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIgfHwgZXZlbnQua2V5ID09PSBcIkVzY2FwZVwiICYmIHRoaXMuI3Bpbm5lZCkge1xuICAgICAgdGhpcy4jdG9nZ2xlKCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUVkaXRlZCh7XG4gICAgcmVjdCxcbiAgICBwb3B1cCxcbiAgICBkZWxldGVkXG4gIH0pIHtcbiAgICBpZiAoZGVsZXRlZCB8fCBwb3B1cD8uZGVsZXRlZCkge1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLiN1cGRhdGVzIHx8PSB7XG4gICAgICBjb250ZW50c09iajogdGhpcy4jY29udGVudHNPYmosXG4gICAgICByaWNoVGV4dDogdGhpcy4jcmljaFRleHRcbiAgICB9O1xuICAgIGlmIChyZWN0KSB7XG4gICAgICB0aGlzLiNwb3NpdGlvbiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChwb3B1cCkge1xuICAgICAgdGhpcy4jcmljaFRleHQgPSB0aGlzLiNtYWtlUG9wdXBDb250ZW50KHBvcHVwLnRleHQpO1xuICAgICAgdGhpcy4jZGF0ZU9iaiA9IFBERkRhdGVTdHJpbmcudG9EYXRlT2JqZWN0KHBvcHVwLmRhdGUpO1xuICAgICAgdGhpcy4jY29udGVudHNPYmogPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNwb3B1cD8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jcG9wdXAgPSBudWxsO1xuICB9XG4gIHJlc2V0RWRpdGVkKCkge1xuICAgIGlmICghdGhpcy4jdXBkYXRlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoe1xuICAgICAgY29udGVudHNPYmo6IHRoaXMuI2NvbnRlbnRzT2JqLFxuICAgICAgcmljaFRleHQ6IHRoaXMuI3JpY2hUZXh0XG4gICAgfSA9IHRoaXMuI3VwZGF0ZXMpO1xuICAgIHRoaXMuI3VwZGF0ZXMgPSBudWxsO1xuICAgIHRoaXMuI3BvcHVwPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNwb3B1cCA9IG51bGw7XG4gICAgdGhpcy4jcG9zaXRpb24gPSBudWxsO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLiNwb3B1cEFib3J0Q29udHJvbGxlcj8uYWJvcnQoKTtcbiAgICB0aGlzLiNwb3B1cEFib3J0Q29udHJvbGxlciA9IG51bGw7XG4gICAgdGhpcy4jcG9wdXA/LnJlbW92ZSgpO1xuICAgIHRoaXMuI3BvcHVwID0gbnVsbDtcbiAgICB0aGlzLiN3YXNWaXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy4jcGlubmVkID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMudHJpZ2dlcikge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwicG9wdXBUcmlnZ2VyQXJlYVwiKTtcbiAgICB9XG4gIH1cbiAgI3NldFBvc2l0aW9uKCkge1xuICAgIGlmICh0aGlzLiNwb3NpdGlvbiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwYWdlOiB7XG4gICAgICAgIHZpZXdcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICByYXdEaW1zOiB7XG4gICAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICAgICAgcGFnZVgsXG4gICAgICAgICAgcGFnZVlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gPSB0aGlzLiNwYXJlbnQ7XG4gICAgbGV0IHVzZVBhcmVudFJlY3QgPSAhIXRoaXMuI3BhcmVudFJlY3Q7XG4gICAgbGV0IHJlY3QgPSB1c2VQYXJlbnRSZWN0ID8gdGhpcy4jcGFyZW50UmVjdCA6IHRoaXMuI3JlY3Q7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuI2VsZW1lbnRzKSB7XG4gICAgICBpZiAoIXJlY3QgfHwgVXRpbC5pbnRlcnNlY3QoZWxlbWVudC5kYXRhLnJlY3QsIHJlY3QpICE9PSBudWxsKSB7XG4gICAgICAgIHJlY3QgPSBlbGVtZW50LmRhdGEucmVjdDtcbiAgICAgICAgdXNlUGFyZW50UmVjdCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemVkUmVjdCA9IFV0aWwubm9ybWFsaXplUmVjdChbcmVjdFswXSwgdmlld1szXSAtIHJlY3RbMV0gKyB2aWV3WzFdLCByZWN0WzJdLCB2aWV3WzNdIC0gcmVjdFszXSArIHZpZXdbMV1dKTtcbiAgICBjb25zdCBIT1JJWk9OVEFMX1NQQUNFX0FGVEVSX0FOTk9UQVRJT04gPSA1O1xuICAgIGNvbnN0IHBhcmVudFdpZHRoID0gdXNlUGFyZW50UmVjdCA/IHJlY3RbMl0gLSByZWN0WzBdICsgSE9SSVpPTlRBTF9TUEFDRV9BRlRFUl9BTk5PVEFUSU9OIDogMDtcbiAgICBjb25zdCBwb3B1cExlZnQgPSBub3JtYWxpemVkUmVjdFswXSArIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IHBvcHVwVG9wID0gbm9ybWFsaXplZFJlY3RbMV07XG4gICAgdGhpcy4jcG9zaXRpb24gPSBbMTAwICogKHBvcHVwTGVmdCAtIHBhZ2VYKSAvIHBhZ2VXaWR0aCwgMTAwICogKHBvcHVwVG9wIC0gcGFnZVkpIC8gcGFnZUhlaWdodF07XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy4jY29udGFpbmVyO1xuICAgIHN0eWxlLmxlZnQgPSBgJHt0aGlzLiNwb3NpdGlvblswXX0lYDtcbiAgICBzdHlsZS50b3AgPSBgJHt0aGlzLiNwb3NpdGlvblsxXX0lYDtcbiAgfVxuICAjdG9nZ2xlKCkge1xuICAgIHRoaXMuI3Bpbm5lZCA9ICF0aGlzLiNwaW5uZWQ7XG4gICAgaWYgKHRoaXMuI3Bpbm5lZCkge1xuICAgICAgdGhpcy4jc2hvdygpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNib3VuZFRvZ2dsZSk7XG4gICAgICB0aGlzLiNjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlEb3duKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jaGlkZSgpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNib3VuZFRvZ2dsZSk7XG4gICAgICB0aGlzLiNjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlEb3duKTtcbiAgICB9XG4gIH1cbiAgI3Nob3coKSB7XG4gICAgaWYgKCF0aGlzLiNwb3B1cCkge1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgdGhpcy4jc2V0UG9zaXRpb24oKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSBwYXJzZUludCh0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4KSArIDEwMDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNwaW5uZWQpIHtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiZm9jdXNlZFwiKTtcbiAgICB9XG4gIH1cbiAgI2hpZGUoKSB7XG4gICAgdGhpcy4jY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJmb2N1c2VkXCIpO1xuICAgIGlmICh0aGlzLiNwaW5uZWQgfHwgIXRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICAgIHRoaXMuI2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSBwYXJzZUludCh0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4KSAtIDEwMDA7XG4gIH1cbiAgZm9yY2VIaWRlKCkge1xuICAgIHRoaXMuI3dhc1Zpc2libGUgPSB0aGlzLmlzVmlzaWJsZTtcbiAgICBpZiAoIXRoaXMuI3dhc1Zpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gIH1cbiAgbWF5YmVTaG93KCkge1xuICAgIHRoaXMuI2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgaWYgKCF0aGlzLiN3YXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jcG9wdXApIHtcbiAgICAgIHRoaXMuI3Nob3coKTtcbiAgICB9XG4gICAgdGhpcy4jd2FzVmlzaWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSBmYWxzZTtcbiAgfVxuICBnZXQgaXNWaXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLiNjb250YWluZXIuaGlkZGVuID09PSBmYWxzZTtcbiAgfVxufVxuY2xhc3MgRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSBwYXJhbWV0ZXJzLmRhdGEudGV4dENvbnRlbnQ7XG4gICAgdGhpcy50ZXh0UG9zaXRpb24gPSBwYXJhbWV0ZXJzLmRhdGEudGV4dFBvc2l0aW9uO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVDtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImZyZWVUZXh0QW5ub3RhdGlvblwiKTtcbiAgICBpZiAodGhpcy50ZXh0Q29udGVudCkge1xuICAgICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoXCJhbm5vdGF0aW9uVGV4dENvbnRlbnRcIik7XG4gICAgICBjb250ZW50LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJjb21tZW50XCIpO1xuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHRoaXMudGV4dENvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgbGluZVNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgbGluZVNwYW4udGV4dENvbnRlbnQgPSBsaW5lO1xuICAgICAgICBjb250ZW50LmFwcGVuZChsaW5lU3Bhbik7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoY29udGVudCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0T25Eb3VibGVDbGljaygpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgTGluZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjbGluZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImxpbmVBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgY29uc3QgbGluZSA9IHRoaXMuI2xpbmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpsaW5lXCIpO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieDFcIiwgZGF0YS5yZWN0WzJdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbMF0pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieTFcIiwgZGF0YS5yZWN0WzNdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbMV0pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieDJcIiwgZGF0YS5yZWN0WzJdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbMl0pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieTJcIiwgZGF0YS5yZWN0WzNdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbM10pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGRhdGEuYm9yZGVyU3R5bGUud2lkdGggfHwgMSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKGxpbmUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2xpbmU7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNzcXVhcmUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzcXVhcmVBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSBkYXRhLmJvcmRlclN0eWxlLndpZHRoO1xuICAgIGNvbnN0IHNxdWFyZSA9IHRoaXMuI3NxdWFyZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnJlY3RcIik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInhcIiwgYm9yZGVyV2lkdGggLyAyKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwieVwiLCBib3JkZXJXaWR0aCAvIDIpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3aWR0aCAtIGJvcmRlcldpZHRoKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGhlaWdodCAtIGJvcmRlcldpZHRoKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGJvcmRlcldpZHRoIHx8IDEpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQoc3F1YXJlKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNzcXVhcmU7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgQ2lyY2xlQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNjaXJjbGUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJjaXJjbGVBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSBkYXRhLmJvcmRlclN0eWxlLndpZHRoO1xuICAgIGNvbnN0IGNpcmNsZSA9IHRoaXMuI2NpcmNsZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmVsbGlwc2VcIik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImN4XCIsIHdpZHRoIC8gMik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImN5XCIsIGhlaWdodCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJyeFwiLCB3aWR0aCAvIDIgLSBib3JkZXJXaWR0aCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJyeVwiLCBoZWlnaHQgLyAyIC0gYm9yZGVyV2lkdGggLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGJvcmRlcldpZHRoIHx8IDEpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQoY2lyY2xlKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNjaXJjbGU7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3BvbHlsaW5lID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lID0gXCJwb2x5bGluZUFubm90YXRpb25cIjtcbiAgICB0aGlzLnN2Z0VsZW1lbnROYW1lID0gXCJzdmc6cG9seWxpbmVcIjtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCh0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSk7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YToge1xuICAgICAgICByZWN0LFxuICAgICAgICB2ZXJ0aWNlcyxcbiAgICAgICAgYm9yZGVyU3R5bGUsXG4gICAgICAgIHBvcHVwUmVmXG4gICAgICB9LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIXZlcnRpY2VzKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfVxuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgbGV0IHBvaW50cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHggPSB2ZXJ0aWNlc1tpXSAtIHJlY3RbMF07XG4gICAgICBjb25zdCB5ID0gcmVjdFszXSAtIHZlcnRpY2VzW2kgKyAxXTtcbiAgICAgIHBvaW50cy5wdXNoKGAke3h9LCR7eX1gKTtcbiAgICB9XG4gICAgcG9pbnRzID0gcG9pbnRzLmpvaW4oXCIgXCIpO1xuICAgIGNvbnN0IHBvbHlsaW5lID0gdGhpcy4jcG9seWxpbmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudCh0aGlzLnN2Z0VsZW1lbnROYW1lKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJwb2ludHNcIiwgcG9pbnRzKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgYm9yZGVyU3R5bGUud2lkdGggfHwgMSk7XG4gICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQocG9seWxpbmUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIGlmICghcG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNwb2x5bGluZTtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG59XG5jbGFzcyBQb2x5Z29uQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBQb2x5bGluZUFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xuICAgIHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lID0gXCJwb2x5Z29uQW5ub3RhdGlvblwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudE5hbWUgPSBcInN2Zzpwb2x5Z29uXCI7XG4gIH1cbn1cbmNsYXNzIENhcmV0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImNhcmV0QW5ub3RhdGlvblwiKTtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBJbmtBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3BvbHlsaW5lc0dyb3VwRWxlbWVudCA9IG51bGw7XG4gICNwb2x5bGluZXMgPSBbXTtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lID0gXCJpbmtBbm5vdGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlsaW5lXCI7XG4gICAgdGhpcy5hbm5vdGF0aW9uRWRpdG9yVHlwZSA9IHRoaXMuZGF0YS5pdCA9PT0gXCJJbmtIaWdobGlnaHRcIiA/IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCA6IEFubm90YXRpb25FZGl0b3JUeXBlLklOSztcbiAgfVxuICAjZ2V0VHJhbnNmb3JtKHJvdGF0aW9uLCByZWN0KSB7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGUoOTApIHRyYW5zbGF0ZSgkey1yZWN0WzBdfSwke3JlY3RbMV19KSBzY2FsZSgxLC0xKWAsXG4gICAgICAgICAgd2lkdGg6IHJlY3RbM10gLSByZWN0WzFdLFxuICAgICAgICAgIGhlaWdodDogcmVjdFsyXSAtIHJlY3RbMF1cbiAgICAgICAgfTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZSgxODApIHRyYW5zbGF0ZSgkey1yZWN0WzJdfSwke3JlY3RbMV19KSBzY2FsZSgxLC0xKWAsXG4gICAgICAgICAgd2lkdGg6IHJlY3RbMl0gLSByZWN0WzBdLFxuICAgICAgICAgIGhlaWdodDogcmVjdFszXSAtIHJlY3RbMV1cbiAgICAgICAgfTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZSgyNzApIHRyYW5zbGF0ZSgkey1yZWN0WzJdfSwke3JlY3RbM119KSBzY2FsZSgxLC0xKWAsXG4gICAgICAgICAgd2lkdGg6IHJlY3RbM10gLSByZWN0WzFdLFxuICAgICAgICAgIGhlaWdodDogcmVjdFsyXSAtIHJlY3RbMF1cbiAgICAgICAgfTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7LXJlY3RbMF19LCR7cmVjdFszXX0pIHNjYWxlKDEsLTEpYCxcbiAgICAgICAgICB3aWR0aDogcmVjdFsyXSAtIHJlY3RbMF0sXG4gICAgICAgICAgaGVpZ2h0OiByZWN0WzNdIC0gcmVjdFsxXVxuICAgICAgICB9O1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCh0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSk7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YToge1xuICAgICAgICByZWN0LFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgaW5rTGlzdHMsXG4gICAgICAgIGJvcmRlclN0eWxlLFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuI2dldFRyYW5zZm9ybShyb3RhdGlvbiwgcmVjdCk7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBjb25zdCBnID0gdGhpcy4jcG9seWxpbmVzR3JvdXBFbGVtZW50ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6Z1wiKTtcbiAgICBzdmcuYXBwZW5kKGcpO1xuICAgIGcuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGJvcmRlclN0eWxlLndpZHRoIHx8IDEpO1xuICAgIGcuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWxpbmVjYXBcIiwgXCJyb3VuZFwiKTtcbiAgICBnLnNldEF0dHJpYnV0ZShcInN0cm9rZS1saW5lam9pblwiLCBcInJvdW5kXCIpO1xuICAgIGcuc2V0QXR0cmlidXRlKFwic3Ryb2tlLW1pdGVybGltaXRcIiwgMTApO1xuICAgIGcuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgZy5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgZy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbmtMaXN0cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdCBwb2x5bGluZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KHRoaXMuc3ZnRWxlbWVudE5hbWUpO1xuICAgICAgdGhpcy4jcG9seWxpbmVzLnB1c2gocG9seWxpbmUpO1xuICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwicG9pbnRzXCIsIGlua0xpc3RzW2ldLmpvaW4oXCIsXCIpKTtcbiAgICAgIGcuYXBwZW5kKHBvbHlsaW5lKTtcbiAgICB9XG4gICAgaWYgKCFwb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgdGhpcy5fZWRpdE9uRG91YmxlQ2xpY2soKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgdXBkYXRlRWRpdGVkKHBhcmFtcykge1xuICAgIHN1cGVyLnVwZGF0ZUVkaXRlZChwYXJhbXMpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRoaWNrbmVzcyxcbiAgICAgIHBvaW50cyxcbiAgICAgIHJlY3RcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGcgPSB0aGlzLiNwb2x5bGluZXNHcm91cEVsZW1lbnQ7XG4gICAgaWYgKHRoaWNrbmVzcyA+PSAwKSB7XG4gICAgICBnLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCB0aGlja25lc3MgfHwgMSk7XG4gICAgfVxuICAgIGlmIChwb2ludHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHRoaXMuI3BvbHlsaW5lcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIHRoaXMuI3BvbHlsaW5lc1tpXS5zZXRBdHRyaWJ1dGUoXCJwb2ludHNcIiwgcG9pbnRzW2ldLmpvaW4oXCIsXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9ID0gdGhpcy4jZ2V0VHJhbnNmb3JtKHRoaXMuZGF0YS5yb3RhdGlvbiwgcmVjdCk7XG4gICAgICBjb25zdCByb290ID0gZy5wYXJlbnRFbGVtZW50O1xuICAgICAgcm9vdC5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsIGAwIDAgJHt3aWR0aH0gJHtoZWlnaHR9YCk7XG4gICAgICBnLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pO1xuICAgIH1cbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNwb2x5bGluZXM7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxuICBnZXQgY29tbWVudEJ1dHRvblBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlua0xpc3RzLFxuICAgICAgcmVjdFxuICAgIH0gPSB0aGlzLmRhdGE7XG4gICAgaWYgKGlua0xpc3RzPy5sZW5ndGggPj0gMSkge1xuICAgICAgbGV0IG1heFggPSAtSW5maW5pdHk7XG4gICAgICBsZXQgbWF4WSA9IC1JbmZpbml0eTtcbiAgICAgIGZvciAoY29uc3QgaW5rTGlzdCBvZiBpbmtMaXN0cykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbmtMaXN0Lmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBpZiAoaW5rTGlzdFtpICsgMV0gPiBtYXhZKSB7XG4gICAgICAgICAgICBtYXhZID0gaW5rTGlzdFtpICsgMV07XG4gICAgICAgICAgICBtYXhYID0gaW5rTGlzdFtpXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlua0xpc3RbaSArIDFdID09PSBtYXhZKSB7XG4gICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgaW5rTGlzdFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWF4WCAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIFttYXhYLCBtYXhZXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIHJldHVybiBbcmVjdFsyXSwgcmVjdFszXV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5jbGFzcyBIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZSxcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5hbm5vdGF0aW9uRWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVDtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YToge1xuICAgICAgICBvdmVybGFpZFRleHQsXG4gICAgICAgIHBvcHVwUmVmXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFwb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFubm90YXRpb25cIik7XG4gICAgdGhpcy5fZWRpdE9uRG91YmxlQ2xpY2soKTtcbiAgICBpZiAob3ZlcmxhaWRUZXh0KSB7XG4gICAgICBjb25zdCBtYXJrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm1hcmtcIik7XG4gICAgICBtYXJrLmNsYXNzTGlzdC5hZGQoXCJvdmVybGFpZFRleHRcIik7XG4gICAgICBtYXJrLnRleHRDb250ZW50ID0gb3ZlcmxhaWRUZXh0O1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKG1hcmspO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFVuZGVybGluZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YToge1xuICAgICAgICBvdmVybGFpZFRleHQsXG4gICAgICAgIHBvcHVwUmVmXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFwb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInVuZGVybGluZUFubm90YXRpb25cIik7XG4gICAgaWYgKG92ZXJsYWlkVGV4dCkge1xuICAgICAgY29uc3QgdW5kZXJsaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVcIik7XG4gICAgICB1bmRlcmxpbmUuY2xhc3NMaXN0LmFkZChcIm92ZXJsYWlkVGV4dFwiKTtcbiAgICAgIHVuZGVybGluZS50ZXh0Q29udGVudCA9IG92ZXJsYWlkVGV4dDtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZCh1bmRlcmxpbmUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFNxdWlnZ2x5QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWUsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIG92ZXJsYWlkVGV4dCxcbiAgICAgICAgcG9wdXBSZWZcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIXBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwic3F1aWdnbHlBbm5vdGF0aW9uXCIpO1xuICAgIGlmIChvdmVybGFpZFRleHQpIHtcbiAgICAgIGNvbnN0IHVuZGVybGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ1XCIpO1xuICAgICAgdW5kZXJsaW5lLmNsYXNzTGlzdC5hZGQoXCJvdmVybGFpZFRleHRcIik7XG4gICAgICB1bmRlcmxpbmUudGV4dENvbnRlbnQgPSBvdmVybGFpZFRleHQ7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQodW5kZXJsaW5lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZSxcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgb3ZlcmxhaWRUZXh0LFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghcG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzdHJpa2VvdXRBbm5vdGF0aW9uXCIpO1xuICAgIGlmIChvdmVybGFpZFRleHQpIHtcbiAgICAgIGNvbnN0IHN0cmlrZW91dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzXCIpO1xuICAgICAgc3RyaWtlb3V0LmNsYXNzTGlzdC5hZGQoXCJvdmVybGFpZFRleHRcIik7XG4gICAgICBzdHJpa2VvdXQudGV4dENvbnRlbnQgPSBvdmVybGFpZFRleHQ7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3RyaWtlb3V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBTdGFtcEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5hbm5vdGF0aW9uRWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwic3RhbXBBbm5vdGF0aW9uXCIpO1xuICAgIHRoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJpbWdcIik7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuX2VkaXRPbkRvdWJsZUNsaWNrKCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBGaWxlQXR0YWNobWVudEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjdHJpZ2dlciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBmaWxlXG4gICAgfSA9IHRoaXMuZGF0YTtcbiAgICB0aGlzLmZpbGVuYW1lID0gZmlsZS5maWxlbmFtZTtcbiAgICB0aGlzLmNvbnRlbnQgPSBmaWxlLmNvbnRlbnQ7XG4gICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJmaWxlYXR0YWNobWVudGFubm90YXRpb25cIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgLi4uZmlsZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiZmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGRhdGFcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgdHJpZ2dlcjtcbiAgICBpZiAoZGF0YS5oYXNBcHBlYXJhbmNlIHx8IGRhdGEuZmlsbEFscGhhID09PSAwKSB7XG4gICAgICB0cmlnZ2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICB0cmlnZ2VyLnNyYyA9IGAke3RoaXMuaW1hZ2VSZXNvdXJjZXNQYXRofWFubm90YXRpb24tJHsvcGFwZXJjbGlwL2kudGVzdChkYXRhLm5hbWUpID8gXCJwYXBlcmNsaXBcIiA6IFwicHVzaHBpblwifS5zdmdgO1xuICAgICAgaWYgKGRhdGEuZmlsbEFscGhhICYmIGRhdGEuZmlsbEFscGhhIDwgMSkge1xuICAgICAgICB0cmlnZ2VyLnN0eWxlID0gYGZpbHRlcjogb3BhY2l0eSgke01hdGgucm91bmQoZGF0YS5maWxsQWxwaGEgKiAxMDApfSUpO2A7XG4gICAgICB9XG4gICAgfVxuICAgIHRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcihcImRibGNsaWNrXCIsIHRoaXMuI2Rvd25sb2FkLmJpbmQodGhpcykpO1xuICAgIHRoaXMuI3RyaWdnZXIgPSB0cmlnZ2VyO1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGV2dCA9PiB7XG4gICAgICBpZiAoZXZ0LmtleSA9PT0gXCJFbnRlclwiICYmIChpc01hYyA/IGV2dC5tZXRhS2V5IDogZXZ0LmN0cmxLZXkpKSB7XG4gICAgICAgIHRoaXMuI2Rvd25sb2FkKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2VyLmNsYXNzTGlzdC5hZGQoXCJwb3B1cFRyaWdnZXJBcmVhXCIpO1xuICAgIH1cbiAgICBjb250YWluZXIuYXBwZW5kKHRyaWdnZXIpO1xuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jdHJpZ2dlcjtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG4gICNkb3dubG9hZCgpIHtcbiAgICB0aGlzLmRvd25sb2FkTWFuYWdlcj8ub3Blbk9yRG93bmxvYWREYXRhKHRoaXMuY29udGVudCwgdGhpcy5maWxlbmFtZSk7XG4gIH1cbn1cbmNsYXNzIEFubm90YXRpb25MYXllciB7XG4gICNhY2Nlc3NpYmlsaXR5TWFuYWdlciA9IG51bGw7XG4gICNhbm5vdGF0aW9uQ2FudmFzTWFwID0gbnVsbDtcbiAgI2VkaXRhYmxlQW5ub3RhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICNzdHJ1Y3RUcmVlTGF5ZXIgPSBudWxsO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZGl2LFxuICAgIGFjY2Vzc2liaWxpdHlNYW5hZ2VyLFxuICAgIGFubm90YXRpb25DYW52YXNNYXAsXG4gICAgYW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlcixcbiAgICBwYWdlLFxuICAgIHZpZXdwb3J0LFxuICAgIHN0cnVjdFRyZWVMYXllclxuICB9KSB7XG4gICAgdGhpcy5kaXYgPSBkaXY7XG4gICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXIgPSBhY2Nlc3NpYmlsaXR5TWFuYWdlcjtcbiAgICB0aGlzLiNhbm5vdGF0aW9uQ2FudmFzTWFwID0gYW5ub3RhdGlvbkNhbnZhc01hcDtcbiAgICB0aGlzLiNzdHJ1Y3RUcmVlTGF5ZXIgPSBzdHJ1Y3RUcmVlTGF5ZXIgfHwgbnVsbDtcbiAgICB0aGlzLnBhZ2UgPSBwYWdlO1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICB0aGlzLnpJbmRleCA9IDA7XG4gICAgdGhpcy5fYW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciA9IGFubm90YXRpb25FZGl0b3JVSU1hbmFnZXI7XG4gIH1cbiAgaGFzRWRpdGFibGVBbm5vdGF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy4jZWRpdGFibGVBbm5vdGF0aW9ucy5zaXplID4gMDtcbiAgfVxuICBhc3luYyAjYXBwZW5kRWxlbWVudChlbGVtZW50LCBpZCwgcG9wdXBFbGVtZW50cykge1xuICAgIGNvbnN0IGNvbnRlbnRFbGVtZW50ID0gZWxlbWVudC5maXJzdENoaWxkIHx8IGVsZW1lbnQ7XG4gICAgY29uc3QgYW5ub3RhdGlvbklkID0gY29udGVudEVsZW1lbnQuaWQgPSBgJHtBbm5vdGF0aW9uUHJlZml4fSR7aWR9YDtcbiAgICBjb25zdCBhcmlhQXR0cmlidXRlcyA9IGF3YWl0IHRoaXMuI3N0cnVjdFRyZWVMYXllcj8uZ2V0QXJpYUF0dHJpYnV0ZXMoYW5ub3RhdGlvbklkKTtcbiAgICBpZiAoYXJpYUF0dHJpYnV0ZXMpIHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGFyaWFBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnRlbnRFbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBvcHVwRWxlbWVudHMpIHtcbiAgICAgIHBvcHVwRWxlbWVudHMuYXQoLTEpLmNvbnRhaW5lci5hZnRlcihlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXYuYXBwZW5kKGVsZW1lbnQpO1xuICAgICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXI/Lm1vdmVFbGVtZW50SW5ET00odGhpcy5kaXYsIGVsZW1lbnQsIGNvbnRlbnRFbGVtZW50LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHJlbmRlcihwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uc1xuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmRpdjtcbiAgICBzZXRMYXllckRpbWVuc2lvbnMobGF5ZXIsIHRoaXMudmlld3BvcnQpO1xuICAgIGNvbnN0IHBvcHVwVG9FbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBlbGVtZW50UGFyYW1zID0ge1xuICAgICAgZGF0YTogbnVsbCxcbiAgICAgIGxheWVyLFxuICAgICAgbGlua1NlcnZpY2U6IHBhcmFtcy5saW5rU2VydmljZSxcbiAgICAgIGRvd25sb2FkTWFuYWdlcjogcGFyYW1zLmRvd25sb2FkTWFuYWdlcixcbiAgICAgIGltYWdlUmVzb3VyY2VzUGF0aDogcGFyYW1zLmltYWdlUmVzb3VyY2VzUGF0aCB8fCBcIlwiLFxuICAgICAgcmVuZGVyRm9ybXM6IHBhcmFtcy5yZW5kZXJGb3JtcyAhPT0gZmFsc2UsXG4gICAgICBzdmdGYWN0b3J5OiBuZXcgRE9NU1ZHRmFjdG9yeSgpLFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IHBhcmFtcy5hbm5vdGF0aW9uU3RvcmFnZSB8fCBuZXcgQW5ub3RhdGlvblN0b3JhZ2UoKSxcbiAgICAgIGVuYWJsZUNvbW1lbnQ6IHBhcmFtcy5lbmFibGVDb21tZW50ID09PSB0cnVlLFxuICAgICAgZW5hYmxlU2NyaXB0aW5nOiBwYXJhbXMuZW5hYmxlU2NyaXB0aW5nID09PSB0cnVlLFxuICAgICAgaGFzSlNBY3Rpb25zOiBwYXJhbXMuaGFzSlNBY3Rpb25zLFxuICAgICAgZmllbGRPYmplY3RzOiBwYXJhbXMuZmllbGRPYmplY3RzLFxuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgZWxlbWVudHM6IG51bGxcbiAgICB9O1xuICAgIGZvciAoY29uc3QgZGF0YSBvZiBhbm5vdGF0aW9ucykge1xuICAgICAgaWYgKGRhdGEubm9IVE1MKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNQb3B1cEFubm90YXRpb24gPSBkYXRhLmFubm90YXRpb25UeXBlID09PSBBbm5vdGF0aW9uVHlwZS5QT1BVUDtcbiAgICAgIGlmICghaXNQb3B1cEFubm90YXRpb24pIHtcbiAgICAgICAgaWYgKGRhdGEucmVjdFsyXSA9PT0gZGF0YS5yZWN0WzBdIHx8IGRhdGEucmVjdFszXSA9PT0gZGF0YS5yZWN0WzFdKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gcG9wdXBUb0VsZW1lbnRzLmdldChkYXRhLmlkKTtcbiAgICAgICAgaWYgKCFlbGVtZW50cykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRQYXJhbXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICAgIH1cbiAgICAgIGVsZW1lbnRQYXJhbXMuZGF0YSA9IGRhdGE7XG4gICAgICBjb25zdCBlbGVtZW50ID0gQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5LmNyZWF0ZShlbGVtZW50UGFyYW1zKTtcbiAgICAgIGlmICghZWxlbWVudC5pc1JlbmRlcmFibGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWlzUG9wdXBBbm5vdGF0aW9uICYmIGRhdGEucG9wdXBSZWYpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBwb3B1cFRvRWxlbWVudHMuZ2V0KGRhdGEucG9wdXBSZWYpO1xuICAgICAgICBpZiAoIWVsZW1lbnRzKSB7XG4gICAgICAgICAgcG9wdXBUb0VsZW1lbnRzLnNldChkYXRhLnBvcHVwUmVmLCBbZWxlbWVudF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbmRlcmVkID0gZWxlbWVudC5yZW5kZXIoKTtcbiAgICAgIGlmIChkYXRhLmhpZGRlbikge1xuICAgICAgICByZW5kZXJlZC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuI2FwcGVuZEVsZW1lbnQocmVuZGVyZWQsIGRhdGEuaWQsIGVsZW1lbnRQYXJhbXMuZWxlbWVudHMpO1xuICAgICAgaWYgKGVsZW1lbnQuX2lzRWRpdGFibGUpIHtcbiAgICAgICAgdGhpcy4jZWRpdGFibGVBbm5vdGF0aW9ucy5zZXQoZWxlbWVudC5kYXRhLmlkLCBlbGVtZW50KTtcbiAgICAgICAgdGhpcy5fYW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlcj8ucmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3NldEFubm90YXRpb25DYW52YXNNYXAoKTtcbiAgfVxuICBhc3luYyBhZGRMaW5rQW5ub3RhdGlvbnMoYW5ub3RhdGlvbnMsIGxpbmtTZXJ2aWNlKSB7XG4gICAgY29uc3QgZWxlbWVudFBhcmFtcyA9IHtcbiAgICAgIGRhdGE6IG51bGwsXG4gICAgICBsYXllcjogdGhpcy5kaXYsXG4gICAgICBsaW5rU2VydmljZSxcbiAgICAgIHN2Z0ZhY3Rvcnk6IG5ldyBET01TVkdGYWN0b3J5KCksXG4gICAgICBwYXJlbnQ6IHRoaXNcbiAgICB9O1xuICAgIGZvciAoY29uc3QgZGF0YSBvZiBhbm5vdGF0aW9ucykge1xuICAgICAgZGF0YS5ib3JkZXJTdHlsZSB8fD0gQW5ub3RhdGlvbkxheWVyLl9kZWZhdWx0Qm9yZGVyU3R5bGU7XG4gICAgICBlbGVtZW50UGFyYW1zLmRhdGEgPSBkYXRhO1xuICAgICAgY29uc3QgZWxlbWVudCA9IEFubm90YXRpb25FbGVtZW50RmFjdG9yeS5jcmVhdGUoZWxlbWVudFBhcmFtcyk7XG4gICAgICBpZiAoIWVsZW1lbnQuaXNSZW5kZXJhYmxlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVuZGVyZWQgPSBlbGVtZW50LnJlbmRlcigpO1xuICAgICAgYXdhaXQgdGhpcy4jYXBwZW5kRWxlbWVudChyZW5kZXJlZCwgZGF0YS5pZCwgbnVsbCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZSh7XG4gICAgdmlld3BvcnRcbiAgfSkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5kaXY7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHNldExheWVyRGltZW5zaW9ucyhsYXllciwge1xuICAgICAgcm90YXRpb246IHZpZXdwb3J0LnJvdGF0aW9uXG4gICAgfSk7XG4gICAgdGhpcy4jc2V0QW5ub3RhdGlvbkNhbnZhc01hcCgpO1xuICAgIGxheWVyLmhpZGRlbiA9IGZhbHNlO1xuICB9XG4gICNzZXRBbm5vdGF0aW9uQ2FudmFzTWFwKCkge1xuICAgIGlmICghdGhpcy4jYW5ub3RhdGlvbkNhbnZhc01hcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXllciA9IHRoaXMuZGl2O1xuICAgIGZvciAoY29uc3QgW2lkLCBjYW52YXNdIG9mIHRoaXMuI2Fubm90YXRpb25DYW52YXNNYXApIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBsYXllci5xdWVyeVNlbGVjdG9yKGBbZGF0YS1hbm5vdGF0aW9uLWlkPVwiJHtpZH1cIl1gKTtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNhbnZhcy5jbGFzc05hbWUgPSBcImFubm90YXRpb25Db250ZW50XCI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZpcnN0Q2hpbGRcbiAgICAgIH0gPSBlbGVtZW50O1xuICAgICAgaWYgKCFmaXJzdENoaWxkKSB7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kKGNhbnZhcyk7XG4gICAgICB9IGVsc2UgaWYgKGZpcnN0Q2hpbGQubm9kZU5hbWUgPT09IFwiQ0FOVkFTXCIpIHtcbiAgICAgICAgZmlyc3RDaGlsZC5yZXBsYWNlV2l0aChjYW52YXMpO1xuICAgICAgfSBlbHNlIGlmICghZmlyc3RDaGlsZC5jbGFzc0xpc3QuY29udGFpbnMoXCJhbm5vdGF0aW9uQ29udGVudFwiKSkge1xuICAgICAgICBmaXJzdENoaWxkLmJlZm9yZShjYW52YXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlyc3RDaGlsZC5hZnRlcihjYW52YXMpO1xuICAgICAgfVxuICAgICAgY29uc3QgZWRpdGFibGVBbm5vdGF0aW9uID0gdGhpcy4jZWRpdGFibGVBbm5vdGF0aW9ucy5nZXQoaWQpO1xuICAgICAgaWYgKCFlZGl0YWJsZUFubm90YXRpb24pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZWRpdGFibGVBbm5vdGF0aW9uLl9oYXNOb0NhbnZhcykge1xuICAgICAgICB0aGlzLl9hbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyPy5zZXRNaXNzaW5nQ2FudmFzKGlkLCBlbGVtZW50LmlkLCBjYW52YXMpO1xuICAgICAgICBlZGl0YWJsZUFubm90YXRpb24uX2hhc05vQ2FudmFzID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0YWJsZUFubm90YXRpb24uY2FudmFzID0gY2FudmFzO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNhbm5vdGF0aW9uQ2FudmFzTWFwLmNsZWFyKCk7XG4gIH1cbiAgZ2V0RWRpdGFibGVBbm5vdGF0aW9ucygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLnZhbHVlcygpKTtcbiAgfVxuICBnZXRFZGl0YWJsZUFubm90YXRpb24oaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jZWRpdGFibGVBbm5vdGF0aW9ucy5nZXQoaWQpO1xuICB9XG4gIHN0YXRpYyBnZXQgX2RlZmF1bHRCb3JkZXJTdHlsZSgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2RlZmF1bHRCb3JkZXJTdHlsZVwiLCBPYmplY3QuZnJlZXplKHtcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgcmF3V2lkdGg6IDEsXG4gICAgICBzdHlsZTogQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5TT0xJRCxcbiAgICAgIGRhc2hBcnJheTogWzNdLFxuICAgICAgaG9yaXpvbnRhbENvcm5lclJhZGl1czogMCxcbiAgICAgIHZlcnRpY2FsQ29ybmVyUmFkaXVzOiAwXG4gICAgfSkpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9mcmVldGV4dC5qc1xuXG5cblxuXG5cbmNvbnN0IEVPTF9QQVRURVJOID0gL1xcclxcbj98XFxuL2c7XG5jbGFzcyBGcmVlVGV4dEVkaXRvciBleHRlbmRzIEFubm90YXRpb25FZGl0b3Ige1xuICAjY29sb3I7XG4gICNjb250ZW50ID0gXCJcIjtcbiAgI2VkaXRvckRpdklkID0gYCR7dGhpcy5pZH0tZWRpdG9yYDtcbiAgI2VkaXRNb2RlQUMgPSBudWxsO1xuICAjZm9udFNpemU7XG4gIF9jb2xvclBpY2tlciA9IG51bGw7XG4gIHN0YXRpYyBfZnJlZVRleHREZWZhdWx0Q29udGVudCA9IFwiXCI7XG4gIHN0YXRpYyBfaW50ZXJuYWxQYWRkaW5nID0gMDtcbiAgc3RhdGljIF9kZWZhdWx0Q29sb3IgPSBudWxsO1xuICBzdGF0aWMgX2RlZmF1bHRGb250U2l6ZSA9IDEwO1xuICBzdGF0aWMgZ2V0IF9rZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgY29uc3QgcHJvdG8gPSBGcmVlVGV4dEVkaXRvci5wcm90b3R5cGU7XG4gICAgY29uc3QgYXJyb3dDaGVja2VyID0gc2VsZiA9PiBzZWxmLmlzRW1wdHkoKTtcbiAgICBjb25zdCBzbWFsbCA9IEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIuVFJBTlNMQVRFX1NNQUxMO1xuICAgIGNvbnN0IGJpZyA9IEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIuVFJBTlNMQVRFX0JJRztcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiY3RybCtzXCIsIFwibWFjK21ldGErc1wiLCBcImN0cmwrcFwiLCBcIm1hYyttZXRhK3BcIl0sIHByb3RvLmNvbW1pdE9yUmVtb3ZlLCB7XG4gICAgICBidWJibGVzOiB0cnVlXG4gICAgfV0sIFtbXCJjdHJsK0VudGVyXCIsIFwibWFjK21ldGErRW50ZXJcIiwgXCJFc2NhcGVcIiwgXCJtYWMrRXNjYXBlXCJdLCBwcm90by5jb21taXRPclJlbW92ZV0sIFtbXCJBcnJvd0xlZnRcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFstc21hbGwsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93TGVmdFwiLCBcIm1hYytzaGlmdCtBcnJvd0xlZnRcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWy1iaWcsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogW3NtYWxsLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1JpZ2h0XCIsIFwibWFjK3NoaWZ0K0Fycm93UmlnaHRcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogW2JpZywgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93VXBcIiwgXCJtYWMrQXJyb3dVcFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbMCwgLXNtYWxsXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1VwXCIsIFwibWFjK3NoaWZ0K0Fycm93VXBcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWzAsIC1iaWddLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd0Rvd25cIiwgXCJtYWMrQXJyb3dEb3duXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCBzbWFsbF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dEb3duXCIsIFwibWFjK3NoaWZ0K0Fycm93RG93blwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbMCwgYmlnXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dXSkpO1xuICB9XG4gIHN0YXRpYyBfdHlwZSA9IFwiZnJlZXRleHRcIjtcbiAgc3RhdGljIF9lZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQ7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG5hbWU6IFwiZnJlZVRleHRFZGl0b3JcIlxuICAgIH0pO1xuICAgIHRoaXMuI2NvbG9yID0gcGFyYW1zLmNvbG9yIHx8IEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Q29sb3IgfHwgQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcjtcbiAgICB0aGlzLiNmb250U2l6ZSA9IHBhcmFtcy5mb250U2l6ZSB8fCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdEZvbnRTaXplO1xuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuYTExeUFsZXJ0KFwicGRmanMtZWRpdG9yLWZyZWV0ZXh0LWFkZGVkLWFsZXJ0XCIpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKTtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgICB0aGlzLl9pbnRlcm5hbFBhZGRpbmcgPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCItLWZyZWV0ZXh0LXBhZGRpbmdcIikpO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkU6XG4gICAgICAgIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Rm9udFNpemUgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SOlxuICAgICAgICBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdENvbG9yID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRTpcbiAgICAgICAgdGhpcy4jdXBkYXRlRm9udFNpemUodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1I6XG4gICAgICAgIHRoaXMuI3VwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFLCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdEZvbnRTaXplXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SLCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdENvbG9yIHx8IEFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3JdXTtcbiAgfVxuICBnZXQgcHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkUsIHRoaXMuI2ZvbnRTaXplXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SLCB0aGlzLiNjb2xvcl1dO1xuICB9XG4gIGdldCB0b29sYmFyQnV0dG9ucygpIHtcbiAgICB0aGlzLl9jb2xvclBpY2tlciB8fD0gbmV3IEJhc2ljQ29sb3JQaWNrZXIodGhpcyk7XG4gICAgcmV0dXJuIFtbXCJjb2xvclBpY2tlclwiLCB0aGlzLl9jb2xvclBpY2tlcl1dO1xuICB9XG4gIGdldCBjb2xvclR5cGUoKSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SO1xuICB9XG4gIGdldCBjb2xvclZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLiNjb2xvcjtcbiAgfVxuICAjdXBkYXRlRm9udFNpemUoZm9udFNpemUpIHtcbiAgICBjb25zdCBzZXRGb250c2l6ZSA9IHNpemUgPT4ge1xuICAgICAgdGhpcy5lZGl0b3JEaXYuc3R5bGUuZm9udFNpemUgPSBgY2FsYygke3NpemV9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKWA7XG4gICAgICB0aGlzLnRyYW5zbGF0ZSgwLCAtKHNpemUgLSB0aGlzLiNmb250U2l6ZSkgKiB0aGlzLnBhcmVudFNjYWxlKTtcbiAgICAgIHRoaXMuI2ZvbnRTaXplID0gc2l6ZTtcbiAgICAgIHRoaXMuI3NldEVkaXRvckRpbWVuc2lvbnMoKTtcbiAgICB9O1xuICAgIGNvbnN0IHNhdmVkRm9udHNpemUgPSB0aGlzLiNmb250U2l6ZTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogc2V0Rm9udHNpemUuYmluZCh0aGlzLCBmb250U2l6ZSksXG4gICAgICB1bmRvOiBzZXRGb250c2l6ZS5iaW5kKHRoaXMsIHNhdmVkRm9udHNpemUpLFxuICAgICAgcG9zdDogdGhpcy5fdWlNYW5hZ2VyLnVwZGF0ZVVJLmJpbmQodGhpcy5fdWlNYW5hZ2VyLCB0aGlzKSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRSxcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gICN1cGRhdGVDb2xvcihjb2xvcikge1xuICAgIGNvbnN0IHNldENvbG9yID0gY29sID0+IHtcbiAgICAgIHRoaXMuI2NvbG9yID0gdGhpcy5lZGl0b3JEaXYuc3R5bGUuY29sb3IgPSBjb2w7XG4gICAgICB0aGlzLl9jb2xvclBpY2tlcj8udXBkYXRlKGNvbCk7XG4gICAgfTtcbiAgICBjb25zdCBzYXZlZENvbG9yID0gdGhpcy4jY29sb3I7XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6IHNldENvbG9yLmJpbmQodGhpcywgY29sb3IpLFxuICAgICAgdW5kbzogc2V0Q29sb3IuYmluZCh0aGlzLCBzYXZlZENvbG9yKSxcbiAgICAgIHBvc3Q6IHRoaXMuX3VpTWFuYWdlci51cGRhdGVVSS5iaW5kKHRoaXMuX3VpTWFuYWdlciwgdGhpcyksXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgX3RyYW5zbGF0ZUVtcHR5KHgsIHkpIHtcbiAgICB0aGlzLl91aU1hbmFnZXIudHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzKHgsIHksIHRydWUpO1xuICB9XG4gIGdldEluaXRpYWxUcmFuc2xhdGlvbigpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMucGFyZW50U2NhbGU7XG4gICAgcmV0dXJuIFstRnJlZVRleHRFZGl0b3IuX2ludGVybmFsUGFkZGluZyAqIHNjYWxlLCAtKEZyZWVUZXh0RWRpdG9yLl9pbnRlcm5hbFBhZGRpbmcgKyB0aGlzLiNmb250U2l6ZSkgKiBzY2FsZV07XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYnVpbGQoKTtcbiAgICBpZiAodGhpcy5kaXYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKHRoaXMpO1xuICAgIH1cbiAgfVxuICBlbmFibGVFZGl0TW9kZSgpIHtcbiAgICBpZiAoIXN1cGVyLmVuYWJsZUVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5vdmVybGF5RGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJlbmFibGVkXCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICB0aGlzLmRpdi5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIik7XG4gICAgdGhpcy4jZWRpdE1vZGVBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuY29tYmluZWRTaWduYWwodGhpcy4jZWRpdE1vZGVBQyk7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5lZGl0b3JEaXZLZXlkb3duLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLmVkaXRvckRpdkZvY3VzLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuZWRpdG9yRGl2Qmx1ci5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy5lZGl0b3JEaXZJbnB1dC5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwicGFzdGVcIiwgdGhpcy5lZGl0b3JEaXZQYXN0ZS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkaXNhYmxlRWRpdE1vZGUoKSB7XG4gICAgaWYgKCFzdXBlci5kaXNhYmxlRWRpdE1vZGUoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLm92ZXJsYXlEaXYuY2xhc3NMaXN0LmFkZChcImVuYWJsZWRcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIsIHRoaXMuI2VkaXRvckRpdklkKTtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IHRydWU7XG4gICAgdGhpcy4jZWRpdE1vZGVBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNlZGl0TW9kZUFDID0gbnVsbDtcbiAgICB0aGlzLmRpdi5mb2N1cyh7XG4gICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnBhcmVudC5kaXYuY2xhc3NMaXN0LmFkZChcImZyZWV0ZXh0RWRpdGluZ1wiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmb2N1c2luKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9mb2N1c0V2ZW50c0FsbG93ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuZm9jdXNpbihldmVudCk7XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5lZGl0b3JEaXYpIHtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmZvY3VzKCk7XG4gICAgfVxuICB9XG4gIG9uY2VBZGRlZChmb2N1cykge1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICBpZiAoZm9jdXMpIHtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmZvY3VzKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9pbml0aWFsT3B0aW9ucz8uaXNDZW50ZXJlZCkge1xuICAgICAgdGhpcy5jZW50ZXIoKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbE9wdGlvbnMgPSBudWxsO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuICF0aGlzLmVkaXRvckRpdiB8fCB0aGlzLmVkaXRvckRpdi5pbm5lclRleHQudHJpbSgpID09PSBcIlwiO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0RWRpdGluZ1N0YXRlKHRydWUpO1xuICAgICAgdGhpcy5wYXJlbnQuZGl2LmNsYXNzTGlzdC5hZGQoXCJmcmVldGV4dEVkaXRpbmdcIik7XG4gICAgfVxuICAgIHN1cGVyLnJlbW92ZSgpO1xuICB9XG4gICNleHRyYWN0VGV4dCgpIHtcbiAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICB0aGlzLmVkaXRvckRpdi5ub3JtYWxpemUoKTtcbiAgICBsZXQgcHJldkNoaWxkID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuZWRpdG9yRGl2LmNoaWxkTm9kZXMpIHtcbiAgICAgIGlmIChwcmV2Q2hpbGQ/Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSAmJiBjaGlsZC5ub2RlTmFtZSA9PT0gXCJCUlwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnVmZmVyLnB1c2goRnJlZVRleHRFZGl0b3IuI2dldE5vZGVDb250ZW50KGNoaWxkKSk7XG4gICAgICBwcmV2Q2hpbGQgPSBjaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiXFxuXCIpO1xuICB9XG4gICNzZXRFZGl0b3JEaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBsZXQgcmVjdDtcbiAgICBpZiAodGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHJlY3QgPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjdXJyZW50TGF5ZXIsXG4gICAgICAgIGRpdlxuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCBzYXZlZERpc3BsYXkgPSBkaXYuc3R5bGUuZGlzcGxheTtcbiAgICAgIGNvbnN0IHNhdmVkVmlzaWJpbGl0eSA9IGRpdi5jbGFzc0xpc3QuY29udGFpbnMoXCJoaWRkZW5cIik7XG4gICAgICBkaXYuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbiAgICAgIGRpdi5zdHlsZS5kaXNwbGF5ID0gXCJoaWRkZW5cIjtcbiAgICAgIGN1cnJlbnRMYXllci5kaXYuYXBwZW5kKHRoaXMuZGl2KTtcbiAgICAgIHJlY3QgPSBkaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBkaXYucmVtb3ZlKCk7XG4gICAgICBkaXYuc3R5bGUuZGlzcGxheSA9IHNhdmVkRGlzcGxheTtcbiAgICAgIGRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiaGlkZGVuXCIsIHNhdmVkVmlzaWJpbGl0eSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJvdGF0aW9uICUgMTgwID09PSB0aGlzLnBhcmVudFJvdGF0aW9uICUgMTgwKSB7XG4gICAgICB0aGlzLndpZHRoID0gcmVjdC53aWR0aCAvIHBhcmVudFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSByZWN0LmhlaWdodCAvIHBhcmVudEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IHJlY3QuaGVpZ2h0IC8gcGFyZW50V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHJlY3Qud2lkdGggLyBwYXJlbnRIZWlnaHQ7XG4gICAgfVxuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICBjb21taXQoKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5FZGl0TW9kZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmNvbW1pdCgpO1xuICAgIHRoaXMuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgY29uc3Qgc2F2ZWRUZXh0ID0gdGhpcy4jY29udGVudDtcbiAgICBjb25zdCBuZXdUZXh0ID0gdGhpcy4jY29udGVudCA9IHRoaXMuI2V4dHJhY3RUZXh0KCkudHJpbUVuZCgpO1xuICAgIGlmIChzYXZlZFRleHQgPT09IG5ld1RleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2V0VGV4dCA9IHRleHQgPT4ge1xuICAgICAgdGhpcy4jY29udGVudCA9IHRleHQ7XG4gICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy4jc2V0Q29udGVudCgpO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnJlYnVpbGQodGhpcyk7XG4gICAgICB0aGlzLiNzZXRFZGl0b3JEaW1lbnNpb25zKCk7XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICBzZXRUZXh0KG5ld1RleHQpO1xuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgc2V0VGV4dChzYXZlZFRleHQpO1xuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMuI3NldEVkaXRvckRpbWVuc2lvbnMoKTtcbiAgfVxuICBzaG91bGRHZXRLZXlib2FyZEV2ZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5pc0luRWRpdE1vZGUoKTtcbiAgfVxuICBlbnRlckluRWRpdE1vZGUoKSB7XG4gICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmZvY3VzKCk7XG4gIH1cbiAga2V5ZG93bihldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuZGl2ICYmIGV2ZW50LmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICB0aGlzLmVudGVySW5FZGl0TW9kZSgpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZWRpdG9yRGl2S2V5ZG93bihldmVudCkge1xuICAgIEZyZWVUZXh0RWRpdG9yLl9rZXlib2FyZE1hbmFnZXIuZXhlYyh0aGlzLCBldmVudCk7XG4gIH1cbiAgZWRpdG9yRGl2Rm9jdXMoZXZlbnQpIHtcbiAgICB0aGlzLmlzRWRpdGluZyA9IHRydWU7XG4gIH1cbiAgZWRpdG9yRGl2Qmx1cihldmVudCkge1xuICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gIH1cbiAgZWRpdG9yRGl2SW5wdXQoZXZlbnQpIHtcbiAgICB0aGlzLnBhcmVudC5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImZyZWV0ZXh0RWRpdGluZ1wiLCB0aGlzLmlzRW1wdHkoKSk7XG4gIH1cbiAgZGlzYWJsZUVkaXRpbmcoKSB7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImNvbW1lbnRcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1tdWx0aWxpbmVcIik7XG4gIH1cbiAgZW5hYmxlRWRpdGluZygpIHtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidGV4dGJveFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLW11bHRpbGluZVwiLCB0cnVlKTtcbiAgfVxuICBnZXQgY2FuQ2hhbmdlQ29udGVudCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfVxuICAgIGxldCBiYXNlWCwgYmFzZVk7XG4gICAgaWYgKHRoaXMuX2lzQ29weSB8fCB0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIGJhc2VYID0gdGhpcy54O1xuICAgICAgYmFzZVkgPSB0aGlzLnk7XG4gICAgfVxuICAgIHN1cGVyLnJlbmRlcigpO1xuICAgIHRoaXMuZWRpdG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jbGFzc05hbWUgPSBcImludGVybmFsXCI7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwiaWRcIiwgdGhpcy4jZWRpdG9yRGl2SWQpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWZyZWUtdGV4dDJcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWF0dHJzXCIsIFwiZGVmYXVsdC1jb250ZW50XCIpO1xuICAgIHRoaXMuZW5hYmxlRWRpdGluZygpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy5lZGl0b3JEaXY7XG4gICAgc3R5bGUuZm9udFNpemUgPSBgY2FsYygke3RoaXMuI2ZvbnRTaXplfXB4ICogdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSlgO1xuICAgIHN0eWxlLmNvbG9yID0gdGhpcy4jY29sb3I7XG4gICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMuZWRpdG9yRGl2KTtcbiAgICB0aGlzLm92ZXJsYXlEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMub3ZlcmxheURpdi5jbGFzc0xpc3QuYWRkKFwib3ZlcmxheVwiLCBcImVuYWJsZWRcIik7XG4gICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMub3ZlcmxheURpdik7XG4gICAgaWYgKHRoaXMuX2lzQ29weSB8fCB0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgIGlmICh0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgIH0gPSB0aGlzLl9pbml0aWFsRGF0YTtcbiAgICAgICAgbGV0IFt0eCwgdHldID0gdGhpcy5nZXRJbml0aWFsVHJhbnNsYXRpb24oKTtcbiAgICAgICAgW3R4LCB0eV0gPSB0aGlzLnBhZ2VUcmFuc2xhdGlvblRvU2NyZWVuKHR4LCB0eSk7XG4gICAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgICAgY29uc3QgW3BhZ2VYLCBwYWdlWV0gPSB0aGlzLnBhZ2VUcmFuc2xhdGlvbjtcbiAgICAgICAgbGV0IHBvc1gsIHBvc1k7XG4gICAgICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCArIChwb3NpdGlvblswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSArIHRoaXMuaGVpZ2h0IC0gKHBvc2l0aW9uWzFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgOTA6XG4gICAgICAgICAgICBwb3NYID0gYmFzZVggKyAocG9zaXRpb25bMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgICBwb3NZID0gYmFzZVkgLSAocG9zaXRpb25bMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgW3R4LCB0eV0gPSBbdHksIC10eF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE4MDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCAtIHRoaXMud2lkdGggKyAocG9zaXRpb25bMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgICBwb3NZID0gYmFzZVkgLSAocG9zaXRpb25bMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgW3R4LCB0eV0gPSBbLXR4LCAtdHldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyNzA6XG4gICAgICAgICAgICBwb3NYID0gYmFzZVggKyAocG9zaXRpb25bMF0gLSBwYWdlWCAtIHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodCkgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgICBwb3NZID0gYmFzZVkgKyAocG9zaXRpb25bMV0gLSBwYWdlWSAtIHRoaXMud2lkdGggKiBwYWdlV2lkdGgpIC8gcGFnZUhlaWdodDtcbiAgICAgICAgICAgIFt0eCwgdHldID0gWy10eSwgdHhdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRBdChwb3NYICogcGFyZW50V2lkdGgsIHBvc1kgKiBwYXJlbnRIZWlnaHQsIHR4LCB0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9tb3ZlQWZ0ZXJQYXN0ZShiYXNlWCwgYmFzZVkpO1xuICAgICAgfVxuICAgICAgdGhpcy4jc2V0Q29udGVudCgpO1xuICAgICAgdGhpcy5faXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgc3RhdGljICNnZXROb2RlQ29udGVudChub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSA/IG5vZGUubm9kZVZhbHVlIDogbm9kZS5pbm5lclRleHQpLnJlcGxhY2VBbGwoRU9MX1BBVFRFUk4sIFwiXCIpO1xuICB9XG4gIGVkaXRvckRpdlBhc3RlKGV2ZW50KSB7XG4gICAgY29uc3QgY2xpcGJvYXJkRGF0YSA9IGV2ZW50LmNsaXBib2FyZERhdGEgfHwgd2luZG93LmNsaXBib2FyZERhdGE7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZXNcbiAgICB9ID0gY2xpcGJvYXJkRGF0YTtcbiAgICBpZiAodHlwZXMubGVuZ3RoID09PSAxICYmIHR5cGVzWzBdID09PSBcInRleHQvcGxhaW5cIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHBhc3RlID0gRnJlZVRleHRFZGl0b3IuI2Rlc2VyaWFsaXplQ29udGVudChjbGlwYm9hcmREYXRhLmdldERhdGEoXCJ0ZXh0XCIpIHx8IFwiXCIpLnJlcGxhY2VBbGwoRU9MX1BBVFRFUk4sIFwiXFxuXCIpO1xuICAgIGlmICghcGFzdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsZWN0aW9uLnJhbmdlQ291bnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lZGl0b3JEaXYubm9ybWFsaXplKCk7XG4gICAgc2VsZWN0aW9uLmRlbGV0ZUZyb21Eb2N1bWVudCgpO1xuICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgaWYgKCFwYXN0ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShwYXN0ZSkpO1xuICAgICAgdGhpcy5lZGl0b3JEaXYubm9ybWFsaXplKCk7XG4gICAgICBzZWxlY3Rpb24uY29sbGFwc2VUb1N0YXJ0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0Q29udGFpbmVyLFxuICAgICAgc3RhcnRPZmZzZXRcbiAgICB9ID0gcmFuZ2U7XG4gICAgY29uc3QgYnVmZmVyQmVmb3JlID0gW107XG4gICAgY29uc3QgYnVmZmVyQWZ0ZXIgPSBbXTtcbiAgICBpZiAoc3RhcnRDb250YWluZXIubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBzdGFydENvbnRhaW5lci5wYXJlbnRFbGVtZW50O1xuICAgICAgYnVmZmVyQWZ0ZXIucHVzaChzdGFydENvbnRhaW5lci5ub2RlVmFsdWUuc2xpY2Uoc3RhcnRPZmZzZXQpLnJlcGxhY2VBbGwoRU9MX1BBVFRFUk4sIFwiXCIpKTtcbiAgICAgIGlmIChwYXJlbnQgIT09IHRoaXMuZWRpdG9yRGl2KSB7XG4gICAgICAgIGxldCBidWZmZXIgPSBidWZmZXJCZWZvcmU7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5lZGl0b3JEaXYuY2hpbGROb2Rlcykge1xuICAgICAgICAgIGlmIChjaGlsZCA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgICBidWZmZXIgPSBidWZmZXJBZnRlcjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWZmZXIucHVzaChGcmVlVGV4dEVkaXRvci4jZ2V0Tm9kZUNvbnRlbnQoY2hpbGQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnVmZmVyQmVmb3JlLnB1c2goc3RhcnRDb250YWluZXIubm9kZVZhbHVlLnNsaWNlKDAsIHN0YXJ0T2Zmc2V0KS5yZXBsYWNlQWxsKEVPTF9QQVRURVJOLCBcIlwiKSk7XG4gICAgfSBlbHNlIGlmIChzdGFydENvbnRhaW5lciA9PT0gdGhpcy5lZGl0b3JEaXYpIHtcbiAgICAgIGxldCBidWZmZXIgPSBidWZmZXJCZWZvcmU7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuZWRpdG9yRGl2LmNoaWxkTm9kZXMpIHtcbiAgICAgICAgaWYgKGkrKyA9PT0gc3RhcnRPZmZzZXQpIHtcbiAgICAgICAgICBidWZmZXIgPSBidWZmZXJBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXIucHVzaChGcmVlVGV4dEVkaXRvci4jZ2V0Tm9kZUNvbnRlbnQoY2hpbGQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jY29udGVudCA9IGAke2J1ZmZlckJlZm9yZS5qb2luKFwiXFxuXCIpfSR7cGFzdGV9JHtidWZmZXJBZnRlci5qb2luKFwiXFxuXCIpfWA7XG4gICAgdGhpcy4jc2V0Q29udGVudCgpO1xuICAgIGNvbnN0IG5ld1JhbmdlID0gbmV3IFJhbmdlKCk7XG4gICAgbGV0IGJlZm9yZUxlbmd0aCA9IE1hdGguc3VtUHJlY2lzZShidWZmZXJCZWZvcmUubWFwKGxpbmUgPT4gbGluZS5sZW5ndGgpKTtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIGZpcnN0Q2hpbGRcbiAgICB9IG9mIHRoaXMuZWRpdG9yRGl2LmNoaWxkTm9kZXMpIHtcbiAgICAgIGlmIChmaXJzdENoaWxkLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBmaXJzdENoaWxkLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgIGlmIChiZWZvcmVMZW5ndGggPD0gbGVuZ3RoKSB7XG4gICAgICAgICAgbmV3UmFuZ2Uuc2V0U3RhcnQoZmlyc3RDaGlsZCwgYmVmb3JlTGVuZ3RoKTtcbiAgICAgICAgICBuZXdSYW5nZS5zZXRFbmQoZmlyc3RDaGlsZCwgYmVmb3JlTGVuZ3RoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBiZWZvcmVMZW5ndGggLT0gbGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgc2VsZWN0aW9uLmFkZFJhbmdlKG5ld1JhbmdlKTtcbiAgfVxuICAjc2V0Q29udGVudCgpIHtcbiAgICB0aGlzLmVkaXRvckRpdi5yZXBsYWNlQ2hpbGRyZW4oKTtcbiAgICBpZiAoIXRoaXMuI2NvbnRlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIHRoaXMuI2NvbnRlbnQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBkaXYuYXBwZW5kKGxpbmUgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgICB0aGlzLmVkaXRvckRpdi5hcHBlbmQoZGl2KTtcbiAgICB9XG4gIH1cbiAgI3NlcmlhbGl6ZUNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbnRlbnQucmVwbGFjZUFsbChcIlxceGEwXCIsIFwiIFwiKTtcbiAgfVxuICBzdGF0aWMgI2Rlc2VyaWFsaXplQ29udGVudChjb250ZW50KSB7XG4gICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZUFsbChcIiBcIiwgXCJcXHhhMFwiKTtcbiAgfVxuICBnZXQgY29udGVudERpdigpIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0b3JEaXY7XG4gIH1cbiAgZ2V0UERGUmVjdCgpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gRnJlZVRleHRFZGl0b3IuX2ludGVybmFsUGFkZGluZyAqIHRoaXMucGFyZW50U2NhbGU7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmVjdChwYWRkaW5nLCBwYWRkaW5nKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBsZXQgaW5pdGlhbERhdGEgPSBudWxsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZGVmYXVsdEFwcGVhcmFuY2VEYXRhOiB7XG4gICAgICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRDb2xvclxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVjdCxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwb3B1cFJlZixcbiAgICAgICAgICBjb250ZW50c09ialxuICAgICAgICB9LFxuICAgICAgICB0ZXh0Q29udGVudCxcbiAgICAgICAgdGV4dFBvc2l0aW9uLFxuICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICBwYWdlTnVtYmVyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGlmICghdGV4dENvbnRlbnQgfHwgdGV4dENvbnRlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaW5pdGlhbERhdGEgPSBkYXRhID0ge1xuICAgICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQsXG4gICAgICAgIGNvbG9yOiBBcnJheS5mcm9tKGZvbnRDb2xvciksXG4gICAgICAgIGZvbnRTaXplLFxuICAgICAgICB2YWx1ZTogdGV4dENvbnRlbnQuam9pbihcIlxcblwiKSxcbiAgICAgICAgcG9zaXRpb246IHRleHRQb3NpdGlvbixcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlTnVtYmVyIC0gMSxcbiAgICAgICAgcmVjdDogcmVjdC5zbGljZSgwKSxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGFubm90YXRpb25FbGVtZW50SWQ6IGlkLFxuICAgICAgICBpZCxcbiAgICAgICAgZGVsZXRlZDogZmFsc2UsXG4gICAgICAgIHBvcHVwUmVmLFxuICAgICAgICBjb21tZW50OiBjb250ZW50c09iaj8uc3RyIHx8IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKTtcbiAgICBlZGl0b3IuI2ZvbnRTaXplID0gZGF0YS5mb250U2l6ZTtcbiAgICBlZGl0b3IuI2NvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4uZGF0YS5jb2xvcik7XG4gICAgZWRpdG9yLiNjb250ZW50ID0gRnJlZVRleHRFZGl0b3IuI2Rlc2VyaWFsaXplQ29udGVudChkYXRhLnZhbHVlKTtcbiAgICBlZGl0b3IuX2luaXRpYWxEYXRhID0gaW5pdGlhbERhdGE7XG4gICAgaWYgKGRhdGEuY29tbWVudCkge1xuICAgICAgZWRpdG9yLnNldENvbW1lbnREYXRhKGRhdGEuY29tbWVudCk7XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplRGVsZXRlZCgpO1xuICAgIH1cbiAgICBjb25zdCByZWN0ID0gdGhpcy5nZXRQREZSZWN0KCk7XG4gICAgY29uc3QgY29sb3IgPSBBbm5vdGF0aW9uRWRpdG9yLl9jb2xvck1hbmFnZXIuY29udmVydCh0aGlzLmlzQXR0YWNoZWRUb0RPTSA/IGdldENvbXB1dGVkU3R5bGUodGhpcy5lZGl0b3JEaXYpLmNvbG9yIDogdGhpcy4jY29sb3IpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQsXG4gICAgICBjb2xvcixcbiAgICAgIGZvbnRTaXplOiB0aGlzLiNmb250U2l6ZSxcbiAgICAgIHZhbHVlOiB0aGlzLiNzZXJpYWxpemVDb250ZW50KCksXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4LFxuICAgICAgcmVjdCxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxuICAgICAgc3RydWN0VHJlZVBhcmVudElkOiB0aGlzLl9zdHJ1Y3RUcmVlUGFyZW50SWRcbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWVudChzZXJpYWxpemVkKTtcbiAgICBpZiAoaXNGb3JDb3B5aW5nKSB7XG4gICAgICBzZXJpYWxpemVkLmlzQ29weSA9IHRydWU7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiAhdGhpcy4jaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZXJpYWxpemVkLmlkID0gdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gICNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICBmb250U2l6ZSxcbiAgICAgIGNvbG9yLFxuICAgICAgcGFnZUluZGV4XG4gICAgfSA9IHRoaXMuX2luaXRpYWxEYXRhO1xuICAgIHJldHVybiB0aGlzLmhhc0VkaXRlZENvbW1lbnQgfHwgdGhpcy5faGFzQmVlbk1vdmVkIHx8IHNlcmlhbGl6ZWQudmFsdWUgIT09IHZhbHVlIHx8IHNlcmlhbGl6ZWQuZm9udFNpemUgIT09IGZvbnRTaXplIHx8IHNlcmlhbGl6ZWQuY29sb3Iuc29tZSgoYywgaSkgPT4gYyAhPT0gY29sb3JbaV0pIHx8IHNlcmlhbGl6ZWQucGFnZUluZGV4ICE9PSBwYWdlSW5kZXg7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBzdXBlci5yZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKTtcbiAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBjb250ZW50O1xuICAgIHN0eWxlLmZvbnRTaXplID0gYGNhbGMoJHt0aGlzLiNmb250U2l6ZX1weCAqIHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikpYDtcbiAgICBzdHlsZS5jb2xvciA9IHRoaXMuI2NvbG9yO1xuICAgIGNvbnRlbnQucmVwbGFjZUNoaWxkcmVuKCk7XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIHRoaXMuI2NvbnRlbnQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBkaXYuYXBwZW5kKGxpbmUgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgICBjb250ZW50LmFwcGVuZChkaXYpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICByZWN0OiB0aGlzLmdldFBERlJlY3QoKVxuICAgIH07XG4gICAgcGFyYW1zLnBvcHVwID0gdGhpcy5oYXNFZGl0ZWRDb21tZW50ID8gdGhpcy5jb21tZW50IDoge1xuICAgICAgdGV4dDogdGhpcy4jY29udGVudFxuICAgIH07XG4gICAgYW5ub3RhdGlvbi51cGRhdGVFZGl0ZWQocGFyYW1zKTtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICByZXNldEFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBzdXBlci5yZXNldEFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pO1xuICAgIGFubm90YXRpb24ucmVzZXRFZGl0ZWQoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvZHJhd2Vycy9vdXRsaW5lLmpzXG5cbmNsYXNzIE91dGxpbmUge1xuICBzdGF0aWMgUFJFQ0lTSU9OID0gMWUtNDtcbiAgdG9TVkdQYXRoKCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGB0b1NWR1BhdGhgIG11c3QgYmUgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG4gIGdldCBib3goKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBnZXR0ZXIgYGJveGAgbXVzdCBiZSBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgc2VyaWFsaXplKF9iYm94LCBfcm90YXRpb24pIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgc2VyaWFsaXplYCBtdXN0IGJlIGltcGxlbWVudGVkLlwiKTtcbiAgfVxuICBzdGF0aWMgX3Jlc2NhbGUoc3JjLCB0eCwgdHksIHN4LCBzeSwgZGVzdCkge1xuICAgIGRlc3QgfHw9IG5ldyBGbG9hdDMyQXJyYXkoc3JjLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3JjLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGRlc3RbaV0gPSB0eCArIHNyY1tpXSAqIHN4O1xuICAgICAgZGVzdFtpICsgMV0gPSB0eSArIHNyY1tpICsgMV0gKiBzeTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cbiAgc3RhdGljIF9yZXNjYWxlQW5kU3dhcChzcmMsIHR4LCB0eSwgc3gsIHN5LCBkZXN0KSB7XG4gICAgZGVzdCB8fD0gbmV3IEZsb2F0MzJBcnJheShzcmMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzcmMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgZGVzdFtpXSA9IHR4ICsgc3JjW2kgKyAxXSAqIHN4O1xuICAgICAgZGVzdFtpICsgMV0gPSB0eSArIHNyY1tpXSAqIHN5O1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuICBzdGF0aWMgX3RyYW5zbGF0ZShzcmMsIHR4LCB0eSwgZGVzdCkge1xuICAgIGRlc3QgfHw9IG5ldyBGbG9hdDMyQXJyYXkoc3JjLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3JjLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGRlc3RbaV0gPSB0eCArIHNyY1tpXTtcbiAgICAgIGRlc3RbaSArIDFdID0gdHkgKyBzcmNbaSArIDFdO1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuICBzdGF0aWMgc3ZnUm91bmQoeCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHggKiAxMDAwMCk7XG4gIH1cbiAgc3RhdGljIF9ub3JtYWxpemVQb2ludCh4LCB5LCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCByb3RhdGlvbikge1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbMSAtIHkgLyBwYXJlbnRXaWR0aCwgeCAvIHBhcmVudEhlaWdodF07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geCAvIHBhcmVudFdpZHRoLCAxIC0geSAvIHBhcmVudEhlaWdodF07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFt5IC8gcGFyZW50V2lkdGgsIDEgLSB4IC8gcGFyZW50SGVpZ2h0XTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbeCAvIHBhcmVudFdpZHRoLCB5IC8gcGFyZW50SGVpZ2h0XTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIF9ub3JtYWxpemVQYWdlUG9pbnQoeCwgeSwgcm90YXRpb24pIHtcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gWzEgLSB5LCB4XTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWzEgLSB4LCAxIC0geV07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFt5LCAxIC0geF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgY3JlYXRlQmV6aWVyUG9pbnRzKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICByZXR1cm4gWyh4MSArIDUgKiB4MikgLyA2LCAoeTEgKyA1ICogeTIpIC8gNiwgKDUgKiB4MiArIHgzKSAvIDYsICg1ICogeTIgKyB5MykgLyA2LCAoeDIgKyB4MykgLyAyLCAoeTIgKyB5MykgLyAyXTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvZHJhd2Vycy9mcmVlZHJhdy5qc1xuXG5cbmNsYXNzIEZyZWVEcmF3T3V0bGluZXIge1xuICAjYm94O1xuICAjYm90dG9tID0gW107XG4gICNpbm5lck1hcmdpbjtcbiAgI2lzTFRSO1xuICAjdG9wID0gW107XG4gICNsYXN0ID0gbmV3IEZsb2F0MzJBcnJheSgxOCk7XG4gICNsYXN0WDtcbiAgI2xhc3RZO1xuICAjbWluO1xuICAjbWluX2Rpc3Q7XG4gICNzY2FsZUZhY3RvcjtcbiAgI3RoaWNrbmVzcztcbiAgI3BvaW50cyA9IFtdO1xuICBzdGF0aWMgI01JTl9ESVNUID0gODtcbiAgc3RhdGljICNNSU5fRElGRiA9IDI7XG4gIHN0YXRpYyAjTUlOID0gRnJlZURyYXdPdXRsaW5lci4jTUlOX0RJU1QgKyBGcmVlRHJhd091dGxpbmVyLiNNSU5fRElGRjtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHgsXG4gICAgeVxuICB9LCBib3gsIHNjYWxlRmFjdG9yLCB0aGlja25lc3MsIGlzTFRSLCBpbm5lck1hcmdpbiA9IDApIHtcbiAgICB0aGlzLiNib3ggPSBib3g7XG4gICAgdGhpcy4jdGhpY2tuZXNzID0gdGhpY2tuZXNzICogc2NhbGVGYWN0b3I7XG4gICAgdGhpcy4jaXNMVFIgPSBpc0xUUjtcbiAgICB0aGlzLiNsYXN0LnNldChbTmFOLCBOYU4sIE5hTiwgTmFOLCB4LCB5XSwgNik7XG4gICAgdGhpcy4jaW5uZXJNYXJnaW4gPSBpbm5lck1hcmdpbjtcbiAgICB0aGlzLiNtaW5fZGlzdCA9IEZyZWVEcmF3T3V0bGluZXIuI01JTl9ESVNUICogc2NhbGVGYWN0b3I7XG4gICAgdGhpcy4jbWluID0gRnJlZURyYXdPdXRsaW5lci4jTUlOICogc2NhbGVGYWN0b3I7XG4gICAgdGhpcy4jc2NhbGVGYWN0b3IgPSBzY2FsZUZhY3RvcjtcbiAgICB0aGlzLiNwb2ludHMucHVzaCh4LCB5KTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiBpc05hTih0aGlzLiNsYXN0WzhdKTtcbiAgfVxuICAjZ2V0TGFzdENvb3JkcygpIHtcbiAgICBjb25zdCBsYXN0VG9wID0gdGhpcy4jbGFzdC5zdWJhcnJheSg0LCA2KTtcbiAgICBjb25zdCBsYXN0Qm90dG9tID0gdGhpcy4jbGFzdC5zdWJhcnJheSgxNiwgMTgpO1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICByZXR1cm4gWyh0aGlzLiNsYXN0WCArIChsYXN0VG9wWzBdIC0gbGFzdEJvdHRvbVswXSkgLyAyIC0geCkgLyB3aWR0aCwgKHRoaXMuI2xhc3RZICsgKGxhc3RUb3BbMV0gLSBsYXN0Qm90dG9tWzFdKSAvIDIgLSB5KSAvIGhlaWdodCwgKHRoaXMuI2xhc3RYICsgKGxhc3RCb3R0b21bMF0gLSBsYXN0VG9wWzBdKSAvIDIgLSB4KSAvIHdpZHRoLCAodGhpcy4jbGFzdFkgKyAobGFzdEJvdHRvbVsxXSAtIGxhc3RUb3BbMV0pIC8gMiAtIHkpIC8gaGVpZ2h0XTtcbiAgfVxuICBhZGQoe1xuICAgIHgsXG4gICAgeVxuICB9KSB7XG4gICAgdGhpcy4jbGFzdFggPSB4O1xuICAgIHRoaXMuI2xhc3RZID0geTtcbiAgICBjb25zdCBbbGF5ZXJYLCBsYXllclksIGxheWVyV2lkdGgsIGxheWVySGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICBsZXQgW3gxLCB5MSwgeDIsIHkyXSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoOCwgMTIpO1xuICAgIGNvbnN0IGRpZmZYID0geCAtIHgyO1xuICAgIGNvbnN0IGRpZmZZID0geSAtIHkyO1xuICAgIGNvbnN0IGQgPSBNYXRoLmh5cG90KGRpZmZYLCBkaWZmWSk7XG4gICAgaWYgKGQgPCB0aGlzLiNtaW4pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZGlmZkQgPSBkIC0gdGhpcy4jbWluX2Rpc3Q7XG4gICAgY29uc3QgSyA9IGRpZmZEIC8gZDtcbiAgICBjb25zdCBzaGlmdFggPSBLICogZGlmZlg7XG4gICAgY29uc3Qgc2hpZnRZID0gSyAqIGRpZmZZO1xuICAgIGxldCB4MCA9IHgxO1xuICAgIGxldCB5MCA9IHkxO1xuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgICB4MiArPSBzaGlmdFg7XG4gICAgeTIgKz0gc2hpZnRZO1xuICAgIHRoaXMuI3BvaW50cz8ucHVzaCh4LCB5KTtcbiAgICBjb25zdCBuWCA9IC1zaGlmdFkgLyBkaWZmRDtcbiAgICBjb25zdCBuWSA9IHNoaWZ0WCAvIGRpZmZEO1xuICAgIGNvbnN0IHRoWCA9IG5YICogdGhpcy4jdGhpY2tuZXNzO1xuICAgIGNvbnN0IHRoWSA9IG5ZICogdGhpcy4jdGhpY2tuZXNzO1xuICAgIHRoaXMuI2xhc3Quc2V0KHRoaXMuI2xhc3Quc3ViYXJyYXkoMiwgOCksIDApO1xuICAgIHRoaXMuI2xhc3Quc2V0KFt4MiArIHRoWCwgeTIgKyB0aFldLCA0KTtcbiAgICB0aGlzLiNsYXN0LnNldCh0aGlzLiNsYXN0LnN1YmFycmF5KDE0LCAxOCksIDEyKTtcbiAgICB0aGlzLiNsYXN0LnNldChbeDIgLSB0aFgsIHkyIC0gdGhZXSwgMTYpO1xuICAgIGlmIChpc05hTih0aGlzLiNsYXN0WzZdKSkge1xuICAgICAgaWYgKHRoaXMuI3RvcC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy4jbGFzdC5zZXQoW3gxICsgdGhYLCB5MSArIHRoWV0sIDIpO1xuICAgICAgICB0aGlzLiN0b3AucHVzaChOYU4sIE5hTiwgTmFOLCBOYU4sICh4MSArIHRoWCAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoeTEgKyB0aFkgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQpO1xuICAgICAgICB0aGlzLiNsYXN0LnNldChbeDEgLSB0aFgsIHkxIC0gdGhZXSwgMTQpO1xuICAgICAgICB0aGlzLiNib3R0b20ucHVzaChOYU4sIE5hTiwgTmFOLCBOYU4sICh4MSAtIHRoWCAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoeTEgLSB0aFkgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQpO1xuICAgICAgfVxuICAgICAgdGhpcy4jbGFzdC5zZXQoW3gwLCB5MCwgeDEsIHkxLCB4MiwgeTJdLCA2KTtcbiAgICAgIHJldHVybiAhdGhpcy5pc0VtcHR5KCk7XG4gICAgfVxuICAgIHRoaXMuI2xhc3Quc2V0KFt4MCwgeTAsIHgxLCB5MSwgeDIsIHkyXSwgNik7XG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLmFicyhNYXRoLmF0YW4yKHkwIC0geTEsIHgwIC0geDEpIC0gTWF0aC5hdGFuMihzaGlmdFksIHNoaWZ0WCkpO1xuICAgIGlmIChhbmdsZSA8IE1hdGguUEkgLyAyKSB7XG4gICAgICBbeDEsIHkxLCB4MiwgeTJdID0gdGhpcy4jbGFzdC5zdWJhcnJheSgyLCA2KTtcbiAgICAgIHRoaXMuI3RvcC5wdXNoKE5hTiwgTmFOLCBOYU4sIE5hTiwgKCh4MSArIHgyKSAvIDIgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCh5MSArIHkyKSAvIDIgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQpO1xuICAgICAgW3gxLCB5MSwgeDAsIHkwXSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMTQsIDE4KTtcbiAgICAgIHRoaXMuI2JvdHRvbS5wdXNoKE5hTiwgTmFOLCBOYU4sIE5hTiwgKCh4MCArIHgxKSAvIDIgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCh5MCArIHkxKSAvIDIgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFt4MCwgeTAsIHgxLCB5MSwgeDIsIHkyXSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMCwgNik7XG4gICAgdGhpcy4jdG9wLnB1c2goKCh4MCArIDUgKiB4MSkgLyA2IC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoeTAgKyA1ICogeTEpIC8gNiAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgKCg1ICogeDEgKyB4MikgLyA2IC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoNSAqIHkxICsgeTIpIC8gNiAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgKCh4MSArIHgyKSAvIDIgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCh5MSArIHkyKSAvIDIgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQpO1xuICAgIFt4MiwgeTIsIHgxLCB5MSwgeDAsIHkwXSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMTIsIDE4KTtcbiAgICB0aGlzLiNib3R0b20ucHVzaCgoKHgwICsgNSAqIHgxKSAvIDYgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCh5MCArIDUgKiB5MSkgLyA2IC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCAoKDUgKiB4MSArIHgyKSAvIDYgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCg1ICogeTEgKyB5MikgLyA2IC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCAoKHgxICsgeDIpIC8gMiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKHkxICsgeTIpIC8gMiAtIGxheWVyWSkgLyBsYXllckhlaWdodCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdG9TVkdQYXRoKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGNvbnN0IHRvcCA9IHRoaXMuI3RvcDtcbiAgICBjb25zdCBib3R0b20gPSB0aGlzLiNib3R0b207XG4gICAgaWYgKGlzTmFOKHRoaXMuI2xhc3RbNl0pICYmICF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuI3RvU1ZHUGF0aFR3b1BvaW50cygpO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICBidWZmZXIucHVzaChgTSR7dG9wWzRdfSAke3RvcFs1XX1gKTtcbiAgICBmb3IgKGxldCBpID0gNjsgaSA8IHRvcC5sZW5ndGg7IGkgKz0gNikge1xuICAgICAgaWYgKGlzTmFOKHRvcFtpXSkpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goYEwke3RvcFtpICsgNF19ICR7dG9wW2kgKyA1XX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBDJHt0b3BbaV19ICR7dG9wW2kgKyAxXX0gJHt0b3BbaSArIDJdfSAke3RvcFtpICsgM119ICR7dG9wW2kgKyA0XX0gJHt0b3BbaSArIDVdfWApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiN0b1NWR1BhdGhFbmQoYnVmZmVyKTtcbiAgICBmb3IgKGxldCBpID0gYm90dG9tLmxlbmd0aCAtIDY7IGkgPj0gNjsgaSAtPSA2KSB7XG4gICAgICBpZiAoaXNOYU4oYm90dG9tW2ldKSkge1xuICAgICAgICBidWZmZXIucHVzaChgTCR7Ym90dG9tW2kgKyA0XX0gJHtib3R0b21baSArIDVdfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyLnB1c2goYEMke2JvdHRvbVtpXX0gJHtib3R0b21baSArIDFdfSAke2JvdHRvbVtpICsgMl19ICR7Ym90dG9tW2kgKyAzXX0gJHtib3R0b21baSArIDRdfSAke2JvdHRvbVtpICsgNV19YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3RvU1ZHUGF0aFN0YXJ0KGJ1ZmZlcik7XG4gICAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiIFwiKTtcbiAgfVxuICAjdG9TVkdQYXRoVHdvUG9pbnRzKCkge1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICBjb25zdCBbbGFzdFRvcFgsIGxhc3RUb3BZLCBsYXN0Qm90dG9tWCwgbGFzdEJvdHRvbVldID0gdGhpcy4jZ2V0TGFzdENvb3JkcygpO1xuICAgIHJldHVybiBgTSR7KHRoaXMuI2xhc3RbMl0gLSB4KSAvIHdpZHRofSAkeyh0aGlzLiNsYXN0WzNdIC0geSkgLyBoZWlnaHR9IEwkeyh0aGlzLiNsYXN0WzRdIC0geCkgLyB3aWR0aH0gJHsodGhpcy4jbGFzdFs1XSAtIHkpIC8gaGVpZ2h0fSBMJHtsYXN0VG9wWH0gJHtsYXN0VG9wWX0gTCR7bGFzdEJvdHRvbVh9ICR7bGFzdEJvdHRvbVl9IEwkeyh0aGlzLiNsYXN0WzE2XSAtIHgpIC8gd2lkdGh9ICR7KHRoaXMuI2xhc3RbMTddIC0geSkgLyBoZWlnaHR9IEwkeyh0aGlzLiNsYXN0WzE0XSAtIHgpIC8gd2lkdGh9ICR7KHRoaXMuI2xhc3RbMTVdIC0geSkgLyBoZWlnaHR9IFpgO1xuICB9XG4gICN0b1NWR1BhdGhTdGFydChidWZmZXIpIHtcbiAgICBjb25zdCBib3R0b20gPSB0aGlzLiNib3R0b207XG4gICAgYnVmZmVyLnB1c2goYEwke2JvdHRvbVs0XX0gJHtib3R0b21bNV19IFpgKTtcbiAgfVxuICAjdG9TVkdQYXRoRW5kKGJ1ZmZlcikge1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICBjb25zdCBsYXN0VG9wID0gdGhpcy4jbGFzdC5zdWJhcnJheSg0LCA2KTtcbiAgICBjb25zdCBsYXN0Qm90dG9tID0gdGhpcy4jbGFzdC5zdWJhcnJheSgxNiwgMTgpO1xuICAgIGNvbnN0IFtsYXN0VG9wWCwgbGFzdFRvcFksIGxhc3RCb3R0b21YLCBsYXN0Qm90dG9tWV0gPSB0aGlzLiNnZXRMYXN0Q29vcmRzKCk7XG4gICAgYnVmZmVyLnB1c2goYEwkeyhsYXN0VG9wWzBdIC0geCkgLyB3aWR0aH0gJHsobGFzdFRvcFsxXSAtIHkpIC8gaGVpZ2h0fSBMJHtsYXN0VG9wWH0gJHtsYXN0VG9wWX0gTCR7bGFzdEJvdHRvbVh9ICR7bGFzdEJvdHRvbVl9IEwkeyhsYXN0Qm90dG9tWzBdIC0geCkgLyB3aWR0aH0gJHsobGFzdEJvdHRvbVsxXSAtIHkpIC8gaGVpZ2h0fWApO1xuICB9XG4gIG5ld0ZyZWVEcmF3T3V0bGluZShvdXRsaW5lLCBwb2ludHMsIGJveCwgc2NhbGVGYWN0b3IsIGlubmVyTWFyZ2luLCBpc0xUUikge1xuICAgIHJldHVybiBuZXcgRnJlZURyYXdPdXRsaW5lKG91dGxpbmUsIHBvaW50cywgYm94LCBzY2FsZUZhY3RvciwgaW5uZXJNYXJnaW4sIGlzTFRSKTtcbiAgfVxuICBnZXRPdXRsaW5lcygpIHtcbiAgICBjb25zdCB0b3AgPSB0aGlzLiN0b3A7XG4gICAgY29uc3QgYm90dG9tID0gdGhpcy4jYm90dG9tO1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLiNsYXN0O1xuICAgIGNvbnN0IFtsYXllclgsIGxheWVyWSwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IHBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoKHRoaXMuI3BvaW50cz8ubGVuZ3RoID8/IDApICsgMik7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aCAtIDI7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBwb2ludHNbaV0gPSAodGhpcy4jcG9pbnRzW2ldIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGg7XG4gICAgICBwb2ludHNbaSArIDFdID0gKHRoaXMuI3BvaW50c1tpICsgMV0gLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQ7XG4gICAgfVxuICAgIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0gPSAodGhpcy4jbGFzdFggLSBsYXllclgpIC8gbGF5ZXJXaWR0aDtcbiAgICBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdID0gKHRoaXMuI2xhc3RZIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0O1xuICAgIGlmIChpc05hTihsYXN0WzZdKSAmJiAhdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLiNnZXRPdXRsaW5lVHdvUG9pbnRzKHBvaW50cyk7XG4gICAgfVxuICAgIGNvbnN0IG91dGxpbmUgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuI3RvcC5sZW5ndGggKyAyNCArIHRoaXMuI2JvdHRvbS5sZW5ndGgpO1xuICAgIGxldCBOID0gdG9wLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkgKz0gMikge1xuICAgICAgaWYgKGlzTmFOKHRvcFtpXSkpIHtcbiAgICAgICAgb3V0bGluZVtpXSA9IG91dGxpbmVbaSArIDFdID0gTmFOO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG91dGxpbmVbaV0gPSB0b3BbaV07XG4gICAgICBvdXRsaW5lW2kgKyAxXSA9IHRvcFtpICsgMV07XG4gICAgfVxuICAgIE4gPSB0aGlzLiNnZXRPdXRsaW5lRW5kKG91dGxpbmUsIE4pO1xuICAgIGZvciAobGV0IGkgPSBib3R0b20ubGVuZ3RoIC0gNjsgaSA+PSA2OyBpIC09IDYpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNjsgaiArPSAyKSB7XG4gICAgICAgIGlmIChpc05hTihib3R0b21baSArIGpdKSkge1xuICAgICAgICAgIG91dGxpbmVbTl0gPSBvdXRsaW5lW04gKyAxXSA9IE5hTjtcbiAgICAgICAgICBOICs9IDI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgb3V0bGluZVtOXSA9IGJvdHRvbVtpICsgal07XG4gICAgICAgIG91dGxpbmVbTiArIDFdID0gYm90dG9tW2kgKyBqICsgMV07XG4gICAgICAgIE4gKz0gMjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jZ2V0T3V0bGluZVN0YXJ0KG91dGxpbmUsIE4pO1xuICAgIHJldHVybiB0aGlzLm5ld0ZyZWVEcmF3T3V0bGluZShvdXRsaW5lLCBwb2ludHMsIHRoaXMuI2JveCwgdGhpcy4jc2NhbGVGYWN0b3IsIHRoaXMuI2lubmVyTWFyZ2luLCB0aGlzLiNpc0xUUik7XG4gIH1cbiAgI2dldE91dGxpbmVUd29Qb2ludHMocG9pbnRzKSB7XG4gICAgY29uc3QgbGFzdCA9IHRoaXMuI2xhc3Q7XG4gICAgY29uc3QgW2xheWVyWCwgbGF5ZXJZLCBsYXllcldpZHRoLCBsYXllckhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgY29uc3QgW2xhc3RUb3BYLCBsYXN0VG9wWSwgbGFzdEJvdHRvbVgsIGxhc3RCb3R0b21ZXSA9IHRoaXMuI2dldExhc3RDb29yZHMoKTtcbiAgICBjb25zdCBvdXRsaW5lID0gbmV3IEZsb2F0MzJBcnJheSgzNik7XG4gICAgb3V0bGluZS5zZXQoW05hTiwgTmFOLCBOYU4sIE5hTiwgKGxhc3RbMl0gLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKGxhc3RbM10gLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsIE5hTiwgTmFOLCBOYU4sIE5hTiwgKGxhc3RbNF0gLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKGxhc3RbNV0gLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsIE5hTiwgTmFOLCBOYU4sIE5hTiwgbGFzdFRvcFgsIGxhc3RUb3BZLCBOYU4sIE5hTiwgTmFOLCBOYU4sIGxhc3RCb3R0b21YLCBsYXN0Qm90dG9tWSwgTmFOLCBOYU4sIE5hTiwgTmFOLCAobGFzdFsxNl0gLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKGxhc3RbMTddIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCBOYU4sIE5hTiwgTmFOLCBOYU4sIChsYXN0WzE0XSAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAobGFzdFsxNV0gLSBsYXllclkpIC8gbGF5ZXJIZWlnaHRdLCAwKTtcbiAgICByZXR1cm4gdGhpcy5uZXdGcmVlRHJhd091dGxpbmUob3V0bGluZSwgcG9pbnRzLCB0aGlzLiNib3gsIHRoaXMuI3NjYWxlRmFjdG9yLCB0aGlzLiNpbm5lck1hcmdpbiwgdGhpcy4jaXNMVFIpO1xuICB9XG4gICNnZXRPdXRsaW5lU3RhcnQob3V0bGluZSwgcG9zKSB7XG4gICAgY29uc3QgYm90dG9tID0gdGhpcy4jYm90dG9tO1xuICAgIG91dGxpbmUuc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIGJvdHRvbVs0XSwgYm90dG9tWzVdXSwgcG9zKTtcbiAgICByZXR1cm4gcG9zICs9IDY7XG4gIH1cbiAgI2dldE91dGxpbmVFbmQob3V0bGluZSwgcG9zKSB7XG4gICAgY29uc3QgbGFzdFRvcCA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoNCwgNik7XG4gICAgY29uc3QgbGFzdEJvdHRvbSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMTYsIDE4KTtcbiAgICBjb25zdCBbbGF5ZXJYLCBsYXllclksIGxheWVyV2lkdGgsIGxheWVySGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICBjb25zdCBbbGFzdFRvcFgsIGxhc3RUb3BZLCBsYXN0Qm90dG9tWCwgbGFzdEJvdHRvbVldID0gdGhpcy4jZ2V0TGFzdENvb3JkcygpO1xuICAgIG91dGxpbmUuc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIChsYXN0VG9wWzBdIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsIChsYXN0VG9wWzFdIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCBOYU4sIE5hTiwgTmFOLCBOYU4sIGxhc3RUb3BYLCBsYXN0VG9wWSwgTmFOLCBOYU4sIE5hTiwgTmFOLCBsYXN0Qm90dG9tWCwgbGFzdEJvdHRvbVksIE5hTiwgTmFOLCBOYU4sIE5hTiwgKGxhc3RCb3R0b21bMF0gLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKGxhc3RCb3R0b21bMV0gLSBsYXllclkpIC8gbGF5ZXJIZWlnaHRdLCBwb3MpO1xuICAgIHJldHVybiBwb3MgKz0gMjQ7XG4gIH1cbn1cbmNsYXNzIEZyZWVEcmF3T3V0bGluZSBleHRlbmRzIE91dGxpbmUge1xuICAjYm94O1xuICAjYmJveCA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICNpbm5lck1hcmdpbjtcbiAgI2lzTFRSO1xuICAjcG9pbnRzO1xuICAjc2NhbGVGYWN0b3I7XG4gICNvdXRsaW5lO1xuICBjb25zdHJ1Y3RvcihvdXRsaW5lLCBwb2ludHMsIGJveCwgc2NhbGVGYWN0b3IsIGlubmVyTWFyZ2luLCBpc0xUUikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jb3V0bGluZSA9IG91dGxpbmU7XG4gICAgdGhpcy4jcG9pbnRzID0gcG9pbnRzO1xuICAgIHRoaXMuI2JveCA9IGJveDtcbiAgICB0aGlzLiNzY2FsZUZhY3RvciA9IHNjYWxlRmFjdG9yO1xuICAgIHRoaXMuI2lubmVyTWFyZ2luID0gaW5uZXJNYXJnaW47XG4gICAgdGhpcy4jaXNMVFIgPSBpc0xUUjtcbiAgICB0aGlzLmxhc3RQb2ludCA9IFtOYU4sIE5hTl07XG4gICAgdGhpcy4jY29tcHV0ZU1pbk1heChpc0xUUik7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYmJveDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBvdXRsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIG91dGxpbmVbaV0gPSAob3V0bGluZVtpXSAtIHgpIC8gd2lkdGg7XG4gICAgICBvdXRsaW5lW2kgKyAxXSA9IChvdXRsaW5lW2kgKyAxXSAtIHkpIC8gaGVpZ2h0O1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgcG9pbnRzW2ldID0gKHBvaW50c1tpXSAtIHgpIC8gd2lkdGg7XG4gICAgICBwb2ludHNbaSArIDFdID0gKHBvaW50c1tpICsgMV0gLSB5KSAvIGhlaWdodDtcbiAgICB9XG4gIH1cbiAgdG9TVkdQYXRoKCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IFtgTSR7dGhpcy4jb3V0bGluZVs0XX0gJHt0aGlzLiNvdXRsaW5lWzVdfWBdO1xuICAgIGZvciAobGV0IGkgPSA2LCBpaSA9IHRoaXMuI291dGxpbmUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNikge1xuICAgICAgaWYgKGlzTmFOKHRoaXMuI291dGxpbmVbaV0pKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBMJHt0aGlzLiNvdXRsaW5lW2kgKyA0XX0gJHt0aGlzLiNvdXRsaW5lW2kgKyA1XX1gKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBidWZmZXIucHVzaChgQyR7dGhpcy4jb3V0bGluZVtpXX0gJHt0aGlzLiNvdXRsaW5lW2kgKyAxXX0gJHt0aGlzLiNvdXRsaW5lW2kgKyAyXX0gJHt0aGlzLiNvdXRsaW5lW2kgKyAzXX0gJHt0aGlzLiNvdXRsaW5lW2kgKyA0XX0gJHt0aGlzLiNvdXRsaW5lW2kgKyA1XX1gKTtcbiAgICB9XG4gICAgYnVmZmVyLnB1c2goXCJaXCIpO1xuICAgIHJldHVybiBidWZmZXIuam9pbihcIiBcIik7XG4gIH1cbiAgc2VyaWFsaXplKFtibFgsIGJsWSwgdHJYLCB0clldLCByb3RhdGlvbikge1xuICAgIGNvbnN0IHdpZHRoID0gdHJYIC0gYmxYO1xuICAgIGNvbnN0IGhlaWdodCA9IHRyWSAtIGJsWTtcbiAgICBsZXQgb3V0bGluZTtcbiAgICBsZXQgcG9pbnRzO1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgb3V0bGluZSA9IE91dGxpbmUuX3Jlc2NhbGUodGhpcy4jb3V0bGluZSwgYmxYLCB0clksIHdpZHRoLCAtaGVpZ2h0KTtcbiAgICAgICAgcG9pbnRzID0gT3V0bGluZS5fcmVzY2FsZSh0aGlzLiNwb2ludHMsIGJsWCwgdHJZLCB3aWR0aCwgLWhlaWdodCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgb3V0bGluZSA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwKHRoaXMuI291dGxpbmUsIGJsWCwgYmxZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgcG9pbnRzID0gT3V0bGluZS5fcmVzY2FsZUFuZFN3YXAodGhpcy4jcG9pbnRzLCBibFgsIGJsWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIG91dGxpbmUgPSBPdXRsaW5lLl9yZXNjYWxlKHRoaXMuI291dGxpbmUsIHRyWCwgYmxZLCAtd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHBvaW50cyA9IE91dGxpbmUuX3Jlc2NhbGUodGhpcy4jcG9pbnRzLCB0clgsIGJsWSwgLXdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICBvdXRsaW5lID0gT3V0bGluZS5fcmVzY2FsZUFuZFN3YXAodGhpcy4jb3V0bGluZSwgdHJYLCB0clksIC13aWR0aCwgLWhlaWdodCk7XG4gICAgICAgIHBvaW50cyA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwKHRoaXMuI3BvaW50cywgdHJYLCB0clksIC13aWR0aCwgLWhlaWdodCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgb3V0bGluZTogQXJyYXkuZnJvbShvdXRsaW5lKSxcbiAgICAgIHBvaW50czogW0FycmF5LmZyb20ocG9pbnRzKV1cbiAgICB9O1xuICB9XG4gICNjb21wdXRlTWluTWF4KGlzTFRSKSB7XG4gICAgY29uc3Qgb3V0bGluZSA9IHRoaXMuI291dGxpbmU7XG4gICAgbGV0IGxhc3RYID0gb3V0bGluZVs0XTtcbiAgICBsZXQgbGFzdFkgPSBvdXRsaW5lWzVdO1xuICAgIGNvbnN0IG1pbk1heCA9IFtsYXN0WCwgbGFzdFksIGxhc3RYLCBsYXN0WV07XG4gICAgbGV0IGxhc3RQb2ludFggPSBsYXN0WDtcbiAgICBsZXQgbGFzdFBvaW50WSA9IGxhc3RZO1xuICAgIGNvbnN0IGx0ckNhbGxiYWNrID0gaXNMVFIgPyBNYXRoLm1heCA6IE1hdGgubWluO1xuICAgIGZvciAobGV0IGkgPSA2LCBpaSA9IG91dGxpbmUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNikge1xuICAgICAgY29uc3QgeCA9IG91dGxpbmVbaSArIDRdLFxuICAgICAgICB5ID0gb3V0bGluZVtpICsgNV07XG4gICAgICBpZiAoaXNOYU4ob3V0bGluZVtpXSkpIHtcbiAgICAgICAgVXRpbC5wb2ludEJvdW5kaW5nQm94KHgsIHksIG1pbk1heCk7XG4gICAgICAgIGlmIChsYXN0UG9pbnRZIDwgeSkge1xuICAgICAgICAgIGxhc3RQb2ludFggPSB4O1xuICAgICAgICAgIGxhc3RQb2ludFkgPSB5O1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RQb2ludFkgPT09IHkpIHtcbiAgICAgICAgICBsYXN0UG9pbnRYID0gbHRyQ2FsbGJhY2sobGFzdFBvaW50WCwgeCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJib3ggPSBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICAgIFV0aWwuYmV6aWVyQm91bmRpbmdCb3gobGFzdFgsIGxhc3RZLCAuLi5vdXRsaW5lLnNsaWNlKGksIGkgKyA2KSwgYmJveCk7XG4gICAgICAgIFV0aWwucmVjdEJvdW5kaW5nQm94KC4uLmJib3gsIG1pbk1heCk7XG4gICAgICAgIGlmIChsYXN0UG9pbnRZIDwgYmJveFszXSkge1xuICAgICAgICAgIGxhc3RQb2ludFggPSBiYm94WzJdO1xuICAgICAgICAgIGxhc3RQb2ludFkgPSBiYm94WzNdO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RQb2ludFkgPT09IGJib3hbM10pIHtcbiAgICAgICAgICBsYXN0UG9pbnRYID0gbHRyQ2FsbGJhY2sobGFzdFBvaW50WCwgYmJveFsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RYID0geDtcbiAgICAgIGxhc3RZID0geTtcbiAgICB9XG4gICAgY29uc3QgYmJveCA9IHRoaXMuI2Jib3g7XG4gICAgYmJveFswXSA9IG1pbk1heFswXSAtIHRoaXMuI2lubmVyTWFyZ2luO1xuICAgIGJib3hbMV0gPSBtaW5NYXhbMV0gLSB0aGlzLiNpbm5lck1hcmdpbjtcbiAgICBiYm94WzJdID0gbWluTWF4WzJdIC0gbWluTWF4WzBdICsgMiAqIHRoaXMuI2lubmVyTWFyZ2luO1xuICAgIGJib3hbM10gPSBtaW5NYXhbM10gLSBtaW5NYXhbMV0gKyAyICogdGhpcy4jaW5uZXJNYXJnaW47XG4gICAgdGhpcy5sYXN0UG9pbnQgPSBbbGFzdFBvaW50WCwgbGFzdFBvaW50WV07XG4gIH1cbiAgZ2V0IGJveCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYmJveDtcbiAgfVxuICBuZXdPdXRsaW5lcihwb2ludCwgYm94LCBzY2FsZUZhY3RvciwgdGhpY2tuZXNzLCBpc0xUUiwgaW5uZXJNYXJnaW4gPSAwKSB7XG4gICAgcmV0dXJuIG5ldyBGcmVlRHJhd091dGxpbmVyKHBvaW50LCBib3gsIHNjYWxlRmFjdG9yLCB0aGlja25lc3MsIGlzTFRSLCBpbm5lck1hcmdpbik7XG4gIH1cbiAgZ2V0TmV3T3V0bGluZSh0aGlja25lc3MsIGlubmVyTWFyZ2luKSB7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYmJveDtcbiAgICBjb25zdCBbbGF5ZXJYLCBsYXllclksIGxheWVyV2lkdGgsIGxheWVySGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICBjb25zdCBzeCA9IHdpZHRoICogbGF5ZXJXaWR0aDtcbiAgICBjb25zdCBzeSA9IGhlaWdodCAqIGxheWVySGVpZ2h0O1xuICAgIGNvbnN0IHR4ID0geCAqIGxheWVyV2lkdGggKyBsYXllclg7XG4gICAgY29uc3QgdHkgPSB5ICogbGF5ZXJIZWlnaHQgKyBsYXllclk7XG4gICAgY29uc3Qgb3V0bGluZXIgPSB0aGlzLm5ld091dGxpbmVyKHtcbiAgICAgIHg6IHRoaXMuI3BvaW50c1swXSAqIHN4ICsgdHgsXG4gICAgICB5OiB0aGlzLiNwb2ludHNbMV0gKiBzeSArIHR5XG4gICAgfSwgdGhpcy4jYm94LCB0aGlzLiNzY2FsZUZhY3RvciwgdGhpY2tuZXNzLCB0aGlzLiNpc0xUUiwgaW5uZXJNYXJnaW4gPz8gdGhpcy4jaW5uZXJNYXJnaW4pO1xuICAgIGZvciAobGV0IGkgPSAyOyBpIDwgdGhpcy4jcG9pbnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBvdXRsaW5lci5hZGQoe1xuICAgICAgICB4OiB0aGlzLiNwb2ludHNbaV0gKiBzeCArIHR4LFxuICAgICAgICB5OiB0aGlzLiNwb2ludHNbaSArIDFdICogc3kgKyB0eVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRsaW5lci5nZXRPdXRsaW5lcygpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9kcmF3ZXJzL2hpZ2hsaWdodC5qc1xuXG5cblxuY2xhc3MgSGlnaGxpZ2h0T3V0bGluZXIge1xuICAjYm94O1xuICAjbGFzdFBvaW50O1xuICAjdmVydGljYWxFZGdlcyA9IFtdO1xuICAjaW50ZXJ2YWxzID0gW107XG4gIGNvbnN0cnVjdG9yKGJveGVzLCBib3JkZXJXaWR0aCA9IDAsIGlubmVyTWFyZ2luID0gMCwgaXNMVFIgPSB0cnVlKSB7XG4gICAgY29uc3QgbWluTWF4ID0gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldO1xuICAgIGNvbnN0IE5VTUJFUl9PRl9ESUdJVFMgPSA0O1xuICAgIGNvbnN0IEVQU0lMT04gPSAxMCAqKiAtTlVNQkVSX09GX0RJR0lUUztcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9IG9mIGJveGVzKSB7XG4gICAgICBjb25zdCB4MSA9IE1hdGguZmxvb3IoKHggLSBib3JkZXJXaWR0aCkgLyBFUFNJTE9OKSAqIEVQU0lMT047XG4gICAgICBjb25zdCB4MiA9IE1hdGguY2VpbCgoeCArIHdpZHRoICsgYm9yZGVyV2lkdGgpIC8gRVBTSUxPTikgKiBFUFNJTE9OO1xuICAgICAgY29uc3QgeTEgPSBNYXRoLmZsb29yKCh5IC0gYm9yZGVyV2lkdGgpIC8gRVBTSUxPTikgKiBFUFNJTE9OO1xuICAgICAgY29uc3QgeTIgPSBNYXRoLmNlaWwoKHkgKyBoZWlnaHQgKyBib3JkZXJXaWR0aCkgLyBFUFNJTE9OKSAqIEVQU0lMT047XG4gICAgICBjb25zdCBsZWZ0ID0gW3gxLCB5MSwgeTIsIHRydWVdO1xuICAgICAgY29uc3QgcmlnaHQgPSBbeDIsIHkxLCB5MiwgZmFsc2VdO1xuICAgICAgdGhpcy4jdmVydGljYWxFZGdlcy5wdXNoKGxlZnQsIHJpZ2h0KTtcbiAgICAgIFV0aWwucmVjdEJvdW5kaW5nQm94KHgxLCB5MSwgeDIsIHkyLCBtaW5NYXgpO1xuICAgIH1cbiAgICBjb25zdCBiYm94V2lkdGggPSBtaW5NYXhbMl0gLSBtaW5NYXhbMF0gKyAyICogaW5uZXJNYXJnaW47XG4gICAgY29uc3QgYmJveEhlaWdodCA9IG1pbk1heFszXSAtIG1pbk1heFsxXSArIDIgKiBpbm5lck1hcmdpbjtcbiAgICBjb25zdCBzaGlmdGVkTWluWCA9IG1pbk1heFswXSAtIGlubmVyTWFyZ2luO1xuICAgIGNvbnN0IHNoaWZ0ZWRNaW5ZID0gbWluTWF4WzFdIC0gaW5uZXJNYXJnaW47XG4gICAgY29uc3QgbGFzdEVkZ2UgPSB0aGlzLiN2ZXJ0aWNhbEVkZ2VzLmF0KGlzTFRSID8gLTEgOiAtMik7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gW2xhc3RFZGdlWzBdLCBsYXN0RWRnZVsyXV07XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIHRoaXMuI3ZlcnRpY2FsRWRnZXMpIHtcbiAgICAgIGNvbnN0IFt4LCB5MSwgeTJdID0gZWRnZTtcbiAgICAgIGVkZ2VbMF0gPSAoeCAtIHNoaWZ0ZWRNaW5YKSAvIGJib3hXaWR0aDtcbiAgICAgIGVkZ2VbMV0gPSAoeTEgLSBzaGlmdGVkTWluWSkgLyBiYm94SGVpZ2h0O1xuICAgICAgZWRnZVsyXSA9ICh5MiAtIHNoaWZ0ZWRNaW5ZKSAvIGJib3hIZWlnaHQ7XG4gICAgfVxuICAgIHRoaXMuI2JveCA9IG5ldyBGbG9hdDMyQXJyYXkoW3NoaWZ0ZWRNaW5YLCBzaGlmdGVkTWluWSwgYmJveFdpZHRoLCBiYm94SGVpZ2h0XSk7XG4gICAgdGhpcy4jbGFzdFBvaW50ID0gbGFzdFBvaW50O1xuICB9XG4gIGdldE91dGxpbmVzKCkge1xuICAgIHRoaXMuI3ZlcnRpY2FsRWRnZXMuc29ydCgoYSwgYikgPT4gYVswXSAtIGJbMF0gfHwgYVsxXSAtIGJbMV0gfHwgYVsyXSAtIGJbMl0pO1xuICAgIGNvbnN0IG91dGxpbmVWZXJ0aWNhbEVkZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIHRoaXMuI3ZlcnRpY2FsRWRnZXMpIHtcbiAgICAgIGlmIChlZGdlWzNdKSB7XG4gICAgICAgIG91dGxpbmVWZXJ0aWNhbEVkZ2VzLnB1c2goLi4udGhpcy4jYnJlYWtFZGdlKGVkZ2UpKTtcbiAgICAgICAgdGhpcy4jaW5zZXJ0KGVkZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4jcmVtb3ZlKGVkZ2UpO1xuICAgICAgICBvdXRsaW5lVmVydGljYWxFZGdlcy5wdXNoKC4uLnRoaXMuI2JyZWFrRWRnZShlZGdlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNnZXRPdXRsaW5lcyhvdXRsaW5lVmVydGljYWxFZGdlcyk7XG4gIH1cbiAgI2dldE91dGxpbmVzKG91dGxpbmVWZXJ0aWNhbEVkZ2VzKSB7XG4gICAgY29uc3QgZWRnZXMgPSBbXTtcbiAgICBjb25zdCBhbGxFZGdlcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2Ygb3V0bGluZVZlcnRpY2FsRWRnZXMpIHtcbiAgICAgIGNvbnN0IFt4LCB5MSwgeTJdID0gZWRnZTtcbiAgICAgIGVkZ2VzLnB1c2goW3gsIHkxLCBlZGdlXSwgW3gsIHkyLCBlZGdlXSk7XG4gICAgfVxuICAgIGVkZ2VzLnNvcnQoKGEsIGIpID0+IGFbMV0gLSBiWzFdIHx8IGFbMF0gLSBiWzBdKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBlZGdlcy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBjb25zdCBlZGdlMSA9IGVkZ2VzW2ldWzJdO1xuICAgICAgY29uc3QgZWRnZTIgPSBlZGdlc1tpICsgMV1bMl07XG4gICAgICBlZGdlMS5wdXNoKGVkZ2UyKTtcbiAgICAgIGVkZ2UyLnB1c2goZWRnZTEpO1xuICAgICAgYWxsRWRnZXMuYWRkKGVkZ2UxKTtcbiAgICAgIGFsbEVkZ2VzLmFkZChlZGdlMik7XG4gICAgfVxuICAgIGNvbnN0IG91dGxpbmVzID0gW107XG4gICAgbGV0IG91dGxpbmU7XG4gICAgd2hpbGUgKGFsbEVkZ2VzLnNpemUgPiAwKSB7XG4gICAgICBjb25zdCBlZGdlID0gYWxsRWRnZXMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuICAgICAgbGV0IFt4LCB5MSwgeTIsIGVkZ2UxLCBlZGdlMl0gPSBlZGdlO1xuICAgICAgYWxsRWRnZXMuZGVsZXRlKGVkZ2UpO1xuICAgICAgbGV0IGxhc3RQb2ludFggPSB4O1xuICAgICAgbGV0IGxhc3RQb2ludFkgPSB5MTtcbiAgICAgIG91dGxpbmUgPSBbeCwgeTJdO1xuICAgICAgb3V0bGluZXMucHVzaChvdXRsaW5lKTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBlO1xuICAgICAgICBpZiAoYWxsRWRnZXMuaGFzKGVkZ2UxKSkge1xuICAgICAgICAgIGUgPSBlZGdlMTtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxFZGdlcy5oYXMoZWRnZTIpKSB7XG4gICAgICAgICAgZSA9IGVkZ2UyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGFsbEVkZ2VzLmRlbGV0ZShlKTtcbiAgICAgICAgW3gsIHkxLCB5MiwgZWRnZTEsIGVkZ2UyXSA9IGU7XG4gICAgICAgIGlmIChsYXN0UG9pbnRYICE9PSB4KSB7XG4gICAgICAgICAgb3V0bGluZS5wdXNoKGxhc3RQb2ludFgsIGxhc3RQb2ludFksIHgsIGxhc3RQb2ludFkgPT09IHkxID8geTEgOiB5Mik7XG4gICAgICAgICAgbGFzdFBvaW50WCA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBvaW50WSA9IGxhc3RQb2ludFkgPT09IHkxID8geTIgOiB5MTtcbiAgICAgIH1cbiAgICAgIG91dGxpbmUucHVzaChsYXN0UG9pbnRYLCBsYXN0UG9pbnRZKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBIaWdobGlnaHRPdXRsaW5lKG91dGxpbmVzLCB0aGlzLiNib3gsIHRoaXMuI2xhc3RQb2ludCk7XG4gIH1cbiAgI2JpbmFyeVNlYXJjaCh5KSB7XG4gICAgY29uc3QgYXJyYXkgPSB0aGlzLiNpbnRlcnZhbHM7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgICBjb25zdCBtaWRkbGUgPSBzdGFydCArIGVuZCA+PiAxO1xuICAgICAgY29uc3QgeTEgPSBhcnJheVttaWRkbGVdWzBdO1xuICAgICAgaWYgKHkxID09PSB5KSB7XG4gICAgICAgIHJldHVybiBtaWRkbGU7XG4gICAgICB9XG4gICAgICBpZiAoeTEgPCB5KSB7XG4gICAgICAgIHN0YXJ0ID0gbWlkZGxlICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IG1pZGRsZSAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbmQgKyAxO1xuICB9XG4gICNpbnNlcnQoWywgeTEsIHkyXSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy4jYmluYXJ5U2VhcmNoKHkxKTtcbiAgICB0aGlzLiNpbnRlcnZhbHMuc3BsaWNlKGluZGV4LCAwLCBbeTEsIHkyXSk7XG4gIH1cbiAgI3JlbW92ZShbLCB5MSwgeTJdKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLiNiaW5hcnlTZWFyY2goeTEpO1xuICAgIGZvciAobGV0IGkgPSBpbmRleDsgaSA8IHRoaXMuI2ludGVydmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gdGhpcy4jaW50ZXJ2YWxzW2ldO1xuICAgICAgaWYgKHN0YXJ0ICE9PSB5MSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA9PT0geTEgJiYgZW5kID09PSB5Mikge1xuICAgICAgICB0aGlzLiNpbnRlcnZhbHMuc3BsaWNlKGksIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBpbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSB0aGlzLiNpbnRlcnZhbHNbaV07XG4gICAgICBpZiAoc3RhcnQgIT09IHkxKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ID09PSB5MSAmJiBlbmQgPT09IHkyKSB7XG4gICAgICAgIHRoaXMuI2ludGVydmFscy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI2JyZWFrRWRnZShlZGdlKSB7XG4gICAgY29uc3QgW3gsIHkxLCB5Ml0gPSBlZGdlO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbW3gsIHkxLCB5Ml1dO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy4jYmluYXJ5U2VhcmNoKHkyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IHRoaXMuI2ludGVydmFsc1tpXTtcbiAgICAgIGZvciAobGV0IGogPSAwLCBqaiA9IHJlc3VsdHMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICBjb25zdCBbLCB5MywgeTRdID0gcmVzdWx0c1tqXTtcbiAgICAgICAgaWYgKGVuZCA8PSB5MyB8fCB5NCA8PSBzdGFydCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5MyA+PSBzdGFydCkge1xuICAgICAgICAgIGlmICh5NCA+IGVuZCkge1xuICAgICAgICAgICAgcmVzdWx0c1tqXVsxXSA9IGVuZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGpqID09PSAxKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgamotLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0c1tqXVsyXSA9IHN0YXJ0O1xuICAgICAgICBpZiAoeTQgPiBlbmQpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goW3gsIGVuZCwgeTRdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxufVxuY2xhc3MgSGlnaGxpZ2h0T3V0bGluZSBleHRlbmRzIE91dGxpbmUge1xuICAjYm94O1xuICAjb3V0bGluZXM7XG4gIGNvbnN0cnVjdG9yKG91dGxpbmVzLCBib3gsIGxhc3RQb2ludCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jb3V0bGluZXMgPSBvdXRsaW5lcztcbiAgICB0aGlzLiNib3ggPSBib3g7XG4gICAgdGhpcy5sYXN0UG9pbnQgPSBsYXN0UG9pbnQ7XG4gIH1cbiAgdG9TVkdQYXRoKCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIGZvciAoY29uc3QgcG9seWdvbiBvZiB0aGlzLiNvdXRsaW5lcykge1xuICAgICAgbGV0IFtwcmV2WCwgcHJldlldID0gcG9seWdvbjtcbiAgICAgIGJ1ZmZlci5wdXNoKGBNJHtwcmV2WH0gJHtwcmV2WX1gKTtcbiAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgcG9seWdvbi5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBjb25zdCB4ID0gcG9seWdvbltpXTtcbiAgICAgICAgY29uc3QgeSA9IHBvbHlnb25baSArIDFdO1xuICAgICAgICBpZiAoeCA9PT0gcHJldlgpIHtcbiAgICAgICAgICBidWZmZXIucHVzaChgViR7eX1gKTtcbiAgICAgICAgICBwcmV2WSA9IHk7XG4gICAgICAgIH0gZWxzZSBpZiAoeSA9PT0gcHJldlkpIHtcbiAgICAgICAgICBidWZmZXIucHVzaChgSCR7eH1gKTtcbiAgICAgICAgICBwcmV2WCA9IHg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJ1ZmZlci5wdXNoKFwiWlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiIFwiKTtcbiAgfVxuICBzZXJpYWxpemUoW2JsWCwgYmxZLCB0clgsIHRyWV0sIF9yb3RhdGlvbikge1xuICAgIGNvbnN0IG91dGxpbmVzID0gW107XG4gICAgY29uc3Qgd2lkdGggPSB0clggLSBibFg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdHJZIC0gYmxZO1xuICAgIGZvciAoY29uc3Qgb3V0bGluZSBvZiB0aGlzLiNvdXRsaW5lcykge1xuICAgICAgY29uc3QgcG9pbnRzID0gbmV3IEFycmF5KG91dGxpbmUubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0bGluZS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBwb2ludHNbaV0gPSBibFggKyBvdXRsaW5lW2ldICogd2lkdGg7XG4gICAgICAgIHBvaW50c1tpICsgMV0gPSB0clkgLSBvdXRsaW5lW2kgKyAxXSAqIGhlaWdodDtcbiAgICAgIH1cbiAgICAgIG91dGxpbmVzLnB1c2gocG9pbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dGxpbmVzO1xuICB9XG4gIGdldCBib3goKSB7XG4gICAgcmV0dXJuIHRoaXMuI2JveDtcbiAgfVxuICBnZXQgY2xhc3NOYW1lc0Zvck91dGxpbmluZygpIHtcbiAgICByZXR1cm4gW1wiaGlnaGxpZ2h0T3V0bGluZVwiXTtcbiAgfVxufVxuY2xhc3MgRnJlZUhpZ2hsaWdodE91dGxpbmVyIGV4dGVuZHMgRnJlZURyYXdPdXRsaW5lciB7XG4gIG5ld0ZyZWVEcmF3T3V0bGluZShvdXRsaW5lLCBwb2ludHMsIGJveCwgc2NhbGVGYWN0b3IsIGlubmVyTWFyZ2luLCBpc0xUUikge1xuICAgIHJldHVybiBuZXcgRnJlZUhpZ2hsaWdodE91dGxpbmUob3V0bGluZSwgcG9pbnRzLCBib3gsIHNjYWxlRmFjdG9yLCBpbm5lck1hcmdpbiwgaXNMVFIpO1xuICB9XG59XG5jbGFzcyBGcmVlSGlnaGxpZ2h0T3V0bGluZSBleHRlbmRzIEZyZWVEcmF3T3V0bGluZSB7XG4gIG5ld091dGxpbmVyKHBvaW50LCBib3gsIHNjYWxlRmFjdG9yLCB0aGlja25lc3MsIGlzTFRSLCBpbm5lck1hcmdpbiA9IDApIHtcbiAgICByZXR1cm4gbmV3IEZyZWVIaWdobGlnaHRPdXRsaW5lcihwb2ludCwgYm94LCBzY2FsZUZhY3RvciwgdGhpY2tuZXNzLCBpc0xUUiwgaW5uZXJNYXJnaW4pO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9oaWdobGlnaHQuanNcblxuXG5cblxuXG5cblxuY2xhc3MgSGlnaGxpZ2h0RWRpdG9yIGV4dGVuZHMgQW5ub3RhdGlvbkVkaXRvciB7XG4gICNhbmNob3JOb2RlID0gbnVsbDtcbiAgI2FuY2hvck9mZnNldCA9IDA7XG4gICNib3hlcztcbiAgI2NsaXBQYXRoSWQgPSBudWxsO1xuICAjY29sb3JQaWNrZXIgPSBudWxsO1xuICAjZm9jdXNPdXRsaW5lcyA9IG51bGw7XG4gICNmb2N1c05vZGUgPSBudWxsO1xuICAjZm9jdXNPZmZzZXQgPSAwO1xuICAjaGlnaGxpZ2h0RGl2ID0gbnVsbDtcbiAgI2hpZ2hsaWdodE91dGxpbmVzID0gbnVsbDtcbiAgI2lkID0gbnVsbDtcbiAgI2lzRnJlZUhpZ2hsaWdodCA9IGZhbHNlO1xuICAjbGFzdFBvaW50ID0gbnVsbDtcbiAgI29wYWNpdHk7XG4gICNvdXRsaW5lSWQgPSBudWxsO1xuICAjdGV4dCA9IFwiXCI7XG4gICN0aGlja25lc3M7XG4gICNtZXRob2RPZkNyZWF0aW9uID0gXCJcIjtcbiAgc3RhdGljIF9kZWZhdWx0Q29sb3IgPSBudWxsO1xuICBzdGF0aWMgX2RlZmF1bHRPcGFjaXR5ID0gMTtcbiAgc3RhdGljIF9kZWZhdWx0VGhpY2tuZXNzID0gMTI7XG4gIHN0YXRpYyBfdHlwZSA9IFwiaGlnaGxpZ2h0XCI7XG4gIHN0YXRpYyBfZWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVDtcbiAgc3RhdGljIF9mcmVlSGlnaGxpZ2h0SWQgPSAtMTtcbiAgc3RhdGljIF9mcmVlSGlnaGxpZ2h0ID0gbnVsbDtcbiAgc3RhdGljIF9mcmVlSGlnaGxpZ2h0Q2xpcElkID0gXCJcIjtcbiAgc3RhdGljIGdldCBfa2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHByb3RvID0gSGlnaGxpZ2h0RWRpdG9yLnByb3RvdHlwZTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93TGVmdFwiXSwgcHJvdG8uX21vdmVDYXJldCwge1xuICAgICAgYXJnczogWzBdXG4gICAgfV0sIFtbXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIHByb3RvLl9tb3ZlQ2FyZXQsIHtcbiAgICAgIGFyZ3M6IFsxXVxuICAgIH1dLCBbW1wiQXJyb3dVcFwiLCBcIm1hYytBcnJvd1VwXCJdLCBwcm90by5fbW92ZUNhcmV0LCB7XG4gICAgICBhcmdzOiBbMl1cbiAgICB9XSwgW1tcIkFycm93RG93blwiLCBcIm1hYytBcnJvd0Rvd25cIl0sIHByb3RvLl9tb3ZlQ2FyZXQsIHtcbiAgICAgIGFyZ3M6IFszXVxuICAgIH1dXSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG5hbWU6IFwiaGlnaGxpZ2h0RWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLmNvbG9yID0gcGFyYW1zLmNvbG9yIHx8IEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdENvbG9yO1xuICAgIHRoaXMuI3RoaWNrbmVzcyA9IHBhcmFtcy50aGlja25lc3MgfHwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzO1xuICAgIHRoaXMuI29wYWNpdHkgPSBwYXJhbXMub3BhY2l0eSB8fCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRPcGFjaXR5O1xuICAgIHRoaXMuI2JveGVzID0gcGFyYW1zLmJveGVzIHx8IG51bGw7XG4gICAgdGhpcy4jbWV0aG9kT2ZDcmVhdGlvbiA9IHBhcmFtcy5tZXRob2RPZkNyZWF0aW9uIHx8IFwiXCI7XG4gICAgdGhpcy4jdGV4dCA9IHBhcmFtcy50ZXh0IHx8IFwiXCI7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICB0aGlzLmRlZmF1bHRMMTBuSWQgPSBcInBkZmpzLWVkaXRvci1oaWdobGlnaHQtZWRpdG9yXCI7XG4gICAgaWYgKHBhcmFtcy5oaWdobGlnaHRJZCA+IC0xKSB7XG4gICAgICB0aGlzLiNpc0ZyZWVIaWdobGlnaHQgPSB0cnVlO1xuICAgICAgdGhpcy4jY3JlYXRlRnJlZU91dGxpbmVzKHBhcmFtcyk7XG4gICAgICB0aGlzLiNhZGRUb0RyYXdMYXllcigpO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jYm94ZXMpIHtcbiAgICAgIHRoaXMuI2FuY2hvck5vZGUgPSBwYXJhbXMuYW5jaG9yTm9kZTtcbiAgICAgIHRoaXMuI2FuY2hvck9mZnNldCA9IHBhcmFtcy5hbmNob3JPZmZzZXQ7XG4gICAgICB0aGlzLiNmb2N1c05vZGUgPSBwYXJhbXMuZm9jdXNOb2RlO1xuICAgICAgdGhpcy4jZm9jdXNPZmZzZXQgPSBwYXJhbXMuZm9jdXNPZmZzZXQ7XG4gICAgICB0aGlzLiNjcmVhdGVPdXRsaW5lcygpO1xuICAgICAgdGhpcy4jYWRkVG9EcmF3TGF5ZXIoKTtcbiAgICAgIHRoaXMucm90YXRlKHRoaXMucm90YXRpb24pO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmExMXlBbGVydChcInBkZmpzLWVkaXRvci1oaWdobGlnaHQtYWRkZWQtYWxlcnRcIik7XG4gICAgfVxuICB9XG4gIGdldCB0ZWxlbWV0cnlJbml0aWFsRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWN0aW9uOiBcImFkZGVkXCIsXG4gICAgICB0eXBlOiB0aGlzLiNpc0ZyZWVIaWdobGlnaHQgPyBcImZyZWVfaGlnaGxpZ2h0XCIgOiBcImhpZ2hsaWdodFwiLFxuICAgICAgY29sb3I6IHRoaXMuX3VpTWFuYWdlci5nZXROb25IQ01Db2xvck5hbWUodGhpcy5jb2xvciksXG4gICAgICB0aGlja25lc3M6IHRoaXMuI3RoaWNrbmVzcyxcbiAgICAgIG1ldGhvZE9mQ3JlYXRpb246IHRoaXMuI21ldGhvZE9mQ3JlYXRpb25cbiAgICB9O1xuICB9XG4gIGdldCB0ZWxlbWV0cnlGaW5hbERhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaGlnaGxpZ2h0XCIsXG4gICAgICBjb2xvcjogdGhpcy5fdWlNYW5hZ2VyLmdldE5vbkhDTUNvbG9yTmFtZSh0aGlzLmNvbG9yKVxuICAgIH07XG4gIH1cbiAgZ2V0IGNvbW1lbnRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvcjtcbiAgfVxuICBzdGF0aWMgY29tcHV0ZVRlbGVtZXRyeUZpbmFsRGF0YShkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG51bWJlck9mQ29sb3JzOiBkYXRhLmdldChcImNvbG9yXCIpLnNpemVcbiAgICB9O1xuICB9XG4gICNjcmVhdGVPdXRsaW5lcygpIHtcbiAgICBjb25zdCBvdXRsaW5lciA9IG5ldyBIaWdobGlnaHRPdXRsaW5lcih0aGlzLiNib3hlcywgMC4wMDEpO1xuICAgIHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzID0gb3V0bGluZXIuZ2V0T3V0bGluZXMoKTtcbiAgICBbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XSA9IHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLmJveDtcbiAgICBjb25zdCBvdXRsaW5lckZvck91dGxpbmUgPSBuZXcgSGlnaGxpZ2h0T3V0bGluZXIodGhpcy4jYm94ZXMsIDAuMDAyNSwgMC4wMDEsIHRoaXMuX3VpTWFuYWdlci5kaXJlY3Rpb24gPT09IFwibHRyXCIpO1xuICAgIHRoaXMuI2ZvY3VzT3V0bGluZXMgPSBvdXRsaW5lckZvck91dGxpbmUuZ2V0T3V0bGluZXMoKTtcbiAgICBjb25zdCB7XG4gICAgICBsYXN0UG9pbnRcbiAgICB9ID0gdGhpcy4jZm9jdXNPdXRsaW5lcztcbiAgICB0aGlzLiNsYXN0UG9pbnQgPSBbKGxhc3RQb2ludFswXSAtIHRoaXMueCkgLyB0aGlzLndpZHRoLCAobGFzdFBvaW50WzFdIC0gdGhpcy55KSAvIHRoaXMuaGVpZ2h0XTtcbiAgfVxuICAjY3JlYXRlRnJlZU91dGxpbmVzKHtcbiAgICBoaWdobGlnaHRPdXRsaW5lcyxcbiAgICBoaWdobGlnaHRJZCxcbiAgICBjbGlwUGF0aElkXG4gIH0pIHtcbiAgICB0aGlzLiNoaWdobGlnaHRPdXRsaW5lcyA9IGhpZ2hsaWdodE91dGxpbmVzO1xuICAgIGNvbnN0IGV4dHJhVGhpY2tuZXNzID0gMS41O1xuICAgIHRoaXMuI2ZvY3VzT3V0bGluZXMgPSBoaWdobGlnaHRPdXRsaW5lcy5nZXROZXdPdXRsaW5lKHRoaXMuI3RoaWNrbmVzcyAvIDIgKyBleHRyYVRoaWNrbmVzcywgMC4wMDI1KTtcbiAgICBpZiAoaGlnaGxpZ2h0SWQgPj0gMCkge1xuICAgICAgdGhpcy4jaWQgPSBoaWdobGlnaHRJZDtcbiAgICAgIHRoaXMuI2NsaXBQYXRoSWQgPSBjbGlwUGF0aElkO1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLmZpbmFsaXplRHJhdyhoaWdobGlnaHRJZCwge1xuICAgICAgICBiYm94OiBoaWdobGlnaHRPdXRsaW5lcy5ib3gsXG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBkOiBoaWdobGlnaHRPdXRsaW5lcy50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuI291dGxpbmVJZCA9IHRoaXMucGFyZW50LmRyYXdMYXllci5kcmF3T3V0bGluZSh7XG4gICAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICAgIGhpZ2hsaWdodE91dGxpbmU6IHRydWUsXG4gICAgICAgICAgZnJlZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBiYm94OiB0aGlzLiNmb2N1c091dGxpbmVzLmJveCxcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IHRoaXMuI2ZvY3VzT3V0bGluZXMudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgY29uc3QgYW5nbGUgPSB0aGlzLnBhcmVudC52aWV3cG9ydC5yb3RhdGlvbjtcbiAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI2lkLCB7XG4gICAgICAgIGJib3g6IEhpZ2hsaWdodEVkaXRvci4jcm90YXRlQmJveCh0aGlzLiNoaWdobGlnaHRPdXRsaW5lcy5ib3gsIChhbmdsZSAtIHRoaXMucm90YXRpb24gKyAzNjApICUgMzYwKSxcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IGhpZ2hsaWdodE91dGxpbmVzLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICAgIGJib3g6IEhpZ2hsaWdodEVkaXRvci4jcm90YXRlQmJveCh0aGlzLiNmb2N1c091dGxpbmVzLmJveCwgYW5nbGUpLFxuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZDogdGhpcy4jZm9jdXNPdXRsaW5lcy50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gaGlnaGxpZ2h0T3V0bGluZXMuYm94O1xuICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgICAgICB0aGlzLnggPSB5O1xuICAgICAgICAgIHRoaXMueSA9IDEgLSB4O1xuICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHBhZ2VIZWlnaHQgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiBwYWdlV2lkdGggLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgdGhpcy54ID0gMSAtIHg7XG4gICAgICAgIHRoaXMueSA9IDEgLSB5O1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgICAgICAgdGhpcy54ID0gMSAtIHk7XG4gICAgICAgICAgdGhpcy55ID0geDtcbiAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGggKiBwYWdlSGVpZ2h0IC8gcGFnZVdpZHRoO1xuICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogcGFnZVdpZHRoIC8gcGFnZUhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBsYXN0UG9pbnRcbiAgICB9ID0gdGhpcy4jZm9jdXNPdXRsaW5lcztcbiAgICB0aGlzLiNsYXN0UG9pbnQgPSBbKGxhc3RQb2ludFswXSAtIHgpIC8gd2lkdGgsIChsYXN0UG9pbnRbMV0gLSB5KSAvIGhlaWdodF07XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5pbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcik7XG4gICAgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0Q29sb3IgfHw9IHVpTWFuYWdlci5oaWdobGlnaHRDb2xvcnM/LnZhbHVlcygpLm5leHQoKS52YWx1ZSB8fCBcIiNmZmYwNjZcIjtcbiAgfVxuICBzdGF0aWMgdXBkYXRlRGVmYXVsdFBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfQ09MT1I6XG4gICAgICAgIEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdENvbG9yID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfVEhJQ0tORVNTOlxuICAgICAgICBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRUaGlja25lc3MgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRyYW5zbGF0ZUluUGFnZSh4LCB5KSB7fVxuICBnZXQgdG9vbGJhclBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNsYXN0UG9pbnQ7XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9DT0xPUjpcbiAgICAgICAgdGhpcy4jdXBkYXRlQ29sb3IodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX1RISUNLTkVTUzpcbiAgICAgICAgdGhpcy4jdXBkYXRlVGhpY2tuZXNzKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfQ09MT1IsIEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdENvbG9yXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9USElDS05FU1MsIEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdFRoaWNrbmVzc11dO1xuICB9XG4gIGdldCBwcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0NPTE9SLCB0aGlzLmNvbG9yIHx8IEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdENvbG9yXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9USElDS05FU1MsIHRoaXMuI3RoaWNrbmVzcyB8fCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRUaGlja25lc3NdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0ZSRUUsIHRoaXMuI2lzRnJlZUhpZ2hsaWdodF1dO1xuICB9XG4gICN1cGRhdGVDb2xvcihjb2xvcikge1xuICAgIGNvbnN0IHNldENvbG9yQW5kT3BhY2l0eSA9IChjb2wsIG9wYSkgPT4ge1xuICAgICAgdGhpcy5jb2xvciA9IGNvbDtcbiAgICAgIHRoaXMuI29wYWNpdHkgPSBvcGE7XG4gICAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jaWQsIHtcbiAgICAgICAgcm9vdDoge1xuICAgICAgICAgIGZpbGw6IGNvbCxcbiAgICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiBvcGFcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLiNjb2xvclBpY2tlcj8udXBkYXRlQ29sb3IoY29sKTtcbiAgICB9O1xuICAgIGNvbnN0IHNhdmVkQ29sb3IgPSB0aGlzLmNvbG9yO1xuICAgIGNvbnN0IHNhdmVkT3BhY2l0eSA9IHRoaXMuI29wYWNpdHk7XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6IHNldENvbG9yQW5kT3BhY2l0eS5iaW5kKHRoaXMsIGNvbG9yLCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRPcGFjaXR5KSxcbiAgICAgIHVuZG86IHNldENvbG9yQW5kT3BhY2l0eS5iaW5kKHRoaXMsIHNhdmVkQ29sb3IsIHNhdmVkT3BhY2l0eSksXG4gICAgICBwb3N0OiB0aGlzLl91aU1hbmFnZXIudXBkYXRlVUkuYmluZCh0aGlzLl91aU1hbmFnZXIsIHRoaXMpLFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfQ09MT1IsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgYWN0aW9uOiBcImNvbG9yX2NoYW5nZWRcIixcbiAgICAgIGNvbG9yOiB0aGlzLl91aU1hbmFnZXIuZ2V0Tm9uSENNQ29sb3JOYW1lKGNvbG9yKVxuICAgIH0sIHRydWUpO1xuICB9XG4gICN1cGRhdGVUaGlja25lc3ModGhpY2tuZXNzKSB7XG4gICAgY29uc3Qgc2F2ZWRUaGlja25lc3MgPSB0aGlzLiN0aGlja25lc3M7XG4gICAgY29uc3Qgc2V0VGhpY2tuZXNzID0gdGggPT4ge1xuICAgICAgdGhpcy4jdGhpY2tuZXNzID0gdGg7XG4gICAgICB0aGlzLiNjaGFuZ2VUaGlja25lc3ModGgpO1xuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6IHNldFRoaWNrbmVzcy5iaW5kKHRoaXMsIHRoaWNrbmVzcyksXG4gICAgICB1bmRvOiBzZXRUaGlja25lc3MuYmluZCh0aGlzLCBzYXZlZFRoaWNrbmVzcyksXG4gICAgICBwb3N0OiB0aGlzLl91aU1hbmFnZXIudXBkYXRlVUkuYmluZCh0aGlzLl91aU1hbmFnZXIsIHRoaXMpLFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfVEhJQ0tORVNTLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgIGFjdGlvbjogXCJ0aGlja25lc3NfY2hhbmdlZFwiLFxuICAgICAgdGhpY2tuZXNzXG4gICAgfSwgdHJ1ZSk7XG4gIH1cbiAgZ2V0IHRvb2xiYXJCdXR0b25zKCkge1xuICAgIGlmICh0aGlzLl91aU1hbmFnZXIuaGlnaGxpZ2h0Q29sb3JzKSB7XG4gICAgICBjb25zdCBjb2xvclBpY2tlciA9IHRoaXMuI2NvbG9yUGlja2VyID0gbmV3IENvbG9yUGlja2VyKHtcbiAgICAgICAgZWRpdG9yOiB0aGlzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBbW1wiY29sb3JQaWNrZXJcIiwgY29sb3JQaWNrZXJdXTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnRvb2xiYXJCdXR0b25zO1xuICB9XG4gIGRpc2FibGVFZGl0aW5nKCkge1xuICAgIHN1cGVyLmRpc2FibGVFZGl0aW5nKCk7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsIHRydWUpO1xuICB9XG4gIGVuYWJsZUVkaXRpbmcoKSB7XG4gICAgc3VwZXIuZW5hYmxlRWRpdGluZygpO1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJkaXNhYmxlZFwiLCBmYWxzZSk7XG4gIH1cbiAgZml4QW5kU2V0UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHN1cGVyLmZpeEFuZFNldFBvc2l0aW9uKHRoaXMuI2dldFJvdGF0aW9uKCkpO1xuICB9XG4gIGdldEJhc2VUcmFuc2xhdGlvbigpIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG4gIGdldFJlY3QodHgsIHR5KSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldFJlY3QodHgsIHR5LCB0aGlzLiNnZXRSb3RhdGlvbigpKTtcbiAgfVxuICBvbmNlQWRkZWQoZm9jdXMpIHtcbiAgICBpZiAoIXRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkVW5kb2FibGVFZGl0b3IodGhpcyk7XG4gICAgfVxuICAgIGlmIChmb2N1cykge1xuICAgICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuI2NsZWFuRHJhd0xheWVyKCk7XG4gICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgIGFjdGlvbjogXCJkZWxldGVkXCJcbiAgICB9KTtcbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVidWlsZCgpO1xuICAgIGlmICh0aGlzLmRpdiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhZGRUb0RyYXdMYXllcigpO1xuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgc2V0UGFyZW50KHBhcmVudCkge1xuICAgIGxldCBtdXN0QmVTZWxlY3RlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnBhcmVudCAmJiAhcGFyZW50KSB7XG4gICAgICB0aGlzLiNjbGVhbkRyYXdMYXllcigpO1xuICAgIH0gZWxzZSBpZiAocGFyZW50KSB7XG4gICAgICB0aGlzLiNhZGRUb0RyYXdMYXllcihwYXJlbnQpO1xuICAgICAgbXVzdEJlU2VsZWN0ZWQgPSAhdGhpcy5wYXJlbnQgJiYgdGhpcy5kaXY/LmNsYXNzTGlzdC5jb250YWlucyhcInNlbGVjdGVkRWRpdG9yXCIpO1xuICAgIH1cbiAgICBzdXBlci5zZXRQYXJlbnQocGFyZW50KTtcbiAgICB0aGlzLnNob3codGhpcy5faXNWaXNpYmxlKTtcbiAgICBpZiAobXVzdEJlU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuc2VsZWN0KCk7XG4gICAgfVxuICB9XG4gICNjaGFuZ2VUaGlja25lc3ModGhpY2tuZXNzKSB7XG4gICAgaWYgKCF0aGlzLiNpc0ZyZWVIaWdobGlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY3JlYXRlRnJlZU91dGxpbmVzKHtcbiAgICAgIGhpZ2hsaWdodE91dGxpbmVzOiB0aGlzLiNoaWdobGlnaHRPdXRsaW5lcy5nZXROZXdPdXRsaW5lKHRoaWNrbmVzcyAvIDIpXG4gICAgfSk7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLnNldERpbXModGhpcy53aWR0aCAqIHBhcmVudFdpZHRoLCB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gIH1cbiAgI2NsZWFuRHJhd0xheWVyKCkge1xuICAgIGlmICh0aGlzLiNpZCA9PT0gbnVsbCB8fCAhdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnJlbW92ZSh0aGlzLiNpZCk7XG4gICAgdGhpcy4jaWQgPSBudWxsO1xuICAgIHRoaXMucGFyZW50LmRyYXdMYXllci5yZW1vdmUodGhpcy4jb3V0bGluZUlkKTtcbiAgICB0aGlzLiNvdXRsaW5lSWQgPSBudWxsO1xuICB9XG4gICNhZGRUb0RyYXdMYXllcihwYXJlbnQgPSB0aGlzLnBhcmVudCkge1xuICAgIGlmICh0aGlzLiNpZCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoe1xuICAgICAgaWQ6IHRoaXMuI2lkLFxuICAgICAgY2xpcFBhdGhJZDogdGhpcy4jY2xpcFBhdGhJZFxuICAgIH0gPSBwYXJlbnQuZHJhd0xheWVyLmRyYXcoe1xuICAgICAgYmJveDogdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMuYm94LFxuICAgICAgcm9vdDoge1xuICAgICAgICB2aWV3Qm94OiBcIjAgMCAxIDFcIixcbiAgICAgICAgZmlsbDogdGhpcy5jb2xvcixcbiAgICAgICAgXCJmaWxsLW9wYWNpdHlcIjogdGhpcy4jb3BhY2l0eVxuICAgICAgfSxcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBoaWdobGlnaHQ6IHRydWUsXG4gICAgICAgIGZyZWU6IHRoaXMuI2lzRnJlZUhpZ2hsaWdodFxuICAgICAgfSxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMudG9TVkdQYXRoKClcbiAgICAgIH1cbiAgICB9LCBmYWxzZSwgdHJ1ZSkpO1xuICAgIHRoaXMuI291dGxpbmVJZCA9IHBhcmVudC5kcmF3TGF5ZXIuZHJhd091dGxpbmUoe1xuICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgIGhpZ2hsaWdodE91dGxpbmU6IHRydWUsXG4gICAgICAgIGZyZWU6IHRoaXMuI2lzRnJlZUhpZ2hsaWdodFxuICAgICAgfSxcbiAgICAgIGJib3g6IHRoaXMuI2ZvY3VzT3V0bGluZXMuYm94LFxuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLiNmb2N1c091dGxpbmVzLnRvU1ZHUGF0aCgpXG4gICAgICB9XG4gICAgfSwgdGhpcy4jaXNGcmVlSGlnaGxpZ2h0KTtcbiAgICBpZiAodGhpcy4jaGlnaGxpZ2h0RGl2KSB7XG4gICAgICB0aGlzLiNoaWdobGlnaHREaXYuc3R5bGUuY2xpcFBhdGggPSB0aGlzLiNjbGlwUGF0aElkO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgI3JvdGF0ZUJib3goW3gsIHksIHdpZHRoLCBoZWlnaHRdLCBhbmdsZSkge1xuICAgIHN3aXRjaCAoYW5nbGUpIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbMSAtIHkgLSBoZWlnaHQsIHgsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbMSAtIHggLSB3aWR0aCwgMSAtIHkgLSBoZWlnaHQsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeSwgMSAtIHggLSB3aWR0aCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgfVxuICAgIHJldHVybiBbeCwgeSwgd2lkdGgsIGhlaWdodF07XG4gIH1cbiAgcm90YXRlKGFuZ2xlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZHJhd0xheWVyXG4gICAgfSA9IHRoaXMucGFyZW50O1xuICAgIGxldCBib3g7XG4gICAgaWYgKHRoaXMuI2lzRnJlZUhpZ2hsaWdodCkge1xuICAgICAgYW5nbGUgPSAoYW5nbGUgLSB0aGlzLnJvdGF0aW9uICsgMzYwKSAlIDM2MDtcbiAgICAgIGJveCA9IEhpZ2hsaWdodEVkaXRvci4jcm90YXRlQmJveCh0aGlzLiNoaWdobGlnaHRPdXRsaW5lcy5ib3gsIGFuZ2xlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm94ID0gSGlnaGxpZ2h0RWRpdG9yLiNyb3RhdGVCYm94KFt0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdLCBhbmdsZSk7XG4gICAgfVxuICAgIGRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI2lkLCB7XG4gICAgICBiYm94OiBib3gsXG4gICAgICByb290OiB7XG4gICAgICAgIFwiZGF0YS1tYWluLXJvdGF0aW9uXCI6IGFuZ2xlXG4gICAgICB9XG4gICAgfSk7XG4gICAgZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICBiYm94OiBIaWdobGlnaHRFZGl0b3IuI3JvdGF0ZUJib3godGhpcy4jZm9jdXNPdXRsaW5lcy5ib3gsIGFuZ2xlKSxcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgXCJkYXRhLW1haW4tcm90YXRpb25cIjogYW5nbGVcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfVxuICAgIGNvbnN0IGRpdiA9IHN1cGVyLnJlbmRlcigpO1xuICAgIGlmICh0aGlzLiN0ZXh0KSB7XG4gICAgICBkaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0aGlzLiN0ZXh0KTtcbiAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwibWFya1wiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2lzRnJlZUhpZ2hsaWdodCkge1xuICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoXCJmcmVlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNrZXlkb3duLmJpbmQodGhpcyksIHtcbiAgICAgICAgc2lnbmFsOiB0aGlzLl91aU1hbmFnZXIuX3NpZ25hbFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGhpZ2hsaWdodERpdiA9IHRoaXMuI2hpZ2hsaWdodERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LmFwcGVuZChoaWdobGlnaHREaXYpO1xuICAgIGhpZ2hsaWdodERpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgaGlnaGxpZ2h0RGl2LmNsYXNzTmFtZSA9IFwiaW50ZXJuYWxcIjtcbiAgICBoaWdobGlnaHREaXYuc3R5bGUuY2xpcFBhdGggPSB0aGlzLiNjbGlwUGF0aElkO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLnNldERpbXModGhpcy53aWR0aCAqIHBhcmVudFdpZHRoLCB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gICAgYmluZEV2ZW50cyh0aGlzLCB0aGlzLiNoaWdobGlnaHREaXYsIFtcInBvaW50ZXJvdmVyXCIsIFwicG9pbnRlcmxlYXZlXCJdKTtcbiAgICB0aGlzLmVuYWJsZUVkaXRpbmcoKTtcbiAgICByZXR1cm4gZGl2O1xuICB9XG4gIHBvaW50ZXJvdmVyKCkge1xuICAgIGlmICghdGhpcy5pc1NlbGVjdGVkKSB7XG4gICAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICAgIGhvdmVyZWQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHBvaW50ZXJsZWF2ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNTZWxlY3RlZCkge1xuICAgICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI291dGxpbmVJZCwge1xuICAgICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgICBob3ZlcmVkOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgI2tleWRvd24oZXZlbnQpIHtcbiAgICBIaWdobGlnaHRFZGl0b3IuX2tleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgfVxuICBfbW92ZUNhcmV0KGRpcmVjdGlvbikge1xuICAgIHRoaXMucGFyZW50LnVuc2VsZWN0KHRoaXMpO1xuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHRoaXMuI3NldENhcmV0KHRydWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgdGhpcy4jc2V0Q2FyZXQoZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgI3NldENhcmV0KHN0YXJ0KSB7XG4gICAgaWYgKCF0aGlzLiNhbmNob3JOb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHNlbGVjdGlvbi5zZXRQb3NpdGlvbih0aGlzLiNhbmNob3JOb2RlLCB0aGlzLiNhbmNob3JPZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3Rpb24uc2V0UG9zaXRpb24odGhpcy4jZm9jdXNOb2RlLCB0aGlzLiNmb2N1c09mZnNldCk7XG4gICAgfVxuICB9XG4gIHNlbGVjdCgpIHtcbiAgICBzdXBlci5zZWxlY3QoKTtcbiAgICBpZiAoIXRoaXMuI291dGxpbmVJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgaG92ZXJlZDogZmFsc2UsXG4gICAgICAgIHNlbGVjdGVkOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdW5zZWxlY3QoKSB7XG4gICAgc3VwZXIudW5zZWxlY3QoKTtcbiAgICBpZiAoIXRoaXMuI291dGxpbmVJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCF0aGlzLiNpc0ZyZWVIaWdobGlnaHQpIHtcbiAgICAgIHRoaXMuI3NldENhcmV0KGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgZ2V0IF9tdXN0Rml4UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLiNpc0ZyZWVIaWdobGlnaHQ7XG4gIH1cbiAgc2hvdyh2aXNpYmxlID0gdGhpcy5faXNWaXNpYmxlKSB7XG4gICAgc3VwZXIuc2hvdyh2aXNpYmxlKTtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI2lkLCB7XG4gICAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICAgIGhpZGRlbjogIXZpc2libGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNvdXRsaW5lSWQsIHtcbiAgICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgICAgaGlkZGVuOiAhdmlzaWJsZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgI2dldFJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNpc0ZyZWVIaWdobGlnaHQgPyB0aGlzLnJvdGF0aW9uIDogMDtcbiAgfVxuICAjc2VyaWFsaXplQm94ZXMoKSB7XG4gICAgaWYgKHRoaXMuI2lzRnJlZUhpZ2hsaWdodCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgIGNvbnN0IGJveGVzID0gdGhpcy4jYm94ZXM7XG4gICAgY29uc3QgcXVhZFBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoYm94ZXMubGVuZ3RoICogOCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gb2YgYm94ZXMpIHtcbiAgICAgIGNvbnN0IHN4ID0geCAqIHBhZ2VXaWR0aCArIHBhZ2VYO1xuICAgICAgY29uc3Qgc3kgPSAoMSAtIHkpICogcGFnZUhlaWdodCArIHBhZ2VZO1xuICAgICAgcXVhZFBvaW50c1tpXSA9IHF1YWRQb2ludHNbaSArIDRdID0gc3g7XG4gICAgICBxdWFkUG9pbnRzW2kgKyAxXSA9IHF1YWRQb2ludHNbaSArIDNdID0gc3k7XG4gICAgICBxdWFkUG9pbnRzW2kgKyAyXSA9IHF1YWRQb2ludHNbaSArIDZdID0gc3ggKyB3aWR0aCAqIHBhZ2VXaWR0aDtcbiAgICAgIHF1YWRQb2ludHNbaSArIDVdID0gcXVhZFBvaW50c1tpICsgN10gPSBzeSAtIGhlaWdodCAqIHBhZ2VIZWlnaHQ7XG4gICAgICBpICs9IDg7XG4gICAgfVxuICAgIHJldHVybiBxdWFkUG9pbnRzO1xuICB9XG4gICNzZXJpYWxpemVPdXRsaW5lcyhyZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLnNlcmlhbGl6ZShyZWN0LCB0aGlzLiNnZXRSb3RhdGlvbigpKTtcbiAgfVxuICBzdGF0aWMgc3RhcnRIaWdobGlnaHRpbmcocGFyZW50LCBpc0xUUiwge1xuICAgIHRhcmdldDogdGV4dExheWVyLFxuICAgIHgsXG4gICAgeVxuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgeDogbGF5ZXJYLFxuICAgICAgeTogbGF5ZXJZLFxuICAgICAgd2lkdGg6IHBhcmVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBwYXJlbnRIZWlnaHRcbiAgICB9ID0gdGV4dExheWVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHBhcmVudC5jb21iaW5lZFNpZ25hbChhYyk7XG4gICAgY29uc3QgcG9pbnRlclVwQ2FsbGJhY2sgPSBlID0+IHtcbiAgICAgIGFjLmFib3J0KCk7XG4gICAgICB0aGlzLiNlbmRIaWdobGlnaHQocGFyZW50LCBlKTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVyVXBDYWxsYmFjaywge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgc3RvcEV2ZW50LCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRleHRMYXllci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgdGhpcy4jaGlnaGxpZ2h0TW92ZS5iaW5kKHRoaXMsIHBhcmVudCksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuX2ZyZWVIaWdobGlnaHQgPSBuZXcgRnJlZUhpZ2hsaWdodE91dGxpbmVyKHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSwgW2xheWVyWCwgbGF5ZXJZLCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSwgcGFyZW50LnNjYWxlLCB0aGlzLl9kZWZhdWx0VGhpY2tuZXNzIC8gMiwgaXNMVFIsIDAuMDAxKTtcbiAgICAoe1xuICAgICAgaWQ6IHRoaXMuX2ZyZWVIaWdobGlnaHRJZCxcbiAgICAgIGNsaXBQYXRoSWQ6IHRoaXMuX2ZyZWVIaWdobGlnaHRDbGlwSWRcbiAgICB9ID0gcGFyZW50LmRyYXdMYXllci5kcmF3KHtcbiAgICAgIGJib3g6IFswLCAwLCAxLCAxXSxcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgdmlld0JveDogXCIwIDAgMSAxXCIsXG4gICAgICAgIGZpbGw6IHRoaXMuX2RlZmF1bHRDb2xvcixcbiAgICAgICAgXCJmaWxsLW9wYWNpdHlcIjogdGhpcy5fZGVmYXVsdE9wYWNpdHlcbiAgICAgIH0sXG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgaGlnaGxpZ2h0OiB0cnVlLFxuICAgICAgICBmcmVlOiB0cnVlXG4gICAgICB9LFxuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLl9mcmVlSGlnaGxpZ2h0LnRvU1ZHUGF0aCgpXG4gICAgICB9XG4gICAgfSwgdHJ1ZSwgdHJ1ZSkpO1xuICB9XG4gIHN0YXRpYyAjaGlnaGxpZ2h0TW92ZShwYXJlbnQsIGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX2ZyZWVIaWdobGlnaHQuYWRkKGV2ZW50KSkge1xuICAgICAgcGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2ZyZWVIaWdobGlnaHRJZCwge1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZDogdGhpcy5fZnJlZUhpZ2hsaWdodC50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgc3RhdGljICNlbmRIaWdobGlnaHQocGFyZW50LCBldmVudCkge1xuICAgIGlmICghdGhpcy5fZnJlZUhpZ2hsaWdodC5pc0VtcHR5KCkpIHtcbiAgICAgIHBhcmVudC5jcmVhdGVBbmRBZGROZXdFZGl0b3IoZXZlbnQsIGZhbHNlLCB7XG4gICAgICAgIGhpZ2hsaWdodElkOiB0aGlzLl9mcmVlSGlnaGxpZ2h0SWQsXG4gICAgICAgIGhpZ2hsaWdodE91dGxpbmVzOiB0aGlzLl9mcmVlSGlnaGxpZ2h0LmdldE91dGxpbmVzKCksXG4gICAgICAgIGNsaXBQYXRoSWQ6IHRoaXMuX2ZyZWVIaWdobGlnaHRDbGlwSWQsXG4gICAgICAgIG1ldGhvZE9mQ3JlYXRpb246IFwibWFpbl90b29sYmFyXCJcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnQuZHJhd0xheWVyLnJlbW92ZSh0aGlzLl9mcmVlSGlnaGxpZ2h0SWQpO1xuICAgIH1cbiAgICB0aGlzLl9mcmVlSGlnaGxpZ2h0SWQgPSAtMTtcbiAgICB0aGlzLl9mcmVlSGlnaGxpZ2h0ID0gbnVsbDtcbiAgICB0aGlzLl9mcmVlSGlnaGxpZ2h0Q2xpcElkID0gXCJcIjtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBsZXQgaW5pdGlhbERhdGEgPSBudWxsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHF1YWRQb2ludHMsXG4gICAgICAgICAgcmVjdCxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBjb2xvcixcbiAgICAgICAgICBvcGFjaXR5LFxuICAgICAgICAgIHBvcHVwUmVmLFxuICAgICAgICAgIGNvbnRlbnRzT2JqXG4gICAgICAgIH0sXG4gICAgICAgIHBhcmVudDoge1xuICAgICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgIHBhZ2VOdW1iZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgaW5pdGlhbERhdGEgPSBkYXRhID0ge1xuICAgICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hULFxuICAgICAgICBjb2xvcjogQXJyYXkuZnJvbShjb2xvciksXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIHF1YWRQb2ludHMsXG4gICAgICAgIGJveGVzOiBudWxsLFxuICAgICAgICBwYWdlSW5kZXg6IHBhZ2VOdW1iZXIgLSAxLFxuICAgICAgICByZWN0OiByZWN0LnNsaWNlKDApLFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgYW5ub3RhdGlvbkVsZW1lbnRJZDogaWQsXG4gICAgICAgIGlkLFxuICAgICAgICBkZWxldGVkOiBmYWxzZSxcbiAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgIGNvbW1lbnQ6IGNvbnRlbnRzT2JqPy5zdHIgfHwgbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBJbmtBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaW5rTGlzdHMsXG4gICAgICAgICAgcmVjdCxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBjb2xvcixcbiAgICAgICAgICBib3JkZXJTdHlsZToge1xuICAgICAgICAgICAgcmF3V2lkdGg6IHRoaWNrbmVzc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgICAgY29udGVudHNPYmpcbiAgICAgICAgfSxcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgcGFnZU51bWJlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpbml0aWFsRGF0YSA9IGRhdGEgPSB7XG4gICAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQsXG4gICAgICAgIGNvbG9yOiBBcnJheS5mcm9tKGNvbG9yKSxcbiAgICAgICAgdGhpY2tuZXNzLFxuICAgICAgICBpbmtMaXN0cyxcbiAgICAgICAgYm94ZXM6IG51bGwsXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZU51bWJlciAtIDEsXG4gICAgICAgIHJlY3Q6IHJlY3Quc2xpY2UoMCksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBhbm5vdGF0aW9uRWxlbWVudElkOiBpZCxcbiAgICAgICAgaWQsXG4gICAgICAgIGRlbGV0ZWQ6IGZhbHNlLFxuICAgICAgICBwb3B1cFJlZixcbiAgICAgICAgY29tbWVudDogY29udGVudHNPYmo/LnN0ciB8fCBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjb2xvcixcbiAgICAgIHF1YWRQb2ludHMsXG4gICAgICBpbmtMaXN0cyxcbiAgICAgIG9wYWNpdHlcbiAgICB9ID0gZGF0YTtcbiAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgZWRpdG9yLmNvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4uY29sb3IpO1xuICAgIGVkaXRvci4jb3BhY2l0eSA9IG9wYWNpdHkgfHwgMTtcbiAgICBpZiAoaW5rTGlzdHMpIHtcbiAgICAgIGVkaXRvci4jdGhpY2tuZXNzID0gZGF0YS50aGlja25lc3M7XG4gICAgfVxuICAgIGVkaXRvci5faW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICBpZiAoZGF0YS5jb21tZW50KSB7XG4gICAgICBlZGl0b3Iuc2V0Q29tbWVudERhdGEoZGF0YS5jb21tZW50KTtcbiAgICB9XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSBlZGl0b3IucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgW3BhZ2VYLCBwYWdlWV0gPSBlZGl0b3IucGFnZVRyYW5zbGF0aW9uO1xuICAgIGlmIChxdWFkUG9pbnRzKSB7XG4gICAgICBjb25zdCBib3hlcyA9IGVkaXRvci4jYm94ZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVhZFBvaW50cy5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgICBib3hlcy5wdXNoKHtcbiAgICAgICAgICB4OiAocXVhZFBvaW50c1tpXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aCxcbiAgICAgICAgICB5OiAxIC0gKHF1YWRQb2ludHNbaSArIDFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodCxcbiAgICAgICAgICB3aWR0aDogKHF1YWRQb2ludHNbaSArIDJdIC0gcXVhZFBvaW50c1tpXSkgLyBwYWdlV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiAocXVhZFBvaW50c1tpICsgMV0gLSBxdWFkUG9pbnRzW2kgKyA1XSkgLyBwYWdlSGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWRpdG9yLiNjcmVhdGVPdXRsaW5lcygpO1xuICAgICAgZWRpdG9yLiNhZGRUb0RyYXdMYXllcigpO1xuICAgICAgZWRpdG9yLnJvdGF0ZShlZGl0b3Iucm90YXRpb24pO1xuICAgIH0gZWxzZSBpZiAoaW5rTGlzdHMpIHtcbiAgICAgIGVkaXRvci4jaXNGcmVlSGlnaGxpZ2h0ID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHBvaW50cyA9IGlua0xpc3RzWzBdO1xuICAgICAgY29uc3QgcG9pbnQgPSB7XG4gICAgICAgIHg6IHBvaW50c1swXSAtIHBhZ2VYLFxuICAgICAgICB5OiBwYWdlSGVpZ2h0IC0gKHBvaW50c1sxXSAtIHBhZ2VZKVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG91dGxpbmVyID0gbmV3IEZyZWVIaWdobGlnaHRPdXRsaW5lcihwb2ludCwgWzAsIDAsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodF0sIDEsIGVkaXRvci4jdGhpY2tuZXNzIC8gMiwgdHJ1ZSwgMC4wMDEpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgcG9pbnQueCA9IHBvaW50c1tpXSAtIHBhZ2VYO1xuICAgICAgICBwb2ludC55ID0gcGFnZUhlaWdodCAtIChwb2ludHNbaSArIDFdIC0gcGFnZVkpO1xuICAgICAgICBvdXRsaW5lci5hZGQocG9pbnQpO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBpZCxcbiAgICAgICAgY2xpcFBhdGhJZFxuICAgICAgfSA9IHBhcmVudC5kcmF3TGF5ZXIuZHJhdyh7XG4gICAgICAgIGJib3g6IFswLCAwLCAxLCAxXSxcbiAgICAgICAgcm9vdDoge1xuICAgICAgICAgIHZpZXdCb3g6IFwiMCAwIDEgMVwiLFxuICAgICAgICAgIGZpbGw6IGVkaXRvci5jb2xvcixcbiAgICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiBlZGl0b3IuX2RlZmF1bHRPcGFjaXR5XG4gICAgICAgIH0sXG4gICAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICAgIGhpZ2hsaWdodDogdHJ1ZSxcbiAgICAgICAgICBmcmVlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBkOiBvdXRsaW5lci50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9LCB0cnVlLCB0cnVlKTtcbiAgICAgIGVkaXRvci4jY3JlYXRlRnJlZU91dGxpbmVzKHtcbiAgICAgICAgaGlnaGxpZ2h0T3V0bGluZXM6IG91dGxpbmVyLmdldE91dGxpbmVzKCksXG4gICAgICAgIGhpZ2hsaWdodElkOiBpZCxcbiAgICAgICAgY2xpcFBhdGhJZFxuICAgICAgfSk7XG4gICAgICBlZGl0b3IuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgICBlZGl0b3Iucm90YXRlKGVkaXRvci5wYXJlbnRSb3RhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpIHx8IGlzRm9yQ29weWluZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZURlbGV0ZWQoKTtcbiAgICB9XG4gICAgY29uc3QgcmVjdCA9IHRoaXMuZ2V0UERGUmVjdCgpO1xuICAgIGNvbnN0IGNvbG9yID0gQW5ub3RhdGlvbkVkaXRvci5fY29sb3JNYW5hZ2VyLmNvbnZlcnQodGhpcy5fdWlNYW5hZ2VyLmdldE5vbkhDTUNvbG9yKHRoaXMuY29sb3IpKTtcbiAgICBjb25zdCBzZXJpYWxpemVkID0ge1xuICAgICAgYW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCxcbiAgICAgIGNvbG9yLFxuICAgICAgb3BhY2l0eTogdGhpcy4jb3BhY2l0eSxcbiAgICAgIHRoaWNrbmVzczogdGhpcy4jdGhpY2tuZXNzLFxuICAgICAgcXVhZFBvaW50czogdGhpcy4jc2VyaWFsaXplQm94ZXMoKSxcbiAgICAgIG91dGxpbmVzOiB0aGlzLiNzZXJpYWxpemVPdXRsaW5lcyhyZWN0KSxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXgsXG4gICAgICByZWN0LFxuICAgICAgcm90YXRpb246IHRoaXMuI2dldFJvdGF0aW9uKCksXG4gICAgICBzdHJ1Y3RUcmVlUGFyZW50SWQ6IHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZFxuICAgIH07XG4gICAgdGhpcy5hZGRDb21tZW50KHNlcmlhbGl6ZWQpO1xuICAgIGlmICh0aGlzLmFubm90YXRpb25FbGVtZW50SWQgJiYgIXRoaXMuI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc2VyaWFsaXplZC5pZCA9IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgfVxuICAjaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbG9yXG4gICAgfSA9IHRoaXMuX2luaXRpYWxEYXRhO1xuICAgIHJldHVybiB0aGlzLmhhc0VkaXRlZENvbW1lbnQgfHwgc2VyaWFsaXplZC5jb2xvci5zb21lKChjLCBpKSA9PiBjICE9PSBjb2xvcltpXSk7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIGFubm90YXRpb24uaGlkZSgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UERGUmVjdCgpXG4gICAgfTtcbiAgICBpZiAodGhpcy5oYXNFZGl0ZWRDb21tZW50KSB7XG4gICAgICBwYXJhbXMucG9wdXAgPSB0aGlzLmNvbW1lbnQ7XG4gICAgfVxuICAgIGFubm90YXRpb24udXBkYXRlRWRpdGVkKHBhcmFtcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc3RhdGljIGNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvZHJhdy5qc1xuXG5cblxuY2xhc3MgRHJhd2luZ09wdGlvbnMge1xuICAjc3ZnUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHVwZGF0ZVByb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpc1tuYW1lXSA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlU1ZHUHJvcGVydHkobmFtZSwgdmFsdWUpO1xuICB9XG4gIHVwZGF0ZVByb3BlcnRpZXMocHJvcGVydGllcykge1xuICAgIGlmICghcHJvcGVydGllcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcGVydGllcykpIHtcbiAgICAgIGlmICghbmFtZS5zdGFydHNXaXRoKFwiX1wiKSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVByb3BlcnR5KG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdXBkYXRlU1ZHUHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLiNzdmdQcm9wZXJ0aWVzW25hbWVdID0gdmFsdWU7XG4gIH1cbiAgdG9TVkdQcm9wZXJ0aWVzKCkge1xuICAgIGNvbnN0IHJvb3QgPSB0aGlzLiNzdmdQcm9wZXJ0aWVzO1xuICAgIHRoaXMuI3N2Z1Byb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiB7XG4gICAgICByb290XG4gICAgfTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLiNzdmdQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICB1cGRhdGVBbGwob3B0aW9ucyA9IHRoaXMpIHtcbiAgICB0aGlzLnVwZGF0ZVByb3BlcnRpZXMob3B0aW9ucyk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgdW5yZWFjaGFibGUoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbn1cbmNsYXNzIERyYXdpbmdFZGl0b3IgZXh0ZW5kcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2RyYXdPdXRsaW5lcyA9IG51bGw7XG4gICNtdXN0QmVDb21taXR0ZWQ7XG4gIF9jb2xvclBpY2tlciA9IG51bGw7XG4gIF9kcmF3SWQgPSBudWxsO1xuICBzdGF0aWMgX2N1cnJlbnREcmF3SWQgPSAtMTtcbiAgc3RhdGljIF9jdXJyZW50UGFyZW50ID0gbnVsbDtcbiAgc3RhdGljICNjdXJyZW50RHJhdyA9IG51bGw7XG4gIHN0YXRpYyAjY3VycmVudERyYXdpbmdBQyA9IG51bGw7XG4gIHN0YXRpYyAjY3VycmVudERyYXdpbmdPcHRpb25zID0gbnVsbDtcbiAgc3RhdGljICNjdXJyZW50UG9pbnRlcklkID0gTmFOO1xuICBzdGF0aWMgI2N1cnJlbnRQb2ludGVyVHlwZSA9IG51bGw7XG4gIHN0YXRpYyAjY3VycmVudFBvaW50ZXJJZHMgPSBudWxsO1xuICBzdGF0aWMgI2N1cnJlbnRNb3ZlVGltZXN0YW1wID0gTmFOO1xuICBzdGF0aWMgX0lOTkVSX01BUkdJTiA9IDM7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHBhcmFtcyk7XG4gICAgdGhpcy4jbXVzdEJlQ29tbWl0dGVkID0gcGFyYW1zLm11c3RCZUNvbW1pdHRlZCB8fCBmYWxzZTtcbiAgICB0aGlzLl9hZGRPdXRsaW5lcyhwYXJhbXMpO1xuICB9XG4gIF9hZGRPdXRsaW5lcyhwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zLmRyYXdPdXRsaW5lcykge1xuICAgICAgdGhpcy4jY3JlYXRlRHJhd091dGxpbmVzKHBhcmFtcyk7XG4gICAgICB0aGlzLiNhZGRUb0RyYXdMYXllcigpO1xuICAgIH1cbiAgfVxuICAjY3JlYXRlRHJhd091dGxpbmVzKHtcbiAgICBkcmF3T3V0bGluZXMsXG4gICAgZHJhd0lkLFxuICAgIGRyYXdpbmdPcHRpb25zXG4gIH0pIHtcbiAgICB0aGlzLiNkcmF3T3V0bGluZXMgPSBkcmF3T3V0bGluZXM7XG4gICAgdGhpcy5fZHJhd2luZ09wdGlvbnMgfHw9IGRyYXdpbmdPcHRpb25zO1xuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuYTExeUFsZXJ0KGBwZGZqcy1lZGl0b3ItJHt0aGlzLmVkaXRvclR5cGV9LWFkZGVkLWFsZXJ0YCk7XG4gICAgfVxuICAgIGlmIChkcmF3SWQgPj0gMCkge1xuICAgICAgdGhpcy5fZHJhd0lkID0gZHJhd0lkO1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLmZpbmFsaXplRHJhdyhkcmF3SWQsIGRyYXdPdXRsaW5lcy5kZWZhdWx0UHJvcGVydGllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RyYXdJZCA9IHRoaXMuI2NyZWF0ZURyYXdpbmcoZHJhd091dGxpbmVzLCB0aGlzLnBhcmVudCk7XG4gICAgfVxuICAgIHRoaXMuI3VwZGF0ZUJib3goZHJhd091dGxpbmVzLmJveCk7XG4gIH1cbiAgI2NyZWF0ZURyYXdpbmcoZHJhd091dGxpbmVzLCBwYXJlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZFxuICAgIH0gPSBwYXJlbnQuZHJhd0xheWVyLmRyYXcoRHJhd2luZ0VkaXRvci5fbWVyZ2VTVkdQcm9wZXJ0aWVzKHRoaXMuX2RyYXdpbmdPcHRpb25zLnRvU1ZHUHJvcGVydGllcygpLCBkcmF3T3V0bGluZXMuZGVmYXVsdFNWR1Byb3BlcnRpZXMpLCBmYWxzZSwgZmFsc2UpO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICBzdGF0aWMgX21lcmdlU1ZHUHJvcGVydGllcyhwMSwgcDIpIHtcbiAgICBjb25zdCBwMUtleXMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHAxKSk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocDIpKSB7XG4gICAgICBpZiAocDFLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocDFba2V5XSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcDFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcDE7XG4gIH1cbiAgc3RhdGljIGdldERlZmF1bHREcmF3aW5nT3B0aW9ucyhfb3B0aW9ucykge1xuICAgIHVucmVhY2hhYmxlKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZXNNYXAoKSB7XG4gICAgdW5yZWFjaGFibGUoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgc3RhdGljIGdldCBpc0RyYXdlcigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgZ2V0IHN1cHBvcnRNdWx0aXBsZURyYXdpbmdzKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgdXBkYXRlRGVmYXVsdFBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IHRoaXMudHlwZXNNYXAuZ2V0KHR5cGUpO1xuICAgIGlmIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucy51cGRhdGVQcm9wZXJ0eShwcm9wZXJ0eU5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRQYXJlbnQpIHtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LnVwZGF0ZVByb3BlcnR5KHByb3BlcnR5TmFtZSwgdmFsdWUpO1xuICAgICAgdGhpcy5fY3VycmVudFBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9jdXJyZW50RHJhd0lkLCB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnMudG9TVkdQcm9wZXJ0aWVzKCkpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBjb25zdCBwcm9wZXJ0eU5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLnR5cGVzTWFwLmdldCh0eXBlKTtcbiAgICBpZiAocHJvcGVydHlOYW1lKSB7XG4gICAgICB0aGlzLl91cGRhdGVQcm9wZXJ0eSh0eXBlLCBwcm9wZXJ0eU5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBkZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBbXTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZGVmYXVsdERyYXdpbmdPcHRpb25zO1xuICAgIGZvciAoY29uc3QgW3R5cGUsIG5hbWVdIG9mIHRoaXMudHlwZXNNYXApIHtcbiAgICAgIHByb3BlcnRpZXMucHVzaChbdHlwZSwgb3B0aW9uc1tuYW1lXV0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcGVydGllcztcbiAgfVxuICBnZXQgcHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBbXTtcbiAgICBjb25zdCB7XG4gICAgICBfZHJhd2luZ09wdGlvbnNcbiAgICB9ID0gdGhpcztcbiAgICBmb3IgKGNvbnN0IFt0eXBlLCBuYW1lXSBvZiB0aGlzLmNvbnN0cnVjdG9yLnR5cGVzTWFwKSB7XG4gICAgICBwcm9wZXJ0aWVzLnB1c2goW3R5cGUsIF9kcmF3aW5nT3B0aW9uc1tuYW1lXV0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcGVydGllcztcbiAgfVxuICBfdXBkYXRlUHJvcGVydHkodHlwZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZHJhd2luZ09wdGlvbnM7XG4gICAgY29uc3Qgc2F2ZWRWYWx1ZSA9IG9wdGlvbnNbbmFtZV07XG4gICAgY29uc3Qgc2V0dGVyID0gdmFsID0+IHtcbiAgICAgIG9wdGlvbnMudXBkYXRlUHJvcGVydHkobmFtZSwgdmFsKTtcbiAgICAgIGNvbnN0IGJib3ggPSB0aGlzLiNkcmF3T3V0bGluZXMudXBkYXRlUHJvcGVydHkobmFtZSwgdmFsKTtcbiAgICAgIGlmIChiYm94KSB7XG4gICAgICAgIHRoaXMuI3VwZGF0ZUJib3goYmJveCk7XG4gICAgICB9XG4gICAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZHJhd0lkLCBvcHRpb25zLnRvU1ZHUHJvcGVydGllcygpKTtcbiAgICAgIGlmICh0eXBlID09PSB0aGlzLmNvbG9yVHlwZSkge1xuICAgICAgICB0aGlzLl9jb2xvclBpY2tlcj8udXBkYXRlKHZhbCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogc2V0dGVyLmJpbmQodGhpcywgdmFsdWUpLFxuICAgICAgdW5kbzogc2V0dGVyLmJpbmQodGhpcywgc2F2ZWRWYWx1ZSksXG4gICAgICBwb3N0OiB0aGlzLl91aU1hbmFnZXIudXBkYXRlVUkuYmluZCh0aGlzLl91aU1hbmFnZXIsIHRoaXMpLFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgX29uUmVzaXppbmcoKSB7XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2RyYXdJZCwgRHJhd2luZ0VkaXRvci5fbWVyZ2VTVkdQcm9wZXJ0aWVzKHRoaXMuI2RyYXdPdXRsaW5lcy5nZXRQYXRoUmVzaXppbmdTVkdQcm9wZXJ0aWVzKHRoaXMuI2NvbnZlcnRUb0RyYXdTcGFjZSgpKSwge1xuICAgICAgYmJveDogdGhpcy4jcm90YXRlQm94KClcbiAgICB9KSk7XG4gIH1cbiAgX29uUmVzaXplZCgpIHtcbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZHJhd0lkLCBEcmF3aW5nRWRpdG9yLl9tZXJnZVNWR1Byb3BlcnRpZXModGhpcy4jZHJhd091dGxpbmVzLmdldFBhdGhSZXNpemVkU1ZHUHJvcGVydGllcyh0aGlzLiNjb252ZXJ0VG9EcmF3U3BhY2UoKSksIHtcbiAgICAgIGJib3g6IHRoaXMuI3JvdGF0ZUJveCgpXG4gICAgfSkpO1xuICB9XG4gIF9vblRyYW5zbGF0aW5nKF94LCBfeSkge1xuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIHtcbiAgICAgIGJib3g6IHRoaXMuI3JvdGF0ZUJveCgpXG4gICAgfSk7XG4gIH1cbiAgX29uVHJhbnNsYXRlZCgpIHtcbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZHJhd0lkLCBEcmF3aW5nRWRpdG9yLl9tZXJnZVNWR1Byb3BlcnRpZXModGhpcy4jZHJhd091dGxpbmVzLmdldFBhdGhUcmFuc2xhdGVkU1ZHUHJvcGVydGllcyh0aGlzLiNjb252ZXJ0VG9EcmF3U3BhY2UoKSwgdGhpcy5wYXJlbnREaW1lbnNpb25zKSwge1xuICAgICAgYmJveDogdGhpcy4jcm90YXRlQm94KClcbiAgICB9KSk7XG4gIH1cbiAgX29uU3RhcnREcmFnZ2luZygpIHtcbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZHJhd0lkLCB7XG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgbW92aW5nOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX29uU3RvcERyYWdnaW5nKCkge1xuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIHtcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBtb3Zpbmc6IGZhbHNlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29tbWl0KCkge1xuICAgIHN1cGVyLmNvbW1pdCgpO1xuICAgIHRoaXMuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5kaXNhYmxlRWRpdGluZygpO1xuICB9XG4gIGRpc2FibGVFZGl0aW5nKCkge1xuICAgIHN1cGVyLmRpc2FibGVFZGl0aW5nKCk7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsIHRydWUpO1xuICB9XG4gIGVuYWJsZUVkaXRpbmcoKSB7XG4gICAgc3VwZXIuZW5hYmxlRWRpdGluZygpO1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJkaXNhYmxlZFwiLCBmYWxzZSk7XG4gIH1cbiAgZ2V0QmFzZVRyYW5zbGF0aW9uKCkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgZ2V0IGlzUmVzaXphYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIG9uY2VBZGRlZChmb2N1cykge1xuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGRVbmRvYWJsZUVkaXRvcih0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgIGlmICh0aGlzLiNtdXN0QmVDb21taXR0ZWQpIHtcbiAgICAgIHRoaXMuI211c3RCZUNvbW1pdHRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5jb21taXQoKTtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgICAgaWYgKGZvY3VzICYmIHRoaXMuaXNPblNjcmVlbikge1xuICAgICAgICB0aGlzLmRpdi5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy4jY2xlYW5EcmF3TGF5ZXIoKTtcbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVidWlsZCgpO1xuICAgIGlmICh0aGlzLmRpdiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhZGRUb0RyYXdMYXllcigpO1xuICAgIHRoaXMuI3VwZGF0ZUJib3godGhpcy4jZHJhd091dGxpbmVzLmJveCk7XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKHRoaXMpO1xuICAgIH1cbiAgfVxuICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgbGV0IG11c3RCZVNlbGVjdGVkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMucGFyZW50ICYmICFwYXJlbnQpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5yZW1vdmVTaG91bGRSZXNjYWxlKHRoaXMpO1xuICAgICAgdGhpcy4jY2xlYW5EcmF3TGF5ZXIoKTtcbiAgICB9IGVsc2UgaWYgKHBhcmVudCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmFkZFNob3VsZFJlc2NhbGUodGhpcyk7XG4gICAgICB0aGlzLiNhZGRUb0RyYXdMYXllcihwYXJlbnQpO1xuICAgICAgbXVzdEJlU2VsZWN0ZWQgPSAhdGhpcy5wYXJlbnQgJiYgdGhpcy5kaXY/LmNsYXNzTGlzdC5jb250YWlucyhcInNlbGVjdGVkRWRpdG9yXCIpO1xuICAgIH1cbiAgICBzdXBlci5zZXRQYXJlbnQocGFyZW50KTtcbiAgICBpZiAobXVzdEJlU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuc2VsZWN0KCk7XG4gICAgfVxuICB9XG4gICNjbGVhbkRyYXdMYXllcigpIHtcbiAgICBpZiAodGhpcy5fZHJhd0lkID09PSBudWxsIHx8ICF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIucmVtb3ZlKHRoaXMuX2RyYXdJZCk7XG4gICAgdGhpcy5fZHJhd0lkID0gbnVsbDtcbiAgICB0aGlzLl9kcmF3aW5nT3B0aW9ucy5yZXNldCgpO1xuICB9XG4gICNhZGRUb0RyYXdMYXllcihwYXJlbnQgPSB0aGlzLnBhcmVudCkge1xuICAgIGlmICh0aGlzLl9kcmF3SWQgIT09IG51bGwgJiYgdGhpcy5wYXJlbnQgPT09IHBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZHJhd0lkICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUGFyZW50KHRoaXMuX2RyYXdJZCwgcGFyZW50LmRyYXdMYXllcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RyYXdpbmdPcHRpb25zLnVwZGF0ZUFsbCgpO1xuICAgIHRoaXMuX2RyYXdJZCA9IHRoaXMuI2NyZWF0ZURyYXdpbmcodGhpcy4jZHJhd091dGxpbmVzLCBwYXJlbnQpO1xuICB9XG4gICNjb252ZXJ0VG9QYXJlbnRTcGFjZShbeCwgeSwgd2lkdGgsIGhlaWdodF0pIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXJlbnREaW1lbnNpb25zOiBbcFcsIHBIXSxcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IHRoaXM7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFt5LCAxIC0geCwgd2lkdGggKiAocEggLyBwVyksIGhlaWdodCAqIChwVyAvIHBIKV07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geCwgMSAtIHksIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbMSAtIHksIHgsIHdpZHRoICogKHBIIC8gcFcpLCBoZWlnaHQgKiAocFcgLyBwSCldO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4LCB5LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICB9XG4gIH1cbiAgI2NvbnZlcnRUb0RyYXdTcGFjZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcGFyZW50RGltZW5zaW9uczogW3BXLCBwSF0sXG4gICAgICByb3RhdGlvblxuICAgIH0gPSB0aGlzO1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbMSAtIHksIHgsIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyldO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbMSAtIHgsIDEgLSB5LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3ksIDEgLSB4LCB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbeCwgeSwgd2lkdGgsIGhlaWdodF07XG4gICAgfVxuICB9XG4gICN1cGRhdGVCYm94KGJib3gpIHtcbiAgICBbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XSA9IHRoaXMuI2NvbnZlcnRUb1BhcmVudFNwYWNlKGJib3gpO1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgdGhpcy5zZXREaW1zKHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgIH1cbiAgICB0aGlzLl9vblJlc2l6ZWQoKTtcbiAgfVxuICAjcm90YXRlQm94KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICByb3RhdGlvbixcbiAgICAgIHBhcmVudFJvdGF0aW9uLFxuICAgICAgcGFyZW50RGltZW5zaW9uczogW3BXLCBwSF1cbiAgICB9ID0gdGhpcztcbiAgICBzd2l0Y2ggKChyb3RhdGlvbiAqIDQgKyBwYXJlbnRSb3RhdGlvbikgLyA5MCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gWzEgLSB5IC0gaGVpZ2h0LCB4LCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIFsxIC0geCAtIHdpZHRoLCAxIC0geSAtIGhlaWdodCwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBbeSwgMSAtIHggLSB3aWR0aCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiBbeCwgeSAtIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyksIHdpZHRoICogKHBXIC8gcEgpXTtcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmV0dXJuIFsxIC0geSwgeCwgd2lkdGggKiAocFcgLyBwSCksIGhlaWdodCAqIChwSCAvIHBXKV07XG4gICAgICBjYXNlIDY6XG4gICAgICAgIHJldHVybiBbMSAtIHggLSBoZWlnaHQgKiAocEggLyBwVyksIDEgLSB5LCBoZWlnaHQgKiAocEggLyBwVyksIHdpZHRoICogKHBXIC8gcEgpXTtcbiAgICAgIGNhc2UgNzpcbiAgICAgICAgcmV0dXJuIFt5IC0gd2lkdGggKiAocFcgLyBwSCksIDEgLSB4IC0gaGVpZ2h0ICogKHBIIC8gcFcpLCB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpXTtcbiAgICAgIGNhc2UgODpcbiAgICAgICAgcmV0dXJuIFt4IC0gd2lkdGgsIHkgLSBoZWlnaHQsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSA5OlxuICAgICAgICByZXR1cm4gWzEgLSB5LCB4IC0gd2lkdGgsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgY2FzZSAxMDpcbiAgICAgICAgcmV0dXJuIFsxIC0geCwgMSAtIHksIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAxMTpcbiAgICAgICAgcmV0dXJuIFt5IC0gaGVpZ2h0LCAxIC0geCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBjYXNlIDEyOlxuICAgICAgICByZXR1cm4gW3ggLSBoZWlnaHQgKiAocEggLyBwVyksIHksIGhlaWdodCAqIChwSCAvIHBXKSwgd2lkdGggKiAocFcgLyBwSCldO1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgcmV0dXJuIFsxIC0geSAtIHdpZHRoICogKHBXIC8gcEgpLCB4IC0gaGVpZ2h0ICogKHBIIC8gcFcpLCB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpXTtcbiAgICAgIGNhc2UgMTQ6XG4gICAgICAgIHJldHVybiBbMSAtIHgsIDEgLSB5IC0gd2lkdGggKiAocFcgLyBwSCksIGhlaWdodCAqIChwSCAvIHBXKSwgd2lkdGggKiAocFcgLyBwSCldO1xuICAgICAgY2FzZSAxNTpcbiAgICAgICAgcmV0dXJuIFt5LCAxIC0geCwgd2lkdGggKiAocFcgLyBwSCksIGhlaWdodCAqIChwSCAvIHBXKV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW3gsIHksIHdpZHRoLCBoZWlnaHRdO1xuICAgIH1cbiAgfVxuICByb3RhdGUoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIERyYXdpbmdFZGl0b3IuX21lcmdlU1ZHUHJvcGVydGllcyh7XG4gICAgICBiYm94OiB0aGlzLiNyb3RhdGVCb3goKVxuICAgIH0sIHRoaXMuI2RyYXdPdXRsaW5lcy51cGRhdGVSb3RhdGlvbigodGhpcy5wYXJlbnRSb3RhdGlvbiAtIHRoaXMucm90YXRpb24gKyAzNjApICUgMzYwKSkpO1xuICB9XG4gIG9uU2NhbGVDaGFuZ2luZygpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3VwZGF0ZUJib3godGhpcy4jZHJhd091dGxpbmVzLnVwZGF0ZVBhcmVudERpbWVuc2lvbnModGhpcy5wYXJlbnREaW1lbnNpb25zLCB0aGlzLnBhcmVudC5zY2FsZSkpO1xuICB9XG4gIHN0YXRpYyBvblNjYWxlQ2hhbmdpbmdXaGVuRHJhd2luZygpIHt9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdjtcbiAgICB9XG4gICAgbGV0IGJhc2VYLCBiYXNlWTtcbiAgICBpZiAodGhpcy5faXNDb3B5KSB7XG4gICAgICBiYXNlWCA9IHRoaXMueDtcbiAgICAgIGJhc2VZID0gdGhpcy55O1xuICAgIH1cbiAgICBjb25zdCBkaXYgPSBzdXBlci5yZW5kZXIoKTtcbiAgICBkaXYuY2xhc3NMaXN0LmFkZChcImRyYXdcIik7XG4gICAgY29uc3QgZHJhd0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LmFwcGVuZChkcmF3RGl2KTtcbiAgICBkcmF3RGl2LnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICBkcmF3RGl2LmNsYXNzTmFtZSA9IFwiaW50ZXJuYWxcIjtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy5zZXREaW1zKHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgIHRoaXMuX3VpTWFuYWdlci5hZGRTaG91bGRSZXNjYWxlKHRoaXMpO1xuICAgIHRoaXMuZGlzYWJsZUVkaXRpbmcoKTtcbiAgICBpZiAodGhpcy5faXNDb3B5KSB7XG4gICAgICB0aGlzLl9tb3ZlQWZ0ZXJQYXN0ZShiYXNlWCwgYmFzZVkpO1xuICAgIH1cbiAgICByZXR1cm4gZGl2O1xuICB9XG4gIHN0YXRpYyBjcmVhdGVEcmF3ZXJJbnN0YW5jZShfeCwgX3ksIF9wYXJlbnRXaWR0aCwgX3BhcmVudEhlaWdodCwgX3JvdGF0aW9uKSB7XG4gICAgdW5yZWFjaGFibGUoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgc3RhdGljIHN0YXJ0RHJhd2luZyhwYXJlbnQsIHVpTWFuYWdlciwgX2lzTFRSLCBldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldCxcbiAgICAgIG9mZnNldFg6IHgsXG4gICAgICBvZmZzZXRZOiB5LFxuICAgICAgcG9pbnRlcklkLFxuICAgICAgcG9pbnRlclR5cGVcbiAgICB9ID0gZXZlbnQ7XG4gICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVyVHlwZSAmJiBEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlclR5cGUgIT09IHBvaW50ZXJUeXBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIHJvdGF0aW9uXG4gICAgICB9XG4gICAgfSA9IHBhcmVudDtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aDogcGFyZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IHBhcmVudEhlaWdodFxuICAgIH0gPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgYWMgPSBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhd2luZ0FDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHBhcmVudC5jb21iaW5lZFNpZ25hbChhYyk7XG4gICAgRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZCB8fD0gcG9pbnRlcklkO1xuICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVyVHlwZSA/Pz0gcG9pbnRlclR5cGU7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgZSA9PiB7XG4gICAgICBpZiAoRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQpIHtcbiAgICAgICAgdGhpcy5fZW5kRHJhdyhlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVySWRzPy5kZWxldGUoZS5wb2ludGVySWQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLCBlID0+IHtcbiAgICAgIGlmIChEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlcklkID09PSBlLnBvaW50ZXJJZCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50UGFyZW50LmVuZERyYXdpbmdTZXNzaW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlcklkcz8uZGVsZXRlKGUucG9pbnRlcklkKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGUgPT4ge1xuICAgICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVyVHlwZSAhPT0gZS5wb2ludGVyVHlwZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAoRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZHMgfHw9IG5ldyBTZXQoKSkuYWRkKGUucG9pbnRlcklkKTtcbiAgICAgIGlmIChEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdy5pc0NhbmNlbGxhYmxlKCkpIHtcbiAgICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcucmVtb3ZlTGFzdEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LmlzRW1wdHkoKSkge1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRQYXJlbnQuZW5kRHJhd2luZ1Nlc3Npb24odHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZW5kRHJhdyhudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLl9kcmF3TW92ZS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBlID0+IHtcbiAgICAgIGlmIChlLnRpbWVTdGFtcCA9PT0gRHJhd2luZ0VkaXRvci4jY3VycmVudE1vdmVUaW1lc3RhbXApIHtcbiAgICAgICAgc3RvcEV2ZW50KGUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHBhcmVudC50b2dnbGVEcmF3aW5nKCk7XG4gICAgdWlNYW5hZ2VyLl9lZGl0b3JVbmRvQmFyPy5oaWRlKCk7XG4gICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3KSB7XG4gICAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fY3VycmVudERyYXdJZCwgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcuc3RhcnROZXcoeCwgeSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgcm90YXRpb24pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdWlNYW5hZ2VyLnVwZGF0ZVVJRm9yRGVmYXVsdFByb3BlcnRpZXModGhpcyk7XG4gICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcgPSB0aGlzLmNyZWF0ZURyYXdlckluc3RhbmNlKHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uKTtcbiAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhd2luZ09wdGlvbnMgPSB0aGlzLmdldERlZmF1bHREcmF3aW5nT3B0aW9ucygpO1xuICAgIHRoaXMuX2N1cnJlbnRQYXJlbnQgPSBwYXJlbnQ7XG4gICAgKHtcbiAgICAgIGlkOiB0aGlzLl9jdXJyZW50RHJhd0lkXG4gICAgfSA9IHBhcmVudC5kcmF3TGF5ZXIuZHJhdyh0aGlzLl9tZXJnZVNWR1Byb3BlcnRpZXMoRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXdpbmdPcHRpb25zLnRvU1ZHUHJvcGVydGllcygpLCBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdy5kZWZhdWx0U1ZHUHJvcGVydGllcyksIHRydWUsIGZhbHNlKSk7XG4gIH1cbiAgc3RhdGljIF9kcmF3TW92ZShldmVudCkge1xuICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRNb3ZlVGltZXN0YW1wID0gLTE7XG4gICAgaWYgKCFEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WSxcbiAgICAgIHBvaW50ZXJJZFxuICAgIH0gPSBldmVudDtcbiAgICBpZiAoRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZCAhPT0gcG9pbnRlcklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlcklkcz8uc2l6ZSA+PSAxKSB7XG4gICAgICB0aGlzLl9lbmREcmF3KGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY3VycmVudFBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9jdXJyZW50RHJhd0lkLCBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdy5hZGQob2Zmc2V0WCwgb2Zmc2V0WSkpO1xuICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRNb3ZlVGltZXN0YW1wID0gZXZlbnQudGltZVN0YW1wO1xuICAgIHN0b3BFdmVudChldmVudCk7XG4gIH1cbiAgc3RhdGljIF9jbGVhbnVwKGFsbCkge1xuICAgIGlmIChhbGwpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnREcmF3SWQgPSAtMTtcbiAgICAgIHRoaXMuX2N1cnJlbnRQYXJlbnQgPSBudWxsO1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcgPSBudWxsO1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXdpbmdPcHRpb25zID0gbnVsbDtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVyVHlwZSA9IG51bGw7XG4gICAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50TW92ZVRpbWVzdGFtcCA9IE5hTjtcbiAgICB9XG4gICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3aW5nQUMpIHtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3aW5nQUMuYWJvcnQoKTtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3aW5nQUMgPSBudWxsO1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZCA9IE5hTjtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVySWRzID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhdGljIF9lbmREcmF3KGV2ZW50KSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fY3VycmVudFBhcmVudDtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwYXJlbnQudG9nZ2xlRHJhd2luZyh0cnVlKTtcbiAgICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbiAgICBpZiAoZXZlbnQ/LnRhcmdldCA9PT0gcGFyZW50LmRpdikge1xuICAgICAgcGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2N1cnJlbnREcmF3SWQsIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LmVuZChldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN1cHBvcnRNdWx0aXBsZURyYXdpbmdzKSB7XG4gICAgICBjb25zdCBkcmF3ID0gRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXc7XG4gICAgICBjb25zdCBkcmF3SWQgPSB0aGlzLl9jdXJyZW50RHJhd0lkO1xuICAgICAgY29uc3QgbGFzdEVsZW1lbnQgPSBkcmF3LmdldExhc3RFbGVtZW50KCk7XG4gICAgICBwYXJlbnQuYWRkQ29tbWFuZHMoe1xuICAgICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXMoZHJhd0lkLCBkcmF3LnNldExhc3RFbGVtZW50KGxhc3RFbGVtZW50KSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXMoZHJhd0lkLCBkcmF3LnJlbW92ZUxhc3RFbGVtZW50KCkpO1xuICAgICAgICB9LFxuICAgICAgICBtdXN0RXhlYzogZmFsc2UsXG4gICAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkRSQVdfU1RFUFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW5kRHJhd2luZyhmYWxzZSk7XG4gIH1cbiAgc3RhdGljIGVuZERyYXdpbmcoaXNBYm9ydGVkKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fY3VycmVudFBhcmVudDtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBhcmVudC50b2dnbGVEcmF3aW5nKHRydWUpO1xuICAgIHBhcmVudC5jbGVhblVuZG9TdGFjayhBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5EUkFXX1NURVApO1xuICAgIGlmICghRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcuaXNFbXB0eSgpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhZ2VEaW1lbnNpb25zOiBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSxcbiAgICAgICAgc2NhbGVcbiAgICAgIH0gPSBwYXJlbnQ7XG4gICAgICBjb25zdCBlZGl0b3IgPSBwYXJlbnQuY3JlYXRlQW5kQWRkTmV3RWRpdG9yKHtcbiAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgb2Zmc2V0WTogMFxuICAgICAgfSwgZmFsc2UsIHtcbiAgICAgICAgZHJhd0lkOiB0aGlzLl9jdXJyZW50RHJhd0lkLFxuICAgICAgICBkcmF3T3V0bGluZXM6IERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LmdldE91dGxpbmVzKHBhZ2VXaWR0aCAqIHNjYWxlLCBwYWdlSGVpZ2h0ICogc2NhbGUsIHNjYWxlLCB0aGlzLl9JTk5FUl9NQVJHSU4pLFxuICAgICAgICBkcmF3aW5nT3B0aW9uczogRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXdpbmdPcHRpb25zLFxuICAgICAgICBtdXN0QmVDb21taXR0ZWQ6ICFpc0Fib3J0ZWRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fY2xlYW51cCh0cnVlKTtcbiAgICAgIHJldHVybiBlZGl0b3I7XG4gICAgfVxuICAgIHBhcmVudC5kcmF3TGF5ZXIucmVtb3ZlKHRoaXMuX2N1cnJlbnREcmF3SWQpO1xuICAgIHRoaXMuX2NsZWFudXAodHJ1ZSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY3JlYXRlRHJhd2luZ09wdGlvbnMoX2RhdGEpIHt9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZURyYXcoX3BhZ2VYLCBfcGFnZVksIF9wYWdlV2lkdGgsIF9wYWdlSGVpZ2h0LCBfaW5uZXJXaWR0aCwgX2RhdGEpIHtcbiAgICB1bnJlYWNoYWJsZShcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICByYXdEaW1zOiB7XG4gICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgcGFnZVgsXG4gICAgICAgIHBhZ2VZXG4gICAgICB9XG4gICAgfSA9IHBhcmVudC52aWV3cG9ydDtcbiAgICBjb25zdCBkcmF3T3V0bGluZXMgPSB0aGlzLmRlc2VyaWFsaXplRHJhdyhwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgdGhpcy5fSU5ORVJfTUFSR0lOLCBkYXRhKTtcbiAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgZWRpdG9yLmNyZWF0ZURyYXdpbmdPcHRpb25zKGRhdGEpO1xuICAgIGVkaXRvci4jY3JlYXRlRHJhd091dGxpbmVzKHtcbiAgICAgIGRyYXdPdXRsaW5lc1xuICAgIH0pO1xuICAgIGVkaXRvci4jYWRkVG9EcmF3TGF5ZXIoKTtcbiAgICBlZGl0b3Iub25TY2FsZUNoYW5naW5nKCk7XG4gICAgZWRpdG9yLnJvdGF0ZSgpO1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplRHJhdyhpc0ZvckNvcHlpbmcpIHtcbiAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICByZXR1cm4gdGhpcy4jZHJhd091dGxpbmVzLnNlcmlhbGl6ZShbcGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdLCBpc0ZvckNvcHlpbmcpO1xuICB9XG4gIHJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBhbm5vdGF0aW9uLnVwZGF0ZUVkaXRlZCh7XG4gICAgICByZWN0OiB0aGlzLmdldFBERlJlY3QoKVxuICAgIH0pO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN0YXRpYyBjYW5DcmVhdGVOZXdFbXB0eUVkaXRvcigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2RyYXdlcnMvaW5rZHJhdy5qc1xuXG5cbmNsYXNzIElua0RyYXdPdXRsaW5lciB7XG4gICNsYXN0ID0gbmV3IEZsb2F0NjRBcnJheSg2KTtcbiAgI2xpbmU7XG4gICNsaW5lcztcbiAgI3JvdGF0aW9uO1xuICAjdGhpY2tuZXNzO1xuICAjcG9pbnRzO1xuICAjbGFzdFNWR1BhdGggPSBcIlwiO1xuICAjbGFzdEluZGV4ID0gMDtcbiAgI291dGxpbmVzID0gbmV3IElua0RyYXdPdXRsaW5lKCk7XG4gICNwYXJlbnRXaWR0aDtcbiAgI3BhcmVudEhlaWdodDtcbiAgY29uc3RydWN0b3IoeCwgeSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgcm90YXRpb24sIHRoaWNrbmVzcykge1xuICAgIHRoaXMuI3BhcmVudFdpZHRoID0gcGFyZW50V2lkdGg7XG4gICAgdGhpcy4jcGFyZW50SGVpZ2h0ID0gcGFyZW50SGVpZ2h0O1xuICAgIHRoaXMuI3JvdGF0aW9uID0gcm90YXRpb247XG4gICAgdGhpcy4jdGhpY2tuZXNzID0gdGhpY2tuZXNzO1xuICAgIFt4LCB5XSA9IHRoaXMuI25vcm1hbGl6ZVBvaW50KHgsIHkpO1xuICAgIGNvbnN0IGxpbmUgPSB0aGlzLiNsaW5lID0gW05hTiwgTmFOLCBOYU4sIE5hTiwgeCwgeV07XG4gICAgdGhpcy4jcG9pbnRzID0gW3gsIHldO1xuICAgIHRoaXMuI2xpbmVzID0gW3tcbiAgICAgIGxpbmUsXG4gICAgICBwb2ludHM6IHRoaXMuI3BvaW50c1xuICAgIH1dO1xuICAgIHRoaXMuI2xhc3Quc2V0KGxpbmUsIDApO1xuICB9XG4gIHVwZGF0ZVByb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKG5hbWUgPT09IFwic3Ryb2tlLXdpZHRoXCIpIHtcbiAgICAgIHRoaXMuI3RoaWNrbmVzcyA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICAjbm9ybWFsaXplUG9pbnQoeCwgeSkge1xuICAgIHJldHVybiBPdXRsaW5lLl9ub3JtYWxpemVQb2ludCh4LCB5LCB0aGlzLiNwYXJlbnRXaWR0aCwgdGhpcy4jcGFyZW50SGVpZ2h0LCB0aGlzLiNyb3RhdGlvbik7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gIXRoaXMuI2xpbmVzIHx8IHRoaXMuI2xpbmVzLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBpc0NhbmNlbGxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLiNwb2ludHMubGVuZ3RoIDw9IDEwO1xuICB9XG4gIGFkZCh4LCB5KSB7XG4gICAgW3gsIHldID0gdGhpcy4jbm9ybWFsaXplUG9pbnQoeCwgeSk7XG4gICAgY29uc3QgW3gxLCB5MSwgeDIsIHkyXSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMiwgNik7XG4gICAgY29uc3QgZGlmZlggPSB4IC0geDI7XG4gICAgY29uc3QgZGlmZlkgPSB5IC0geTI7XG4gICAgY29uc3QgZCA9IE1hdGguaHlwb3QodGhpcy4jcGFyZW50V2lkdGggKiBkaWZmWCwgdGhpcy4jcGFyZW50SGVpZ2h0ICogZGlmZlkpO1xuICAgIGlmIChkIDw9IDIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNwb2ludHMucHVzaCh4LCB5KTtcbiAgICBpZiAoaXNOYU4oeDEpKSB7XG4gICAgICB0aGlzLiNsYXN0LnNldChbeDIsIHkyLCB4LCB5XSwgMik7XG4gICAgICB0aGlzLiNsaW5lLnB1c2goTmFOLCBOYU4sIE5hTiwgTmFOLCB4LCB5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBkOiB0aGlzLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpc05hTih0aGlzLiNsYXN0WzBdKSkge1xuICAgICAgdGhpcy4jbGluZS5zcGxpY2UoNiwgNik7XG4gICAgfVxuICAgIHRoaXMuI2xhc3Quc2V0KFt4MSwgeTEsIHgyLCB5MiwgeCwgeV0sIDApO1xuICAgIHRoaXMuI2xpbmUucHVzaCguLi5PdXRsaW5lLmNyZWF0ZUJlemllclBvaW50cyh4MSwgeTEsIHgyLCB5MiwgeCwgeSkpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGVuZCh4LCB5KSB7XG4gICAgY29uc3QgY2hhbmdlID0gdGhpcy5hZGQoeCwgeSk7XG4gICAgaWYgKGNoYW5nZSkge1xuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3BvaW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBkOiB0aGlzLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN0YXJ0TmV3KHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uKSB7XG4gICAgdGhpcy4jcGFyZW50V2lkdGggPSBwYXJlbnRXaWR0aDtcbiAgICB0aGlzLiNwYXJlbnRIZWlnaHQgPSBwYXJlbnRIZWlnaHQ7XG4gICAgdGhpcy4jcm90YXRpb24gPSByb3RhdGlvbjtcbiAgICBbeCwgeV0gPSB0aGlzLiNub3JtYWxpemVQb2ludCh4LCB5KTtcbiAgICBjb25zdCBsaW5lID0gdGhpcy4jbGluZSA9IFtOYU4sIE5hTiwgTmFOLCBOYU4sIHgsIHldO1xuICAgIHRoaXMuI3BvaW50cyA9IFt4LCB5XTtcbiAgICBjb25zdCBsYXN0ID0gdGhpcy4jbGluZXMuYXQoLTEpO1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0LmxpbmUgPSBuZXcgRmxvYXQzMkFycmF5KGxhc3QubGluZSk7XG4gICAgICBsYXN0LnBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkobGFzdC5wb2ludHMpO1xuICAgIH1cbiAgICB0aGlzLiNsaW5lcy5wdXNoKHtcbiAgICAgIGxpbmUsXG4gICAgICBwb2ludHM6IHRoaXMuI3BvaW50c1xuICAgIH0pO1xuICAgIHRoaXMuI2xhc3Quc2V0KGxpbmUsIDApO1xuICAgIHRoaXMuI2xhc3RJbmRleCA9IDA7XG4gICAgdGhpcy50b1NWR1BhdGgoKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXRMYXN0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy4jbGluZXMuYXQoLTEpO1xuICB9XG4gIHNldExhc3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBpZiAoIXRoaXMuI2xpbmVzKSB7XG4gICAgICByZXR1cm4gdGhpcy4jb3V0bGluZXMuc2V0TGFzdEVsZW1lbnQoZWxlbWVudCk7XG4gICAgfVxuICAgIHRoaXMuI2xpbmVzLnB1c2goZWxlbWVudCk7XG4gICAgdGhpcy4jbGluZSA9IGVsZW1lbnQubGluZTtcbiAgICB0aGlzLiNwb2ludHMgPSBlbGVtZW50LnBvaW50cztcbiAgICB0aGlzLiNsYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJlbW92ZUxhc3RFbGVtZW50KCkge1xuICAgIGlmICghdGhpcy4jbGluZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLiNvdXRsaW5lcy5yZW1vdmVMYXN0RWxlbWVudCgpO1xuICAgIH1cbiAgICB0aGlzLiNsaW5lcy5wb3AoKTtcbiAgICB0aGlzLiNsYXN0U1ZHUGF0aCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdGhpcy4jbGluZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsaW5lLFxuICAgICAgICBwb2ludHNcbiAgICAgIH0gPSB0aGlzLiNsaW5lc1tpXTtcbiAgICAgIHRoaXMuI2xpbmUgPSBsaW5lO1xuICAgICAgdGhpcy4jcG9pbnRzID0gcG9pbnRzO1xuICAgICAgdGhpcy4jbGFzdEluZGV4ID0gMDtcbiAgICAgIHRoaXMudG9TVkdQYXRoKCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMuI2xhc3RTVkdQYXRoXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0b1NWR1BhdGgoKSB7XG4gICAgY29uc3QgZmlyc3RYID0gT3V0bGluZS5zdmdSb3VuZCh0aGlzLiNsaW5lWzRdKTtcbiAgICBjb25zdCBmaXJzdFkgPSBPdXRsaW5lLnN2Z1JvdW5kKHRoaXMuI2xpbmVbNV0pO1xuICAgIGlmICh0aGlzLiNwb2ludHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB0aGlzLiNsYXN0U1ZHUGF0aCA9IGAke3RoaXMuI2xhc3RTVkdQYXRofSBNICR7Zmlyc3RYfSAke2ZpcnN0WX0gWmA7XG4gICAgICByZXR1cm4gdGhpcy4jbGFzdFNWR1BhdGg7XG4gICAgfVxuICAgIGlmICh0aGlzLiNwb2ludHMubGVuZ3RoIDw9IDYpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLiNsYXN0U1ZHUGF0aC5sYXN0SW5kZXhPZihcIk1cIik7XG4gICAgICB0aGlzLiNsYXN0U1ZHUGF0aCA9IGAke3RoaXMuI2xhc3RTVkdQYXRoLnNsaWNlKDAsIGkpfSBNICR7Zmlyc3RYfSAke2ZpcnN0WX1gO1xuICAgICAgdGhpcy4jbGFzdEluZGV4ID0gNjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3BvaW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgIGNvbnN0IHNlY29uZFggPSBPdXRsaW5lLnN2Z1JvdW5kKHRoaXMuI2xpbmVbMTBdKTtcbiAgICAgIGNvbnN0IHNlY29uZFkgPSBPdXRsaW5lLnN2Z1JvdW5kKHRoaXMuI2xpbmVbMTFdKTtcbiAgICAgIHRoaXMuI2xhc3RTVkdQYXRoID0gYCR7dGhpcy4jbGFzdFNWR1BhdGh9IEwgJHtzZWNvbmRYfSAke3NlY29uZFl9YDtcbiAgICAgIHRoaXMuI2xhc3RJbmRleCA9IDEyO1xuICAgICAgcmV0dXJuIHRoaXMuI2xhc3RTVkdQYXRoO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICBpZiAodGhpcy4jbGFzdEluZGV4ID09PSAwKSB7XG4gICAgICBidWZmZXIucHVzaChgTSAke2ZpcnN0WH0gJHtmaXJzdFl9YCk7XG4gICAgICB0aGlzLiNsYXN0SW5kZXggPSA2O1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gdGhpcy4jbGFzdEluZGV4LCBpaSA9IHRoaXMuI2xpbmUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNikge1xuICAgICAgY29uc3QgW2MxeCwgYzF5LCBjMngsIGMyeSwgeCwgeV0gPSB0aGlzLiNsaW5lLnNsaWNlKGksIGkgKyA2KS5tYXAoT3V0bGluZS5zdmdSb3VuZCk7XG4gICAgICBidWZmZXIucHVzaChgQyR7YzF4fSAke2MxeX0gJHtjMnh9ICR7YzJ5fSAke3h9ICR7eX1gKTtcbiAgICB9XG4gICAgdGhpcy4jbGFzdFNWR1BhdGggKz0gYnVmZmVyLmpvaW4oXCIgXCIpO1xuICAgIHRoaXMuI2xhc3RJbmRleCA9IHRoaXMuI2xpbmUubGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLiNsYXN0U1ZHUGF0aDtcbiAgfVxuICBnZXRPdXRsaW5lcyhwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCBzY2FsZSwgaW5uZXJNYXJnaW4pIHtcbiAgICBjb25zdCBsYXN0ID0gdGhpcy4jbGluZXMuYXQoLTEpO1xuICAgIGxhc3QubGluZSA9IG5ldyBGbG9hdDMyQXJyYXkobGFzdC5saW5lKTtcbiAgICBsYXN0LnBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkobGFzdC5wb2ludHMpO1xuICAgIHRoaXMuI291dGxpbmVzLmJ1aWxkKHRoaXMuI2xpbmVzLCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCBzY2FsZSwgdGhpcy4jcm90YXRpb24sIHRoaXMuI3RoaWNrbmVzcywgaW5uZXJNYXJnaW4pO1xuICAgIHRoaXMuI2xhc3QgPSBudWxsO1xuICAgIHRoaXMuI2xpbmUgPSBudWxsO1xuICAgIHRoaXMuI2xpbmVzID0gbnVsbDtcbiAgICB0aGlzLiNsYXN0U1ZHUGF0aCA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXMuI291dGxpbmVzO1xuICB9XG4gIGdldCBkZWZhdWx0U1ZHUHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vdDoge1xuICAgICAgICB2aWV3Qm94OiBcIjAgMCAxMDAwMCAxMDAwMFwiXG4gICAgICB9LFxuICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgIGRyYXc6IHRydWVcbiAgICAgIH0sXG4gICAgICBiYm94OiBbMCwgMCwgMSwgMV1cbiAgICB9O1xuICB9XG59XG5jbGFzcyBJbmtEcmF3T3V0bGluZSBleHRlbmRzIE91dGxpbmUge1xuICAjYmJveDtcbiAgI2N1cnJlbnRSb3RhdGlvbiA9IDA7XG4gICNpbm5lck1hcmdpbjtcbiAgI2xpbmVzO1xuICAjcGFyZW50V2lkdGg7XG4gICNwYXJlbnRIZWlnaHQ7XG4gICNwYXJlbnRTY2FsZTtcbiAgI3JvdGF0aW9uO1xuICAjdGhpY2tuZXNzO1xuICBidWlsZChsaW5lcywgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgcGFyZW50U2NhbGUsIHJvdGF0aW9uLCB0aGlja25lc3MsIGlubmVyTWFyZ2luKSB7XG4gICAgdGhpcy4jcGFyZW50V2lkdGggPSBwYXJlbnRXaWR0aDtcbiAgICB0aGlzLiNwYXJlbnRIZWlnaHQgPSBwYXJlbnRIZWlnaHQ7XG4gICAgdGhpcy4jcGFyZW50U2NhbGUgPSBwYXJlbnRTY2FsZTtcbiAgICB0aGlzLiNyb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMuI3RoaWNrbmVzcyA9IHRoaWNrbmVzcztcbiAgICB0aGlzLiNpbm5lck1hcmdpbiA9IGlubmVyTWFyZ2luID8/IDA7XG4gICAgdGhpcy4jbGluZXMgPSBsaW5lcztcbiAgICB0aGlzLiNjb21wdXRlQmJveCgpO1xuICB9XG4gIGdldCB0aGlja25lc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3RoaWNrbmVzcztcbiAgfVxuICBzZXRMYXN0RWxlbWVudChlbGVtZW50KSB7XG4gICAgdGhpcy4jbGluZXMucHVzaChlbGVtZW50KTtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLnRvU1ZHUGF0aCgpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZW1vdmVMYXN0RWxlbWVudCgpIHtcbiAgICB0aGlzLiNsaW5lcy5wb3AoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLnRvU1ZHUGF0aCgpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0b1NWR1BhdGgoKSB7XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBsaW5lXG4gICAgfSBvZiB0aGlzLiNsaW5lcykge1xuICAgICAgYnVmZmVyLnB1c2goYE0ke091dGxpbmUuc3ZnUm91bmQobGluZVs0XSl9ICR7T3V0bGluZS5zdmdSb3VuZChsaW5lWzVdKX1gKTtcbiAgICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gNikge1xuICAgICAgICBidWZmZXIucHVzaChcIlpcIik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUubGVuZ3RoID09PSAxMiAmJiBpc05hTihsaW5lWzZdKSkge1xuICAgICAgICBidWZmZXIucHVzaChgTCR7T3V0bGluZS5zdmdSb3VuZChsaW5lWzEwXSl9ICR7T3V0bGluZS5zdmdSb3VuZChsaW5lWzExXSl9YCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDYsIGlpID0gbGluZS5sZW5ndGg7IGkgPCBpaTsgaSArPSA2KSB7XG4gICAgICAgIGNvbnN0IFtjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHldID0gbGluZS5zdWJhcnJheShpLCBpICsgNikubWFwKE91dGxpbmUuc3ZnUm91bmQpO1xuICAgICAgICBidWZmZXIucHVzaChgQyR7YzF4fSAke2MxeX0gJHtjMnh9ICR7YzJ5fSAke3h9ICR7eX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiXCIpO1xuICB9XG4gIHNlcmlhbGl6ZShbcGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdLCBpc0ZvckNvcHlpbmcpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkTGluZXMgPSBbXTtcbiAgICBjb25zdCBzZXJpYWxpemVkUG9pbnRzID0gW107XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jZ2V0QkJveFdpdGhOb01hcmdpbigpO1xuICAgIGxldCB0eCwgdHksIHN4LCBzeSwgeDEsIHkxLCB4MiwgeTIsIHJlc2NhbGVGbjtcbiAgICBzd2l0Y2ggKHRoaXMuI3JvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJlc2NhbGVGbiA9IE91dGxpbmUuX3Jlc2NhbGU7XG4gICAgICAgIHR4ID0gcGFnZVg7XG4gICAgICAgIHR5ID0gcGFnZVkgKyBwYWdlSGVpZ2h0O1xuICAgICAgICBzeCA9IHBhZ2VXaWR0aDtcbiAgICAgICAgc3kgPSAtcGFnZUhlaWdodDtcbiAgICAgICAgeDEgPSBwYWdlWCArIHggKiBwYWdlV2lkdGg7XG4gICAgICAgIHkxID0gcGFnZVkgKyAoMSAtIHkgLSBoZWlnaHQpICogcGFnZUhlaWdodDtcbiAgICAgICAgeDIgPSBwYWdlWCArICh4ICsgd2lkdGgpICogcGFnZVdpZHRoO1xuICAgICAgICB5MiA9IHBhZ2VZICsgKDEgLSB5KSAqIHBhZ2VIZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmVzY2FsZUZuID0gT3V0bGluZS5fcmVzY2FsZUFuZFN3YXA7XG4gICAgICAgIHR4ID0gcGFnZVg7XG4gICAgICAgIHR5ID0gcGFnZVk7XG4gICAgICAgIHN4ID0gcGFnZVdpZHRoO1xuICAgICAgICBzeSA9IHBhZ2VIZWlnaHQ7XG4gICAgICAgIHgxID0gcGFnZVggKyB5ICogcGFnZVdpZHRoO1xuICAgICAgICB5MSA9IHBhZ2VZICsgeCAqIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHgyID0gcGFnZVggKyAoeSArIGhlaWdodCkgKiBwYWdlV2lkdGg7XG4gICAgICAgIHkyID0gcGFnZVkgKyAoeCArIHdpZHRoKSAqIHBhZ2VIZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJlc2NhbGVGbiA9IE91dGxpbmUuX3Jlc2NhbGU7XG4gICAgICAgIHR4ID0gcGFnZVggKyBwYWdlV2lkdGg7XG4gICAgICAgIHR5ID0gcGFnZVk7XG4gICAgICAgIHN4ID0gLXBhZ2VXaWR0aDtcbiAgICAgICAgc3kgPSBwYWdlSGVpZ2h0O1xuICAgICAgICB4MSA9IHBhZ2VYICsgKDEgLSB4IC0gd2lkdGgpICogcGFnZVdpZHRoO1xuICAgICAgICB5MSA9IHBhZ2VZICsgeSAqIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHgyID0gcGFnZVggKyAoMSAtIHgpICogcGFnZVdpZHRoO1xuICAgICAgICB5MiA9IHBhZ2VZICsgKHkgKyBoZWlnaHQpICogcGFnZUhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmVzY2FsZUZuID0gT3V0bGluZS5fcmVzY2FsZUFuZFN3YXA7XG4gICAgICAgIHR4ID0gcGFnZVggKyBwYWdlV2lkdGg7XG4gICAgICAgIHR5ID0gcGFnZVkgKyBwYWdlSGVpZ2h0O1xuICAgICAgICBzeCA9IC1wYWdlV2lkdGg7XG4gICAgICAgIHN5ID0gLXBhZ2VIZWlnaHQ7XG4gICAgICAgIHgxID0gcGFnZVggKyAoMSAtIHkgLSBoZWlnaHQpICogcGFnZVdpZHRoO1xuICAgICAgICB5MSA9IHBhZ2VZICsgKDEgLSB4IC0gd2lkdGgpICogcGFnZUhlaWdodDtcbiAgICAgICAgeDIgPSBwYWdlWCArICgxIC0geSkgKiBwYWdlV2lkdGg7XG4gICAgICAgIHkyID0gcGFnZVkgKyAoMSAtIHgpICogcGFnZUhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAoY29uc3Qge1xuICAgICAgbGluZSxcbiAgICAgIHBvaW50c1xuICAgIH0gb2YgdGhpcy4jbGluZXMpIHtcbiAgICAgIHNlcmlhbGl6ZWRMaW5lcy5wdXNoKHJlc2NhbGVGbihsaW5lLCB0eCwgdHksIHN4LCBzeSwgaXNGb3JDb3B5aW5nID8gbmV3IEFycmF5KGxpbmUubGVuZ3RoKSA6IG51bGwpKTtcbiAgICAgIHNlcmlhbGl6ZWRQb2ludHMucHVzaChyZXNjYWxlRm4ocG9pbnRzLCB0eCwgdHksIHN4LCBzeSwgaXNGb3JDb3B5aW5nID8gbmV3IEFycmF5KHBvaW50cy5sZW5ndGgpIDogbnVsbCkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbGluZXM6IHNlcmlhbGl6ZWRMaW5lcyxcbiAgICAgIHBvaW50czogc2VyaWFsaXplZFBvaW50cyxcbiAgICAgIHJlY3Q6IFt4MSwgeTEsIHgyLCB5Ml1cbiAgICB9O1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgaW5uZXJNYXJnaW4sIHtcbiAgICBwYXRoczoge1xuICAgICAgbGluZXMsXG4gICAgICBwb2ludHNcbiAgICB9LFxuICAgIHJvdGF0aW9uLFxuICAgIHRoaWNrbmVzc1xuICB9KSB7XG4gICAgY29uc3QgbmV3TGluZXMgPSBbXTtcbiAgICBsZXQgdHgsIHR5LCBzeCwgc3ksIHJlc2NhbGVGbjtcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJlc2NhbGVGbiA9IE91dGxpbmUuX3Jlc2NhbGU7XG4gICAgICAgIHR4ID0gLXBhZ2VYIC8gcGFnZVdpZHRoO1xuICAgICAgICB0eSA9IHBhZ2VZIC8gcGFnZUhlaWdodCArIDE7XG4gICAgICAgIHN4ID0gMSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgc3kgPSAtMSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmVzY2FsZUZuID0gT3V0bGluZS5fcmVzY2FsZUFuZFN3YXA7XG4gICAgICAgIHR4ID0gLXBhZ2VZIC8gcGFnZUhlaWdodDtcbiAgICAgICAgdHkgPSAtcGFnZVggLyBwYWdlV2lkdGg7XG4gICAgICAgIHN4ID0gMSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHN5ID0gMSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmVzY2FsZUZuID0gT3V0bGluZS5fcmVzY2FsZTtcbiAgICAgICAgdHggPSBwYWdlWCAvIHBhZ2VXaWR0aCArIDE7XG4gICAgICAgIHR5ID0gLXBhZ2VZIC8gcGFnZUhlaWdodDtcbiAgICAgICAgc3ggPSAtMSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgc3kgPSAxIC8gcGFnZUhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmVzY2FsZUZuID0gT3V0bGluZS5fcmVzY2FsZUFuZFN3YXA7XG4gICAgICAgIHR4ID0gcGFnZVkgLyBwYWdlSGVpZ2h0ICsgMTtcbiAgICAgICAgdHkgPSBwYWdlWCAvIHBhZ2VXaWR0aCArIDE7XG4gICAgICAgIHN4ID0gLTEgLyBwYWdlSGVpZ2h0O1xuICAgICAgICBzeSA9IC0xIC8gcGFnZVdpZHRoO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKCFsaW5lcykge1xuICAgICAgbGluZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgcG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IHBvaW50Lmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMikge1xuICAgICAgICAgIGxpbmVzLnB1c2gobmV3IEZsb2F0MzJBcnJheShbTmFOLCBOYU4sIE5hTiwgTmFOLCBwb2ludFswXSwgcG9pbnRbMV1dKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbiA9PT0gNCkge1xuICAgICAgICAgIGxpbmVzLnB1c2gobmV3IEZsb2F0MzJBcnJheShbTmFOLCBOYU4sIE5hTiwgTmFOLCBwb2ludFswXSwgcG9pbnRbMV0sIE5hTiwgTmFOLCBOYU4sIE5hTiwgcG9pbnRbMl0sIHBvaW50WzNdXSkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmUgPSBuZXcgRmxvYXQzMkFycmF5KDMgKiAobGVuIC0gMikpO1xuICAgICAgICBsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICBsZXQgW3gxLCB5MSwgeDIsIHkyXSA9IHBvaW50LnN1YmFycmF5KDAsIDQpO1xuICAgICAgICBsaW5lLnNldChbTmFOLCBOYU4sIE5hTiwgTmFOLCB4MSwgeTFdLCAwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDQ7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICAgIGNvbnN0IHggPSBwb2ludFtpXTtcbiAgICAgICAgICBjb25zdCB5ID0gcG9pbnRbaSArIDFdO1xuICAgICAgICAgIGxpbmUuc2V0KE91dGxpbmUuY3JlYXRlQmV6aWVyUG9pbnRzKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSwgKGkgLSAyKSAqIDMpO1xuICAgICAgICAgIFt4MSwgeTEsIHgyLCB5Ml0gPSBbeDIsIHkyLCB4LCB5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsaW5lcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBuZXdMaW5lcy5wdXNoKHtcbiAgICAgICAgbGluZTogcmVzY2FsZUZuKGxpbmVzW2ldLm1hcCh4ID0+IHggPz8gTmFOKSwgdHgsIHR5LCBzeCwgc3kpLFxuICAgICAgICBwb2ludHM6IHJlc2NhbGVGbihwb2ludHNbaV0ubWFwKHggPT4geCA/PyBOYU4pLCB0eCwgdHksIHN4LCBzeSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBvdXRsaW5lcyA9IG5ldyB0aGlzLnByb3RvdHlwZS5jb25zdHJ1Y3RvcigpO1xuICAgIG91dGxpbmVzLmJ1aWxkKG5ld0xpbmVzLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIDEsIHJvdGF0aW9uLCB0aGlja25lc3MsIGlubmVyTWFyZ2luKTtcbiAgICByZXR1cm4gb3V0bGluZXM7XG4gIH1cbiAgI2dldE1hcmdpbkNvbXBvbmVudHModGhpY2tuZXNzID0gdGhpcy4jdGhpY2tuZXNzKSB7XG4gICAgY29uc3QgbWFyZ2luID0gdGhpcy4jaW5uZXJNYXJnaW4gKyB0aGlja25lc3MgLyAyICogdGhpcy4jcGFyZW50U2NhbGU7XG4gICAgcmV0dXJuIHRoaXMuI3JvdGF0aW9uICUgMTgwID09PSAwID8gW21hcmdpbiAvIHRoaXMuI3BhcmVudFdpZHRoLCBtYXJnaW4gLyB0aGlzLiNwYXJlbnRIZWlnaHRdIDogW21hcmdpbiAvIHRoaXMuI3BhcmVudEhlaWdodCwgbWFyZ2luIC8gdGhpcy4jcGFyZW50V2lkdGhdO1xuICB9XG4gICNnZXRCQm94V2l0aE5vTWFyZ2luKCkge1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2Jib3g7XG4gICAgY29uc3QgW21hcmdpblgsIG1hcmdpblldID0gdGhpcy4jZ2V0TWFyZ2luQ29tcG9uZW50cygwKTtcbiAgICByZXR1cm4gW3ggKyBtYXJnaW5YLCB5ICsgbWFyZ2luWSwgd2lkdGggLSAyICogbWFyZ2luWCwgaGVpZ2h0IC0gMiAqIG1hcmdpblldO1xuICB9XG4gICNjb21wdXRlQmJveCgpIHtcbiAgICBjb25zdCBiYm94ID0gdGhpcy4jYmJveCA9IG5ldyBGbG9hdDMyQXJyYXkoW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldKTtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIGxpbmVcbiAgICB9IG9mIHRoaXMuI2xpbmVzKSB7XG4gICAgICBpZiAobGluZS5sZW5ndGggPD0gMTIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDQsIGlpID0gbGluZS5sZW5ndGg7IGkgPCBpaTsgaSArPSA2KSB7XG4gICAgICAgICAgVXRpbC5wb2ludEJvdW5kaW5nQm94KGxpbmVbaV0sIGxpbmVbaSArIDFdLCBiYm94KTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBsYXN0WCA9IGxpbmVbNF0sXG4gICAgICAgIGxhc3RZID0gbGluZVs1XTtcbiAgICAgIGZvciAobGV0IGkgPSA2LCBpaSA9IGxpbmUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNikge1xuICAgICAgICBjb25zdCBbYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5XSA9IGxpbmUuc3ViYXJyYXkoaSwgaSArIDYpO1xuICAgICAgICBVdGlsLmJlemllckJvdW5kaW5nQm94KGxhc3RYLCBsYXN0WSwgYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5LCBiYm94KTtcbiAgICAgICAgbGFzdFggPSB4O1xuICAgICAgICBsYXN0WSA9IHk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IFttYXJnaW5YLCBtYXJnaW5ZXSA9IHRoaXMuI2dldE1hcmdpbkNvbXBvbmVudHMoKTtcbiAgICBiYm94WzBdID0gTWF0aENsYW1wKGJib3hbMF0gLSBtYXJnaW5YLCAwLCAxKTtcbiAgICBiYm94WzFdID0gTWF0aENsYW1wKGJib3hbMV0gLSBtYXJnaW5ZLCAwLCAxKTtcbiAgICBiYm94WzJdID0gTWF0aENsYW1wKGJib3hbMl0gKyBtYXJnaW5YLCAwLCAxKTtcbiAgICBiYm94WzNdID0gTWF0aENsYW1wKGJib3hbM10gKyBtYXJnaW5ZLCAwLCAxKTtcbiAgICBiYm94WzJdIC09IGJib3hbMF07XG4gICAgYmJveFszXSAtPSBiYm94WzFdO1xuICB9XG4gIGdldCBib3goKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Jib3g7XG4gIH1cbiAgdXBkYXRlUHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZSA9PT0gXCJzdHJva2Utd2lkdGhcIikge1xuICAgICAgcmV0dXJuIHRoaXMuI3VwZGF0ZVRoaWNrbmVzcyh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gICN1cGRhdGVUaGlja25lc3ModGhpY2tuZXNzKSB7XG4gICAgY29uc3QgW29sZE1hcmdpblgsIG9sZE1hcmdpblldID0gdGhpcy4jZ2V0TWFyZ2luQ29tcG9uZW50cygpO1xuICAgIHRoaXMuI3RoaWNrbmVzcyA9IHRoaWNrbmVzcztcbiAgICBjb25zdCBbbmV3TWFyZ2luWCwgbmV3TWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKCk7XG4gICAgY29uc3QgW2RpZmZNYXJnaW5YLCBkaWZmTWFyZ2luWV0gPSBbbmV3TWFyZ2luWCAtIG9sZE1hcmdpblgsIG5ld01hcmdpblkgLSBvbGRNYXJnaW5ZXTtcbiAgICBjb25zdCBiYm94ID0gdGhpcy4jYmJveDtcbiAgICBiYm94WzBdIC09IGRpZmZNYXJnaW5YO1xuICAgIGJib3hbMV0gLT0gZGlmZk1hcmdpblk7XG4gICAgYmJveFsyXSArPSAyICogZGlmZk1hcmdpblg7XG4gICAgYmJveFszXSArPSAyICogZGlmZk1hcmdpblk7XG4gICAgcmV0dXJuIGJib3g7XG4gIH1cbiAgdXBkYXRlUGFyZW50RGltZW5zaW9ucyhbd2lkdGgsIGhlaWdodF0sIHNjYWxlKSB7XG4gICAgY29uc3QgW29sZE1hcmdpblgsIG9sZE1hcmdpblldID0gdGhpcy4jZ2V0TWFyZ2luQ29tcG9uZW50cygpO1xuICAgIHRoaXMuI3BhcmVudFdpZHRoID0gd2lkdGg7XG4gICAgdGhpcy4jcGFyZW50SGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuI3BhcmVudFNjYWxlID0gc2NhbGU7XG4gICAgY29uc3QgW25ld01hcmdpblgsIG5ld01hcmdpblldID0gdGhpcy4jZ2V0TWFyZ2luQ29tcG9uZW50cygpO1xuICAgIGNvbnN0IGRpZmZNYXJnaW5YID0gbmV3TWFyZ2luWCAtIG9sZE1hcmdpblg7XG4gICAgY29uc3QgZGlmZk1hcmdpblkgPSBuZXdNYXJnaW5ZIC0gb2xkTWFyZ2luWTtcbiAgICBjb25zdCBiYm94ID0gdGhpcy4jYmJveDtcbiAgICBiYm94WzBdIC09IGRpZmZNYXJnaW5YO1xuICAgIGJib3hbMV0gLT0gZGlmZk1hcmdpblk7XG4gICAgYmJveFsyXSArPSAyICogZGlmZk1hcmdpblg7XG4gICAgYmJveFszXSArPSAyICogZGlmZk1hcmdpblk7XG4gICAgcmV0dXJuIGJib3g7XG4gIH1cbiAgdXBkYXRlUm90YXRpb24ocm90YXRpb24pIHtcbiAgICB0aGlzLiNjdXJyZW50Um90YXRpb24gPSByb3RhdGlvbjtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDoge1xuICAgICAgICB0cmFuc2Zvcm06IHRoaXMucm90YXRpb25UcmFuc2Zvcm1cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGdldCB2aWV3Qm94KCkge1xuICAgIHJldHVybiB0aGlzLiNiYm94Lm1hcChPdXRsaW5lLnN2Z1JvdW5kKS5qb2luKFwiIFwiKTtcbiAgfVxuICBnZXQgZGVmYXVsdFByb3BlcnRpZXMoKSB7XG4gICAgY29uc3QgW3gsIHldID0gdGhpcy4jYmJveDtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vdDoge1xuICAgICAgICB2aWV3Qm94OiB0aGlzLnZpZXdCb3hcbiAgICAgIH0sXG4gICAgICBwYXRoOiB7XG4gICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBgJHtPdXRsaW5lLnN2Z1JvdW5kKHgpfSAke091dGxpbmUuc3ZnUm91bmQoeSl9YFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZ2V0IHJvdGF0aW9uVHJhbnNmb3JtKCkge1xuICAgIGNvbnN0IFssLCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2Jib3g7XG4gICAgbGV0IGEgPSAwLFxuICAgICAgYiA9IDAsXG4gICAgICBjID0gMCxcbiAgICAgIGQgPSAwLFxuICAgICAgZSA9IDAsXG4gICAgICBmID0gMDtcbiAgICBzd2l0Y2ggKHRoaXMuI2N1cnJlbnRSb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgYiA9IGhlaWdodCAvIHdpZHRoO1xuICAgICAgICBjID0gLXdpZHRoIC8gaGVpZ2h0O1xuICAgICAgICBlID0gd2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIGEgPSAtMTtcbiAgICAgICAgZCA9IC0xO1xuICAgICAgICBlID0gd2lkdGg7XG4gICAgICAgIGYgPSBoZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIGIgPSAtaGVpZ2h0IC8gd2lkdGg7XG4gICAgICAgIGMgPSB3aWR0aCAvIGhlaWdodDtcbiAgICAgICAgZiA9IGhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGBtYXRyaXgoJHthfSAke2J9ICR7Y30gJHtkfSAke091dGxpbmUuc3ZnUm91bmQoZSl9ICR7T3V0bGluZS5zdmdSb3VuZChmKX0pYDtcbiAgfVxuICBnZXRQYXRoUmVzaXppbmdTVkdQcm9wZXJ0aWVzKFtuZXdYLCBuZXdZLCBuZXdXaWR0aCwgbmV3SGVpZ2h0XSkge1xuICAgIGNvbnN0IFttYXJnaW5YLCBtYXJnaW5ZXSA9IHRoaXMuI2dldE1hcmdpbkNvbXBvbmVudHMoKTtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNiYm94O1xuICAgIGlmIChNYXRoLmFicyh3aWR0aCAtIG1hcmdpblgpIDw9IE91dGxpbmUuUFJFQ0lTSU9OIHx8IE1hdGguYWJzKGhlaWdodCAtIG1hcmdpblkpIDw9IE91dGxpbmUuUFJFQ0lTSU9OKSB7XG4gICAgICBjb25zdCB0eCA9IG5ld1ggKyBuZXdXaWR0aCAvIDIgLSAoeCArIHdpZHRoIC8gMik7XG4gICAgICBjb25zdCB0eSA9IG5ld1kgKyBuZXdIZWlnaHQgLyAyIC0gKHkgKyBoZWlnaHQgLyAyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBcInRyYW5zZm9ybS1vcmlnaW5cIjogYCR7T3V0bGluZS5zdmdSb3VuZChuZXdYKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKG5ld1kpfWAsXG4gICAgICAgICAgdHJhbnNmb3JtOiBgJHt0aGlzLnJvdGF0aW9uVHJhbnNmb3JtfSB0cmFuc2xhdGUoJHt0eH0gJHt0eX0pYFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzMXggPSAobmV3V2lkdGggLSAyICogbWFyZ2luWCkgLyAod2lkdGggLSAyICogbWFyZ2luWCk7XG4gICAgY29uc3QgczF5ID0gKG5ld0hlaWdodCAtIDIgKiBtYXJnaW5ZKSAvIChoZWlnaHQgLSAyICogbWFyZ2luWSk7XG4gICAgY29uc3QgczJ4ID0gd2lkdGggLyBuZXdXaWR0aDtcbiAgICBjb25zdCBzMnkgPSBoZWlnaHQgLyBuZXdIZWlnaHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IGAke091dGxpbmUuc3ZnUm91bmQoeCl9ICR7T3V0bGluZS5zdmdSb3VuZCh5KX1gLFxuICAgICAgICB0cmFuc2Zvcm06IGAke3RoaXMucm90YXRpb25UcmFuc2Zvcm19IHNjYWxlKCR7czJ4fSAke3MyeX0pIGAgKyBgdHJhbnNsYXRlKCR7T3V0bGluZS5zdmdSb3VuZChtYXJnaW5YKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKG1hcmdpblkpfSkgc2NhbGUoJHtzMXh9ICR7czF5fSkgYCArIGB0cmFuc2xhdGUoJHtPdXRsaW5lLnN2Z1JvdW5kKC1tYXJnaW5YKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKC1tYXJnaW5ZKX0pYFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZ2V0UGF0aFJlc2l6ZWRTVkdQcm9wZXJ0aWVzKFtuZXdYLCBuZXdZLCBuZXdXaWR0aCwgbmV3SGVpZ2h0XSkge1xuICAgIGNvbnN0IFttYXJnaW5YLCBtYXJnaW5ZXSA9IHRoaXMuI2dldE1hcmdpbkNvbXBvbmVudHMoKTtcbiAgICBjb25zdCBiYm94ID0gdGhpcy4jYmJveDtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSBiYm94O1xuICAgIGJib3hbMF0gPSBuZXdYO1xuICAgIGJib3hbMV0gPSBuZXdZO1xuICAgIGJib3hbMl0gPSBuZXdXaWR0aDtcbiAgICBiYm94WzNdID0gbmV3SGVpZ2h0O1xuICAgIGlmIChNYXRoLmFicyh3aWR0aCAtIG1hcmdpblgpIDw9IE91dGxpbmUuUFJFQ0lTSU9OIHx8IE1hdGguYWJzKGhlaWdodCAtIG1hcmdpblkpIDw9IE91dGxpbmUuUFJFQ0lTSU9OKSB7XG4gICAgICBjb25zdCB0eCA9IG5ld1ggKyBuZXdXaWR0aCAvIDIgLSAoeCArIHdpZHRoIC8gMik7XG4gICAgICBjb25zdCB0eSA9IG5ld1kgKyBuZXdIZWlnaHQgLyAyIC0gKHkgKyBoZWlnaHQgLyAyKTtcbiAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICBsaW5lLFxuICAgICAgICBwb2ludHNcbiAgICAgIH0gb2YgdGhpcy4jbGluZXMpIHtcbiAgICAgICAgT3V0bGluZS5fdHJhbnNsYXRlKGxpbmUsIHR4LCB0eSwgbGluZSk7XG4gICAgICAgIE91dGxpbmUuX3RyYW5zbGF0ZShwb2ludHMsIHR4LCB0eSwgcG9pbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICB2aWV3Qm94OiB0aGlzLnZpZXdCb3hcbiAgICAgICAgfSxcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBgJHtPdXRsaW5lLnN2Z1JvdW5kKG5ld1gpfSAke091dGxpbmUuc3ZnUm91bmQobmV3WSl9YCxcbiAgICAgICAgICB0cmFuc2Zvcm06IHRoaXMucm90YXRpb25UcmFuc2Zvcm0gfHwgbnVsbCxcbiAgICAgICAgICBkOiB0aGlzLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHMxeCA9IChuZXdXaWR0aCAtIDIgKiBtYXJnaW5YKSAvICh3aWR0aCAtIDIgKiBtYXJnaW5YKTtcbiAgICBjb25zdCBzMXkgPSAobmV3SGVpZ2h0IC0gMiAqIG1hcmdpblkpIC8gKGhlaWdodCAtIDIgKiBtYXJnaW5ZKTtcbiAgICBjb25zdCB0eCA9IC1zMXggKiAoeCArIG1hcmdpblgpICsgbmV3WCArIG1hcmdpblg7XG4gICAgY29uc3QgdHkgPSAtczF5ICogKHkgKyBtYXJnaW5ZKSArIG5ld1kgKyBtYXJnaW5ZO1xuICAgIGlmIChzMXggIT09IDEgfHwgczF5ICE9PSAxIHx8IHR4ICE9PSAwIHx8IHR5ICE9PSAwKSB7XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgcG9pbnRzXG4gICAgICB9IG9mIHRoaXMuI2xpbmVzKSB7XG4gICAgICAgIE91dGxpbmUuX3Jlc2NhbGUobGluZSwgdHgsIHR5LCBzMXgsIHMxeSwgbGluZSk7XG4gICAgICAgIE91dGxpbmUuX3Jlc2NhbGUocG9pbnRzLCB0eCwgdHksIHMxeCwgczF5LCBwb2ludHMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcm9vdDoge1xuICAgICAgICB2aWV3Qm94OiB0aGlzLnZpZXdCb3hcbiAgICAgIH0sXG4gICAgICBwYXRoOiB7XG4gICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBgJHtPdXRsaW5lLnN2Z1JvdW5kKG5ld1gpfSAke091dGxpbmUuc3ZnUm91bmQobmV3WSl9YCxcbiAgICAgICAgdHJhbnNmb3JtOiB0aGlzLnJvdGF0aW9uVHJhbnNmb3JtIHx8IG51bGwsXG4gICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGdldFBhdGhUcmFuc2xhdGVkU1ZHUHJvcGVydGllcyhbbmV3WCwgbmV3WV0sIHBhcmVudERpbWVuc2lvbnMpIHtcbiAgICBjb25zdCBbbmV3UGFyZW50V2lkdGgsIG5ld1BhcmVudEhlaWdodF0gPSBwYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNiYm94O1xuICAgIGNvbnN0IHR4ID0gbmV3WCAtIGJib3hbMF07XG4gICAgY29uc3QgdHkgPSBuZXdZIC0gYmJveFsxXTtcbiAgICBpZiAodGhpcy4jcGFyZW50V2lkdGggPT09IG5ld1BhcmVudFdpZHRoICYmIHRoaXMuI3BhcmVudEhlaWdodCA9PT0gbmV3UGFyZW50SGVpZ2h0KSB7XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgcG9pbnRzXG4gICAgICB9IG9mIHRoaXMuI2xpbmVzKSB7XG4gICAgICAgIE91dGxpbmUuX3RyYW5zbGF0ZShsaW5lLCB0eCwgdHksIGxpbmUpO1xuICAgICAgICBPdXRsaW5lLl90cmFuc2xhdGUocG9pbnRzLCB0eCwgdHksIHBvaW50cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN4ID0gdGhpcy4jcGFyZW50V2lkdGggLyBuZXdQYXJlbnRXaWR0aDtcbiAgICAgIGNvbnN0IHN5ID0gdGhpcy4jcGFyZW50SGVpZ2h0IC8gbmV3UGFyZW50SGVpZ2h0O1xuICAgICAgdGhpcy4jcGFyZW50V2lkdGggPSBuZXdQYXJlbnRXaWR0aDtcbiAgICAgIHRoaXMuI3BhcmVudEhlaWdodCA9IG5ld1BhcmVudEhlaWdodDtcbiAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICBsaW5lLFxuICAgICAgICBwb2ludHNcbiAgICAgIH0gb2YgdGhpcy4jbGluZXMpIHtcbiAgICAgICAgT3V0bGluZS5fcmVzY2FsZShsaW5lLCB0eCwgdHksIHN4LCBzeSwgbGluZSk7XG4gICAgICAgIE91dGxpbmUuX3Jlc2NhbGUocG9pbnRzLCB0eCwgdHksIHN4LCBzeSwgcG9pbnRzKTtcbiAgICAgIH1cbiAgICAgIGJib3hbMl0gKj0gc3g7XG4gICAgICBiYm94WzNdICo9IHN5O1xuICAgIH1cbiAgICBiYm94WzBdID0gbmV3WDtcbiAgICBiYm94WzFdID0gbmV3WTtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vdDoge1xuICAgICAgICB2aWV3Qm94OiB0aGlzLnZpZXdCb3hcbiAgICAgIH0sXG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKCksXG4gICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBgJHtPdXRsaW5lLnN2Z1JvdW5kKG5ld1gpfSAke091dGxpbmUuc3ZnUm91bmQobmV3WSl9YFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZ2V0IGRlZmF1bHRTVkdQcm9wZXJ0aWVzKCkge1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNiYm94O1xuICAgIHJldHVybiB7XG4gICAgICByb290OiB7XG4gICAgICAgIHZpZXdCb3g6IHRoaXMudmlld0JveFxuICAgICAgfSxcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBkcmF3OiB0cnVlXG4gICAgICB9LFxuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLnRvU1ZHUGF0aCgpLFxuICAgICAgICBcInRyYW5zZm9ybS1vcmlnaW5cIjogYCR7T3V0bGluZS5zdmdSb3VuZChiYm94WzBdKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKGJib3hbMV0pfWAsXG4gICAgICAgIHRyYW5zZm9ybTogdGhpcy5yb3RhdGlvblRyYW5zZm9ybSB8fCBudWxsXG4gICAgICB9LFxuICAgICAgYmJveFxuICAgIH07XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2luay5qc1xuXG5cblxuXG5cblxuY2xhc3MgSW5rRHJhd2luZ09wdGlvbnMgZXh0ZW5kcyBEcmF3aW5nT3B0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKHZpZXdlclBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3ZpZXdQYXJhbWV0ZXJzID0gdmlld2VyUGFyYW1ldGVycztcbiAgICBzdXBlci51cGRhdGVQcm9wZXJ0aWVzKHtcbiAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgc3Ryb2tlOiBBbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yLFxuICAgICAgXCJzdHJva2Utb3BhY2l0eVwiOiAxLFxuICAgICAgXCJzdHJva2Utd2lkdGhcIjogMSxcbiAgICAgIFwic3Ryb2tlLWxpbmVjYXBcIjogXCJyb3VuZFwiLFxuICAgICAgXCJzdHJva2UtbGluZWpvaW5cIjogXCJyb3VuZFwiLFxuICAgICAgXCJzdHJva2UtbWl0ZXJsaW1pdFwiOiAxMFxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVNWR1Byb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKG5hbWUgPT09IFwic3Ryb2tlLXdpZHRoXCIpIHtcbiAgICAgIHZhbHVlID8/PSB0aGlzW1wic3Ryb2tlLXdpZHRoXCJdO1xuICAgICAgdmFsdWUgKj0gdGhpcy5fdmlld1BhcmFtZXRlcnMucmVhbFNjYWxlO1xuICAgIH1cbiAgICBzdXBlci51cGRhdGVTVkdQcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgSW5rRHJhd2luZ09wdGlvbnModGhpcy5fdmlld1BhcmFtZXRlcnMpO1xuICAgIGNsb25lLnVwZGF0ZUFsbCh0aGlzKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cbmNsYXNzIElua0VkaXRvciBleHRlbmRzIERyYXdpbmdFZGl0b3Ige1xuICBzdGF0aWMgX3R5cGUgPSBcImlua1wiO1xuICBzdGF0aWMgX2VkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5JTks7XG4gIHN0YXRpYyBfZGVmYXVsdERyYXdpbmdPcHRpb25zID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJpbmtFZGl0b3JcIlxuICAgIH0pO1xuICAgIHRoaXMuX3dpbGxLZWVwQXNwZWN0UmF0aW8gPSB0cnVlO1xuICAgIHRoaXMuZGVmYXVsdEwxMG5JZCA9IFwicGRmanMtZWRpdG9yLWluay1lZGl0b3JcIjtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKTtcbiAgICB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnMgPSBuZXcgSW5rRHJhd2luZ09wdGlvbnModWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzKTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVmYXVsdERyYXdpbmdPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBjbG9uZSA9IHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucy5jbG9uZSgpO1xuICAgIGNsb25lLnVwZGF0ZVByb3BlcnRpZXMob3B0aW9ucyk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIHN0YXRpYyBnZXQgc3VwcG9ydE11bHRpcGxlRHJhd2luZ3MoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlc01hcCgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwidHlwZXNNYXBcIiwgbmV3IE1hcChbW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19USElDS05FU1MsIFwic3Ryb2tlLXdpZHRoXCJdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX0NPTE9SLCBcInN0cm9rZVwiXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19PUEFDSVRZLCBcInN0cm9rZS1vcGFjaXR5XCJdXSkpO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVEcmF3ZXJJbnN0YW5jZSh4LCB5LCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCByb3RhdGlvbikge1xuICAgIHJldHVybiBuZXcgSW5rRHJhd091dGxpbmVyKHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uLCB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnNbXCJzdHJva2Utd2lkdGhcIl0pO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZURyYXcocGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIGlubmVyTWFyZ2luLCBkYXRhKSB7XG4gICAgcmV0dXJuIElua0RyYXdPdXRsaW5lLmRlc2VyaWFsaXplKHBhZ2VYLCBwYWdlWSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCBpbm5lck1hcmdpbiwgZGF0YSk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgbGV0IGluaXRpYWxEYXRhID0gbnVsbDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIElua0Fubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpbmtMaXN0cyxcbiAgICAgICAgICByZWN0LFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgIG9wYWNpdHksXG4gICAgICAgICAgYm9yZGVyU3R5bGU6IHtcbiAgICAgICAgICAgIHJhd1dpZHRoOiB0aGlja25lc3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBvcHVwUmVmLFxuICAgICAgICAgIGNvbnRlbnRzT2JqXG4gICAgICAgIH0sXG4gICAgICAgIHBhcmVudDoge1xuICAgICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgIHBhZ2VOdW1iZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgaW5pdGlhbERhdGEgPSBkYXRhID0ge1xuICAgICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LLFxuICAgICAgICBjb2xvcjogQXJyYXkuZnJvbShjb2xvciksXG4gICAgICAgIHRoaWNrbmVzcyxcbiAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgcGF0aHM6IHtcbiAgICAgICAgICBwb2ludHM6IGlua0xpc3RzXG4gICAgICAgIH0sXG4gICAgICAgIGJveGVzOiBudWxsLFxuICAgICAgICBwYWdlSW5kZXg6IHBhZ2VOdW1iZXIgLSAxLFxuICAgICAgICByZWN0OiByZWN0LnNsaWNlKDApLFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgYW5ub3RhdGlvbkVsZW1lbnRJZDogaWQsXG4gICAgICAgIGlkLFxuICAgICAgICBkZWxldGVkOiBmYWxzZSxcbiAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgIGNvbW1lbnQ6IGNvbnRlbnRzT2JqPy5zdHIgfHwgbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGVkaXRvci5faW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICBpZiAoZGF0YS5jb21tZW50KSB7XG4gICAgICBlZGl0b3Iuc2V0Q29tbWVudERhdGEoZGF0YS5jb21tZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBnZXQgdG9vbGJhckJ1dHRvbnMoKSB7XG4gICAgdGhpcy5fY29sb3JQaWNrZXIgfHw9IG5ldyBCYXNpY0NvbG9yUGlja2VyKHRoaXMpO1xuICAgIHJldHVybiBbW1wiY29sb3JQaWNrZXJcIiwgdGhpcy5fY29sb3JQaWNrZXJdXTtcbiAgfVxuICBnZXQgY29sb3JUeXBlKCkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfQ09MT1I7XG4gIH1cbiAgZ2V0IGNvbG9yVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RyYXdpbmdPcHRpb25zLnN0cm9rZTtcbiAgfVxuICBvblNjYWxlQ2hhbmdpbmcoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5vblNjYWxlQ2hhbmdpbmcoKTtcbiAgICBjb25zdCB7XG4gICAgICBfZHJhd0lkLFxuICAgICAgX2RyYXdpbmdPcHRpb25zLFxuICAgICAgcGFyZW50XG4gICAgfSA9IHRoaXM7XG4gICAgX2RyYXdpbmdPcHRpb25zLnVwZGF0ZVNWR1Byb3BlcnR5KFwic3Ryb2tlLXdpZHRoXCIpO1xuICAgIHBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyhfZHJhd0lkLCBfZHJhd2luZ09wdGlvbnMudG9TVkdQcm9wZXJ0aWVzKCkpO1xuICB9XG4gIHN0YXRpYyBvblNjYWxlQ2hhbmdpbmdXaGVuRHJhd2luZygpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9jdXJyZW50UGFyZW50O1xuICAgIGlmICghcGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLm9uU2NhbGVDaGFuZ2luZ1doZW5EcmF3aW5nKCk7XG4gICAgdGhpcy5fZGVmYXVsdERyYXdpbmdPcHRpb25zLnVwZGF0ZVNWR1Byb3BlcnR5KFwic3Ryb2tlLXdpZHRoXCIpO1xuICAgIHBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9jdXJyZW50RHJhd0lkLCB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnMudG9TVkdQcm9wZXJ0aWVzKCkpO1xuICB9XG4gIGNyZWF0ZURyYXdpbmdPcHRpb25zKHtcbiAgICBjb2xvcixcbiAgICB0aGlja25lc3MsXG4gICAgb3BhY2l0eVxuICB9KSB7XG4gICAgdGhpcy5fZHJhd2luZ09wdGlvbnMgPSBJbmtFZGl0b3IuZ2V0RGVmYXVsdERyYXdpbmdPcHRpb25zKHtcbiAgICAgIHN0cm9rZTogVXRpbC5tYWtlSGV4Q29sb3IoLi4uY29sb3IpLFxuICAgICAgXCJzdHJva2Utd2lkdGhcIjogdGhpY2tuZXNzLFxuICAgICAgXCJzdHJva2Utb3BhY2l0eVwiOiBvcGFjaXR5XG4gICAgfSk7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplRGVsZXRlZCgpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBsaW5lcyxcbiAgICAgIHBvaW50cyxcbiAgICAgIHJlY3RcbiAgICB9ID0gdGhpcy5zZXJpYWxpemVEcmF3KGlzRm9yQ29weWluZyk7XG4gICAgY29uc3Qge1xuICAgICAgX2RyYXdpbmdPcHRpb25zOiB7XG4gICAgICAgIHN0cm9rZSxcbiAgICAgICAgXCJzdHJva2Utb3BhY2l0eVwiOiBvcGFjaXR5LFxuICAgICAgICBcInN0cm9rZS13aWR0aFwiOiB0aGlja25lc3NcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzZXJpYWxpemVkID0ge1xuICAgICAgYW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLklOSyxcbiAgICAgIGNvbG9yOiBBbm5vdGF0aW9uRWRpdG9yLl9jb2xvck1hbmFnZXIuY29udmVydChzdHJva2UpLFxuICAgICAgb3BhY2l0eSxcbiAgICAgIHRoaWNrbmVzcyxcbiAgICAgIHBhdGhzOiB7XG4gICAgICAgIGxpbmVzLFxuICAgICAgICBwb2ludHNcbiAgICAgIH0sXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4LFxuICAgICAgcmVjdCxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxuICAgICAgc3RydWN0VHJlZVBhcmVudElkOiB0aGlzLl9zdHJ1Y3RUcmVlUGFyZW50SWRcbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWVudChzZXJpYWxpemVkKTtcbiAgICBpZiAoaXNGb3JDb3B5aW5nKSB7XG4gICAgICBzZXJpYWxpemVkLmlzQ29weSA9IHRydWU7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiAhdGhpcy4jaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZXJpYWxpemVkLmlkID0gdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gICNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29sb3IsXG4gICAgICB0aGlja25lc3MsXG4gICAgICBvcGFjaXR5LFxuICAgICAgcGFnZUluZGV4XG4gICAgfSA9IHRoaXMuX2luaXRpYWxEYXRhO1xuICAgIHJldHVybiB0aGlzLmhhc0VkaXRlZENvbW1lbnQgfHwgdGhpcy5faGFzQmVlbk1vdmVkIHx8IHRoaXMuX2hhc0JlZW5SZXNpemVkIHx8IHNlcmlhbGl6ZWQuY29sb3Iuc29tZSgoYywgaSkgPT4gYyAhPT0gY29sb3JbaV0pIHx8IHNlcmlhbGl6ZWQudGhpY2tuZXNzICE9PSB0aGlja25lc3MgfHwgc2VyaWFsaXplZC5vcGFjaXR5ICE9PSBvcGFjaXR5IHx8IHNlcmlhbGl6ZWQucGFnZUluZGV4ICE9PSBwYWdlSW5kZXg7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIGFubm90YXRpb24uaGlkZSgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHBvaW50cyxcbiAgICAgIHJlY3RcbiAgICB9ID0gdGhpcy5zZXJpYWxpemVEcmF3KGZhbHNlKTtcbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICByZWN0LFxuICAgICAgdGhpY2tuZXNzOiB0aGlzLl9kcmF3aW5nT3B0aW9uc1tcInN0cm9rZS13aWR0aFwiXSxcbiAgICAgIHBvaW50c1xuICAgIH07XG4gICAgaWYgKHRoaXMuaGFzRWRpdGVkQ29tbWVudCkge1xuICAgICAgcGFyYW1zLnBvcHVwID0gdGhpcy5jb21tZW50O1xuICAgIH1cbiAgICBhbm5vdGF0aW9uLnVwZGF0ZUVkaXRlZChwYXJhbXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9kcmF3ZXJzL2NvbnRvdXIuanNcblxuY2xhc3MgQ29udG91ckRyYXdPdXRsaW5lIGV4dGVuZHMgSW5rRHJhd091dGxpbmUge1xuICB0b1NWR1BhdGgoKSB7XG4gICAgbGV0IHBhdGggPSBzdXBlci50b1NWR1BhdGgoKTtcbiAgICBpZiAoIXBhdGguZW5kc1dpdGgoXCJaXCIpKSB7XG4gICAgICBwYXRoICs9IFwiWlwiO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvZHJhd2Vycy9zaWduYXR1cmVkcmF3LmpzXG5cblxuXG5cbmNvbnN0IEJBU0VfSEVBREVSX0xFTkdUSCA9IDg7XG5jb25zdCBQT0lOVFNfUFJPUEVSVElFU19OVU1CRVIgPSAzO1xuY2xhc3MgU2lnbmF0dXJlRXh0cmFjdG9yIHtcbiAgc3RhdGljICNQQVJBTUVURVJTID0ge1xuICAgIG1heERpbTogNTEyLFxuICAgIHNpZ21hU0ZhY3RvcjogMC4wMixcbiAgICBzaWdtYVI6IDI1LFxuICAgIGtlcm5lbFNpemU6IDE2XG4gIH07XG4gIHN0YXRpYyAjbmVpZ2hib3JJbmRleFRvSWQoaTAsIGowLCBpLCBqKSB7XG4gICAgaSAtPSBpMDtcbiAgICBqIC09IGowO1xuICAgIGlmIChpID09PSAwKSB7XG4gICAgICByZXR1cm4gaiA+IDAgPyAwIDogNDtcbiAgICB9XG4gICAgaWYgKGkgPT09IDEpIHtcbiAgICAgIHJldHVybiBqICsgNjtcbiAgICB9XG4gICAgcmV0dXJuIDIgLSBqO1xuICB9XG4gIHN0YXRpYyAjbmVpZ2hib3JJZFRvSW5kZXggPSBuZXcgSW50MzJBcnJheShbMCwgMSwgLTEsIDEsIC0xLCAwLCAtMSwgLTEsIDAsIC0xLCAxLCAtMSwgMSwgMCwgMSwgMV0pO1xuICBzdGF0aWMgI2Nsb2Nrd2lzZU5vblplcm8oYnVmLCB3aWR0aCwgaTAsIGowLCBpLCBqLCBvZmZzZXQpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuI25laWdoYm9ySW5kZXhUb0lkKGkwLCBqMCwgaSwgaik7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGNvbnN0IGtrID0gKC1rICsgaWQgLSBvZmZzZXQgKyAxNikgJSA4O1xuICAgICAgY29uc3Qgc2hpZnRJID0gdGhpcy4jbmVpZ2hib3JJZFRvSW5kZXhbMiAqIGtrXTtcbiAgICAgIGNvbnN0IHNoaWZ0SiA9IHRoaXMuI25laWdoYm9ySWRUb0luZGV4WzIgKiBrayArIDFdO1xuICAgICAgaWYgKGJ1ZlsoaTAgKyBzaGlmdEkpICogd2lkdGggKyAoajAgKyBzaGlmdEopXSAhPT0gMCkge1xuICAgICAgICByZXR1cm4ga2s7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBzdGF0aWMgI2NvdW50ZXJDbG9ja3dpc2VOb25aZXJvKGJ1Ziwgd2lkdGgsIGkwLCBqMCwgaSwgaiwgb2Zmc2V0KSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLiNuZWlnaGJvckluZGV4VG9JZChpMCwgajAsIGksIGopO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgODsgaysrKSB7XG4gICAgICBjb25zdCBrayA9IChrICsgaWQgKyBvZmZzZXQgKyAxNikgJSA4O1xuICAgICAgY29uc3Qgc2hpZnRJID0gdGhpcy4jbmVpZ2hib3JJZFRvSW5kZXhbMiAqIGtrXTtcbiAgICAgIGNvbnN0IHNoaWZ0SiA9IHRoaXMuI25laWdoYm9ySWRUb0luZGV4WzIgKiBrayArIDFdO1xuICAgICAgaWYgKGJ1ZlsoaTAgKyBzaGlmdEkpICogd2lkdGggKyAoajAgKyBzaGlmdEopXSAhPT0gMCkge1xuICAgICAgICByZXR1cm4ga2s7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBzdGF0aWMgI2ZpbmRDb250b3VycyhidWYsIHdpZHRoLCBoZWlnaHQsIHRocmVzaG9sZCkge1xuICAgIGNvbnN0IE4gPSBidWYubGVuZ3RoO1xuICAgIGNvbnN0IHR5cGVzID0gbmV3IEludDMyQXJyYXkoTik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHR5cGVzW2ldID0gYnVmW2ldIDw9IHRocmVzaG9sZCA/IDEgOiAwO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGhlaWdodCAtIDE7IGkrKykge1xuICAgICAgdHlwZXNbaSAqIHdpZHRoXSA9IHR5cGVzW2kgKiB3aWR0aCArIHdpZHRoIC0gMV0gPSAwO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgIHR5cGVzW2ldID0gdHlwZXNbd2lkdGggKiBoZWlnaHQgLSAxIC0gaV0gPSAwO1xuICAgIH1cbiAgICBsZXQgbmJkID0gMTtcbiAgICBsZXQgbG5iZDtcbiAgICBjb25zdCBjb250b3VycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaGVpZ2h0IC0gMTsgaSsrKSB7XG4gICAgICBsbmJkID0gMTtcbiAgICAgIGZvciAobGV0IGogPSAxOyBqIDwgd2lkdGggLSAxOyBqKyspIHtcbiAgICAgICAgY29uc3QgaWogPSBpICogd2lkdGggKyBqO1xuICAgICAgICBjb25zdCBwaXggPSB0eXBlc1tpal07XG4gICAgICAgIGlmIChwaXggPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaTIgPSBpO1xuICAgICAgICBsZXQgajIgPSBqO1xuICAgICAgICBpZiAocGl4ID09PSAxICYmIHR5cGVzW2lqIC0gMV0gPT09IDApIHtcbiAgICAgICAgICBuYmQgKz0gMTtcbiAgICAgICAgICBqMiAtPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHBpeCA+PSAxICYmIHR5cGVzW2lqICsgMV0gPT09IDApIHtcbiAgICAgICAgICBuYmQgKz0gMTtcbiAgICAgICAgICBqMiArPSAxO1xuICAgICAgICAgIGlmIChwaXggPiAxKSB7XG4gICAgICAgICAgICBsbmJkID0gcGl4O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocGl4ICE9PSAxKSB7XG4gICAgICAgICAgICBsbmJkID0gTWF0aC5hYnMocGl4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9pbnRzID0gW2osIGldO1xuICAgICAgICBjb25zdCBpc0hvbGUgPSBqMiA9PT0gaiArIDE7XG4gICAgICAgIGNvbnN0IGNvbnRvdXIgPSB7XG4gICAgICAgICAgaXNIb2xlLFxuICAgICAgICAgIHBvaW50cyxcbiAgICAgICAgICBpZDogbmJkLFxuICAgICAgICAgIHBhcmVudDogMFxuICAgICAgICB9O1xuICAgICAgICBjb250b3Vycy5wdXNoKGNvbnRvdXIpO1xuICAgICAgICBsZXQgY29udG91cjA7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBjb250b3Vycykge1xuICAgICAgICAgIGlmIChjLmlkID09PSBsbmJkKSB7XG4gICAgICAgICAgICBjb250b3VyMCA9IGM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb250b3VyMCkge1xuICAgICAgICAgIGNvbnRvdXIucGFyZW50ID0gaXNIb2xlID8gbG5iZCA6IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udG91cjAuaXNIb2xlKSB7XG4gICAgICAgICAgY29udG91ci5wYXJlbnQgPSBpc0hvbGUgPyBjb250b3VyMC5wYXJlbnQgOiBsbmJkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRvdXIucGFyZW50ID0gaXNIb2xlID8gbG5iZCA6IGNvbnRvdXIwLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrID0gdGhpcy4jY2xvY2t3aXNlTm9uWmVybyh0eXBlcywgd2lkdGgsIGksIGosIGkyLCBqMiwgMCk7XG4gICAgICAgIGlmIChrID09PSAtMSkge1xuICAgICAgICAgIHR5cGVzW2lqXSA9IC1uYmQ7XG4gICAgICAgICAgaWYgKHR5cGVzW2lqXSAhPT0gMSkge1xuICAgICAgICAgICAgbG5iZCA9IE1hdGguYWJzKHR5cGVzW2lqXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaGlmdEkgPSB0aGlzLiNuZWlnaGJvcklkVG9JbmRleFsyICoga107XG4gICAgICAgIGxldCBzaGlmdEogPSB0aGlzLiNuZWlnaGJvcklkVG9JbmRleFsyICogayArIDFdO1xuICAgICAgICBjb25zdCBpMSA9IGkgKyBzaGlmdEk7XG4gICAgICAgIGNvbnN0IGoxID0gaiArIHNoaWZ0SjtcbiAgICAgICAgaTIgPSBpMTtcbiAgICAgICAgajIgPSBqMTtcbiAgICAgICAgbGV0IGkzID0gaTtcbiAgICAgICAgbGV0IGozID0gajtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCBrayA9IHRoaXMuI2NvdW50ZXJDbG9ja3dpc2VOb25aZXJvKHR5cGVzLCB3aWR0aCwgaTMsIGozLCBpMiwgajIsIDEpO1xuICAgICAgICAgIHNoaWZ0SSA9IHRoaXMuI25laWdoYm9ySWRUb0luZGV4WzIgKiBra107XG4gICAgICAgICAgc2hpZnRKID0gdGhpcy4jbmVpZ2hib3JJZFRvSW5kZXhbMiAqIGtrICsgMV07XG4gICAgICAgICAgY29uc3QgaTQgPSBpMyArIHNoaWZ0STtcbiAgICAgICAgICBjb25zdCBqNCA9IGozICsgc2hpZnRKO1xuICAgICAgICAgIHBvaW50cy5wdXNoKGo0LCBpNCk7XG4gICAgICAgICAgY29uc3QgaWozID0gaTMgKiB3aWR0aCArIGozO1xuICAgICAgICAgIGlmICh0eXBlc1tpajMgKyAxXSA9PT0gMCkge1xuICAgICAgICAgICAgdHlwZXNbaWozXSA9IC1uYmQ7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlc1tpajNdID09PSAxKSB7XG4gICAgICAgICAgICB0eXBlc1tpajNdID0gbmJkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaTQgPT09IGkgJiYgajQgPT09IGogJiYgaTMgPT09IGkxICYmIGozID09PSBqMSkge1xuICAgICAgICAgICAgaWYgKHR5cGVzW2lqXSAhPT0gMSkge1xuICAgICAgICAgICAgICBsbmJkID0gTWF0aC5hYnModHlwZXNbaWpdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpMiA9IGkzO1xuICAgICAgICAgICAgajIgPSBqMztcbiAgICAgICAgICAgIGkzID0gaTQ7XG4gICAgICAgICAgICBqMyA9IGo0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udG91cnM7XG4gIH1cbiAgc3RhdGljICNkb3VnbGFzUGV1Y2tlckhlbHBlcihwb2ludHMsIHN0YXJ0LCBlbmQsIG91dHB1dCkge1xuICAgIGlmIChlbmQgLSBzdGFydCA8PSA0KSB7XG4gICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQgLSAyOyBpICs9IDIpIHtcbiAgICAgICAgb3V0cHV0LnB1c2gocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXggPSBwb2ludHNbc3RhcnRdO1xuICAgIGNvbnN0IGF5ID0gcG9pbnRzW3N0YXJ0ICsgMV07XG4gICAgY29uc3QgYWJ4ID0gcG9pbnRzW2VuZCAtIDRdIC0gYXg7XG4gICAgY29uc3QgYWJ5ID0gcG9pbnRzW2VuZCAtIDNdIC0gYXk7XG4gICAgY29uc3QgZGlzdCA9IE1hdGguaHlwb3QoYWJ4LCBhYnkpO1xuICAgIGNvbnN0IG5hYnggPSBhYnggLyBkaXN0O1xuICAgIGNvbnN0IG5hYnkgPSBhYnkgLyBkaXN0O1xuICAgIGNvbnN0IGFhID0gbmFieCAqIGF5IC0gbmFieSAqIGF4O1xuICAgIGNvbnN0IG0gPSBhYnkgLyBhYng7XG4gICAgY29uc3QgaW52UyA9IDEgLyBkaXN0O1xuICAgIGNvbnN0IHBoaSA9IE1hdGguYXRhbihtKTtcbiAgICBjb25zdCBjb3NQaGkgPSBNYXRoLmNvcyhwaGkpO1xuICAgIGNvbnN0IHNpblBoaSA9IE1hdGguc2luKHBoaSk7XG4gICAgY29uc3QgdG1heCA9IGludlMgKiAoTWF0aC5hYnMoY29zUGhpKSArIE1hdGguYWJzKHNpblBoaSkpO1xuICAgIGNvbnN0IHBvbHkgPSBpbnZTICogKDEgLSB0bWF4ICsgdG1heCAqKiAyKTtcbiAgICBjb25zdCBwYXJ0aWFsUGhpID0gTWF0aC5tYXgoTWF0aC5hdGFuKE1hdGguYWJzKHNpblBoaSArIGNvc1BoaSkgKiBwb2x5KSwgTWF0aC5hdGFuKE1hdGguYWJzKHNpblBoaSAtIGNvc1BoaSkgKiBwb2x5KSk7XG4gICAgbGV0IGRtYXggPSAwO1xuICAgIGxldCBpbmRleCA9IHN0YXJ0O1xuICAgIGZvciAobGV0IGkgPSBzdGFydCArIDI7IGkgPCBlbmQgLSAyOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IGQgPSBNYXRoLmFicyhhYSAtIG5hYnggKiBwb2ludHNbaSArIDFdICsgbmFieSAqIHBvaW50c1tpXSk7XG4gICAgICBpZiAoZCA+IGRtYXgpIHtcbiAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICBkbWF4ID0gZDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRtYXggPiAoZGlzdCAqIHBhcnRpYWxQaGkpICoqIDIpIHtcbiAgICAgIHRoaXMuI2RvdWdsYXNQZXVja2VySGVscGVyKHBvaW50cywgc3RhcnQsIGluZGV4ICsgMiwgb3V0cHV0KTtcbiAgICAgIHRoaXMuI2RvdWdsYXNQZXVja2VySGVscGVyKHBvaW50cywgaW5kZXgsIGVuZCwgb3V0cHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goYXgsIGF5KTtcbiAgICB9XG4gIH1cbiAgc3RhdGljICNkb3VnbGFzUGV1Y2tlcihwb2ludHMpIHtcbiAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICBjb25zdCBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgIHRoaXMuI2RvdWdsYXNQZXVja2VySGVscGVyKHBvaW50cywgMCwgbGVuLCBvdXRwdXQpO1xuICAgIG91dHB1dC5wdXNoKHBvaW50c1tsZW4gLSAyXSwgcG9pbnRzW2xlbiAtIDFdKTtcbiAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA8PSA0ID8gbnVsbCA6IG91dHB1dDtcbiAgfVxuICBzdGF0aWMgI2JpbGF0ZXJhbEZpbHRlcihidWYsIHdpZHRoLCBoZWlnaHQsIHNpZ21hUywgc2lnbWFSLCBrZXJuZWxTaXplKSB7XG4gICAgY29uc3Qga2VybmVsID0gbmV3IEZsb2F0MzJBcnJheShrZXJuZWxTaXplICoqIDIpO1xuICAgIGNvbnN0IHNpZ21hUzIgPSAtMiAqIHNpZ21hUyAqKiAyO1xuICAgIGNvbnN0IGhhbGZTaXplID0ga2VybmVsU2l6ZSA+PiAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2VybmVsU2l6ZTsgaSsrKSB7XG4gICAgICBjb25zdCB4ID0gKGkgLSBoYWxmU2l6ZSkgKiogMjtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwga2VybmVsU2l6ZTsgaisrKSB7XG4gICAgICAgIGtlcm5lbFtpICoga2VybmVsU2l6ZSArIGpdID0gTWF0aC5leHAoKHggKyAoaiAtIGhhbGZTaXplKSAqKiAyKSAvIHNpZ21hUzIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByYW5nZVZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoMjU2KTtcbiAgICBjb25zdCBzaWdtYVIyID0gLTIgKiBzaWdtYVIgKiogMjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICByYW5nZVZhbHVlc1tpXSA9IE1hdGguZXhwKGkgKiogMiAvIHNpZ21hUjIpO1xuICAgIH1cbiAgICBjb25zdCBOID0gYnVmLmxlbmd0aDtcbiAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheShOKTtcbiAgICBjb25zdCBoaXN0b2dyYW0gPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICAgICAgY29uc3QgaWogPSBpICogd2lkdGggKyBqO1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBidWZbaWpdO1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IG5vcm0gPSAwO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGtlcm5lbFNpemU7IGsrKykge1xuICAgICAgICAgIGNvbnN0IHkgPSBpICsgayAtIGhhbGZTaXplO1xuICAgICAgICAgIGlmICh5IDwgMCB8fCB5ID49IGhlaWdodCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwga2VybmVsU2l6ZTsgbCsrKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gaiArIGwgLSBoYWxmU2l6ZTtcbiAgICAgICAgICAgIGlmICh4IDwgMCB8fCB4ID49IHdpZHRoKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmVpZ2hib3VyID0gYnVmW3kgKiB3aWR0aCArIHhdO1xuICAgICAgICAgICAgY29uc3QgdyA9IGtlcm5lbFtrICoga2VybmVsU2l6ZSArIGxdICogcmFuZ2VWYWx1ZXNbTWF0aC5hYnMobmVpZ2hib3VyIC0gY2VudGVyKV07XG4gICAgICAgICAgICBzdW0gKz0gbmVpZ2hib3VyICogdztcbiAgICAgICAgICAgIG5vcm0gKz0gdztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGl4ID0gb3V0W2lqXSA9IE1hdGgucm91bmQoc3VtIC8gbm9ybSk7XG4gICAgICAgIGhpc3RvZ3JhbVtwaXhdKys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbb3V0LCBoaXN0b2dyYW1dO1xuICB9XG4gIHN0YXRpYyAjZ2V0SGlzdG9ncmFtKGJ1Zikge1xuICAgIGNvbnN0IGhpc3RvZ3JhbSA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIGZvciAoY29uc3QgZyBvZiBidWYpIHtcbiAgICAgIGhpc3RvZ3JhbVtnXSsrO1xuICAgIH1cbiAgICByZXR1cm4gaGlzdG9ncmFtO1xuICB9XG4gIHN0YXRpYyAjdG9VaW50OChidWYpIHtcbiAgICBjb25zdCBOID0gYnVmLmxlbmd0aDtcbiAgICBjb25zdCBvdXQgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoTiA+PiAyKTtcbiAgICBsZXQgbWF4ID0gLUluZmluaXR5O1xuICAgIGxldCBtaW4gPSBJbmZpbml0eTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBvdXQubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3QgcGl4ID0gb3V0W2ldID0gYnVmW2kgPDwgMl07XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIHBpeCk7XG4gICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHBpeCk7XG4gICAgfVxuICAgIGNvbnN0IHJhdGlvID0gMjU1IC8gKG1heCAtIG1pbik7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gb3V0Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIG91dFtpXSA9IChvdXRbaV0gLSBtaW4pICogcmF0aW87XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgc3RhdGljICNndWVzc1RocmVzaG9sZChoaXN0b2dyYW0pIHtcbiAgICBsZXQgaTtcbiAgICBsZXQgTSA9IC1JbmZpbml0eTtcbiAgICBsZXQgTCA9IC1JbmZpbml0eTtcbiAgICBjb25zdCBtaW4gPSBoaXN0b2dyYW0uZmluZEluZGV4KHYgPT4gdiAhPT0gMCk7XG4gICAgbGV0IHBvcyA9IG1pbjtcbiAgICBsZXQgc3BvcyA9IG1pbjtcbiAgICBmb3IgKGkgPSBtaW47IGkgPCAyNTY7IGkrKykge1xuICAgICAgY29uc3QgdiA9IGhpc3RvZ3JhbVtpXTtcbiAgICAgIGlmICh2ID4gTSkge1xuICAgICAgICBpZiAoaSAtIHBvcyA+IEwpIHtcbiAgICAgICAgICBMID0gaSAtIHBvcztcbiAgICAgICAgICBzcG9zID0gaSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgTSA9IHY7XG4gICAgICAgIHBvcyA9IGk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IHNwb3MgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGhpc3RvZ3JhbVtpXSA+IGhpc3RvZ3JhbVtpICsgMV0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9XG4gIHN0YXRpYyAjZ2V0R3JheVBpeGVscyhiaXRtYXApIHtcbiAgICBjb25zdCBvcmlnaW5hbEJpdG1hcCA9IGJpdG1hcDtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBiaXRtYXA7XG4gICAgY29uc3Qge1xuICAgICAgbWF4RGltXG4gICAgfSA9IHRoaXMuI1BBUkFNRVRFUlM7XG4gICAgbGV0IG5ld1dpZHRoID0gd2lkdGg7XG4gICAgbGV0IG5ld0hlaWdodCA9IGhlaWdodDtcbiAgICBpZiAod2lkdGggPiBtYXhEaW0gfHwgaGVpZ2h0ID4gbWF4RGltKSB7XG4gICAgICBsZXQgcHJldldpZHRoID0gd2lkdGg7XG4gICAgICBsZXQgcHJldkhlaWdodCA9IGhlaWdodDtcbiAgICAgIGxldCBzdGVwcyA9IE1hdGgubG9nMihNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KSAvIG1heERpbSk7XG4gICAgICBjb25zdCBpc3RlcHMgPSBNYXRoLmZsb29yKHN0ZXBzKTtcbiAgICAgIHN0ZXBzID0gc3RlcHMgPT09IGlzdGVwcyA/IGlzdGVwcyAtIDEgOiBpc3RlcHM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ZXBzOyBpKyspIHtcbiAgICAgICAgbmV3V2lkdGggPSBNYXRoLmNlaWwocHJldldpZHRoIC8gMik7XG4gICAgICAgIG5ld0hlaWdodCA9IE1hdGguY2VpbChwcmV2SGVpZ2h0IC8gMik7XG4gICAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMobmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICAgIGNvbnN0IGN0eCA9IG9mZnNjcmVlbi5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBwcmV2V2lkdGgsIHByZXZIZWlnaHQsIDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgICBwcmV2V2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgcHJldkhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgaWYgKGJpdG1hcCAhPT0gb3JpZ2luYWxCaXRtYXApIHtcbiAgICAgICAgICBiaXRtYXAuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBiaXRtYXAgPSBvZmZzY3JlZW4udHJhbnNmZXJUb0ltYWdlQml0bWFwKCk7XG4gICAgICB9XG4gICAgICBjb25zdCByYXRpbyA9IE1hdGgubWluKG1heERpbSAvIG5ld1dpZHRoLCBtYXhEaW0gLyBuZXdIZWlnaHQpO1xuICAgICAgbmV3V2lkdGggPSBNYXRoLnJvdW5kKG5ld1dpZHRoICogcmF0aW8pO1xuICAgICAgbmV3SGVpZ2h0ID0gTWF0aC5yb3VuZChuZXdIZWlnaHQgKiByYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMobmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgY29uc3QgY3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbiAgICB9KTtcbiAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICBjdHguZmlsdGVyID0gXCJncmF5c2NhbGUoMSlcIjtcbiAgICBjdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCwgYml0bWFwLndpZHRoLCBiaXRtYXAuaGVpZ2h0LCAwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICBjb25zdCBncmF5SW1hZ2UgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpLmRhdGE7XG4gICAgY29uc3QgdWludDhCdWYgPSB0aGlzLiN0b1VpbnQ4KGdyYXlJbWFnZSk7XG4gICAgcmV0dXJuIFt1aW50OEJ1ZiwgbmV3V2lkdGgsIG5ld0hlaWdodF07XG4gIH1cbiAgc3RhdGljIGV4dHJhY3RDb250b3Vyc0Zyb21UZXh0KHRleHQsIHtcbiAgICBmb250RmFtaWx5LFxuICAgIGZvbnRTdHlsZSxcbiAgICBmb250V2VpZ2h0XG4gIH0sIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgcm90YXRpb24sIGlubmVyTWFyZ2luKSB7XG4gICAgbGV0IGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSk7XG4gICAgbGV0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgYWxwaGE6IGZhbHNlXG4gICAgfSk7XG4gICAgY29uc3QgZm9udFNpemUgPSAyMDA7XG4gICAgY29uc3QgZm9udCA9IGN0eC5mb250ID0gYCR7Zm9udFN0eWxlfSAke2ZvbnRXZWlnaHR9ICR7Zm9udFNpemV9cHggJHtmb250RmFtaWx5fWA7XG4gICAgY29uc3Qge1xuICAgICAgYWN0dWFsQm91bmRpbmdCb3hMZWZ0LFxuICAgICAgYWN0dWFsQm91bmRpbmdCb3hSaWdodCxcbiAgICAgIGFjdHVhbEJvdW5kaW5nQm94QXNjZW50LFxuICAgICAgYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50LFxuICAgICAgZm9udEJvdW5kaW5nQm94QXNjZW50LFxuICAgICAgZm9udEJvdW5kaW5nQm94RGVzY2VudCxcbiAgICAgIHdpZHRoXG4gICAgfSA9IGN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgICBjb25zdCBTQ0FMRSA9IDEuNTtcbiAgICBjb25zdCBjYW52YXNXaWR0aCA9IE1hdGguY2VpbChNYXRoLm1heChNYXRoLmFicyhhY3R1YWxCb3VuZGluZ0JveExlZnQpICsgTWF0aC5hYnMoYWN0dWFsQm91bmRpbmdCb3hSaWdodCkgfHwgMCwgd2lkdGgpICogU0NBTEUpO1xuICAgIGNvbnN0IGNhbnZhc0hlaWdodCA9IE1hdGguY2VpbChNYXRoLm1heChNYXRoLmFicyhhY3R1YWxCb3VuZGluZ0JveEFzY2VudCkgKyBNYXRoLmFicyhhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQpIHx8IGZvbnRTaXplLCBNYXRoLmFicyhmb250Qm91bmRpbmdCb3hBc2NlbnQpICsgTWF0aC5hYnMoZm9udEJvdW5kaW5nQm94RGVzY2VudCkgfHwgZm9udFNpemUpICogU0NBTEUpO1xuICAgIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICBhbHBoYTogdHJ1ZSxcbiAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgIH0pO1xuICAgIGN0eC5mb250ID0gZm9udDtcbiAgICBjdHguZmlsdGVyID0gXCJncmF5c2NhbGUoMSlcIjtcbiAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gXCJibGFja1wiO1xuICAgIGN0eC5maWxsVGV4dCh0ZXh0LCBjYW52YXNXaWR0aCAqIChTQ0FMRSAtIDEpIC8gMiwgY2FudmFzSGVpZ2h0ICogKDMgLSBTQ0FMRSkgLyAyKTtcbiAgICBjb25zdCB1aW50OEJ1ZiA9IHRoaXMuI3RvVWludDgoY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KS5kYXRhKTtcbiAgICBjb25zdCBoaXN0b2dyYW0gPSB0aGlzLiNnZXRIaXN0b2dyYW0odWludDhCdWYpO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IHRoaXMuI2d1ZXNzVGhyZXNob2xkKGhpc3RvZ3JhbSk7XG4gICAgY29uc3QgY29udG91ckxpc3QgPSB0aGlzLiNmaW5kQ29udG91cnModWludDhCdWYsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQsIHRocmVzaG9sZCk7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc0RyYXduTGluZXMoe1xuICAgICAgbGluZXM6IHtcbiAgICAgICAgY3VydmVzOiBjb250b3VyTGlzdCxcbiAgICAgICAgd2lkdGg6IGNhbnZhc1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhc0hlaWdodFxuICAgICAgfSxcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICByb3RhdGlvbixcbiAgICAgIGlubmVyTWFyZ2luLFxuICAgICAgbXVzdFNtb290aDogdHJ1ZSxcbiAgICAgIGFyZUNvbnRvdXJzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIHByb2Nlc3MoYml0bWFwLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIHJvdGF0aW9uLCBpbm5lck1hcmdpbikge1xuICAgIGNvbnN0IFt1aW50OEJ1Ziwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNnZXRHcmF5UGl4ZWxzKGJpdG1hcCk7XG4gICAgY29uc3QgW2J1ZmZlciwgaGlzdG9ncmFtXSA9IHRoaXMuI2JpbGF0ZXJhbEZpbHRlcih1aW50OEJ1Ziwgd2lkdGgsIGhlaWdodCwgTWF0aC5oeXBvdCh3aWR0aCwgaGVpZ2h0KSAqIHRoaXMuI1BBUkFNRVRFUlMuc2lnbWFTRmFjdG9yLCB0aGlzLiNQQVJBTUVURVJTLnNpZ21hUiwgdGhpcy4jUEFSQU1FVEVSUy5rZXJuZWxTaXplKTtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSB0aGlzLiNndWVzc1RocmVzaG9sZChoaXN0b2dyYW0pO1xuICAgIGNvbnN0IGNvbnRvdXJMaXN0ID0gdGhpcy4jZmluZENvbnRvdXJzKGJ1ZmZlciwgd2lkdGgsIGhlaWdodCwgdGhyZXNob2xkKTtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzRHJhd25MaW5lcyh7XG4gICAgICBsaW5lczoge1xuICAgICAgICBjdXJ2ZXM6IGNvbnRvdXJMaXN0LFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9LFxuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgaW5uZXJNYXJnaW4sXG4gICAgICBtdXN0U21vb3RoOiB0cnVlLFxuICAgICAgYXJlQ29udG91cnM6IHRydWVcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgcHJvY2Vzc0RyYXduTGluZXMoe1xuICAgIGxpbmVzLFxuICAgIHBhZ2VXaWR0aCxcbiAgICBwYWdlSGVpZ2h0LFxuICAgIHJvdGF0aW9uLFxuICAgIGlubmVyTWFyZ2luLFxuICAgIG11c3RTbW9vdGgsXG4gICAgYXJlQ29udG91cnNcbiAgfSkge1xuICAgIGlmIChyb3RhdGlvbiAlIDE4MCAhPT0gMCkge1xuICAgICAgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSBbcGFnZUhlaWdodCwgcGFnZVdpZHRoXTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY3VydmVzLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gbGluZXM7XG4gICAgY29uc3QgdGhpY2tuZXNzID0gbGluZXMudGhpY2tuZXNzID8/IDA7XG4gICAgY29uc3QgbGluZXNBbmRQb2ludHMgPSBbXTtcbiAgICBjb25zdCByYXRpbyA9IE1hdGgubWluKHBhZ2VXaWR0aCAvIHdpZHRoLCBwYWdlSGVpZ2h0IC8gaGVpZ2h0KTtcbiAgICBjb25zdCB4U2NhbGUgPSByYXRpbyAvIHBhZ2VXaWR0aDtcbiAgICBjb25zdCB5U2NhbGUgPSByYXRpbyAvIHBhZ2VIZWlnaHQ7XG4gICAgY29uc3QgbmV3Q3VydmVzID0gW107XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBwb2ludHNcbiAgICB9IG9mIGN1cnZlcykge1xuICAgICAgY29uc3QgcmVkdWNlZFBvaW50cyA9IG11c3RTbW9vdGggPyB0aGlzLiNkb3VnbGFzUGV1Y2tlcihwb2ludHMpIDogcG9pbnRzO1xuICAgICAgaWYgKCFyZWR1Y2VkUG9pbnRzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbmV3Q3VydmVzLnB1c2gocmVkdWNlZFBvaW50cyk7XG4gICAgICBjb25zdCBsZW4gPSByZWR1Y2VkUG9pbnRzLmxlbmd0aDtcbiAgICAgIGNvbnN0IG5ld1BvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkobGVuKTtcbiAgICAgIGNvbnN0IGxpbmUgPSBuZXcgRmxvYXQzMkFycmF5KDMgKiAobGVuID09PSAyID8gMiA6IGxlbiAtIDIpKTtcbiAgICAgIGxpbmVzQW5kUG9pbnRzLnB1c2goe1xuICAgICAgICBsaW5lLFxuICAgICAgICBwb2ludHM6IG5ld1BvaW50c1xuICAgICAgfSk7XG4gICAgICBpZiAobGVuID09PSAyKSB7XG4gICAgICAgIG5ld1BvaW50c1swXSA9IHJlZHVjZWRQb2ludHNbMF0gKiB4U2NhbGU7XG4gICAgICAgIG5ld1BvaW50c1sxXSA9IHJlZHVjZWRQb2ludHNbMV0gKiB5U2NhbGU7XG4gICAgICAgIGxpbmUuc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIG5ld1BvaW50c1swXSwgbmV3UG9pbnRzWzFdXSwgMCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IFt4MSwgeTEsIHgyLCB5Ml0gPSByZWR1Y2VkUG9pbnRzO1xuICAgICAgeDEgKj0geFNjYWxlO1xuICAgICAgeTEgKj0geVNjYWxlO1xuICAgICAgeDIgKj0geFNjYWxlO1xuICAgICAgeTIgKj0geVNjYWxlO1xuICAgICAgbmV3UG9pbnRzLnNldChbeDEsIHkxLCB4MiwgeTJdLCAwKTtcbiAgICAgIGxpbmUuc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIHgxLCB5MV0sIDApO1xuICAgICAgZm9yIChsZXQgaSA9IDQ7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICBjb25zdCB4ID0gbmV3UG9pbnRzW2ldID0gcmVkdWNlZFBvaW50c1tpXSAqIHhTY2FsZTtcbiAgICAgICAgY29uc3QgeSA9IG5ld1BvaW50c1tpICsgMV0gPSByZWR1Y2VkUG9pbnRzW2kgKyAxXSAqIHlTY2FsZTtcbiAgICAgICAgbGluZS5zZXQoT3V0bGluZS5jcmVhdGVCZXppZXJQb2ludHMoeDEsIHkxLCB4MiwgeTIsIHgsIHkpLCAoaSAtIDIpICogMyk7XG4gICAgICAgIFt4MSwgeTEsIHgyLCB5Ml0gPSBbeDIsIHkyLCB4LCB5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxpbmVzQW5kUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG91dGxpbmUgPSBhcmVDb250b3VycyA/IG5ldyBDb250b3VyRHJhd091dGxpbmUoKSA6IG5ldyBJbmtEcmF3T3V0bGluZSgpO1xuICAgIG91dGxpbmUuYnVpbGQobGluZXNBbmRQb2ludHMsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgMSwgcm90YXRpb24sIGFyZUNvbnRvdXJzID8gMCA6IHRoaWNrbmVzcywgaW5uZXJNYXJnaW4pO1xuICAgIHJldHVybiB7XG4gICAgICBvdXRsaW5lLFxuICAgICAgbmV3Q3VydmVzLFxuICAgICAgYXJlQ29udG91cnMsXG4gICAgICB0aGlja25lc3MsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH07XG4gIH1cbiAgc3RhdGljIGFzeW5jIGNvbXByZXNzU2lnbmF0dXJlKHtcbiAgICBvdXRsaW5lcyxcbiAgICBhcmVDb250b3VycyxcbiAgICB0aGlja25lc3MsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0pIHtcbiAgICBsZXQgbWluRGlmZiA9IEluZmluaXR5O1xuICAgIGxldCBtYXhEaWZmID0gLUluZmluaXR5O1xuICAgIGxldCBvdXRsaW5lc0xlbmd0aCA9IDA7XG4gICAgZm9yIChjb25zdCBwb2ludHMgb2Ygb3V0bGluZXMpIHtcbiAgICAgIG91dGxpbmVzTGVuZ3RoICs9IHBvaW50cy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMiwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBjb25zdCBkeCA9IHBvaW50c1tpXSAtIHBvaW50c1tpIC0gMl07XG4gICAgICAgIG1pbkRpZmYgPSBNYXRoLm1pbihtaW5EaWZmLCBkeCk7XG4gICAgICAgIG1heERpZmYgPSBNYXRoLm1heChtYXhEaWZmLCBkeCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBidWZmZXJUeXBlO1xuICAgIGlmIChtaW5EaWZmID49IC0xMjggJiYgbWF4RGlmZiA8PSAxMjcpIHtcbiAgICAgIGJ1ZmZlclR5cGUgPSBJbnQ4QXJyYXk7XG4gICAgfSBlbHNlIGlmIChtaW5EaWZmID49IC0zMjc2OCAmJiBtYXhEaWZmIDw9IDMyNzY3KSB7XG4gICAgICBidWZmZXJUeXBlID0gSW50MTZBcnJheTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyVHlwZSA9IEludDMyQXJyYXk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IG91dGxpbmVzLmxlbmd0aDtcbiAgICBjb25zdCBoZWFkZXJMZW5ndGggPSBCQVNFX0hFQURFUl9MRU5HVEggKyBQT0lOVFNfUFJPUEVSVElFU19OVU1CRVIgKiBsZW47XG4gICAgY29uc3QgaGVhZGVyID0gbmV3IFVpbnQzMkFycmF5KGhlYWRlckxlbmd0aCk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgaGVhZGVyW29mZnNldCsrXSA9IGhlYWRlckxlbmd0aCAqIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICsgKG91dGxpbmVzTGVuZ3RoIC0gMiAqIGxlbikgKiBidWZmZXJUeXBlLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgIGhlYWRlcltvZmZzZXQrK10gPSAwO1xuICAgIGhlYWRlcltvZmZzZXQrK10gPSB3aWR0aDtcbiAgICBoZWFkZXJbb2Zmc2V0KytdID0gaGVpZ2h0O1xuICAgIGhlYWRlcltvZmZzZXQrK10gPSBhcmVDb250b3VycyA/IDAgOiAxO1xuICAgIGhlYWRlcltvZmZzZXQrK10gPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHRoaWNrbmVzcyA/PyAwKSk7XG4gICAgaGVhZGVyW29mZnNldCsrXSA9IGxlbjtcbiAgICBoZWFkZXJbb2Zmc2V0KytdID0gYnVmZmVyVHlwZS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICBmb3IgKGNvbnN0IHBvaW50cyBvZiBvdXRsaW5lcykge1xuICAgICAgaGVhZGVyW29mZnNldCsrXSA9IHBvaW50cy5sZW5ndGggLSAyO1xuICAgICAgaGVhZGVyW29mZnNldCsrXSA9IHBvaW50c1swXTtcbiAgICAgIGhlYWRlcltvZmZzZXQrK10gPSBwb2ludHNbMV07XG4gICAgfVxuICAgIGNvbnN0IGNzID0gbmV3IENvbXByZXNzaW9uU3RyZWFtKFwiZGVmbGF0ZS1yYXdcIik7XG4gICAgY29uc3Qgd3JpdGVyID0gY3Mud3JpdGFibGUuZ2V0V3JpdGVyKCk7XG4gICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgIHdyaXRlci53cml0ZShoZWFkZXIpO1xuICAgIGNvbnN0IEJ1ZmZlckN0b3IgPSBidWZmZXJUeXBlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcbiAgICBmb3IgKGNvbnN0IHBvaW50cyBvZiBvdXRsaW5lcykge1xuICAgICAgY29uc3QgZGlmZnMgPSBuZXcgQnVmZmVyQ3Rvcihwb2ludHMubGVuZ3RoIC0gMik7XG4gICAgICBmb3IgKGxldCBpID0gMiwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBkaWZmc1tpIC0gMl0gPSBwb2ludHNbaV0gLSBwb2ludHNbaSAtIDJdO1xuICAgICAgfVxuICAgICAgd3JpdGVyLndyaXRlKGRpZmZzKTtcbiAgICB9XG4gICAgd3JpdGVyLmNsb3NlKCk7XG4gICAgY29uc3QgYnVmID0gYXdhaXQgbmV3IFJlc3BvbnNlKGNzLnJlYWRhYmxlKS5hcnJheUJ1ZmZlcigpO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgICByZXR1cm4gdG9CYXNlNjRVdGlsKGJ5dGVzKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVjb21wcmVzc1NpZ25hdHVyZShzaWduYXR1cmVEYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gZnJvbUJhc2U2NFV0aWwoc2lnbmF0dXJlRGF0YSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlYWRhYmxlLFxuICAgICAgICB3cml0YWJsZVxuICAgICAgfSA9IG5ldyBEZWNvbXByZXNzaW9uU3RyZWFtKFwiZGVmbGF0ZS1yYXdcIik7XG4gICAgICBjb25zdCB3cml0ZXIgPSB3cml0YWJsZS5nZXRXcml0ZXIoKTtcbiAgICAgIGF3YWl0IHdyaXRlci5yZWFkeTtcbiAgICAgIHdyaXRlci53cml0ZShieXRlcykudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHdyaXRlci5yZWFkeTtcbiAgICAgICAgYXdhaXQgd3JpdGVyLmNsb3NlKCk7XG4gICAgICB9KS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgICBsZXQgZGF0YSA9IG51bGw7XG4gICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVhZGFibGUpIHtcbiAgICAgICAgZGF0YSB8fD0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KGNodW5rLmJ1ZmZlciwgMCwgNClbMF0pO1xuICAgICAgICBkYXRhLnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhlYWRlciA9IG5ldyBVaW50MzJBcnJheShkYXRhLmJ1ZmZlciwgMCwgZGF0YS5sZW5ndGggPj4gMik7XG4gICAgICBjb25zdCB2ZXJzaW9uID0gaGVhZGVyWzFdO1xuICAgICAgaWYgKHZlcnNpb24gIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZlcnNpb246ICR7dmVyc2lvbn1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdpZHRoID0gaGVhZGVyWzJdO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gaGVhZGVyWzNdO1xuICAgICAgY29uc3QgYXJlQ29udG91cnMgPSBoZWFkZXJbNF0gPT09IDA7XG4gICAgICBjb25zdCB0aGlja25lc3MgPSBoZWFkZXJbNV07XG4gICAgICBjb25zdCBudW1iZXJPZkRyYXdpbmdzID0gaGVhZGVyWzZdO1xuICAgICAgY29uc3QgYnVmZmVyVHlwZSA9IGhlYWRlcls3XTtcbiAgICAgIGNvbnN0IG91dGxpbmVzID0gW107XG4gICAgICBjb25zdCBkaWZmc09mZnNldCA9IChCQVNFX0hFQURFUl9MRU5HVEggKyBQT0lOVFNfUFJPUEVSVElFU19OVU1CRVIgKiBudW1iZXJPZkRyYXdpbmdzKSAqIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgbGV0IGRpZmZzO1xuICAgICAgc3dpdGNoIChidWZmZXJUeXBlKSB7XG4gICAgICAgIGNhc2UgSW50OEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UOlxuICAgICAgICAgIGRpZmZzID0gbmV3IEludDhBcnJheShkYXRhLmJ1ZmZlciwgZGlmZnNPZmZzZXQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEludDE2QXJyYXkuQllURVNfUEVSX0VMRU1FTlQ6XG4gICAgICAgICAgZGlmZnMgPSBuZXcgSW50MTZBcnJheShkYXRhLmJ1ZmZlciwgZGlmZnNPZmZzZXQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ6XG4gICAgICAgICAgZGlmZnMgPSBuZXcgSW50MzJBcnJheShkYXRhLmJ1ZmZlciwgZGlmZnNPZmZzZXQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZEcmF3aW5nczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IGhlYWRlcltQT0lOVFNfUFJPUEVSVElFU19OVU1CRVIgKiBpICsgQkFTRV9IRUFERVJfTEVOR1RIXTtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheShsZW4gKyAyKTtcbiAgICAgICAgb3V0bGluZXMucHVzaChwb2ludHMpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IFBPSU5UU19QUk9QRVJUSUVTX05VTUJFUiAtIDE7IGorKykge1xuICAgICAgICAgIHBvaW50c1tqXSA9IGhlYWRlcltQT0lOVFNfUFJPUEVSVElFU19OVU1CRVIgKiBpICsgQkFTRV9IRUFERVJfTEVOR1RIICsgaiArIDFdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICBwb2ludHNbaiArIDJdID0gcG9pbnRzW2pdICsgZGlmZnNbb2Zmc2V0KytdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhcmVDb250b3VycyxcbiAgICAgICAgdGhpY2tuZXNzLFxuICAgICAgICBvdXRsaW5lcyxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKGBkZWNvbXByZXNzU2lnbmF0dXJlOiAke2V9YCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL3NpZ25hdHVyZS5qc1xuXG5cblxuXG5cblxuXG5jbGFzcyBTaWduYXR1cmVPcHRpb25zIGV4dGVuZHMgRHJhd2luZ09wdGlvbnMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHN1cGVyLnVwZGF0ZVByb3BlcnRpZXMoe1xuICAgICAgZmlsbDogQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcixcbiAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IDBcbiAgICB9KTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBTaWduYXR1cmVPcHRpb25zKCk7XG4gICAgY2xvbmUudXBkYXRlQWxsKHRoaXMpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuY2xhc3MgRHJhd25TaWduYXR1cmVPcHRpb25zIGV4dGVuZHMgSW5rRHJhd2luZ09wdGlvbnMge1xuICBjb25zdHJ1Y3Rvcih2aWV3ZXJQYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIodmlld2VyUGFyYW1ldGVycyk7XG4gICAgc3VwZXIudXBkYXRlUHJvcGVydGllcyh7XG4gICAgICBzdHJva2U6IEFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3IsXG4gICAgICBcInN0cm9rZS13aWR0aFwiOiAxXG4gICAgfSk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgRHJhd25TaWduYXR1cmVPcHRpb25zKHRoaXMuX3ZpZXdQYXJhbWV0ZXJzKTtcbiAgICBjbG9uZS51cGRhdGVBbGwodGhpcyk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG5jbGFzcyBTaWduYXR1cmVFZGl0b3IgZXh0ZW5kcyBEcmF3aW5nRWRpdG9yIHtcbiAgI2lzRXh0cmFjdGVkID0gZmFsc2U7XG4gICNkZXNjcmlwdGlvbiA9IG51bGw7XG4gICNzaWduYXR1cmVEYXRhID0gbnVsbDtcbiAgI3NpZ25hdHVyZVVVSUQgPSBudWxsO1xuICBzdGF0aWMgX3R5cGUgPSBcInNpZ25hdHVyZVwiO1xuICBzdGF0aWMgX2VkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TSUdOQVRVUkU7XG4gIHN0YXRpYyBfZGVmYXVsdERyYXdpbmdPcHRpb25zID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbXVzdEJlQ29tbWl0dGVkOiB0cnVlLFxuICAgICAgbmFtZTogXCJzaWduYXR1cmVFZGl0b3JcIlxuICAgIH0pO1xuICAgIHRoaXMuX3dpbGxLZWVwQXNwZWN0UmF0aW8gPSB0cnVlO1xuICAgIHRoaXMuI3NpZ25hdHVyZURhdGEgPSBwYXJhbXMuc2lnbmF0dXJlRGF0YSB8fCBudWxsO1xuICAgIHRoaXMuI2Rlc2NyaXB0aW9uID0gbnVsbDtcbiAgICB0aGlzLmRlZmF1bHRMMTBuSWQgPSBcInBkZmpzLWVkaXRvci1zaWduYXR1cmUtZWRpdG9yMVwiO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcikge1xuICAgIEFubm90YXRpb25FZGl0b3IuaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpO1xuICAgIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucyA9IG5ldyBTaWduYXR1cmVPcHRpb25zKCk7XG4gICAgdGhpcy5fZGVmYXVsdERyYXduU2lnbmF0dXJlT3B0aW9ucyA9IG5ldyBEcmF3blNpZ25hdHVyZU9wdGlvbnModWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzKTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVmYXVsdERyYXdpbmdPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBjbG9uZSA9IHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucy5jbG9uZSgpO1xuICAgIGNsb25lLnVwZGF0ZVByb3BlcnRpZXMob3B0aW9ucyk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIHN0YXRpYyBnZXQgc3VwcG9ydE11bHRpcGxlRHJhd2luZ3MoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZXNNYXAoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcInR5cGVzTWFwXCIsIG5ldyBNYXAoKSk7XG4gIH1cbiAgc3RhdGljIGdldCBpc0RyYXdlcigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0IHRlbGVtZXRyeUZpbmFsRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzaWduYXR1cmVcIixcbiAgICAgIGhhc0Rlc2NyaXB0aW9uOiAhIXRoaXMuI2Rlc2NyaXB0aW9uXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgY29tcHV0ZVRlbGVtZXRyeUZpbmFsRGF0YShkYXRhKSB7XG4gICAgY29uc3QgaGFzRGVzY3JpcHRpb25TdGF0cyA9IGRhdGEuZ2V0KFwiaGFzRGVzY3JpcHRpb25cIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc0FsdFRleHQ6IGhhc0Rlc2NyaXB0aW9uU3RhdHMuZ2V0KHRydWUpID8/IDAsXG4gICAgICBoYXNOb0FsdFRleHQ6IGhhc0Rlc2NyaXB0aW9uU3RhdHMuZ2V0KGZhbHNlKSA/PyAwXG4gICAgfTtcbiAgfVxuICBnZXQgaXNSZXNpemFibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKCkge1xuICAgIGlmICh0aGlzLl9kcmF3SWQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIub25TY2FsZUNoYW5naW5nKCk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBsZXQgYmFzZVgsIGJhc2VZO1xuICAgIGNvbnN0IHtcbiAgICAgIF9pc0NvcHlcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoX2lzQ29weSkge1xuICAgICAgdGhpcy5faXNDb3B5ID0gZmFsc2U7XG4gICAgICBiYXNlWCA9IHRoaXMueDtcbiAgICAgIGJhc2VZID0gdGhpcy55O1xuICAgIH1cbiAgICBzdXBlci5yZW5kZXIoKTtcbiAgICBpZiAodGhpcy5fZHJhd0lkID09PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy4jc2lnbmF0dXJlRGF0YSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbGluZXMsXG4gICAgICAgICAgbXVzdFNtb290aCxcbiAgICAgICAgICBhcmVDb250b3VycyxcbiAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICB1dWlkLFxuICAgICAgICAgIGhlaWdodEluUGFnZVxuICAgICAgICB9ID0gdGhpcy4jc2lnbmF0dXJlRGF0YTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgICAgIHBhZ2VIZWlnaHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJvdGF0aW9uXG4gICAgICAgIH0gPSB0aGlzLnBhcmVudC52aWV3cG9ydDtcbiAgICAgICAgY29uc3Qgb3V0bGluZSA9IFNpZ25hdHVyZUV4dHJhY3Rvci5wcm9jZXNzRHJhd25MaW5lcyh7XG4gICAgICAgICAgbGluZXMsXG4gICAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaW5uZXJNYXJnaW46IFNpZ25hdHVyZUVkaXRvci5fSU5ORVJfTUFSR0lOLFxuICAgICAgICAgIG11c3RTbW9vdGgsXG4gICAgICAgICAgYXJlQ29udG91cnNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRkU2lnbmF0dXJlKG91dGxpbmUsIGhlaWdodEluUGFnZSwgZGVzY3JpcHRpb24sIHV1aWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWFyZ3NcIiwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5kaXYuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdWlNYW5hZ2VyLmdldFNpZ25hdHVyZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWFyZ3NcIiwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBkZXNjcmlwdGlvbjogdGhpcy4jZGVzY3JpcHRpb24gfHwgXCJcIlxuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoX2lzQ29weSkge1xuICAgICAgdGhpcy5faXNDb3B5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuX21vdmVBZnRlclBhc3RlKGJhc2VYLCBiYXNlWSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICBzZXRVdWlkKHV1aWQpIHtcbiAgICB0aGlzLiNzaWduYXR1cmVVVUlEID0gdXVpZDtcbiAgICB0aGlzLmFkZEVkaXRUb29sYmFyKCk7XG4gIH1cbiAgZ2V0VXVpZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2lnbmF0dXJlVVVJRDtcbiAgfVxuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Rlc2NyaXB0aW9uO1xuICB9XG4gIHNldCBkZXNjcmlwdGlvbihkZXNjcmlwdGlvbikge1xuICAgIHRoaXMuI2Rlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgaWYgKCF0aGlzLmRpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4tYXJnc1wiLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBkZXNjcmlwdGlvblxuICAgIH0pKTtcbiAgICBzdXBlci5hZGRFZGl0VG9vbGJhcigpLnRoZW4odG9vbGJhciA9PiB7XG4gICAgICB0b29sYmFyPy51cGRhdGVFZGl0U2lnbmF0dXJlQnV0dG9uKGRlc2NyaXB0aW9uKTtcbiAgICB9KTtcbiAgfVxuICBnZXRTaWduYXR1cmVQcmV2aWV3KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5ld0N1cnZlcyxcbiAgICAgIGFyZUNvbnRvdXJzLFxuICAgICAgdGhpY2tuZXNzLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy4jc2lnbmF0dXJlRGF0YTtcbiAgICBjb25zdCBtYXhEaW0gPSBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCBvdXRsaW5lRGF0YSA9IFNpZ25hdHVyZUV4dHJhY3Rvci5wcm9jZXNzRHJhd25MaW5lcyh7XG4gICAgICBsaW5lczoge1xuICAgICAgICBjdXJ2ZXM6IG5ld0N1cnZlcy5tYXAocG9pbnRzID0+ICh7XG4gICAgICAgICAgcG9pbnRzXG4gICAgICAgIH0pKSxcbiAgICAgICAgdGhpY2tuZXNzLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9LFxuICAgICAgcGFnZVdpZHRoOiBtYXhEaW0sXG4gICAgICBwYWdlSGVpZ2h0OiBtYXhEaW0sXG4gICAgICByb3RhdGlvbjogMCxcbiAgICAgIGlubmVyTWFyZ2luOiAwLFxuICAgICAgbXVzdFNtb290aDogZmFsc2UsXG4gICAgICBhcmVDb250b3Vyc1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBhcmVDb250b3VycyxcbiAgICAgIG91dGxpbmU6IG91dGxpbmVEYXRhLm91dGxpbmVcbiAgICB9O1xuICB9XG4gIGdldCB0b29sYmFyQnV0dG9ucygpIHtcbiAgICBpZiAodGhpcy5fdWlNYW5hZ2VyLnNpZ25hdHVyZU1hbmFnZXIpIHtcbiAgICAgIHJldHVybiBbW1wiZWRpdFNpZ25hdHVyZVwiLCB0aGlzLl91aU1hbmFnZXIuc2lnbmF0dXJlTWFuYWdlcl1dO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIudG9vbGJhckJ1dHRvbnM7XG4gIH1cbiAgYWRkU2lnbmF0dXJlKGRhdGEsIGhlaWdodEluUGFnZSwgZGVzY3JpcHRpb24sIHV1aWQpIHtcbiAgICBjb25zdCB7XG4gICAgICB4OiBzYXZlZFgsXG4gICAgICB5OiBzYXZlZFlcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBvdXRsaW5lXG4gICAgfSA9IHRoaXMuI3NpZ25hdHVyZURhdGEgPSBkYXRhO1xuICAgIHRoaXMuI2lzRXh0cmFjdGVkID0gb3V0bGluZSBpbnN0YW5jZW9mIENvbnRvdXJEcmF3T3V0bGluZTtcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgbGV0IGRyYXdpbmdPcHRpb25zO1xuICAgIGlmICh0aGlzLiNpc0V4dHJhY3RlZCkge1xuICAgICAgZHJhd2luZ09wdGlvbnMgPSBTaWduYXR1cmVFZGl0b3IuZ2V0RGVmYXVsdERyYXdpbmdPcHRpb25zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRyYXdpbmdPcHRpb25zID0gU2lnbmF0dXJlRWRpdG9yLl9kZWZhdWx0RHJhd25TaWduYXR1cmVPcHRpb25zLmNsb25lKCk7XG4gICAgICBkcmF3aW5nT3B0aW9ucy51cGRhdGVQcm9wZXJ0aWVzKHtcbiAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogb3V0bGluZS50aGlja25lc3NcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9hZGRPdXRsaW5lcyh7XG4gICAgICBkcmF3T3V0bGluZXM6IG91dGxpbmUsXG4gICAgICBkcmF3aW5nT3B0aW9uc1xuICAgIH0pO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCBbLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgbGV0IG5ld0hlaWdodCA9IGhlaWdodEluUGFnZSAvIHBhZ2VIZWlnaHQ7XG4gICAgbmV3SGVpZ2h0ID0gbmV3SGVpZ2h0ID49IDEgPyAwLjUgOiBuZXdIZWlnaHQ7XG4gICAgdGhpcy53aWR0aCAqPSBuZXdIZWlnaHQgLyB0aGlzLmhlaWdodDtcbiAgICBpZiAodGhpcy53aWR0aCA+PSAxKSB7XG4gICAgICBuZXdIZWlnaHQgKj0gMC45IC8gdGhpcy53aWR0aDtcbiAgICAgIHRoaXMud2lkdGggPSAwLjk7XG4gICAgfVxuICAgIHRoaXMuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgIHRoaXMuc2V0RGltcyhwYXJlbnRXaWR0aCAqIHRoaXMud2lkdGgsIHBhcmVudEhlaWdodCAqIHRoaXMuaGVpZ2h0KTtcbiAgICB0aGlzLnggPSBzYXZlZFg7XG4gICAgdGhpcy55ID0gc2F2ZWRZO1xuICAgIHRoaXMuY2VudGVyKCk7XG4gICAgdGhpcy5fb25SZXNpemVkKCk7XG4gICAgdGhpcy5vblNjYWxlQ2hhbmdpbmcoKTtcbiAgICB0aGlzLnJvdGF0ZSgpO1xuICAgIHRoaXMuX3VpTWFuYWdlci5hZGRUb0Fubm90YXRpb25TdG9yYWdlKHRoaXMpO1xuICAgIHRoaXMuc2V0VXVpZCh1dWlkKTtcbiAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgYWN0aW9uOiBcInBkZmpzLnNpZ25hdHVyZS5pbnNlcnRlZFwiLFxuICAgICAgZGF0YToge1xuICAgICAgICBoYXNCZWVuU2F2ZWQ6ICEhdXVpZCxcbiAgICAgICAgaGFzRGVzY3JpcHRpb246ICEhZGVzY3JpcHRpb25cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgfVxuICBnZXRGcm9tSW1hZ2UoYml0bWFwKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmF3RGltczoge1xuICAgICAgICBwYWdlV2lkdGgsXG4gICAgICAgIHBhZ2VIZWlnaHRcbiAgICAgIH0sXG4gICAgICByb3RhdGlvblxuICAgIH0gPSB0aGlzLnBhcmVudC52aWV3cG9ydDtcbiAgICByZXR1cm4gU2lnbmF0dXJlRXh0cmFjdG9yLnByb2Nlc3MoYml0bWFwLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIHJvdGF0aW9uLCBTaWduYXR1cmVFZGl0b3IuX0lOTkVSX01BUkdJTik7XG4gIH1cbiAgZ2V0RnJvbVRleHQodGV4dCwgZm9udEluZm8pIHtcbiAgICBjb25zdCB7XG4gICAgICByYXdEaW1zOiB7XG4gICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgcGFnZUhlaWdodFxuICAgICAgfSxcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IHRoaXMucGFyZW50LnZpZXdwb3J0O1xuICAgIHJldHVybiBTaWduYXR1cmVFeHRyYWN0b3IuZXh0cmFjdENvbnRvdXJzRnJvbVRleHQodGV4dCwgZm9udEluZm8sIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgcm90YXRpb24sIFNpZ25hdHVyZUVkaXRvci5fSU5ORVJfTUFSR0lOKTtcbiAgfVxuICBnZXREcmF3blNpZ25hdHVyZShjdXJ2ZXMpIHtcbiAgICBjb25zdCB7XG4gICAgICByYXdEaW1zOiB7XG4gICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgcGFnZUhlaWdodFxuICAgICAgfSxcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IHRoaXMucGFyZW50LnZpZXdwb3J0O1xuICAgIHJldHVybiBTaWduYXR1cmVFeHRyYWN0b3IucHJvY2Vzc0RyYXduTGluZXMoe1xuICAgICAgbGluZXM6IGN1cnZlcyxcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICByb3RhdGlvbixcbiAgICAgIGlubmVyTWFyZ2luOiBTaWduYXR1cmVFZGl0b3IuX0lOTkVSX01BUkdJTixcbiAgICAgIG11c3RTbW9vdGg6IGZhbHNlLFxuICAgICAgYXJlQ29udG91cnM6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlRHJhd2luZ09wdGlvbnMoe1xuICAgIGFyZUNvbnRvdXJzLFxuICAgIHRoaWNrbmVzc1xuICB9KSB7XG4gICAgaWYgKGFyZUNvbnRvdXJzKSB7XG4gICAgICB0aGlzLl9kcmF3aW5nT3B0aW9ucyA9IFNpZ25hdHVyZUVkaXRvci5nZXREZWZhdWx0RHJhd2luZ09wdGlvbnMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZHJhd2luZ09wdGlvbnMgPSBTaWduYXR1cmVFZGl0b3IuX2RlZmF1bHREcmF3blNpZ25hdHVyZU9wdGlvbnMuY2xvbmUoKTtcbiAgICAgIHRoaXMuX2RyYXdpbmdPcHRpb25zLnVwZGF0ZVByb3BlcnRpZXMoe1xuICAgICAgICBcInN0cm9rZS13aWR0aFwiOiB0aGlja25lc3NcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBsaW5lcyxcbiAgICAgIHBvaW50cyxcbiAgICAgIHJlY3RcbiAgICB9ID0gdGhpcy5zZXJpYWxpemVEcmF3KGlzRm9yQ29weWluZyk7XG4gICAgY29uc3Qge1xuICAgICAgX2RyYXdpbmdPcHRpb25zOiB7XG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHRoaWNrbmVzc1xuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuU0lHTkFUVVJFLFxuICAgICAgaXNTaWduYXR1cmU6IHRydWUsXG4gICAgICBhcmVDb250b3VyczogdGhpcy4jaXNFeHRyYWN0ZWQsXG4gICAgICBjb2xvcjogWzAsIDAsIDBdLFxuICAgICAgdGhpY2tuZXNzOiB0aGlzLiNpc0V4dHJhY3RlZCA/IDAgOiB0aGlja25lc3MsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4LFxuICAgICAgcmVjdCxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxuICAgICAgc3RydWN0VHJlZVBhcmVudElkOiB0aGlzLl9zdHJ1Y3RUcmVlUGFyZW50SWRcbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWVudChzZXJpYWxpemVkKTtcbiAgICBpZiAoaXNGb3JDb3B5aW5nKSB7XG4gICAgICBzZXJpYWxpemVkLnBhdGhzID0ge1xuICAgICAgICBsaW5lcyxcbiAgICAgICAgcG9pbnRzXG4gICAgICB9O1xuICAgICAgc2VyaWFsaXplZC51dWlkID0gdGhpcy4jc2lnbmF0dXJlVVVJRDtcbiAgICAgIHNlcmlhbGl6ZWQuaXNDb3B5ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWFsaXplZC5saW5lcyA9IGxpbmVzO1xuICAgIH1cbiAgICBpZiAodGhpcy4jZGVzY3JpcHRpb24pIHtcbiAgICAgIHNlcmlhbGl6ZWQuYWNjZXNzaWJpbGl0eURhdGEgPSB7XG4gICAgICAgIHR5cGU6IFwiRmlndXJlXCIsXG4gICAgICAgIGFsdDogdGhpcy4jZGVzY3JpcHRpb25cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZURyYXcocGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIGlubmVyTWFyZ2luLCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuYXJlQ29udG91cnMpIHtcbiAgICAgIHJldHVybiBDb250b3VyRHJhd091dGxpbmUuZGVzZXJpYWxpemUocGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIGlubmVyTWFyZ2luLCBkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIElua0RyYXdPdXRsaW5lLmRlc2VyaWFsaXplKHBhZ2VYLCBwYWdlWSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCBpbm5lck1hcmdpbiwgZGF0YSk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgY29uc3QgZWRpdG9yID0gYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGVkaXRvci4jaXNFeHRyYWN0ZWQgPSBkYXRhLmFyZUNvbnRvdXJzO1xuICAgIGVkaXRvci5kZXNjcmlwdGlvbiA9IGRhdGEuYWNjZXNzaWJpbGl0eURhdGE/LmFsdCB8fCBcIlwiO1xuICAgIGVkaXRvci4jc2lnbmF0dXJlVVVJRCA9IGRhdGEudXVpZDtcbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9zdGFtcC5qc1xuXG5cblxuXG5jbGFzcyBTdGFtcEVkaXRvciBleHRlbmRzIEFubm90YXRpb25FZGl0b3Ige1xuICAjYml0bWFwID0gbnVsbDtcbiAgI2JpdG1hcElkID0gbnVsbDtcbiAgI2JpdG1hcFByb21pc2UgPSBudWxsO1xuICAjYml0bWFwVXJsID0gbnVsbDtcbiAgI2JpdG1hcEZpbGUgPSBudWxsO1xuICAjYml0bWFwRmlsZU5hbWUgPSBcIlwiO1xuICAjY2FudmFzID0gbnVsbDtcbiAgI21pc3NpbmdDYW52YXMgPSBmYWxzZTtcbiAgI3Jlc2l6ZVRpbWVvdXRJZCA9IG51bGw7XG4gICNpc1N2ZyA9IGZhbHNlO1xuICAjaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2sgPSBmYWxzZTtcbiAgc3RhdGljIF90eXBlID0gXCJzdGFtcFwiO1xuICBzdGF0aWMgX2VkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUDtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJzdGFtcEVkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy4jYml0bWFwVXJsID0gcGFyYW1zLmJpdG1hcFVybDtcbiAgICB0aGlzLiNiaXRtYXBGaWxlID0gcGFyYW1zLmJpdG1hcEZpbGU7XG4gICAgdGhpcy5kZWZhdWx0TDEwbklkID0gXCJwZGZqcy1lZGl0b3Itc3RhbXAtZWRpdG9yXCI7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5pbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcik7XG4gIH1cbiAgc3RhdGljIGlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyhtaW1lKSB7XG4gICAgcmV0dXJuIFN1cHBvcnRlZEltYWdlTWltZVR5cGVzLmluY2x1ZGVzKG1pbWUpO1xuICB9XG4gIHN0YXRpYyBwYXN0ZShpdGVtLCBwYXJlbnQpIHtcbiAgICBwYXJlbnQucGFzdGVFZGl0b3Ioe1xuICAgICAgbW9kZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVBcbiAgICB9LCB7XG4gICAgICBiaXRtYXBGaWxlOiBpdGVtLmdldEFzRmlsZSgpXG4gICAgfSk7XG4gIH1cbiAgYWx0VGV4dEZpbmlzaCgpIHtcbiAgICBpZiAodGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRGbG93KSB7XG4gICAgICB0aGlzLmRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gICAgc3VwZXIuYWx0VGV4dEZpbmlzaCgpO1xuICB9XG4gIGdldCB0ZWxlbWV0cnlGaW5hbERhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3RhbXBcIixcbiAgICAgIGhhc0FsdFRleHQ6ICEhdGhpcy5hbHRUZXh0RGF0YT8uYWx0VGV4dFxuICAgIH07XG4gIH1cbiAgc3RhdGljIGNvbXB1dGVUZWxlbWV0cnlGaW5hbERhdGEoZGF0YSkge1xuICAgIGNvbnN0IGhhc0FsdFRleHRTdGF0cyA9IGRhdGEuZ2V0KFwiaGFzQWx0VGV4dFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgaGFzQWx0VGV4dDogaGFzQWx0VGV4dFN0YXRzLmdldCh0cnVlKSA/PyAwLFxuICAgICAgaGFzTm9BbHRUZXh0OiBoYXNBbHRUZXh0U3RhdHMuZ2V0KGZhbHNlKSA/PyAwXG4gICAgfTtcbiAgfVxuICAjZ2V0Qml0bWFwRmV0Y2hlZChkYXRhLCBmcm9tSWQgPSBmYWxzZSkge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYml0bWFwID0gZGF0YS5iaXRtYXA7XG4gICAgaWYgKCFmcm9tSWQpIHtcbiAgICAgIHRoaXMuI2JpdG1hcElkID0gZGF0YS5pZDtcbiAgICAgIHRoaXMuI2lzU3ZnID0gZGF0YS5pc1N2ZztcbiAgICB9XG4gICAgaWYgKGRhdGEuZmlsZSkge1xuICAgICAgdGhpcy4jYml0bWFwRmlsZU5hbWUgPSBkYXRhLmZpbGUubmFtZTtcbiAgICB9XG4gICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gIH1cbiAgI2dldEJpdG1hcERvbmUoKSB7XG4gICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcoZmFsc2UpO1xuICAgIGlmICghdGhpcy4jY2FudmFzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSAmJiB0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dEZsb3cgJiYgdGhpcy4jYml0bWFwKSB7XG4gICAgICB0aGlzLmFkZEVkaXRUb29sYmFyKCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuX2VkaXRUb29sYmFyLmhpZGUoKTtcbiAgICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVkaXRBbHRUZXh0KHRoaXMsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UgJiYgdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRGbG93ICYmIHRoaXMuI2JpdG1hcCkge1xuICAgICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgICAgYWN0aW9uOiBcInBkZmpzLmltYWdlLmltYWdlX2FkZGVkXCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBhbHRfdGV4dF9tb2RhbDogZmFsc2UsXG4gICAgICAgICAgYWx0X3RleHRfdHlwZTogXCJlbXB0eVwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5tbEd1ZXNzQWx0VGV4dCgpO1xuICAgICAgfSBjYXRjaCB7fVxuICAgIH1cbiAgICB0aGlzLmRpdi5mb2N1cygpO1xuICB9XG4gIGFzeW5jIG1sR3Vlc3NBbHRUZXh0KGltYWdlRGF0YSA9IG51bGwsIHVwZGF0ZUFsdFRleHREYXRhID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLmhhc0FsdFRleHREYXRhKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBtbE1hbmFnZXJcbiAgICB9ID0gdGhpcy5fdWlNYW5hZ2VyO1xuICAgIGlmICghbWxNYW5hZ2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBNTC5cIik7XG4gICAgfVxuICAgIGlmICghKGF3YWl0IG1sTWFuYWdlci5pc0VuYWJsZWRGb3IoXCJhbHRUZXh0XCIpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTUwgaXNuJ3QgZW5hYmxlZCBmb3IgYWx0IHRleHQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gaW1hZ2VEYXRhIHx8IHRoaXMuY29weUNhbnZhcyhudWxsLCBudWxsLCB0cnVlKS5pbWFnZURhdGE7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtbE1hbmFnZXIuZ3Vlc3Moe1xuICAgICAgbmFtZTogXCJhbHRUZXh0XCIsXG4gICAgICByZXF1ZXN0OiB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGNoYW5uZWxzOiBkYXRhLmxlbmd0aCAvICh3aWR0aCAqIGhlaWdodClcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZXNwb25zZSBmcm9tIHRoZSBBSSBzZXJ2aWNlLlwiKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBmcm9tIHRoZSBBSSBzZXJ2aWNlLlwiKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLmNhbmNlbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2Uub3V0cHV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB2YWxpZCByZXNwb25zZSBmcm9tIHRoZSBBSSBzZXJ2aWNlLlwiKTtcbiAgICB9XG4gICAgY29uc3QgYWx0VGV4dCA9IHJlc3BvbnNlLm91dHB1dDtcbiAgICBhd2FpdCB0aGlzLnNldEd1ZXNzZWRBbHRUZXh0KGFsdFRleHQpO1xuICAgIGlmICh1cGRhdGVBbHRUZXh0RGF0YSAmJiAhdGhpcy5oYXNBbHRUZXh0RGF0YSgpKSB7XG4gICAgICB0aGlzLmFsdFRleHREYXRhID0ge1xuICAgICAgICBhbHQ6IGFsdFRleHQsXG4gICAgICAgIGRlY29yYXRpdmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYWx0VGV4dDtcbiAgfVxuICAjZ2V0Qml0bWFwKCkge1xuICAgIGlmICh0aGlzLiNiaXRtYXBJZCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcodHJ1ZSk7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21JZCh0aGlzLiNiaXRtYXBJZCkudGhlbihkYXRhID0+IHRoaXMuI2dldEJpdG1hcEZldGNoZWQoZGF0YSwgdHJ1ZSkpLmZpbmFsbHkoKCkgPT4gdGhpcy4jZ2V0Qml0bWFwRG9uZSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2JpdG1hcFVybCkge1xuICAgICAgY29uc3QgdXJsID0gdGhpcy4jYml0bWFwVXJsO1xuICAgICAgdGhpcy4jYml0bWFwVXJsID0gbnVsbDtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKHRydWUpO1xuICAgICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0RnJvbVVybCh1cmwpLnRoZW4oZGF0YSA9PiB0aGlzLiNnZXRCaXRtYXBGZXRjaGVkKGRhdGEpKS5maW5hbGx5KCgpID0+IHRoaXMuI2dldEJpdG1hcERvbmUoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNiaXRtYXBGaWxlKSB7XG4gICAgICBjb25zdCBmaWxlID0gdGhpcy4jYml0bWFwRmlsZTtcbiAgICAgIHRoaXMuI2JpdG1hcEZpbGUgPSBudWxsO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcodHJ1ZSk7XG4gICAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tRmlsZShmaWxlKS50aGVuKGRhdGEgPT4gdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhKSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBpbnB1dC50eXBlID0gXCJmaWxlXCI7XG4gICAgaW5wdXQuYWNjZXB0ID0gU3VwcG9ydGVkSW1hZ2VNaW1lVHlwZXMuam9pbihcIixcIik7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICghaW5wdXQuZmlsZXMgfHwgaW5wdXQuZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyh0cnVlKTtcbiAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tRmlsZShpbnB1dC5maWxlc1swXSk7XG4gICAgICAgICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgICAgICAgIGFjdGlvbjogXCJwZGZqcy5pbWFnZS5pbWFnZV9zZWxlY3RlZFwiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBhbHRfdGV4dF9tb2RhbDogdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRGbG93XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2FuY2VsXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4gdGhpcy4jZ2V0Qml0bWFwRG9uZSgpKTtcbiAgICBpbnB1dC5jbGljaygpO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy4jYml0bWFwSWQpIHtcbiAgICAgIHRoaXMuI2JpdG1hcCA9IG51bGw7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmRlbGV0ZUlkKHRoaXMuI2JpdG1hcElkKTtcbiAgICAgIHRoaXMuI2NhbnZhcz8ucmVtb3ZlKCk7XG4gICAgICB0aGlzLiNjYW52YXMgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy4jcmVzaXplVGltZW91dElkKTtcbiAgICAgICAgdGhpcy4jcmVzaXplVGltZW91dElkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIucmVtb3ZlKCk7XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICBpZiAodGhpcy4jYml0bWFwSWQpIHtcbiAgICAgICAgdGhpcy4jZ2V0Qml0bWFwKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYnVpbGQoKTtcbiAgICBpZiAodGhpcy5kaXYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2JpdG1hcElkICYmIHRoaXMuI2NhbnZhcyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy4jZ2V0Qml0bWFwKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgb25jZUFkZGVkKGZvY3VzKSB7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgIGlmIChmb2N1cykge1xuICAgICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gISh0aGlzLiNiaXRtYXBQcm9taXNlIHx8IHRoaXMuI2JpdG1hcCB8fCB0aGlzLiNiaXRtYXBVcmwgfHwgdGhpcy4jYml0bWFwRmlsZSB8fCB0aGlzLiNiaXRtYXBJZCB8fCB0aGlzLiNtaXNzaW5nQ2FudmFzKTtcbiAgfVxuICBnZXQgdG9vbGJhckJ1dHRvbnMoKSB7XG4gICAgcmV0dXJuIFtbXCJhbHRUZXh0XCIsIHRoaXMuY3JlYXRlQWx0VGV4dCgpXV07XG4gIH1cbiAgZ2V0IGlzUmVzaXphYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdjtcbiAgICB9XG4gICAgbGV0IGJhc2VYLCBiYXNlWTtcbiAgICBpZiAodGhpcy5faXNDb3B5KSB7XG4gICAgICBiYXNlWCA9IHRoaXMueDtcbiAgICAgIGJhc2VZID0gdGhpcy55O1xuICAgIH1cbiAgICBzdXBlci5yZW5kZXIoKTtcbiAgICB0aGlzLmRpdi5oaWRkZW4gPSB0cnVlO1xuICAgIHRoaXMuY3JlYXRlQWx0VGV4dCgpO1xuICAgIGlmICghdGhpcy4jbWlzc2luZ0NhbnZhcykge1xuICAgICAgaWYgKHRoaXMuI2JpdG1hcCkge1xuICAgICAgICB0aGlzLiNjcmVhdGVDYW52YXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuI2dldEJpdG1hcCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5faXNDb3B5KSB7XG4gICAgICB0aGlzLl9tb3ZlQWZ0ZXJQYXN0ZShiYXNlWCwgYmFzZVkpO1xuICAgIH1cbiAgICB0aGlzLl91aU1hbmFnZXIuYWRkU2hvdWxkUmVzY2FsZSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgc2V0Q2FudmFzKGFubm90YXRpb25FbGVtZW50SWQsIGNhbnZhcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkOiBiaXRtYXBJZCxcbiAgICAgIGJpdG1hcFxuICAgIH0gPSB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21DYW52YXMoYW5ub3RhdGlvbkVsZW1lbnRJZCwgY2FudmFzKTtcbiAgICBjYW52YXMucmVtb3ZlKCk7XG4gICAgaWYgKGJpdG1hcElkICYmIHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuaXNWYWxpZElkKGJpdG1hcElkKSkge1xuICAgICAgdGhpcy4jYml0bWFwSWQgPSBiaXRtYXBJZDtcbiAgICAgIGlmIChiaXRtYXApIHtcbiAgICAgICAgdGhpcy4jYml0bWFwID0gYml0bWFwO1xuICAgICAgfVxuICAgICAgdGhpcy4jbWlzc2luZ0NhbnZhcyA9IGZhbHNlO1xuICAgICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gICAgfVxuICB9XG4gIF9vblJlc2l6ZWQoKSB7XG4gICAgdGhpcy5vblNjYWxlQ2hhbmdpbmcoKTtcbiAgfVxuICBvblNjYWxlQ2hhbmdpbmcoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jcmVzaXplVGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jcmVzaXplVGltZW91dElkKTtcbiAgICB9XG4gICAgY29uc3QgVElNRV9UT19XQUlUID0gMjAwO1xuICAgIHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy4jcmVzaXplVGltZW91dElkID0gbnVsbDtcbiAgICAgIHRoaXMuI2RyYXdCaXRtYXAoKTtcbiAgICB9LCBUSU1FX1RPX1dBSVQpO1xuICB9XG4gICNjcmVhdGVDYW52YXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGl2XG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuI2JpdG1hcDtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgTUFYX1JBVElPID0gMC43NTtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgd2lkdGggPSB0aGlzLndpZHRoICogcGFnZVdpZHRoO1xuICAgICAgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAod2lkdGggPiBNQVhfUkFUSU8gKiBwYWdlV2lkdGggfHwgaGVpZ2h0ID4gTUFYX1JBVElPICogcGFnZUhlaWdodCkge1xuICAgICAgY29uc3QgZmFjdG9yID0gTWF0aC5taW4oTUFYX1JBVElPICogcGFnZVdpZHRoIC8gd2lkdGgsIE1BWF9SQVRJTyAqIHBhZ2VIZWlnaHQgLyBoZWlnaHQpO1xuICAgICAgd2lkdGggKj0gZmFjdG9yO1xuICAgICAgaGVpZ2h0ICo9IGZhY3RvcjtcbiAgICB9XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMuc2V0RGltcyh3aWR0aCAqIHBhcmVudFdpZHRoIC8gcGFnZVdpZHRoLCBoZWlnaHQgKiBwYXJlbnRIZWlnaHQgLyBwYWdlSGVpZ2h0KTtcbiAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyhmYWxzZSk7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy4jY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImltZ1wiKTtcbiAgICB0aGlzLmFkZENvbnRhaW5lcihjYW52YXMpO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCAvIHBhZ2VXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAvIHBhZ2VIZWlnaHQ7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxPcHRpb25zPy5pc0NlbnRlcmVkKSB7XG4gICAgICB0aGlzLmNlbnRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxPcHRpb25zID0gbnVsbDtcbiAgICBpZiAoIXRoaXMuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlIHx8ICF0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dEZsb3cgfHwgdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICBkaXYuaGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuI2RyYXdCaXRtYXAoKTtcbiAgICBpZiAoIXRoaXMuI2hhc0JlZW5BZGRlZEluVW5kb1N0YWNrKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGRVbmRvYWJsZUVkaXRvcih0aGlzKTtcbiAgICAgIHRoaXMuI2hhc0JlZW5BZGRlZEluVW5kb1N0YWNrID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgIGFjdGlvbjogXCJpbnNlcnRlZF9pbWFnZVwiXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuI2JpdG1hcEZpbGVOYW1lKSB7XG4gICAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaXB0aW9uXCIsIHRoaXMuI2JpdG1hcEZpbGVOYW1lKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5hMTF5QWxlcnQoXCJwZGZqcy1lZGl0b3Itc3RhbXAtYWRkZWQtYWxlcnRcIik7XG4gICAgfVxuICB9XG4gIGNvcHlDYW52YXMobWF4RGF0YURpbWVuc2lvbiwgbWF4UHJldmlld0RpbWVuc2lvbiwgY3JlYXRlSW1hZ2VEYXRhID0gZmFsc2UpIHtcbiAgICBpZiAoIW1heERhdGFEaW1lbnNpb24pIHtcbiAgICAgIG1heERhdGFEaW1lbnNpb24gPSAyMjQ7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoOiBiaXRtYXBXaWR0aCxcbiAgICAgIGhlaWdodDogYml0bWFwSGVpZ2h0XG4gICAgfSA9IHRoaXMuI2JpdG1hcDtcbiAgICBjb25zdCBvdXRwdXRTY2FsZSA9IG5ldyBPdXRwdXRTY2FsZSgpO1xuICAgIGxldCBiaXRtYXAgPSB0aGlzLiNiaXRtYXA7XG4gICAgbGV0IHdpZHRoID0gYml0bWFwV2lkdGgsXG4gICAgICBoZWlnaHQgPSBiaXRtYXBIZWlnaHQ7XG4gICAgbGV0IGNhbnZhcyA9IG51bGw7XG4gICAgaWYgKG1heFByZXZpZXdEaW1lbnNpb24pIHtcbiAgICAgIGlmIChiaXRtYXBXaWR0aCA+IG1heFByZXZpZXdEaW1lbnNpb24gfHwgYml0bWFwSGVpZ2h0ID4gbWF4UHJldmlld0RpbWVuc2lvbikge1xuICAgICAgICBjb25zdCByYXRpbyA9IE1hdGgubWluKG1heFByZXZpZXdEaW1lbnNpb24gLyBiaXRtYXBXaWR0aCwgbWF4UHJldmlld0RpbWVuc2lvbiAvIGJpdG1hcEhlaWdodCk7XG4gICAgICAgIHdpZHRoID0gTWF0aC5mbG9vcihiaXRtYXBXaWR0aCAqIHJhdGlvKTtcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5mbG9vcihiaXRtYXBIZWlnaHQgKiByYXRpbyk7XG4gICAgICB9XG4gICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgY29uc3Qgc2NhbGVkV2lkdGggPSBjYW52YXMud2lkdGggPSBNYXRoLmNlaWwod2lkdGggKiBvdXRwdXRTY2FsZS5zeCk7XG4gICAgICBjb25zdCBzY2FsZWRIZWlnaHQgPSBjYW52YXMuaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCAqIG91dHB1dFNjYWxlLnN5KTtcbiAgICAgIGlmICghdGhpcy4jaXNTdmcpIHtcbiAgICAgICAgYml0bWFwID0gdGhpcy4jc2NhbGVCaXRtYXAoc2NhbGVkV2lkdGgsIHNjYWxlZEhlaWdodCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LmZpbHRlciA9IHRoaXMuX3VpTWFuYWdlci5oY21GaWx0ZXI7XG4gICAgICBsZXQgd2hpdGUgPSBcIndoaXRlXCIsXG4gICAgICAgIGJsYWNrID0gXCIjY2ZjZmQ4XCI7XG4gICAgICBpZiAodGhpcy5fdWlNYW5hZ2VyLmhjbUZpbHRlciAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgYmxhY2sgPSBcImJsYWNrXCI7XG4gICAgICB9IGVsc2UgaWYgKHdpbmRvdy5tYXRjaE1lZGlhPy4oXCIocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspXCIpLm1hdGNoZXMpIHtcbiAgICAgICAgd2hpdGUgPSBcIiM4ZjhmOWRcIjtcbiAgICAgICAgYmxhY2sgPSBcIiM0MjQxNGRcIjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJveERpbSA9IDE1O1xuICAgICAgY29uc3QgYm94RGltV2lkdGggPSBib3hEaW0gKiBvdXRwdXRTY2FsZS5zeDtcbiAgICAgIGNvbnN0IGJveERpbUhlaWdodCA9IGJveERpbSAqIG91dHB1dFNjYWxlLnN5O1xuICAgICAgY29uc3QgcGF0dGVybiA9IG5ldyBPZmZzY3JlZW5DYW52YXMoYm94RGltV2lkdGggKiAyLCBib3hEaW1IZWlnaHQgKiAyKTtcbiAgICAgIGNvbnN0IHBhdHRlcm5DdHggPSBwYXR0ZXJuLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIHBhdHRlcm5DdHguZmlsbFN0eWxlID0gd2hpdGU7XG4gICAgICBwYXR0ZXJuQ3R4LmZpbGxSZWN0KDAsIDAsIGJveERpbVdpZHRoICogMiwgYm94RGltSGVpZ2h0ICogMik7XG4gICAgICBwYXR0ZXJuQ3R4LmZpbGxTdHlsZSA9IGJsYWNrO1xuICAgICAgcGF0dGVybkN0eC5maWxsUmVjdCgwLCAwLCBib3hEaW1XaWR0aCwgYm94RGltSGVpZ2h0KTtcbiAgICAgIHBhdHRlcm5DdHguZmlsbFJlY3QoYm94RGltV2lkdGgsIGJveERpbUhlaWdodCwgYm94RGltV2lkdGgsIGJveERpbUhlaWdodCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gY3R4LmNyZWF0ZVBhdHRlcm4ocGF0dGVybiwgXCJyZXBlYXRcIik7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgc2NhbGVkV2lkdGgsIHNjYWxlZEhlaWdodCk7XG4gICAgICBjdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCwgYml0bWFwLndpZHRoLCBiaXRtYXAuaGVpZ2h0LCAwLCAwLCBzY2FsZWRXaWR0aCwgc2NhbGVkSGVpZ2h0KTtcbiAgICB9XG4gICAgbGV0IGltYWdlRGF0YSA9IG51bGw7XG4gICAgaWYgKGNyZWF0ZUltYWdlRGF0YSkge1xuICAgICAgbGV0IGRhdGFXaWR0aCwgZGF0YUhlaWdodDtcbiAgICAgIGlmIChvdXRwdXRTY2FsZS5zeW1tZXRyaWMgJiYgYml0bWFwLndpZHRoIDwgbWF4RGF0YURpbWVuc2lvbiAmJiBiaXRtYXAuaGVpZ2h0IDwgbWF4RGF0YURpbWVuc2lvbikge1xuICAgICAgICBkYXRhV2lkdGggPSBiaXRtYXAud2lkdGg7XG4gICAgICAgIGRhdGFIZWlnaHQgPSBiaXRtYXAuaGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYml0bWFwID0gdGhpcy4jYml0bWFwO1xuICAgICAgICBpZiAoYml0bWFwV2lkdGggPiBtYXhEYXRhRGltZW5zaW9uIHx8IGJpdG1hcEhlaWdodCA+IG1heERhdGFEaW1lbnNpb24pIHtcbiAgICAgICAgICBjb25zdCByYXRpbyA9IE1hdGgubWluKG1heERhdGFEaW1lbnNpb24gLyBiaXRtYXBXaWR0aCwgbWF4RGF0YURpbWVuc2lvbiAvIGJpdG1hcEhlaWdodCk7XG4gICAgICAgICAgZGF0YVdpZHRoID0gTWF0aC5mbG9vcihiaXRtYXBXaWR0aCAqIHJhdGlvKTtcbiAgICAgICAgICBkYXRhSGVpZ2h0ID0gTWF0aC5mbG9vcihiaXRtYXBIZWlnaHQgKiByYXRpbyk7XG4gICAgICAgICAgaWYgKCF0aGlzLiNpc1N2Zykge1xuICAgICAgICAgICAgYml0bWFwID0gdGhpcy4jc2NhbGVCaXRtYXAoZGF0YVdpZHRoLCBkYXRhSGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMoZGF0YVdpZHRoLCBkYXRhSGVpZ2h0KTtcbiAgICAgIGNvbnN0IG9mZnNjcmVlbkN0eCA9IG9mZnNjcmVlbi5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbiAgICAgIH0pO1xuICAgICAgb2Zmc2NyZWVuQ3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDAsIGJpdG1hcC53aWR0aCwgYml0bWFwLmhlaWdodCwgMCwgMCwgZGF0YVdpZHRoLCBkYXRhSGVpZ2h0KTtcbiAgICAgIGltYWdlRGF0YSA9IHtcbiAgICAgICAgd2lkdGg6IGRhdGFXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBkYXRhSGVpZ2h0LFxuICAgICAgICBkYXRhOiBvZmZzY3JlZW5DdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGRhdGFXaWR0aCwgZGF0YUhlaWdodCkuZGF0YVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhcyxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgaW1hZ2VEYXRhXG4gICAgfTtcbiAgfVxuICAjc2NhbGVCaXRtYXAod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoOiBiaXRtYXBXaWR0aCxcbiAgICAgIGhlaWdodDogYml0bWFwSGVpZ2h0XG4gICAgfSA9IHRoaXMuI2JpdG1hcDtcbiAgICBsZXQgbmV3V2lkdGggPSBiaXRtYXBXaWR0aDtcbiAgICBsZXQgbmV3SGVpZ2h0ID0gYml0bWFwSGVpZ2h0O1xuICAgIGxldCBiaXRtYXAgPSB0aGlzLiNiaXRtYXA7XG4gICAgd2hpbGUgKG5ld1dpZHRoID4gMiAqIHdpZHRoIHx8IG5ld0hlaWdodCA+IDIgKiBoZWlnaHQpIHtcbiAgICAgIGNvbnN0IHByZXZXaWR0aCA9IG5ld1dpZHRoO1xuICAgICAgY29uc3QgcHJldkhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgIGlmIChuZXdXaWR0aCA+IDIgKiB3aWR0aCkge1xuICAgICAgICBuZXdXaWR0aCA9IG5ld1dpZHRoID49IDE2Mzg0ID8gTWF0aC5mbG9vcihuZXdXaWR0aCAvIDIpIC0gMSA6IE1hdGguY2VpbChuZXdXaWR0aCAvIDIpO1xuICAgICAgfVxuICAgICAgaWYgKG5ld0hlaWdodCA+IDIgKiBoZWlnaHQpIHtcbiAgICAgICAgbmV3SGVpZ2h0ID0gbmV3SGVpZ2h0ID49IDE2Mzg0ID8gTWF0aC5mbG9vcihuZXdIZWlnaHQgLyAyKSAtIDEgOiBNYXRoLmNlaWwobmV3SGVpZ2h0IC8gMik7XG4gICAgICB9XG4gICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgY29uc3QgY3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBwcmV2V2lkdGgsIHByZXZIZWlnaHQsIDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgYml0bWFwID0gb2Zmc2NyZWVuLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpO1xuICAgIH1cbiAgICByZXR1cm4gYml0bWFwO1xuICB9XG4gICNkcmF3Qml0bWFwKCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IG91dHB1dFNjYWxlID0gbmV3IE91dHB1dFNjYWxlKCk7XG4gICAgY29uc3Qgc2NhbGVkV2lkdGggPSBNYXRoLmNlaWwod2lkdGggKiBwYXJlbnRXaWR0aCAqIG91dHB1dFNjYWxlLnN4KTtcbiAgICBjb25zdCBzY2FsZWRIZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICogcGFyZW50SGVpZ2h0ICogb3V0cHV0U2NhbGUuc3kpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuI2NhbnZhcztcbiAgICBpZiAoIWNhbnZhcyB8fCBjYW52YXMud2lkdGggPT09IHNjYWxlZFdpZHRoICYmIGNhbnZhcy5oZWlnaHQgPT09IHNjYWxlZEhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYW52YXMud2lkdGggPSBzY2FsZWRXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gc2NhbGVkSGVpZ2h0O1xuICAgIGNvbnN0IGJpdG1hcCA9IHRoaXMuI2lzU3ZnID8gdGhpcy4jYml0bWFwIDogdGhpcy4jc2NhbGVCaXRtYXAoc2NhbGVkV2lkdGgsIHNjYWxlZEhlaWdodCk7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBjdHguZmlsdGVyID0gdGhpcy5fdWlNYW5hZ2VyLmhjbUZpbHRlcjtcbiAgICBjdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCwgYml0bWFwLndpZHRoLCBiaXRtYXAuaGVpZ2h0LCAwLCAwLCBzY2FsZWRXaWR0aCwgc2NhbGVkSGVpZ2h0KTtcbiAgfVxuICAjc2VyaWFsaXplQml0bWFwKHRvVXJsKSB7XG4gICAgaWYgKHRvVXJsKSB7XG4gICAgICBpZiAodGhpcy4jaXNTdmcpIHtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRTdmdVcmwodGhpcy4jYml0bWFwSWQpO1xuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICh7XG4gICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodFxuICAgICAgfSA9IHRoaXMuI2JpdG1hcCk7XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLiNiaXRtYXAsIDAsIDApO1xuICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2lzU3ZnKSB7XG4gICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgICBjb25zdCB3aWR0aCA9IE1hdGgucm91bmQodGhpcy53aWR0aCAqIHBhZ2VXaWR0aCAqIFBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUyk7XG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLnJvdW5kKHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodCAqIFBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUyk7XG4gICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgY3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy4jYml0bWFwLCAwLCAwLCB0aGlzLiNiaXRtYXAud2lkdGgsIHRoaXMuI2JpdG1hcC5oZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcmV0dXJuIG9mZnNjcmVlbi50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cnVjdHVyZWRDbG9uZSh0aGlzLiNiaXRtYXApO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGxldCBpbml0aWFsRGF0YSA9IG51bGw7XG4gICAgbGV0IG1pc3NpbmdDYW52YXMgPSBmYWxzZTtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIFN0YW1wQW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgc3RydWN0UGFyZW50LFxuICAgICAgICAgIHBvcHVwUmVmLFxuICAgICAgICAgIGNvbnRlbnRzT2JqXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgcGFnZU51bWJlclxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2FudmFzXG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGxldCBiaXRtYXBJZCwgYml0bWFwO1xuICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICBkZWxldGUgZGF0YS5jYW52YXM7XG4gICAgICAgICh7XG4gICAgICAgICAgaWQ6IGJpdG1hcElkLFxuICAgICAgICAgIGJpdG1hcFxuICAgICAgICB9ID0gdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tQ2FudmFzKGNvbnRhaW5lci5pZCwgY2FudmFzKSk7XG4gICAgICAgIGNhbnZhcy5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pc3NpbmdDYW52YXMgPSB0cnVlO1xuICAgICAgICBkYXRhLl9oYXNOb0NhbnZhcyA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBhbHRUZXh0ID0gKGF3YWl0IHBhcmVudC5fc3RydWN0VHJlZS5nZXRBcmlhQXR0cmlidXRlcyhgJHtBbm5vdGF0aW9uUHJlZml4fSR7aWR9YCkpPy5nZXQoXCJhcmlhLWxhYmVsXCIpIHx8IFwiXCI7XG4gICAgICBpbml0aWFsRGF0YSA9IGRhdGEgPSB7XG4gICAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUCxcbiAgICAgICAgYml0bWFwSWQsXG4gICAgICAgIGJpdG1hcCxcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlTnVtYmVyIC0gMSxcbiAgICAgICAgcmVjdDogcmVjdC5zbGljZSgwKSxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGFubm90YXRpb25FbGVtZW50SWQ6IGlkLFxuICAgICAgICBpZCxcbiAgICAgICAgZGVsZXRlZDogZmFsc2UsXG4gICAgICAgIGFjY2Vzc2liaWxpdHlEYXRhOiB7XG4gICAgICAgICAgZGVjb3JhdGl2ZTogZmFsc2UsXG4gICAgICAgICAgYWx0VGV4dFxuICAgICAgICB9LFxuICAgICAgICBpc1N2ZzogZmFsc2UsXG4gICAgICAgIHN0cnVjdFBhcmVudCxcbiAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgIGNvbW1lbnQ6IGNvbnRlbnRzT2JqPy5zdHIgfHwgbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlY3QsXG4gICAgICBiaXRtYXAsXG4gICAgICBiaXRtYXBVcmwsXG4gICAgICBiaXRtYXBJZCxcbiAgICAgIGlzU3ZnLFxuICAgICAgYWNjZXNzaWJpbGl0eURhdGFcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAobWlzc2luZ0NhbnZhcykge1xuICAgICAgdWlNYW5hZ2VyLmFkZE1pc3NpbmdDYW52YXMoZGF0YS5pZCwgZWRpdG9yKTtcbiAgICAgIGVkaXRvci4jbWlzc2luZ0NhbnZhcyA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChiaXRtYXBJZCAmJiB1aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmlzVmFsaWRJZChiaXRtYXBJZCkpIHtcbiAgICAgIGVkaXRvci4jYml0bWFwSWQgPSBiaXRtYXBJZDtcbiAgICAgIGlmIChiaXRtYXApIHtcbiAgICAgICAgZWRpdG9yLiNiaXRtYXAgPSBiaXRtYXA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkaXRvci4jYml0bWFwVXJsID0gYml0bWFwVXJsO1xuICAgIH1cbiAgICBlZGl0b3IuI2lzU3ZnID0gaXNTdmc7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gZWRpdG9yLnBhZ2VEaW1lbnNpb25zO1xuICAgIGVkaXRvci53aWR0aCA9IChyZWN0WzJdIC0gcmVjdFswXSkgLyBwYXJlbnRXaWR0aDtcbiAgICBlZGl0b3IuaGVpZ2h0ID0gKHJlY3RbM10gLSByZWN0WzFdKSAvIHBhcmVudEhlaWdodDtcbiAgICBpZiAoYWNjZXNzaWJpbGl0eURhdGEpIHtcbiAgICAgIGVkaXRvci5hbHRUZXh0RGF0YSA9IGFjY2Vzc2liaWxpdHlEYXRhO1xuICAgIH1cbiAgICBlZGl0b3IuX2luaXRpYWxEYXRhID0gaW5pdGlhbERhdGE7XG4gICAgaWYgKGRhdGEuY29tbWVudCkge1xuICAgICAgZWRpdG9yLnNldENvbW1lbnREYXRhKGRhdGEuY29tbWVudCk7XG4gICAgfVxuICAgIGVkaXRvci4jaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2sgPSAhIWluaXRpYWxEYXRhO1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlLCBjb250ZXh0ID0gbnVsbCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZURlbGV0ZWQoKTtcbiAgICB9XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUCxcbiAgICAgIGJpdG1hcElkOiB0aGlzLiNiaXRtYXBJZCxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXgsXG4gICAgICByZWN0OiB0aGlzLmdldFBERlJlY3QoKSxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxuICAgICAgaXNTdmc6IHRoaXMuI2lzU3ZnLFxuICAgICAgc3RydWN0VHJlZVBhcmVudElkOiB0aGlzLl9zdHJ1Y3RUcmVlUGFyZW50SWRcbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWVudChzZXJpYWxpemVkKTtcbiAgICBpZiAoaXNGb3JDb3B5aW5nKSB7XG4gICAgICBzZXJpYWxpemVkLmJpdG1hcFVybCA9IHRoaXMuI3NlcmlhbGl6ZUJpdG1hcCh0cnVlKTtcbiAgICAgIHNlcmlhbGl6ZWQuYWNjZXNzaWJpbGl0eURhdGEgPSB0aGlzLnNlcmlhbGl6ZUFsdFRleHQodHJ1ZSk7XG4gICAgICBzZXJpYWxpemVkLmlzQ29weSA9IHRydWU7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZGVjb3JhdGl2ZSxcbiAgICAgIGFsdFRleHRcbiAgICB9ID0gdGhpcy5zZXJpYWxpemVBbHRUZXh0KGZhbHNlKTtcbiAgICBpZiAoIWRlY29yYXRpdmUgJiYgYWx0VGV4dCkge1xuICAgICAgc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YSA9IHtcbiAgICAgICAgdHlwZTogXCJGaWd1cmVcIixcbiAgICAgICAgYWx0OiBhbHRUZXh0XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy4jaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCk7XG4gICAgICBpZiAoY2hhbmdlcy5pc1NhbWUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoY2hhbmdlcy5pc1NhbWVBbHRUZXh0KSB7XG4gICAgICAgIGRlbGV0ZSBzZXJpYWxpemVkLmFjY2Vzc2liaWxpdHlEYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YS5zdHJ1Y3RQYXJlbnQgPSB0aGlzLl9pbml0aWFsRGF0YS5zdHJ1Y3RQYXJlbnQgPz8gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIHNlcmlhbGl6ZWQuaWQgPSB0aGlzLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgaWYgKGNvbnRleHQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICBjb250ZXh0LnN0YW1wcyB8fD0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGFyZWEgPSB0aGlzLiNpc1N2ZyA/IChzZXJpYWxpemVkLnJlY3RbMl0gLSBzZXJpYWxpemVkLnJlY3RbMF0pICogKHNlcmlhbGl6ZWQucmVjdFszXSAtIHNlcmlhbGl6ZWQucmVjdFsxXSkgOiBudWxsO1xuICAgIGlmICghY29udGV4dC5zdGFtcHMuaGFzKHRoaXMuI2JpdG1hcElkKSkge1xuICAgICAgY29udGV4dC5zdGFtcHMuc2V0KHRoaXMuI2JpdG1hcElkLCB7XG4gICAgICAgIGFyZWEsXG4gICAgICAgIHNlcmlhbGl6ZWRcbiAgICAgIH0pO1xuICAgICAgc2VyaWFsaXplZC5iaXRtYXAgPSB0aGlzLiNzZXJpYWxpemVCaXRtYXAoZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jaXNTdmcpIHtcbiAgICAgIGNvbnN0IHByZXZEYXRhID0gY29udGV4dC5zdGFtcHMuZ2V0KHRoaXMuI2JpdG1hcElkKTtcbiAgICAgIGlmIChhcmVhID4gcHJldkRhdGEuYXJlYSkge1xuICAgICAgICBwcmV2RGF0YS5hcmVhID0gYXJlYTtcbiAgICAgICAgcHJldkRhdGEuc2VyaWFsaXplZC5iaXRtYXAuY2xvc2UoKTtcbiAgICAgICAgcHJldkRhdGEuc2VyaWFsaXplZC5iaXRtYXAgPSB0aGlzLiNzZXJpYWxpemVCaXRtYXAoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgfVxuICAjaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VJbmRleCxcbiAgICAgIGFjY2Vzc2liaWxpdHlEYXRhOiB7XG4gICAgICAgIGFsdFRleHRcbiAgICAgIH1cbiAgICB9ID0gdGhpcy5faW5pdGlhbERhdGE7XG4gICAgY29uc3QgaXNTYW1lUGFnZUluZGV4ID0gc2VyaWFsaXplZC5wYWdlSW5kZXggPT09IHBhZ2VJbmRleDtcbiAgICBjb25zdCBpc1NhbWVBbHRUZXh0ID0gKHNlcmlhbGl6ZWQuYWNjZXNzaWJpbGl0eURhdGE/LmFsdCB8fCBcIlwiKSA9PT0gYWx0VGV4dDtcbiAgICByZXR1cm4ge1xuICAgICAgaXNTYW1lOiAhdGhpcy5oYXNFZGl0ZWRDb21tZW50ICYmICF0aGlzLl9oYXNCZWVuTW92ZWQgJiYgIXRoaXMuX2hhc0JlZW5SZXNpemVkICYmIGlzU2FtZVBhZ2VJbmRleCAmJiBpc1NhbWVBbHRUZXh0LFxuICAgICAgaXNTYW1lQWx0VGV4dFxuICAgIH07XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIGFubm90YXRpb24uaGlkZSgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UERGUmVjdCgpXG4gICAgfTtcbiAgICBpZiAodGhpcy5oYXNFZGl0ZWRDb21tZW50KSB7XG4gICAgICBwYXJhbXMucG9wdXAgPSB0aGlzLmNvbW1lbnQ7XG4gICAgfVxuICAgIGFubm90YXRpb24udXBkYXRlRWRpdGVkKHBhcmFtcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2Fubm90YXRpb25fZWRpdG9yX2xheWVyLmpzXG5cblxuXG5cblxuXG5cblxuY2xhc3MgQW5ub3RhdGlvbkVkaXRvckxheWVyIHtcbiAgI2FjY2Vzc2liaWxpdHlNYW5hZ2VyO1xuICAjYWxsb3dDbGljayA9IGZhbHNlO1xuICAjYW5ub3RhdGlvbkxheWVyID0gbnVsbDtcbiAgI2NsaWNrQUMgPSBudWxsO1xuICAjZWRpdG9yRm9jdXNUaW1lb3V0SWQgPSBudWxsO1xuICAjZWRpdG9ycyA9IG5ldyBNYXAoKTtcbiAgI2hhZFBvaW50ZXJEb3duID0gZmFsc2U7XG4gICNpc0Rpc2FibGluZyA9IGZhbHNlO1xuICAjaXNFbmFibGluZyA9IGZhbHNlO1xuICAjZHJhd2luZ0FDID0gbnVsbDtcbiAgI2ZvY3VzZWRFbGVtZW50ID0gbnVsbDtcbiAgI3RleHRMYXllciA9IG51bGw7XG4gICN0ZXh0U2VsZWN0aW9uQUMgPSBudWxsO1xuICAjdGV4dExheWVyRGJsQ2xpY2tBQyA9IG51bGw7XG4gICNsYXN0UG9pbnRlckRvd25UaW1lc3RhbXAgPSAtMTtcbiAgI3VpTWFuYWdlcjtcbiAgc3RhdGljIF9pbml0aWFsaXplZCA9IGZhbHNlO1xuICBzdGF0aWMgI2VkaXRvclR5cGVzID0gbmV3IE1hcChbRnJlZVRleHRFZGl0b3IsIElua0VkaXRvciwgU3RhbXBFZGl0b3IsIEhpZ2hsaWdodEVkaXRvciwgU2lnbmF0dXJlRWRpdG9yXS5tYXAodHlwZSA9PiBbdHlwZS5fZWRpdG9yVHlwZSwgdHlwZV0pKTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHVpTWFuYWdlcixcbiAgICBwYWdlSW5kZXgsXG4gICAgZGl2LFxuICAgIHN0cnVjdFRyZWVMYXllcixcbiAgICBhY2Nlc3NpYmlsaXR5TWFuYWdlcixcbiAgICBhbm5vdGF0aW9uTGF5ZXIsXG4gICAgZHJhd0xheWVyLFxuICAgIHRleHRMYXllcixcbiAgICB2aWV3cG9ydCxcbiAgICBsMTBuXG4gIH0pIHtcbiAgICBjb25zdCBlZGl0b3JUeXBlcyA9IFsuLi5Bbm5vdGF0aW9uRWRpdG9yTGF5ZXIuI2VkaXRvclR5cGVzLnZhbHVlcygpXTtcbiAgICBpZiAoIUFubm90YXRpb25FZGl0b3JMYXllci5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIEFubm90YXRpb25FZGl0b3JMYXllci5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIGVkaXRvclR5cGVzKSB7XG4gICAgICAgIGVkaXRvclR5cGUuaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICB1aU1hbmFnZXIucmVnaXN0ZXJFZGl0b3JUeXBlcyhlZGl0b3JUeXBlcyk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyID0gdWlNYW5hZ2VyO1xuICAgIHRoaXMucGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgIHRoaXMuZGl2ID0gZGl2O1xuICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyID0gYWNjZXNzaWJpbGl0eU1hbmFnZXI7XG4gICAgdGhpcy4jYW5ub3RhdGlvbkxheWVyID0gYW5ub3RhdGlvbkxheWVyO1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICB0aGlzLiN0ZXh0TGF5ZXIgPSB0ZXh0TGF5ZXI7XG4gICAgdGhpcy5kcmF3TGF5ZXIgPSBkcmF3TGF5ZXI7XG4gICAgdGhpcy5fc3RydWN0VHJlZSA9IHN0cnVjdFRyZWVMYXllcjtcbiAgICB0aGlzLiN1aU1hbmFnZXIuYWRkTGF5ZXIodGhpcyk7XG4gIH1cbiAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VkaXRvcnMuc2l6ZSA9PT0gMDtcbiAgfVxuICBnZXQgaXNJbnZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNFbXB0eSAmJiB0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FO1xuICB9XG4gIHVwZGF0ZVRvb2xiYXIob3B0aW9ucykge1xuICAgIHRoaXMuI3VpTWFuYWdlci51cGRhdGVUb29sYmFyKG9wdGlvbnMpO1xuICB9XG4gIHVwZGF0ZU1vZGUobW9kZSA9IHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkpIHtcbiAgICB0aGlzLiNjbGVhbnVwKCk7XG4gICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkU6XG4gICAgICAgIHRoaXMuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy50b2dnbGVQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgICAgICAgdGhpcy50b2dnbGVBbm5vdGF0aW9uTGF5ZXJQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgICAgICB0aGlzLmRpc2FibGVDbGljaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JUeXBlLklOSzpcbiAgICAgICAgdGhpcy5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnRvZ2dsZVBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgICAgIHRoaXMuZW5hYmxlQ2xpY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVDpcbiAgICAgICAgdGhpcy5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyhmYWxzZSk7XG4gICAgICAgIHRoaXMuZGlzYWJsZUNsaWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnRvZ2dsZVBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgICAgIHRoaXMuZW5hYmxlQ2xpY2soKTtcbiAgICB9XG4gICAgdGhpcy50b2dnbGVBbm5vdGF0aW9uTGF5ZXJQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgICBjb25zdCB7XG4gICAgICBjbGFzc0xpc3RcbiAgICB9ID0gdGhpcy5kaXY7XG4gICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIEFubm90YXRpb25FZGl0b3JMYXllci4jZWRpdG9yVHlwZXMudmFsdWVzKCkpIHtcbiAgICAgIGNsYXNzTGlzdC50b2dnbGUoYCR7ZWRpdG9yVHlwZS5fdHlwZX1FZGl0aW5nYCwgbW9kZSA9PT0gZWRpdG9yVHlwZS5fZWRpdG9yVHlwZSk7XG4gICAgfVxuICAgIHRoaXMuZGl2LmhpZGRlbiA9IGZhbHNlO1xuICB9XG4gIGhhc1RleHRMYXllcih0ZXh0TGF5ZXIpIHtcbiAgICByZXR1cm4gdGV4dExheWVyID09PSB0aGlzLiN0ZXh0TGF5ZXI/LmRpdjtcbiAgfVxuICBzZXRFZGl0aW5nU3RhdGUoaXNFZGl0aW5nKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldEVkaXRpbmdTdGF0ZShpc0VkaXRpbmcpO1xuICB9XG4gIGFkZENvbW1hbmRzKHBhcmFtcykge1xuICAgIHRoaXMuI3VpTWFuYWdlci5hZGRDb21tYW5kcyhwYXJhbXMpO1xuICB9XG4gIGNsZWFuVW5kb1N0YWNrKHR5cGUpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuY2xlYW5VbmRvU3RhY2sodHlwZSk7XG4gIH1cbiAgdG9nZ2xlRHJhd2luZyhlbmFibGVkID0gZmFsc2UpIHtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZHJhd2luZ1wiLCAhZW5hYmxlZCk7XG4gIH1cbiAgdG9nZ2xlUG9pbnRlckV2ZW50cyhlbmFibGVkID0gZmFsc2UpIHtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZGlzYWJsZWRcIiwgIWVuYWJsZWQpO1xuICB9XG4gIHRvZ2dsZUFubm90YXRpb25MYXllclBvaW50ZXJFdmVudHMoZW5hYmxlZCA9IGZhbHNlKSB7XG4gICAgdGhpcy4jYW5ub3RhdGlvbkxheWVyPy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsICFlbmFibGVkKTtcbiAgfVxuICBhc3luYyBlbmFibGUoKSB7XG4gICAgdGhpcy4jaXNFbmFibGluZyA9IHRydWU7XG4gICAgdGhpcy5kaXYudGFiSW5kZXggPSAwO1xuICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICB0aGlzLiN0ZXh0TGF5ZXJEYmxDbGlja0FDPy5hYm9ydCgpO1xuICAgIHRoaXMuI3RleHRMYXllckRibENsaWNrQUMgPSBudWxsO1xuICAgIGNvbnN0IGFubm90YXRpb25FbGVtZW50SWRzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGVkaXRvci5lbmFibGVFZGl0aW5nKCk7XG4gICAgICBlZGl0b3Iuc2hvdyh0cnVlKTtcbiAgICAgIGlmIChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgICB0aGlzLiN1aU1hbmFnZXIucmVtb3ZlQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbihlZGl0b3IpO1xuICAgICAgICBhbm5vdGF0aW9uRWxlbWVudElkcy5hZGQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuI2Fubm90YXRpb25MYXllcikge1xuICAgICAgdGhpcy4jaXNFbmFibGluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlZGl0YWJsZXMgPSB0aGlzLiNhbm5vdGF0aW9uTGF5ZXIuZ2V0RWRpdGFibGVBbm5vdGF0aW9ucygpO1xuICAgIGZvciAoY29uc3QgZWRpdGFibGUgb2YgZWRpdGFibGVzKSB7XG4gICAgICBlZGl0YWJsZS5oaWRlKCk7XG4gICAgICBpZiAodGhpcy4jdWlNYW5hZ2VyLmlzRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRhYmxlLmRhdGEuaWQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGFubm90YXRpb25FbGVtZW50SWRzLmhhcyhlZGl0YWJsZS5kYXRhLmlkKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IHRoaXMuZGVzZXJpYWxpemUoZWRpdGFibGUpO1xuICAgICAgaWYgKCFlZGl0b3IpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgICAgZWRpdG9yLmVuYWJsZUVkaXRpbmcoKTtcbiAgICB9XG4gICAgdGhpcy4jaXNFbmFibGluZyA9IGZhbHNlO1xuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy4jaXNEaXNhYmxpbmcgPSB0cnVlO1xuICAgIHRoaXMuZGl2LnRhYkluZGV4ID0gLTE7XG4gICAgdGhpcy50b2dnbGVQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgICBpZiAodGhpcy4jdGV4dExheWVyICYmICF0aGlzLiN0ZXh0TGF5ZXJEYmxDbGlja0FDKSB7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXJEYmxDbGlja0FDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI3RleHRMYXllckRibENsaWNrQUMpO1xuICAgICAgdGhpcy4jdGV4dExheWVyLmRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgZSA9PiB7XG4gICAgICAgIGNvbnN0IERCTF9DTElDS19USFJFU0hPTEQgPSA1MDA7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjbGllbnRYLFxuICAgICAgICAgIGNsaWVudFksXG4gICAgICAgICAgdGltZVN0YW1wXG4gICAgICAgIH0gPSBlO1xuICAgICAgICBjb25zdCBsYXN0UG9pbnRlckRvd25UaW1lc3RhbXAgPSB0aGlzLiNsYXN0UG9pbnRlckRvd25UaW1lc3RhbXA7XG4gICAgICAgIGlmICh0aW1lU3RhbXAgLSBsYXN0UG9pbnRlckRvd25UaW1lc3RhbXAgPiBEQkxfQ0xJQ0tfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgdGhpcy4jbGFzdFBvaW50ZXJEb3duVGltZXN0YW1wID0gdGltZVN0YW1wO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNsYXN0UG9pbnRlckRvd25UaW1lc3RhbXAgPSAtMTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNsYXNzTGlzdFxuICAgICAgICB9ID0gdGhpcy5kaXY7XG4gICAgICAgIGNsYXNzTGlzdC50b2dnbGUoXCJnZXRFbGVtZW50c1wiLCB0cnVlKTtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBkb2N1bWVudC5lbGVtZW50c0Zyb21Qb2ludChjbGllbnRYLCBjbGllbnRZKTtcbiAgICAgICAgY2xhc3NMaXN0LnRvZ2dsZShcImdldEVsZW1lbnRzXCIsIGZhbHNlKTtcbiAgICAgICAgaWYgKCF0aGlzLmRpdi5jb250YWlucyhlbGVtZW50c1swXSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYF4ke0Fubm90YXRpb25FZGl0b3JQcmVmaXh9WzAtOV0rJGApO1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICBpZiAocmVnZXgudGVzdChlbGVtZW50LmlkKSkge1xuICAgICAgICAgICAgaWQgPSBlbGVtZW50LmlkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy4jZWRpdG9ycy5nZXQoaWQpO1xuICAgICAgICBpZiAoZWRpdG9yPy5hbm5vdGF0aW9uRWxlbWVudElkID09PSBudWxsKSB7XG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZWRpdG9yLmRibGNsaWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgc2lnbmFsLFxuICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlZEFubm90YXRpb25zID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHJlc2V0QW5ub3RhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgZWRpdG9yLmRpc2FibGVFZGl0aW5nKCk7XG4gICAgICBpZiAoIWVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGVkaXRvci5zZXJpYWxpemUoKSAhPT0gbnVsbCkge1xuICAgICAgICBjaGFuZ2VkQW5ub3RhdGlvbnMuc2V0KGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkLCBlZGl0b3IpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0QW5ub3RhdGlvbnMuc2V0KGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkLCBlZGl0b3IpO1xuICAgICAgfVxuICAgICAgdGhpcy5nZXRFZGl0YWJsZUFubm90YXRpb24oZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpPy5zaG93KCk7XG4gICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNhbm5vdGF0aW9uTGF5ZXIpIHtcbiAgICAgIGNvbnN0IGVkaXRhYmxlcyA9IHRoaXMuI2Fubm90YXRpb25MYXllci5nZXRFZGl0YWJsZUFubm90YXRpb25zKCk7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRhYmxlIG9mIGVkaXRhYmxlcykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IGVkaXRhYmxlLmRhdGE7XG4gICAgICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoaWQpKSB7XG4gICAgICAgICAgZWRpdGFibGUudXBkYXRlRWRpdGVkKHtcbiAgICAgICAgICAgIGRlbGV0ZWQ6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZWRpdG9yID0gcmVzZXRBbm5vdGF0aW9ucy5nZXQoaWQpO1xuICAgICAgICBpZiAoZWRpdG9yKSB7XG4gICAgICAgICAgZWRpdG9yLnJlc2V0QW5ub3RhdGlvbkVsZW1lbnQoZWRpdGFibGUpO1xuICAgICAgICAgIGVkaXRvci5zaG93KGZhbHNlKTtcbiAgICAgICAgICBlZGl0YWJsZS5zaG93KCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWRpdG9yID0gY2hhbmdlZEFubm90YXRpb25zLmdldChpZCk7XG4gICAgICAgIGlmIChlZGl0b3IpIHtcbiAgICAgICAgICB0aGlzLiN1aU1hbmFnZXIuYWRkQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbihlZGl0b3IpO1xuICAgICAgICAgIGlmIChlZGl0b3IucmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoZWRpdGFibGUpKSB7XG4gICAgICAgICAgICBlZGl0b3Iuc2hvdyhmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVkaXRhYmxlLnNob3coKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jY2xlYW51cCgpO1xuICAgIGlmICh0aGlzLmlzRW1wdHkpIHtcbiAgICAgIHRoaXMuZGl2LmhpZGRlbiA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNsYXNzTGlzdFxuICAgIH0gPSB0aGlzLmRpdjtcbiAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgQW5ub3RhdGlvbkVkaXRvckxheWVyLiNlZGl0b3JUeXBlcy52YWx1ZXMoKSkge1xuICAgICAgY2xhc3NMaXN0LnJlbW92ZShgJHtlZGl0b3JUeXBlLl90eXBlfUVkaXRpbmdgKTtcbiAgICB9XG4gICAgdGhpcy5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgIHRoaXMudG9nZ2xlQW5ub3RhdGlvbkxheWVyUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICB0aGlzLiNpc0Rpc2FibGluZyA9IGZhbHNlO1xuICB9XG4gIGdldEVkaXRhYmxlQW5ub3RhdGlvbihpZCkge1xuICAgIHJldHVybiB0aGlzLiNhbm5vdGF0aW9uTGF5ZXI/LmdldEVkaXRhYmxlQW5ub3RhdGlvbihpZCkgfHwgbnVsbDtcbiAgfVxuICBzZXRBY3RpdmVFZGl0b3IoZWRpdG9yKSB7XG4gICAgY29uc3QgY3VycmVudEFjdGl2ZSA9IHRoaXMuI3VpTWFuYWdlci5nZXRBY3RpdmUoKTtcbiAgICBpZiAoY3VycmVudEFjdGl2ZSA9PT0gZWRpdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3VpTWFuYWdlci5zZXRBY3RpdmVFZGl0b3IoZWRpdG9yKTtcbiAgfVxuICBlbmFibGVUZXh0U2VsZWN0aW9uKCkge1xuICAgIHRoaXMuZGl2LnRhYkluZGV4ID0gLTE7XG4gICAgaWYgKHRoaXMuI3RleHRMYXllcj8uZGl2ICYmICF0aGlzLiN0ZXh0U2VsZWN0aW9uQUMpIHtcbiAgICAgIHRoaXMuI3RleHRTZWxlY3Rpb25BQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiN0ZXh0U2VsZWN0aW9uQUMpO1xuICAgICAgdGhpcy4jdGV4dExheWVyLmRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jdGV4dExheWVyUG9pbnRlckRvd24uYmluZCh0aGlzKSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgdGhpcy4jdGV4dExheWVyLmRpdi5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0aW5nXCIpO1xuICAgIH1cbiAgfVxuICBkaXNhYmxlVGV4dFNlbGVjdGlvbigpIHtcbiAgICB0aGlzLmRpdi50YWJJbmRleCA9IDA7XG4gICAgaWYgKHRoaXMuI3RleHRMYXllcj8uZGl2ICYmIHRoaXMuI3RleHRTZWxlY3Rpb25BQykge1xuICAgICAgdGhpcy4jdGV4dFNlbGVjdGlvbkFDLmFib3J0KCk7XG4gICAgICB0aGlzLiN0ZXh0U2VsZWN0aW9uQUMgPSBudWxsO1xuICAgICAgdGhpcy4jdGV4dExheWVyLmRpdi5jbGFzc0xpc3QucmVtb3ZlKFwiaGlnaGxpZ2h0aW5nXCIpO1xuICAgIH1cbiAgfVxuICAjdGV4dExheWVyUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudW5zZWxlY3RBbGwoKTtcbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXRcbiAgICB9ID0gZXZlbnQ7XG4gICAgaWYgKHRhcmdldCA9PT0gdGhpcy4jdGV4dExheWVyLmRpdiB8fCAodGFyZ2V0LmdldEF0dHJpYnV0ZShcInJvbGVcIikgPT09IFwiaW1nXCIgfHwgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImVuZE9mQ29udGVudFwiKSkgJiYgdGhpcy4jdGV4dExheWVyLmRpdi5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlzTWFjXG4gICAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuc2hvd0FsbEVkaXRvcnMoXCJoaWdobGlnaHRcIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmNsYXNzTGlzdC5hZGQoXCJmcmVlXCIpO1xuICAgICAgdGhpcy50b2dnbGVEcmF3aW5nKCk7XG4gICAgICBIaWdobGlnaHRFZGl0b3Iuc3RhcnRIaWdobGlnaHRpbmcodGhpcywgdGhpcy4jdWlNYW5hZ2VyLmRpcmVjdGlvbiA9PT0gXCJsdHJcIiwge1xuICAgICAgICB0YXJnZXQ6IHRoaXMuI3RleHRMYXllci5kaXYsXG4gICAgICAgIHg6IGV2ZW50LngsXG4gICAgICAgIHk6IGV2ZW50LnlcbiAgICAgIH0pO1xuICAgICAgdGhpcy4jdGV4dExheWVyLmRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy4jdGV4dExheWVyLmRpdi5jbGFzc0xpc3QucmVtb3ZlKFwiZnJlZVwiKTtcbiAgICAgICAgdGhpcy50b2dnbGVEcmF3aW5nKHRydWUpO1xuICAgICAgfSwge1xuICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICBzaWduYWw6IHRoaXMuI3VpTWFuYWdlci5fc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG4gIGVuYWJsZUNsaWNrKCkge1xuICAgIGlmICh0aGlzLiNjbGlja0FDKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NsaWNrQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2NsaWNrQUMpO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLnBvaW50ZXJkb3duLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IHBvaW50ZXJ1cCA9IHRoaXMucG9pbnRlcnVwLmJpbmQodGhpcyk7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVydXAsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyY2FuY2VsXCIsIHBvaW50ZXJ1cCwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgZGlzYWJsZUNsaWNrKCkge1xuICAgIHRoaXMuI2NsaWNrQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jY2xpY2tBQyA9IG51bGw7XG4gIH1cbiAgYXR0YWNoKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnMuc2V0KGVkaXRvci5pZCwgZWRpdG9yKTtcbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uRWxlbWVudElkXG4gICAgfSA9IGVkaXRvcjtcbiAgICBpZiAoYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiB0aGlzLiN1aU1hbmFnZXIuaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbkVsZW1lbnRJZCkpIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5yZW1vdmVEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgZGV0YWNoKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnMuZGVsZXRlKGVkaXRvci5pZCk7XG4gICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXI/LnJlbW92ZVBvaW50ZXJJblRleHRMYXllcihlZGl0b3IuY29udGVudERpdik7XG4gICAgaWYgKCF0aGlzLiNpc0Rpc2FibGluZyAmJiBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmFkZERlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICByZW1vdmUoZWRpdG9yKSB7XG4gICAgdGhpcy5kZXRhY2goZWRpdG9yKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIucmVtb3ZlRWRpdG9yKGVkaXRvcik7XG4gICAgZWRpdG9yLmRpdi5yZW1vdmUoKTtcbiAgICBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NID0gZmFsc2U7XG4gIH1cbiAgY2hhbmdlUGFyZW50KGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IucGFyZW50ID09PSB0aGlzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlZGl0b3IucGFyZW50ICYmIGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuYWRkRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICAgIEFubm90YXRpb25FZGl0b3IuZGVsZXRlQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5hdHRhY2goZWRpdG9yKTtcbiAgICBlZGl0b3IucGFyZW50Py5kZXRhY2goZWRpdG9yKTtcbiAgICBlZGl0b3Iuc2V0UGFyZW50KHRoaXMpO1xuICAgIGlmIChlZGl0b3IuZGl2ICYmIGVkaXRvci5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIGVkaXRvci5kaXYucmVtb3ZlKCk7XG4gICAgICB0aGlzLmRpdi5hcHBlbmQoZWRpdG9yLmRpdik7XG4gICAgfVxuICB9XG4gIGFkZChlZGl0b3IpIHtcbiAgICBpZiAoZWRpdG9yLnBhcmVudCA9PT0gdGhpcyAmJiBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY2hhbmdlUGFyZW50KGVkaXRvcik7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZEVkaXRvcihlZGl0b3IpO1xuICAgIHRoaXMuYXR0YWNoKGVkaXRvcik7XG4gICAgaWYgKCFlZGl0b3IuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICBjb25zdCBkaXYgPSBlZGl0b3IucmVuZGVyKCk7XG4gICAgICB0aGlzLmRpdi5hcHBlbmQoZGl2KTtcbiAgICAgIGVkaXRvci5pc0F0dGFjaGVkVG9ET00gPSB0cnVlO1xuICAgIH1cbiAgICBlZGl0b3IuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICBlZGl0b3Iub25jZUFkZGVkKCF0aGlzLiNpc0VuYWJsaW5nKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShlZGl0b3IpO1xuICAgIGVkaXRvci5fcmVwb3J0VGVsZW1ldHJ5KGVkaXRvci50ZWxlbWV0cnlJbml0aWFsRGF0YSk7XG4gIH1cbiAgbW92ZUVkaXRvckluRE9NKGVkaXRvcikge1xuICAgIGlmICghZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhY3RpdmVFbGVtZW50XG4gICAgfSA9IGRvY3VtZW50O1xuICAgIGlmIChlZGl0b3IuZGl2LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpICYmICF0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCkge1xuICAgICAgZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuI2VkaXRvckZvY3VzVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuI2VkaXRvckZvY3VzVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgaWYgKCFlZGl0b3IuZGl2LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgZWRpdG9yLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCAoKSA9PiB7XG4gICAgICAgICAgICBlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgIHNpZ25hbDogdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgZWRpdG9yLl9zdHJ1Y3RUcmVlUGFyZW50SWQgPSB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlcj8ubW92ZUVsZW1lbnRJbkRPTSh0aGlzLmRpdiwgZWRpdG9yLmRpdiwgZWRpdG9yLmNvbnRlbnREaXYsIHRydWUpO1xuICB9XG4gIGFkZE9yUmVidWlsZChlZGl0b3IpIHtcbiAgICBpZiAoZWRpdG9yLm5lZWRzVG9CZVJlYnVpbHQoKSkge1xuICAgICAgZWRpdG9yLnBhcmVudCB8fD0gdGhpcztcbiAgICAgIGVkaXRvci5yZWJ1aWxkKCk7XG4gICAgICBlZGl0b3Iuc2hvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBhZGRVbmRvYWJsZUVkaXRvcihlZGl0b3IpIHtcbiAgICBjb25zdCBjbWQgPSAoKSA9PiBlZGl0b3IuX3VpTWFuYWdlci5yZWJ1aWxkKGVkaXRvcik7XG4gICAgY29uc3QgdW5kbyA9ICgpID0+IHtcbiAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kLFxuICAgICAgdW5kbyxcbiAgICAgIG11c3RFeGVjOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGdldE5leHRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jdWlNYW5hZ2VyLmdldElkKCk7XG4gIH1cbiAgZ2V0ICNjdXJyZW50RWRpdG9yVHlwZSgpIHtcbiAgICByZXR1cm4gQW5ub3RhdGlvbkVkaXRvckxheWVyLiNlZGl0b3JUeXBlcy5nZXQodGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSk7XG4gIH1cbiAgY29tYmluZWRTaWduYWwoYWMpIHtcbiAgICByZXR1cm4gdGhpcy4jdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKGFjKTtcbiAgfVxuICAjY3JlYXRlTmV3RWRpdG9yKHBhcmFtcykge1xuICAgIGNvbnN0IGVkaXRvclR5cGUgPSB0aGlzLiNjdXJyZW50RWRpdG9yVHlwZTtcbiAgICByZXR1cm4gZWRpdG9yVHlwZSA/IG5ldyBlZGl0b3JUeXBlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcihwYXJhbXMpIDogbnVsbDtcbiAgfVxuICBjYW5DcmVhdGVOZXdFbXB0eUVkaXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy4jY3VycmVudEVkaXRvclR5cGU/LmNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yKCk7XG4gIH1cbiAgYXN5bmMgcGFzdGVFZGl0b3Iob3B0aW9ucywgcGFyYW1zKSB7XG4gICAgdGhpcy51cGRhdGVUb29sYmFyKG9wdGlvbnMpO1xuICAgIGF3YWl0IHRoaXMuI3VpTWFuYWdlci51cGRhdGVNb2RlKG9wdGlvbnMubW9kZSk7XG4gICAgY29uc3Qge1xuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFlcbiAgICB9ID0gdGhpcy4jZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ2V0TmV4dElkKCk7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jY3JlYXRlTmV3RWRpdG9yKHtcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIGlkLFxuICAgICAgeDogb2Zmc2V0WCxcbiAgICAgIHk6IG9mZnNldFksXG4gICAgICB1aU1hbmFnZXI6IHRoaXMuI3VpTWFuYWdlcixcbiAgICAgIGlzQ2VudGVyZWQ6IHRydWUsXG4gICAgICAuLi5wYXJhbXNcbiAgICB9KTtcbiAgICBpZiAoZWRpdG9yKSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBhc3luYyBkZXNlcmlhbGl6ZShkYXRhKSB7XG4gICAgcmV0dXJuIChhd2FpdCBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuI2VkaXRvclR5cGVzLmdldChkYXRhLmFubm90YXRpb25UeXBlID8/IGRhdGEuYW5ub3RhdGlvbkVkaXRvclR5cGUpPy5kZXNlcmlhbGl6ZShkYXRhLCB0aGlzLCB0aGlzLiN1aU1hbmFnZXIpKSB8fCBudWxsO1xuICB9XG4gIGNyZWF0ZUFuZEFkZE5ld0VkaXRvcihldmVudCwgaXNDZW50ZXJlZCwgZGF0YSA9IHt9KSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdldE5leHRJZCgpO1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI2NyZWF0ZU5ld0VkaXRvcih7XG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBpZCxcbiAgICAgIHg6IGV2ZW50Lm9mZnNldFgsXG4gICAgICB5OiBldmVudC5vZmZzZXRZLFxuICAgICAgdWlNYW5hZ2VyOiB0aGlzLiN1aU1hbmFnZXIsXG4gICAgICBpc0NlbnRlcmVkLFxuICAgICAgLi4uZGF0YVxuICAgIH0pO1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuYWRkKGVkaXRvcik7XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgI2dldENlbnRlclBvaW50KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgdGxYID0gTWF0aC5tYXgoMCwgeCk7XG4gICAgY29uc3QgdGxZID0gTWF0aC5tYXgoMCwgeSk7XG4gICAgY29uc3QgYnJYID0gTWF0aC5taW4od2luZG93LmlubmVyV2lkdGgsIHggKyB3aWR0aCk7XG4gICAgY29uc3QgYnJZID0gTWF0aC5taW4od2luZG93LmlubmVySGVpZ2h0LCB5ICsgaGVpZ2h0KTtcbiAgICBjb25zdCBjZW50ZXJYID0gKHRsWCArIGJyWCkgLyAyIC0geDtcbiAgICBjb25zdCBjZW50ZXJZID0gKHRsWSArIGJyWSkgLyAyIC0geTtcbiAgICBjb25zdCBbb2Zmc2V0WCwgb2Zmc2V0WV0gPSB0aGlzLnZpZXdwb3J0LnJvdGF0aW9uICUgMTgwID09PSAwID8gW2NlbnRlclgsIGNlbnRlclldIDogW2NlbnRlclksIGNlbnRlclhdO1xuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WVxuICAgIH07XG4gIH1cbiAgYWRkTmV3RWRpdG9yKGRhdGEgPSB7fSkge1xuICAgIHRoaXMuY3JlYXRlQW5kQWRkTmV3RWRpdG9yKHRoaXMuI2dldENlbnRlclBvaW50KCksIHRydWUsIGRhdGEpO1xuICB9XG4gIHNldFNlbGVjdGVkKGVkaXRvcikge1xuICAgIHRoaXMuI3VpTWFuYWdlci5zZXRTZWxlY3RlZChlZGl0b3IpO1xuICB9XG4gIHRvZ2dsZVNlbGVjdGVkKGVkaXRvcikge1xuICAgIHRoaXMuI3VpTWFuYWdlci50b2dnbGVTZWxlY3RlZChlZGl0b3IpO1xuICB9XG4gIHVuc2VsZWN0KGVkaXRvcikge1xuICAgIHRoaXMuI3VpTWFuYWdlci51bnNlbGVjdChlZGl0b3IpO1xuICB9XG4gIHBvaW50ZXJ1cChldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jaGFkUG9pbnRlckRvd24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaGFkUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgICBpZiAodGhpcy4jY3VycmVudEVkaXRvclR5cGU/LmlzRHJhd2VyICYmIHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlLnN1cHBvcnRNdWx0aXBsZURyYXdpbmdzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jYWxsb3dDbGljaykge1xuICAgICAgdGhpcy4jYWxsb3dDbGljayA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRNb2RlID0gdGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKTtcbiAgICBpZiAoY3VycmVudE1vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QIHx8IGN1cnJlbnRNb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TSUdOQVRVUkUpIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci51bnNlbGVjdEFsbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNyZWF0ZUFuZEFkZE5ld0VkaXRvcihldmVudCwgZmFsc2UpO1xuICB9XG4gIHBvaW50ZXJkb3duKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCkge1xuICAgICAgdGhpcy5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNoYWRQb2ludGVyRG93bikge1xuICAgICAgdGhpcy4jaGFkUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5kaXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaGFkUG9pbnRlckRvd24gPSB0cnVlO1xuICAgIGlmICh0aGlzLiNjdXJyZW50RWRpdG9yVHlwZT8uaXNEcmF3ZXIpIHtcbiAgICAgIHRoaXMuc3RhcnREcmF3aW5nU2Vzc2lvbihldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI3VpTWFuYWdlci5nZXRBY3RpdmUoKTtcbiAgICB0aGlzLiNhbGxvd0NsaWNrID0gIWVkaXRvciB8fCBlZGl0b3IuaXNFbXB0eSgpO1xuICB9XG4gIHN0YXJ0RHJhd2luZ1Nlc3Npb24oZXZlbnQpIHtcbiAgICB0aGlzLmRpdi5mb2N1cyh7XG4gICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuI2RyYXdpbmdBQykge1xuICAgICAgdGhpcy4jY3VycmVudEVkaXRvclR5cGUuc3RhcnREcmF3aW5nKHRoaXMsIHRoaXMuI3VpTWFuYWdlciwgZmFsc2UsIGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldEN1cnJlbnREcmF3aW5nU2Vzc2lvbih0aGlzKTtcbiAgICB0aGlzLiNkcmF3aW5nQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2RyYXdpbmdBQyk7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgKHtcbiAgICAgIHJlbGF0ZWRUYXJnZXRcbiAgICB9KSA9PiB7XG4gICAgICBpZiAocmVsYXRlZFRhcmdldCAmJiAhdGhpcy5kaXYuY29udGFpbnMocmVsYXRlZFRhcmdldCkpIHtcbiAgICAgICAgdGhpcy4jZm9jdXNlZEVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy4jY3VycmVudEVkaXRvclR5cGUuc3RhcnREcmF3aW5nKHRoaXMsIHRoaXMuI3VpTWFuYWdlciwgZmFsc2UsIGV2ZW50KTtcbiAgfVxuICBwYXVzZShvbikge1xuICAgIGlmIChvbikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY3RpdmVFbGVtZW50XG4gICAgICB9ID0gZG9jdW1lbnQ7XG4gICAgICBpZiAodGhpcy5kaXYuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgdGhpcy4jZm9jdXNlZEVsZW1lbnQgPSBhY3RpdmVFbGVtZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jZm9jdXNlZEVsZW1lbnQpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLiNmb2N1c2VkRWxlbWVudD8uZm9jdXMoKTtcbiAgICAgICAgdGhpcy4jZm9jdXNlZEVsZW1lbnQgPSBudWxsO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9XG4gIGVuZERyYXdpbmdTZXNzaW9uKGlzQWJvcnRlZCA9IGZhbHNlKSB7XG4gICAgaWYgKCF0aGlzLiNkcmF3aW5nQUMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0Q3VycmVudERyYXdpbmdTZXNzaW9uKG51bGwpO1xuICAgIHRoaXMuI2RyYXdpbmdBQy5hYm9ydCgpO1xuICAgIHRoaXMuI2RyYXdpbmdBQyA9IG51bGw7XG4gICAgdGhpcy4jZm9jdXNlZEVsZW1lbnQgPSBudWxsO1xuICAgIHJldHVybiB0aGlzLiNjdXJyZW50RWRpdG9yVHlwZS5lbmREcmF3aW5nKGlzQWJvcnRlZCk7XG4gIH1cbiAgZmluZE5ld1BhcmVudChlZGl0b3IsIHgsIHkpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuI3VpTWFuYWdlci5maW5kUGFyZW50KHgsIHkpO1xuICAgIGlmIChsYXllciA9PT0gbnVsbCB8fCBsYXllciA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsYXllci5jaGFuZ2VQYXJlbnQoZWRpdG9yKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb21taXRPclJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy4jZHJhd2luZ0FDKSB7XG4gICAgICB0aGlzLmVuZERyYXdpbmdTZXNzaW9uKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG9uU2NhbGVDaGFuZ2luZygpIHtcbiAgICBpZiAoIXRoaXMuI2RyYXdpbmdBQykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjdXJyZW50RWRpdG9yVHlwZS5vblNjYWxlQ2hhbmdpbmdXaGVuRHJhd2luZyh0aGlzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICBpZiAodGhpcy4jdWlNYW5hZ2VyLmdldEFjdGl2ZSgpPy5wYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5jb21taXRPclJlbW92ZSgpO1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLnNldEFjdGl2ZUVkaXRvcihudWxsKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2VkaXRvckZvY3VzVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jZWRpdG9yRm9jdXNUaW1lb3V0SWQpO1xuICAgICAgdGhpcy4jZWRpdG9yRm9jdXNUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlcj8ucmVtb3ZlUG9pbnRlckluVGV4dExheWVyKGVkaXRvci5jb250ZW50RGl2KTtcbiAgICAgIGVkaXRvci5zZXRQYXJlbnQobnVsbCk7XG4gICAgICBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NID0gZmFsc2U7XG4gICAgICBlZGl0b3IuZGl2LnJlbW92ZSgpO1xuICAgIH1cbiAgICB0aGlzLmRpdiA9IG51bGw7XG4gICAgdGhpcy4jZWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI3VpTWFuYWdlci5yZW1vdmVMYXllcih0aGlzKTtcbiAgfVxuICAjY2xlYW51cCgpIHtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZWRpdG9yLmlzRW1wdHkoKSkge1xuICAgICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlbmRlcih7XG4gICAgdmlld3BvcnRcbiAgfSkge1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICBzZXRMYXllckRpbWVuc2lvbnModGhpcy5kaXYsIHZpZXdwb3J0KTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiN1aU1hbmFnZXIuZ2V0RWRpdG9ycyh0aGlzLnBhZ2VJbmRleCkpIHtcbiAgICAgIHRoaXMuYWRkKGVkaXRvcik7XG4gICAgICBlZGl0b3IucmVidWlsZCgpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZU1vZGUoKTtcbiAgfVxuICB1cGRhdGUoe1xuICAgIHZpZXdwb3J0XG4gIH0pIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB0aGlzLiNjbGVhbnVwKCk7XG4gICAgY29uc3Qgb2xkUm90YXRpb24gPSB0aGlzLnZpZXdwb3J0LnJvdGF0aW9uO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdmlld3BvcnQucm90YXRpb247XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHNldExheWVyRGltZW5zaW9ucyh0aGlzLmRpdiwge1xuICAgICAgcm90YXRpb25cbiAgICB9KTtcbiAgICBpZiAob2xkUm90YXRpb24gIT09IHJvdGF0aW9uKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIGVkaXRvci5yb3RhdGUocm90YXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgcGFnZURpbWVuc2lvbnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodFxuICAgIH0gPSB0aGlzLnZpZXdwb3J0LnJhd0RpbXM7XG4gICAgcmV0dXJuIFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdO1xuICB9XG4gIGdldCBzY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jdWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzLnJlYWxTY2FsZTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9kcmF3X2xheWVyLmpzXG5cblxuY2xhc3MgRHJhd0xheWVyIHtcbiAgI3BhcmVudCA9IG51bGw7XG4gICNtYXBwaW5nID0gbmV3IE1hcCgpO1xuICAjdG9VcGRhdGUgPSBuZXcgTWFwKCk7XG4gIHN0YXRpYyAjaWQgPSAwO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcGFnZUluZGV4XG4gIH0pIHtcbiAgICB0aGlzLnBhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgfVxuICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgaWYgKCF0aGlzLiNwYXJlbnQpIHtcbiAgICAgIHRoaXMuI3BhcmVudCA9IHBhcmVudDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3BhcmVudCAhPT0gcGFyZW50KSB7XG4gICAgICBpZiAodGhpcy4jbWFwcGluZy5zaXplID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJvb3Qgb2YgdGhpcy4jbWFwcGluZy52YWx1ZXMoKSkge1xuICAgICAgICAgIHJvb3QucmVtb3ZlKCk7XG4gICAgICAgICAgcGFyZW50LmFwcGVuZChyb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy4jcGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IF9zdmdGYWN0b3J5KCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfc3ZnRmFjdG9yeVwiLCBuZXcgRE9NU1ZHRmFjdG9yeSgpKTtcbiAgfVxuICBzdGF0aWMgI3NldEJveChlbGVtZW50LCBbeCwgeSwgd2lkdGgsIGhlaWdodF0pIHtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBlbGVtZW50O1xuICAgIHN0eWxlLnRvcCA9IGAkezEwMCAqIHl9JWA7XG4gICAgc3R5bGUubGVmdCA9IGAkezEwMCAqIHh9JWA7XG4gICAgc3R5bGUud2lkdGggPSBgJHsxMDAgKiB3aWR0aH0lYDtcbiAgICBzdHlsZS5oZWlnaHQgPSBgJHsxMDAgKiBoZWlnaHR9JWA7XG4gIH1cbiAgI2NyZWF0ZVNWRygpIHtcbiAgICBjb25zdCBzdmcgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlKDEsIDEsIHRydWUpO1xuICAgIHRoaXMuI3BhcmVudC5hcHBlbmQoc3ZnKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgdHJ1ZSk7XG4gICAgcmV0dXJuIHN2ZztcbiAgfVxuICAjY3JlYXRlQ2xpcFBhdGgoZGVmcywgcGF0aElkKSB7XG4gICAgY29uc3QgY2xpcFBhdGggPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImNsaXBQYXRoXCIpO1xuICAgIGRlZnMuYXBwZW5kKGNsaXBQYXRoKTtcbiAgICBjb25zdCBjbGlwUGF0aElkID0gYGNsaXBfJHtwYXRoSWR9YDtcbiAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBjbGlwUGF0aElkKTtcbiAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGUoXCJjbGlwUGF0aFVuaXRzXCIsIFwib2JqZWN0Qm91bmRpbmdCb3hcIik7XG4gICAgY29uc3QgY2xpcFBhdGhVc2UgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInVzZVwiKTtcbiAgICBjbGlwUGF0aC5hcHBlbmQoY2xpcFBhdGhVc2UpO1xuICAgIGNsaXBQYXRoVXNlLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgYCMke3BhdGhJZH1gKTtcbiAgICBjbGlwUGF0aFVzZS5jbGFzc0xpc3QuYWRkKFwiY2xpcFwiKTtcbiAgICByZXR1cm4gY2xpcFBhdGhJZDtcbiAgfVxuICAjdXBkYXRlUHJvcGVydGllcyhlbGVtZW50LCBwcm9wZXJ0aWVzKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcGVydGllcykpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRyYXcocHJvcGVydGllcywgaXNQYXRoVXBkYXRhYmxlID0gZmFsc2UsIGhhc0NsaXAgPSBmYWxzZSkge1xuICAgIGNvbnN0IGlkID0gRHJhd0xheWVyLiNpZCsrO1xuICAgIGNvbnN0IHJvb3QgPSB0aGlzLiNjcmVhdGVTVkcoKTtcbiAgICBjb25zdCBkZWZzID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIpO1xuICAgIHJvb3QuYXBwZW5kKGRlZnMpO1xuICAgIGNvbnN0IHBhdGggPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInBhdGhcIik7XG4gICAgZGVmcy5hcHBlbmQocGF0aCk7XG4gICAgY29uc3QgcGF0aElkID0gYHBhdGhfcCR7dGhpcy5wYWdlSW5kZXh9XyR7aWR9YDtcbiAgICBwYXRoLnNldEF0dHJpYnV0ZShcImlkXCIsIHBhdGhJZCk7XG4gICAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJ2ZWN0b3ItZWZmZWN0XCIsIFwibm9uLXNjYWxpbmctc3Ryb2tlXCIpO1xuICAgIGlmIChpc1BhdGhVcGRhdGFibGUpIHtcbiAgICAgIHRoaXMuI3RvVXBkYXRlLnNldChpZCwgcGF0aCk7XG4gICAgfVxuICAgIGNvbnN0IGNsaXBQYXRoSWQgPSBoYXNDbGlwID8gdGhpcy4jY3JlYXRlQ2xpcFBhdGgoZGVmcywgcGF0aElkKSA6IG51bGw7XG4gICAgY29uc3QgdXNlID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJ1c2VcIik7XG4gICAgcm9vdC5hcHBlbmQodXNlKTtcbiAgICB1c2Uuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBgIyR7cGF0aElkfWApO1xuICAgIHRoaXMudXBkYXRlUHJvcGVydGllcyhyb290LCBwcm9wZXJ0aWVzKTtcbiAgICB0aGlzLiNtYXBwaW5nLnNldChpZCwgcm9vdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkLFxuICAgICAgY2xpcFBhdGhJZDogYHVybCgjJHtjbGlwUGF0aElkfSlgXG4gICAgfTtcbiAgfVxuICBkcmF3T3V0bGluZShwcm9wZXJ0aWVzLCBtdXN0UmVtb3ZlU2VsZkludGVyc2VjdGlvbnMpIHtcbiAgICBjb25zdCBpZCA9IERyYXdMYXllci4jaWQrKztcbiAgICBjb25zdCByb290ID0gdGhpcy4jY3JlYXRlU1ZHKCk7XG4gICAgY29uc3QgZGVmcyA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiKTtcbiAgICByb290LmFwcGVuZChkZWZzKTtcbiAgICBjb25zdCBwYXRoID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIpO1xuICAgIGRlZnMuYXBwZW5kKHBhdGgpO1xuICAgIGNvbnN0IHBhdGhJZCA9IGBwYXRoX3Ake3RoaXMucGFnZUluZGV4fV8ke2lkfWA7XG4gICAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBwYXRoSWQpO1xuICAgIHBhdGguc2V0QXR0cmlidXRlKFwidmVjdG9yLWVmZmVjdFwiLCBcIm5vbi1zY2FsaW5nLXN0cm9rZVwiKTtcbiAgICBsZXQgbWFza0lkO1xuICAgIGlmIChtdXN0UmVtb3ZlU2VsZkludGVyc2VjdGlvbnMpIHtcbiAgICAgIGNvbnN0IG1hc2sgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcIm1hc2tcIik7XG4gICAgICBkZWZzLmFwcGVuZChtYXNrKTtcbiAgICAgIG1hc2tJZCA9IGBtYXNrX3Ake3RoaXMucGFnZUluZGV4fV8ke2lkfWA7XG4gICAgICBtYXNrLnNldEF0dHJpYnV0ZShcImlkXCIsIG1hc2tJZCk7XG4gICAgICBtYXNrLnNldEF0dHJpYnV0ZShcIm1hc2tVbml0c1wiLCBcIm9iamVjdEJvdW5kaW5nQm94XCIpO1xuICAgICAgY29uc3QgcmVjdCA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwicmVjdFwiKTtcbiAgICAgIG1hc2suYXBwZW5kKHJlY3QpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjFcIik7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjFcIik7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ3aGl0ZVwiKTtcbiAgICAgIGNvbnN0IHVzZSA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwidXNlXCIpO1xuICAgICAgbWFzay5hcHBlbmQodXNlKTtcbiAgICAgIHVzZS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGAjJHtwYXRoSWR9YCk7XG4gICAgICB1c2Uuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwibm9uZVwiKTtcbiAgICAgIHVzZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwiYmxhY2tcIik7XG4gICAgICB1c2Uuc2V0QXR0cmlidXRlKFwiZmlsbC1ydWxlXCIsIFwibm9uemVyb1wiKTtcbiAgICAgIHVzZS5jbGFzc0xpc3QuYWRkKFwibWFza1wiKTtcbiAgICB9XG4gICAgY29uc3QgdXNlMSA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwidXNlXCIpO1xuICAgIHJvb3QuYXBwZW5kKHVzZTEpO1xuICAgIHVzZTEuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBgIyR7cGF0aElkfWApO1xuICAgIGlmIChtYXNrSWQpIHtcbiAgICAgIHVzZTEuc2V0QXR0cmlidXRlKFwibWFza1wiLCBgdXJsKCMke21hc2tJZH0pYCk7XG4gICAgfVxuICAgIGNvbnN0IHVzZTIgPSB1c2UxLmNsb25lTm9kZSgpO1xuICAgIHJvb3QuYXBwZW5kKHVzZTIpO1xuICAgIHVzZTEuY2xhc3NMaXN0LmFkZChcIm1haW5PdXRsaW5lXCIpO1xuICAgIHVzZTIuY2xhc3NMaXN0LmFkZChcInNlY29uZGFyeU91dGxpbmVcIik7XG4gICAgdGhpcy51cGRhdGVQcm9wZXJ0aWVzKHJvb3QsIHByb3BlcnRpZXMpO1xuICAgIHRoaXMuI21hcHBpbmcuc2V0KGlkLCByb290KTtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgZmluYWxpemVEcmF3KGlkLCBwcm9wZXJ0aWVzKSB7XG4gICAgdGhpcy4jdG9VcGRhdGUuZGVsZXRlKGlkKTtcbiAgICB0aGlzLnVwZGF0ZVByb3BlcnRpZXMoaWQsIHByb3BlcnRpZXMpO1xuICB9XG4gIHVwZGF0ZVByb3BlcnRpZXMoZWxlbWVudE9ySWQsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIXByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcm9vdCxcbiAgICAgIGJib3gsXG4gICAgICByb290Q2xhc3MsXG4gICAgICBwYXRoXG4gICAgfSA9IHByb3BlcnRpZXM7XG4gICAgY29uc3QgZWxlbWVudCA9IHR5cGVvZiBlbGVtZW50T3JJZCA9PT0gXCJudW1iZXJcIiA/IHRoaXMuI21hcHBpbmcuZ2V0KGVsZW1lbnRPcklkKSA6IGVsZW1lbnRPcklkO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocm9vdCkge1xuICAgICAgdGhpcy4jdXBkYXRlUHJvcGVydGllcyhlbGVtZW50LCByb290KTtcbiAgICB9XG4gICAgaWYgKGJib3gpIHtcbiAgICAgIERyYXdMYXllci4jc2V0Qm94KGVsZW1lbnQsIGJib3gpO1xuICAgIH1cbiAgICBpZiAocm9vdENsYXNzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNsYXNzTGlzdFxuICAgICAgfSA9IGVsZW1lbnQ7XG4gICAgICBmb3IgKGNvbnN0IFtjbGFzc05hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyb290Q2xhc3MpKSB7XG4gICAgICAgIGNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXRoKSB7XG4gICAgICBjb25zdCBkZWZzID0gZWxlbWVudC5maXJzdENoaWxkO1xuICAgICAgY29uc3QgcGF0aEVsZW1lbnQgPSBkZWZzLmZpcnN0Q2hpbGQ7XG4gICAgICB0aGlzLiN1cGRhdGVQcm9wZXJ0aWVzKHBhdGhFbGVtZW50LCBwYXRoKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlUGFyZW50KGlkLCBsYXllcikge1xuICAgIGlmIChsYXllciA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByb290ID0gdGhpcy4jbWFwcGluZy5nZXQoaWQpO1xuICAgIGlmICghcm9vdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsYXllci4jcGFyZW50LmFwcGVuZChyb290KTtcbiAgICB0aGlzLiNtYXBwaW5nLmRlbGV0ZShpZCk7XG4gICAgbGF5ZXIuI21hcHBpbmcuc2V0KGlkLCByb290KTtcbiAgfVxuICByZW1vdmUoaWQpIHtcbiAgICB0aGlzLiN0b1VwZGF0ZS5kZWxldGUoaWQpO1xuICAgIGlmICh0aGlzLiNwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jbWFwcGluZy5nZXQoaWQpLnJlbW92ZSgpO1xuICAgIHRoaXMuI21hcHBpbmcuZGVsZXRlKGlkKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI3BhcmVudCA9IG51bGw7XG4gICAgZm9yIChjb25zdCByb290IG9mIHRoaXMuI21hcHBpbmcudmFsdWVzKCkpIHtcbiAgICAgIHJvb3QucmVtb3ZlKCk7XG4gICAgfVxuICAgIHRoaXMuI21hcHBpbmcuY2xlYXIoKTtcbiAgICB0aGlzLiN0b1VwZGF0ZS5jbGVhcigpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9wZGYuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxue1xuICBnbG9iYWxUaGlzLl9wZGZqc1Rlc3RpbmdVdGlscyA9IHtcbiAgICBIaWdobGlnaHRPdXRsaW5lcjogSGlnaGxpZ2h0T3V0bGluZXJcbiAgfTtcbn1cbmdsb2JhbFRoaXMucGRmanNMaWIgPSB7XG4gIEFib3J0RXhjZXB0aW9uOiBBYm9ydEV4Y2VwdGlvbixcbiAgQW5ub3RhdGlvbkVkaXRvckxheWVyOiBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIsXG4gIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlOiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSxcbiAgQW5ub3RhdGlvbkVkaXRvclR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLFxuICBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyOiBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLFxuICBBbm5vdGF0aW9uTGF5ZXI6IEFubm90YXRpb25MYXllcixcbiAgQW5ub3RhdGlvbk1vZGU6IEFubm90YXRpb25Nb2RlLFxuICBBbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvblR5cGUsXG4gIGJ1aWxkOiBidWlsZCxcbiAgQ29sb3JQaWNrZXI6IENvbG9yUGlja2VyLFxuICBjcmVhdGVWYWxpZEFic29sdXRlVXJsOiBjcmVhdGVWYWxpZEFic29sdXRlVXJsLFxuICBET01TVkdGYWN0b3J5OiBET01TVkdGYWN0b3J5LFxuICBEcmF3TGF5ZXI6IERyYXdMYXllcixcbiAgRmVhdHVyZVRlc3Q6IHV0aWxfRmVhdHVyZVRlc3QsXG4gIGZldGNoRGF0YTogZmV0Y2hEYXRhLFxuICBnZXREb2N1bWVudDogZ2V0RG9jdW1lbnQsXG4gIGdldEZpbGVuYW1lRnJvbVVybDogZ2V0RmlsZW5hbWVGcm9tVXJsLFxuICBnZXRQZGZGaWxlbmFtZUZyb21Vcmw6IGdldFBkZkZpbGVuYW1lRnJvbVVybCxcbiAgZ2V0UkdCOiBnZXRSR0IsXG4gIGdldFV1aWQ6IGdldFV1aWQsXG4gIGdldFhmYVBhZ2VWaWV3cG9ydDogZ2V0WGZhUGFnZVZpZXdwb3J0LFxuICBHbG9iYWxXb3JrZXJPcHRpb25zOiBHbG9iYWxXb3JrZXJPcHRpb25zLFxuICBJbWFnZUtpbmQ6IHV0aWxfSW1hZ2VLaW5kLFxuICBJbnZhbGlkUERGRXhjZXB0aW9uOiBJbnZhbGlkUERGRXhjZXB0aW9uLFxuICBpc0RhdGFTY2hlbWU6IGlzRGF0YVNjaGVtZSxcbiAgaXNQZGZGaWxlOiBpc1BkZkZpbGUsXG4gIGlzVmFsaWRFeHBsaWNpdERlc3Q6IGlzVmFsaWRFeHBsaWNpdERlc3QsXG4gIE1hdGhDbGFtcDogTWF0aENsYW1wLFxuICBub0NvbnRleHRNZW51OiBub0NvbnRleHRNZW51LFxuICBub3JtYWxpemVVbmljb2RlOiBub3JtYWxpemVVbmljb2RlLFxuICBPUFM6IE9QUyxcbiAgT3V0cHV0U2NhbGU6IE91dHB1dFNjYWxlLFxuICBQYXNzd29yZFJlc3BvbnNlczogUGFzc3dvcmRSZXNwb25zZXMsXG4gIFBERkRhdGFSYW5nZVRyYW5zcG9ydDogUERGRGF0YVJhbmdlVHJhbnNwb3J0LFxuICBQREZEYXRlU3RyaW5nOiBQREZEYXRlU3RyaW5nLFxuICBQREZXb3JrZXI6IFBERldvcmtlcixcbiAgUGVybWlzc2lvbkZsYWc6IFBlcm1pc3Npb25GbGFnLFxuICBQaXhlbHNQZXJJbmNoOiBQaXhlbHNQZXJJbmNoLFxuICBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb246IFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbixcbiAgUmVzcG9uc2VFeGNlcHRpb246IFJlc3BvbnNlRXhjZXB0aW9uLFxuICBzZXRMYXllckRpbWVuc2lvbnM6IHNldExheWVyRGltZW5zaW9ucyxcbiAgc2hhZG93OiBzaGFkb3csXG4gIFNpZ25hdHVyZUV4dHJhY3RvcjogU2lnbmF0dXJlRXh0cmFjdG9yLFxuICBzdG9wRXZlbnQ6IHN0b3BFdmVudCxcbiAgU3VwcG9ydGVkSW1hZ2VNaW1lVHlwZXM6IFN1cHBvcnRlZEltYWdlTWltZVR5cGVzLFxuICBUZXh0TGF5ZXI6IFRleHRMYXllcixcbiAgVG91Y2hNYW5hZ2VyOiBUb3VjaE1hbmFnZXIsXG4gIHVwZGF0ZVVybEhhc2g6IHVwZGF0ZVVybEhhc2gsXG4gIFV0aWw6IFV0aWwsXG4gIFZlcmJvc2l0eUxldmVsOiBWZXJib3NpdHlMZXZlbCxcbiAgdmVyc2lvbjogdmVyc2lvbixcbiAgWGZhTGF5ZXI6IFhmYUxheWVyXG59O1xuXG5leHBvcnQgeyBBYm9ydEV4Y2VwdGlvbiwgQW5ub3RhdGlvbkVkaXRvckxheWVyLCBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSwgQW5ub3RhdGlvbkVkaXRvclR5cGUsIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIsIEFubm90YXRpb25MYXllciwgQW5ub3RhdGlvbk1vZGUsIEFubm90YXRpb25UeXBlLCBDb2xvclBpY2tlciwgRE9NU1ZHRmFjdG9yeSwgRHJhd0xheWVyLCB1dGlsX0ZlYXR1cmVUZXN0IGFzIEZlYXR1cmVUZXN0LCBHbG9iYWxXb3JrZXJPcHRpb25zLCB1dGlsX0ltYWdlS2luZCBhcyBJbWFnZUtpbmQsIEludmFsaWRQREZFeGNlcHRpb24sIE1hdGhDbGFtcCwgT1BTLCBPdXRwdXRTY2FsZSwgUERGRGF0YVJhbmdlVHJhbnNwb3J0LCBQREZEYXRlU3RyaW5nLCBQREZXb3JrZXIsIFBhc3N3b3JkUmVzcG9uc2VzLCBQZXJtaXNzaW9uRmxhZywgUGl4ZWxzUGVySW5jaCwgUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uLCBSZXNwb25zZUV4Y2VwdGlvbiwgU2lnbmF0dXJlRXh0cmFjdG9yLCBTdXBwb3J0ZWRJbWFnZU1pbWVUeXBlcywgVGV4dExheWVyLCBUb3VjaE1hbmFnZXIsIFV0aWwsIFZlcmJvc2l0eUxldmVsLCBYZmFMYXllciwgYnVpbGQsIGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwsIGZldGNoRGF0YSwgZ2V0RG9jdW1lbnQsIGdldEZpbGVuYW1lRnJvbVVybCwgZ2V0UGRmRmlsZW5hbWVGcm9tVXJsLCBnZXRSR0IsIGdldFV1aWQsIGdldFhmYVBhZ2VWaWV3cG9ydCwgaXNEYXRhU2NoZW1lLCBpc1BkZkZpbGUsIGlzVmFsaWRFeHBsaWNpdERlc3QsIG5vQ29udGV4dE1lbnUsIG5vcm1hbGl6ZVVuaWNvZGUsIHNldExheWVyRGltZW5zaW9ucywgc2hhZG93LCBzdG9wRXZlbnQsIHVwZGF0ZVVybEhhc2gsIHZlcnNpb24gfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGRmLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/pdfjs-dist/build/pdf.mjs\n");

/***/ })

};
;